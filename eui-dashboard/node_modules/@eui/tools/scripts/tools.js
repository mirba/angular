'use strict';

const fs = require('fs');
const fse = require('fs-extra');
const path = require('path');
const glob = require('glob');
const childProcess = require("child_process");
const execSync = childProcess.execSync;
const semver = require('semver');
const chalk = require('chalk');
const figures = require('figures');
const spawn = require('cross-spawn');
const eol = require('eol');

function runScript(_args, cwdFolder) {
    const args = _args.replace(/\s+/g, ' ').split(' ');
    const binary = args.shift();

    return new Promise((resolve, reject) => {
        const child = spawn(
            binary,
            args,
            { stdio: 'inherit' }
        );

        child.on('exit', (code) => {
            if (code !== 0) {
                return reject(new Error(`Error executing script: "${binary} ${args.join(' ')}"`));
            }
            resolve();
        });
    });
}

function relativeCopy(fileGlob, from, to) {
    return new Promise((resolve, reject) => {
        glob(fileGlob, { cwd: from, nodir: true, follow: true, dot: true }, (err, files) => {
            if (err) reject(err);
            files.forEach(file => {
                const origin = path.join(from, file);
                const dest = path.join(to, file);
                _recursiveMkDir(path.dirname(dest));
                fse.copy(origin, dest);
                resolve();
            })
        })
    });
}

function relativeCopyEol(fileGlob, from, to) {
    return new Promise((resolve, reject) => {
        glob(fileGlob, { cwd: from, nodir: true, follow: true, dot: true }, (err, files) => {
            if (err) reject(err);
            files.forEach(file => {
                const origin = path.join(from, file);
                const dest = path.join(to, file);
                _recursiveMkDir(path.dirname(dest));
                //fse.copy(origin, dest);
                const content = fs.readFileSync(origin, { encoding: 'utf8' });
                const contentToCRLF = eol.crlf(content);
                fs.writeFileSync(dest, contentToCRLF);
                resolve();
            })
        })
    });
}

function copydir(from, to, overwrite = true) {
    console.log('----->copydir from : ' + from + ' ====> to : ' + to );
    // Use synchronous Globs otherwise files are overwritten in the wrong order.
    // (It's still copying a bigger set of files from a previous Glob while the new Glob wants to replace files.)
    var files = glob.sync('**/*', { cwd: from, nodir: true, follow: true, dot: true });
    files.forEach(file => {
        const origin = path.join(from, file);
        const dest = path.join(to, file);
        _recursiveMkDir(path.dirname(dest));
        fse.copySync(origin, dest, { overwrite: overwrite });
    });
}

function rmdir(path) {
    console.log('----> path exists ' + path);
    try {
        if (isWindows()) {
            fs.rmdirSync(path);
        } else {
            fs.unlinkSync(path);
        }
    } catch(e) {
    }
}

function rmdirFull(dirPath, removeSelf) {
    try {
        if (removeSelf === undefined)
        removeSelf = true;
        try { var files = fse.readdirSync(dirPath); }
        catch(e) {
            return;
        }
        if (files.length > 0)
        for (var i = 0; i < files.length; i++) {
            var filePath = path.join(dirPath, files[i]);
            if (fse.statSync(filePath).isFile())
            fse.unlinkSync(filePath);
            else
            rmdir(filePath);
        }
        if (removeSelf)
        fse.rmdirSync(dirPath);
    }
    catch(e) {
        return;
    }
  };

function mkdir(path) {
    if (!fs.existsSync(path)) {
        fs.mkdirSync(path);
    }
}

function mkdirRecursive(path) {
    if (!fs.existsSync(path)) {
        _recursiveMkDir(path);
    }
}

function isDirExists(path) {
    try {
        return fs.statSync(path).isDirectory();
    } catch (err) {
        return false;
    }
}

function isFileExists(path) {
    try {
        return fs.statSync(path);
    } catch (err) {
        return false;
    }
}

function link(src, target) {
    rmdir(target);
    if (isWindows()) {
        execSync(`mklink /D ${target} ${src}`);
    } else {
        execSync(`ln -s ${src} ${target}`);
    }
}

function isWindows() {
    if (path.sep === "\\") {
        return true;
    } else {
        return false;
    }
}

function getPackages(rootFolder) {
    if (!rootFolder) {
        rootFolder = 'src/packages';
    }
    console.log('-- Getting packages from ' + rootFolder);

    const packages = fs.readdirSync(rootFolder)
                       .filter(name => fs.lstatSync(path.resolve(rootFolder, name)).isDirectory())
                       .map(name => {
                           return { 'package': name }
                       });

    if (packages.length === 0) {
        console.log('----> no packages found');
    } else {
        console.log('----> packages found : ' + packages.map(p => p.package));
    }
    return packages;
}

function isDirExists(path) {
    try {
        return fs.statSync(path).isDirectory();
    } catch (err) {
        return false;
    }
}

// Recursively create a dir.
function _recursiveMkDir(dir) {
    if (!fs.existsSync(dir)) {
        _recursiveMkDir(path.dirname(dir));
        fs.mkdirSync(dir);
    }
}

function writeJsonFile(filename, data) {
    return new Promise((resolve, reject) => {
            fs.writeFile(filename, JSON.stringify(data, null, 4), function (err) {
                if (err) reject(err);
                resolve();
            });
    });
}

function replacePackagesVersion(packages, version, tag) {
    return new Promise((resolve, reject) => {
        packages.forEach(item => {
            const file = process.cwd() + '/src/packages/' + item.package + '/package.json';

            console.log('-- updating ' + file + '...');

            const jsonFile = require(file);

            jsonFile.version = version;
            jsonFile.tag = tag;

            writeJsonFile('./src/packages/' + item.package + '/package.json', jsonFile);

            resolve();
        })
    });
}

function copy(origin, dest) {
    fse.copySync(origin, dest);
}

function remove(path) {
    fse.removeSync(path);
}

function move(from, to) {
    fse.moveSync(from, to);
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function camelCaseString(string, separator, first) {
    var stringArray = string.split(separator);
    var result = '';
    var s;

    for (var i=0; i<stringArray.length;i++) {
        s = stringArray[i];
        if (i == 0) {
            if (first) {
                result += s.substring(0,1).toUpperCase() + s.substr(1);
            } else {
                result += s;
            }
        } else {
            result += s.substring(0,1).toUpperCase() + s.substr(1);
        }
    }

    return result;
}

function getSysConfig() {
    console.log('\n');
    console.log(chalk.cyan('Getting system infos...'));

    const infos = {};

    const node = execSync('node -v').toString().trim();

    infos.node = semver.clean(node);

    try {
        infos.npm = execSync('npm -v').toString().trim();
    } catch(e) {
        infos.npm = null;
    }
    try {
        infos.yarn = execSync('yarn -v').toString().trim();
    } catch(e) {
        infos.yarn = null;
    }

    infos.httpsProxy = execSync('npm config get https-proxy').toString().trim();
    const registry = execSync('npm config get registry').toString().trim();

    infos.isRegistryDiplazium = registry.indexOf('diplazium') >= 0;
    infos.isRegistryEcDevops = registry.indexOf('ecdevops.eu') >= 0;

    console.log(chalk.green('---> OK\n'));

    return infos;
}

function isSysConfigValid() {
    const infos = getSysConfig();

    const validVersions = {
        node: '8.x',
        npmMaxDiplazium : '<=4.6.1',
    }

    console.log(chalk.cyan('Checking system infos...'));

    if (!semver.satisfies(infos.node, validVersions.node)) {
        console.log(chalk.red(`---> Invalid NodeJS version : found:${infos.node} - required:${validVersions.node}`));
        return false;
    }

    if (infos.isRegistryDiplazium && !semver.satisfies(infos.npm, validVersions.npmMaxDiplazium) && infos.yarn === null) {
        console.log(chalk.red(`---> Invalid NPM version when used against diplazium : found:${infos.npm} - required:${validVersions.npmMaxDiplazium}`));
        console.log('------> you can only use NPM 5.x and above if YARN is used as your dependency manager ===> Yarn NOT INSTALLED');
        return false;
    }

    if (infos.isRegistryDiplazium && infos.httpsProxy === 'undefined') {
        console.log(chalk.red('---> No proxy setting set when used against diplazium registry'));
        console.log('------> check eUI documentation on how to configure your proxy setting');
        return false;
    }

    console.log(chalk.green('---> OK\n'));

    return true;
}

function logSuccess(msg) {
    console.log(`${chalk.green(figures.tick)} ${msg}`);
}

function logError(msg) {
    console.log(`${chalk.red(figures.cross)} ${msg}`);
}

module.exports.relativeCopy = relativeCopy;
module.exports.relativeCopyEol = relativeCopyEol;
module.exports.link = link;
module.exports.isDirExists = isDirExists;
module.exports.isFileExists = isFileExists;
module.exports.mkdir = mkdir;
module.exports.mkdirRecursive = mkdirRecursive;
module.exports.copydir = copydir;
module.exports.rmdir = rmdir;
module.exports.rmdirFull = rmdirFull;
module.exports.copy = copy;
module.exports.remove = remove;
module.exports.move = move;
module.exports.getPackages = getPackages;
module.exports.runScript = runScript;
module.exports.replacePackagesVersion = replacePackagesVersion;
module.exports.isDirExists = isDirExists;
module.exports.writeJsonFile = writeJsonFile;
module.exports.capitalizeFirstLetter = capitalizeFirstLetter;
module.exports.camelCaseString = camelCaseString;
module.exports.getSysConfig = getSysConfig;
module.exports.isSysConfigValid = isSysConfigValid;
module.exports.logSuccess = logSuccess;
module.exports.logError = logError;
