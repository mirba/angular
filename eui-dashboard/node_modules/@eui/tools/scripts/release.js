'use strict';

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const execa = require('execa');
const figures = require('figures');
const conventionalRecommendedBump = require('conventional-recommended-bump')
const semver = require('semver')

const utilsPackages = require('./utils/packages');
const config = require('../config/project');
const { doSendToSlack, processFailed } = require('./slack/slack');
const tools = require('./tools');

const pkgInfo = utilsPackages.getPackage();
const { pkg } = pkgInfo;
const paths = require('../config/paths')(pkgInfo);

console.log('\n\n---------------------------------------------------');
console.log(chalk.cyan(`Releasing new version of package "${pkg}"`));
console.log('---------------------------------------------------');

const cwd = paths.pkgDirectory;

// fetching arguments from global config
const { branch, dryRun } = config;

// checking if at least the branch has been given as a parameter
if (!branch) {
    throw(new Error('Branch missing to make the release.'));
    process.exit(1);
}

const isSupportBranch = (branch !== 'master' && branch.indexOf('support/') > -1);
const isSnapshot = (branch !== 'master' && !isSupportBranch);
const generateChangelog = (branch === 'master' || isSupportBranch);
const tagBranch = (branch === 'master' || isSupportBranch);

const pathPkgJson = path.resolve(paths.pkgDirectory, 'package.json');
const pkgJson = require(pathPkgJson);

const execaOptions = { cwd, stdio: 'inherit' };

var newVersion = pkgJson.version;

return Promise.resolve()

    // Get the commit version type based on commit messages since last tag
    .then(() => {
        console.log(chalk.cyan('--> Extracting recommended version'));
        return new Promise((resolve, reject) => {
              conventionalRecommendedBump({
                preset: 'angular',
                path: paths.pkgDirectory
              }, function (err, release) {
                if (err) return reject(err)
                else return resolve(release)
              })
          });
    })

    // Increment the version according to the type found from the conventional commits
    .then((release) => {
        console.log(chalk.green('----> release info found : ' + JSON.stringify(release)));
        newVersion = semver.valid(release.releaseType) || semver.inc(pkgJson.version, release.releaseType)
        console.log(chalk.green('----> new version found : ' + newVersion));
        return newVersion;
    })

    // Generate changelog since the last tag
    .then(() => {
        console.log(chalk.cyan('--> generating changelog'));
        if (!isSnapshot || isSupportBranch) {
            // TODO
        } else {
            console.log(`${chalk.red(figures.cross)} ----> not applicable`);
        }
    })

    // Update package.json from the version found
    .then(() => {
        console.log(chalk.cyan('--> updating package version'));
        pkgJson.version = newVersion;
        fs.writeFileSync(pathPkgJson, JSON.stringify(pkgJson, null, 4));
        // TODO
    })

    // Extract git metadata commits from the previous tag until now for the LATEST release on MASTER branch
    // or Support branches
    .then(() => {
        if (!isSnapshot || isSupportBranch) {
            return tools.runScript(`eui-scripts extract-git-metadata ${pkgInfo.pkg}`)
            // return tools.runScript(`eui-scripts extract-git-metadata ${pkgInfo.pkg} --tag v${pkgJson.version}`)
        }
    })

    // Commit and push newly generated files
    .then(() => {
        console.log(chalk.cyan('--> commiting updated files'));
        if (!dryRun && (!isSnapshot || isSupportBranch)) {
            console.log(`${chalk.green(figures.tick)} Adding git metadata...`);
            return execa.shell('git add .', execaOptions);
            // TODO PUSH
        } else {
            console.log(`${chalk.red(figures.cross)} ----> not applicable`);
        }
    })

    // Tag the new release
    .then(() => {
        console.log(chalk.cyan('--> tagging the release'));
        if (!isSnapshot && !isSupportBranch && !dryRun) {
            console.log(`${chalk.green(figures.tick)} Pushing changes to origin/${branch}...`);
            // TODO tag !!
            return execa('git', ['push', '--follow-tags', 'origin',  branch], execaOptions);
        } else {
            console.log(`${chalk.red(figures.cross)} ----> not applicable`);
        }
    })

    // If we did a production release (master branch)
    // we merge back to develop our changes
    .then(() => {
        console.log(chalk.cyan('--> Merge back on develop'));
        if (!isSnapshot && !isSupportBranch && !dryRun) {
            try {
                console.log(`${chalk.green(figures.tick)} Merging release changes into "develop" branch...`);
                execa.shellSync('git fetch origin', execaOptions);
                execa.shellSync('git checkout develop', execaOptions);
                execa.shellSync('git merge origin/develop', execaOptions);
                execa.shellSync('git merge -X theirs master', execaOptions);
                execa.shellSync('git push origin develop', execaOptions);
            } catch(e) {
                throw e;
            }
        } else {
            console.log(`${chalk.red(figures.cross)} ----> not applicable`);
        }
    })

    // Send summary to slack
    .then(() => {
        if (doSendToSlack()) {
            processSucceded(pkg);
        }
    })

    // Break and send error to slack in case of failure
    .catch((e) => {
        console.log(e);
        if (doSendToSlack()) {
            return processFailed(pkg, undefined, e, `[RELEASE ERROR]`, 'An error occured whiled creating the release (CHANGELOG & Semver version)')
                .then(() => {
                    process.exit(1);
                });
        }
        process.exit(1);
    });




    // .then(() => {
    //     const pkgJson = require(pathPkgJson);

    //     let args = ['--no-verify'];

    //     if (dryRun) {
    //         args = [...args, '--dry-run'];
    //     }

    //     pkgJson['standard-version'] = {
    //         skip: {
    //             changelog: !generateChangelog,
    //             tag: !tagBranch,
    //         }
    //     }
    //     fs.writeFileSync(pathPkgJson, JSON.stringify(pkgJson, null, 4));

    //     if (isSnapshot) {
    //         args = [...args, '--prerelease', 'snapshot-' + Date.now()]
    //     }

    //     return execa('standard-version', args, execaOptions)
    // })
