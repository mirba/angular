'use strict';

var Bluebird = require('bluebird');
var CP       = Bluebird.promisifyAll(require('child_process'));
var path     = require('path');
var chalk    = require('chalk');

var SEPARATOR      = '===END===';
var COMMIT_PATTERN = /^(\w*)(?:\((.*)\))?\: (.*)$/;
var ISSUE_PATTERN = /((?!([A-Z0-9a-z]{1,10})-?$)[A-Z]{1}[A-Z0-9]+-\d+)/g;
var FORMAT         = '%H%n%s%n%ad%n%an%n%b%n%f%n' + SEPARATOR;

const utilsPackages = require('../utils/packages');

const pkgInfo = utilsPackages.getPackage();
const paths = require('../../config/paths')(pkgInfo);

function getCommitsFromTag(tag) {
  return Bluebird.resolve()
  .then(function () {
    console.log(chalk.cyan('--> Extracting commit history...'));
  })
  .then(function () {
    if (tag) {
      return tag;
    } else {
      return CP.execAsync('git describe --tags --abbrev=0', {cwd: paths.pkgDirectory})
    }
  })
  .catch(function () {
    return;
  })
  .then(function (tag) {
    tag = tag.toString().trim();
    var revisions = tag ? tag + '..HEAD' : '';

    return CP.execAsync('git log -E --date=short --format=' + FORMAT + ' ' + revisions, {cwd: paths.pkgDirectory});
  })
  .catch(function (e) {
    throw new Error(e);
  })
  .then(function (commits) {
    return commits.split('\n' + SEPARATOR + '\n');
  })
  .map(function (raw) {
    if (!raw) {
      return null;
    }

    var lines = raw.split('\n');
    var commit = {};
    var parsedMessage;

    commit.hash = lines[0];
    commit.subject = lines[1];
    commit.date = lines[2];
    commit.user = lines[3];
    commit.body = lines[4];

    if (commit.body) {
        var parsedIssueBody = commit.body.match(ISSUE_PATTERN);
        if (parsedIssueBody) {
            commit.issue = parsedIssueBody[0];
        }
    }

    console.log('----> parsing commit : ' + commit.date + ' ==> ' + commit.subject);

    var parsed = commit.subject.match(COMMIT_PATTERN);
    var parsedIssue = commit.subject.match(ISSUE_PATTERN);

    if (!parsed || !parsed[1]) {
      if (commit.subject.indexOf('Merge pull request') === -1 &&
          commit.subject.indexOf('Merge branch') === -1 &&
          commit.subject.indexOf('Merge remote-tracking branch') === -1) {
            console.log(chalk.red('----> INVALID COMMIT MESSAGE FORMAT : ' + commit.subject));
      }
      return null;
    }

    commit.type = parsed[1].toLowerCase();
    if (parsed[2] !== undefined) {
        commit.category = parsed[2].substr(0) || '';
    }
    commit.subject = parsed[3];

    if (parsedIssue) {
        commit.issue = parsedIssue[0];
    }

    if (!commit.issue) {
        commit.issue = '';
    }

    if (commit.type === 'chore') {
        return null;
    }

    if (commit.type !== 'chore' && commit.subject.indexOf('lint') !== -1) {
        return null;
    }

    parsedMessage = '----> VALID COMMIT MESSAGE : ' + commit.type + '(' + commit.category + '): ' + commit.subject + '----> Related issue : ' + commit.issue;
    console.log(chalk.green(parsedMessage));

    return commit;
  })
  .filter(function (commit) {
    if (!commit) {
      return false;
    }
    return commit;
  })
  .then(function(commits) {
      console.log(chalk.green('----> OK'));
      return commits;
  })
  .catch(function (e) {
      console.log(chalk.red('----> ERROR'));
      console.log(e);
      process.exit(1);
  })
};

function extractIssuesFromCommits(commits) {
    return Bluebird.resolve()
    .then(function () {
        console.log(chalk.cyan('--> Extracting issues...'));
    })
    .then(function () {
        return commits.map(function(commit) {
            return commit.issue;
        })
        .filter(function (issue) {
            if (issue === '') {
                return false;
            }
            return issue;
        })
    })
    .then(function(issues) {
        console.log('----> Issues found : ' + issues);
        console.log(chalk.green('----> OK'));
        return issues;
    })
    .catch(function (e) {
        console.log(chalk.red('----> ERROR'));
        console.log(e);
        process.exit(1);
    })
}

module.exports.getCommitsFromTag = getCommitsFromTag;
module.exports.extractIssuesFromCommits = extractIssuesFromCommits;
