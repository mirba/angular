(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/add/operator/map'), require('rxjs/add/operator/debounceTime'), require('rxjs/add/operator/do'), require('rxjs/add/operator/catch'), require('rxjs/add/operator/mergeMap'), require('rxjs/add/operator/switchMap'), require('rxjs/add/operator/distinctUntilChanged'), require('rxjs/add/operator/delay'), require('rxjs/add/operator/take'), require('rxjs/add/operator/filter'), require('rxjs/add/observable/of'), require('rxjs/add/observable/forkJoin'), require('rxjs/add/observable/throw'), require('@angular/core'), require('extend'), require('@angular/common'), require('util'), require('@ngrx/store'), require('rxjs/observable/throw'), require('reselect'), require('rxjs/BehaviorSubject'), require('@angular/router'), require('@angular/forms'), require('rxjs/Observable'), require('@ngrx/effects'), require('@angular/common/http'), require('@ngx-translate/core'), require('rxjs/observable/of'), require('rxjs/Subject'), require('rxjs/operators'), require('@angular/cdk/portal'), require('rxjs/add/observable/zip'), require('moment-timezone'), require('@angular/platform-browser'), require('rxjs/observable/fromEvent'), require('rxjs/add/observable/concat'), require('rxjs/add/observable/timer'), require('rxjs/add/operator/switchMapTo'), require('cleave.js'), require('@angular/cdk/a11y'), require('primeng/tooltip'), require('angular2-moment'), require('rxjs/add/observable/fromEvent'), require('rxjs/observable/timer'), require('@angular/material/autocomplete'), require('@angular/cdk/keycodes'), require('primeng/components/chart/chart'), require('primeng/components/calendar/calendar'), require('moment'), require('rxjs/ReplaySubject')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/add/operator/map', 'rxjs/add/operator/debounceTime', 'rxjs/add/operator/do', 'rxjs/add/operator/catch', 'rxjs/add/operator/mergeMap', 'rxjs/add/operator/switchMap', 'rxjs/add/operator/distinctUntilChanged', 'rxjs/add/operator/delay', 'rxjs/add/operator/take', 'rxjs/add/operator/filter', 'rxjs/add/observable/of', 'rxjs/add/observable/forkJoin', 'rxjs/add/observable/throw', '@angular/core', 'extend', '@angular/common', 'util', '@ngrx/store', 'rxjs/observable/throw', 'reselect', 'rxjs/BehaviorSubject', '@angular/router', '@angular/forms', 'rxjs/Observable', '@ngrx/effects', '@angular/common/http', '@ngx-translate/core', 'rxjs/observable/of', 'rxjs/Subject', 'rxjs/operators', '@angular/cdk/portal', 'rxjs/add/observable/zip', 'moment-timezone', '@angular/platform-browser', 'rxjs/observable/fromEvent', 'rxjs/add/observable/concat', 'rxjs/add/observable/timer', 'rxjs/add/operator/switchMapTo', 'cleave.js', '@angular/cdk/a11y', 'primeng/tooltip', 'angular2-moment', 'rxjs/add/observable/fromEvent', 'rxjs/observable/timer', '@angular/material/autocomplete', '@angular/cdk/keycodes', 'primeng/components/chart/chart', 'primeng/components/calendar/calendar', 'moment', 'rxjs/ReplaySubject'], factory) :
    (factory((global.core = {}),global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable,global.ng.core,global.extendProxy,global.ng.common,global.util,global.ngrx.store,global.Rx.Observable,global.Reselect,global.Rx,global.ng.router,global.ng.forms,global.Rx,global.ngrx.effects,global.ng.common.http,global['ngx-translate-core'],global.Rx.Observable,global.Rx,global.Rx.Observable.prototype,global.ng.cdk.portal,global.Rx.Observable,global.momenttz,global.ng.platformBrowser,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Cleave,global.ng.cdk.a11y,global.tooltip,global.angular2Moment,global.Rx.Observable,global.Rx.Observable,global.autocomplete,global.ng.cdk.keycodes,global.primeng_components_chart_chart,global.primeng_components_calendar_calendar,global.moment,global.Rx));
}(this, (function (exports,map,debounceTime,_do,_catch,mergeMap,switchMap,distinctUntilChanged,delay,take,filter,of,forkJoin,_throw,core,extendProxy,common,util,store,_throw$1,reselect,BehaviorSubject,router,forms,Observable,effects,http,core$1,of$1,Subject,operators,portal,zip,moment,platformBrowser,fromEvent,concat,timer,switchMapTo,Cleave,a11y,tooltip,angular2Moment,fromEvent$1,timer$1,autocomplete,KeyCodes,chart,calendar,moment$1,ReplaySubject) { 'use strict';

    extendProxy = extendProxy && extendProxy.hasOwnProperty('default') ? extendProxy['default'] : extendProxy;
    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    moment$1 = moment$1 && moment$1.hasOwnProperty('default') ? moment$1['default'] : moment$1;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ extend = (/** @type {?} */ (extendProxy)).default || extendProxy;
    var /** @type {?} */ CONFIG_TOKEN = new core.InjectionToken('config');
    var /** @type {?} */ APP_CONFIG_TOKEN = new core.InjectionToken('appConfig');
    var /** @type {?} */ ENVIRONMENT_TOKEN = new core.InjectionToken('environment');
    /**
     * @param {?} appConfig
     * @param {?=} environment
     * @return {?}
     */
    function getConfig(appConfig, environment) {
        if (environment === void 0) { environment = {}; }
        return extend(true, {}, appConfig, environment);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} appConfig
     * @param {?} storeService
     * @param {?} userService
     * @param {?} localizationService
     * @param {?} injector
     * @param {?} appService
     * @param {?} envConfigService
     * @return {?}
     */
    function initApp(appConfig, storeService, userService, localizationService, injector, appService, envConfigService) {
        return function () {
            return new Promise(function (resolve, reject) {
                // FIX for bug in IE
                // https://github.com/angular/angular-cli/issues/5762  |  https://github.com/angular/angular/issues/15501
                // TODO: remove when Angular update fixes this
                var /** @type {?} */ locationInitialized = injector.get(common.LOCATION_INITIALIZED, Promise.resolve(null));
                locationInitialized.then(function () {
                    console.log('Startup configurator for eUI...');
                    if (typeof appConfig === 'function') {
                        appConfig = appConfig();
                    }
                    appService.listenForConnectionUpdate();
                    /**
                                     * Load User Details
                                     * then initialize the store with the user details
                                     * then initialize app language (if not found --> falls back to defaultLanguage)
                                     */
                    envConfigService.loadDynamicConfig()
                        .switchMap(function () { return userService.loadUserDetail(); })
                        .do(function (user) {
                        storeService.initializeStore(appConfig.versions, user);
                        userService.observePreferencesUpdate();
                    })
                        .switchMap(function () { return userService.loadUserPreferences(); })
                        .switchMap(function () { return localizationService.init(appConfig.global.languages, appConfig.global.defaultLanguage); })
                        .subscribe(function () {
                        /**
                                                 * Handle auto save of the Redux store
                                                 */
                        storeService.handleAutoSave();
                        resolve();
                    }, function (error) {
                        console.log(error);
                        resolve();
                    });
                });
            });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {string} */
    var LOG_LEVEL = {
        info: 'info',
        warning: 'warning',
        error: 'error',
    };
    var TraceService = (function () {
        function TraceService(config) {
            this.config = config;
            if (config.global && config.global.logLevel) {
                this.logLevel = config.global.logLevel;
            }
            else {
                this.logLevel = LOG_LEVEL.error;
            }
        }
        /**
         * @param {?} message
         * @return {?}
         */
        TraceService.prototype.info = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            var /** @type {?} */ levels = [LOG_LEVEL.info];
            if (levels.indexOf(this.logLevel) >= 0) {
                console.log("[INFO] " + message);
            }
            this.log(message, LOG_LEVEL.info);
        };
        /**
         * @param {?} message
         * @return {?}
         */
        TraceService.prototype.warning = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            var /** @type {?} */ levels = [LOG_LEVEL.warning, LOG_LEVEL.error];
            if (levels.indexOf(this.logLevel) >= 0) {
                console.log("[WARNING] " + message);
            }
            this.log(message, LOG_LEVEL.warning);
        };
        /**
         * @param {?} message
         * @return {?}
         */
        TraceService.prototype.error = /**
         * @param {?} message
         * @return {?}
         */
        function (message) {
            var /** @type {?} */ levels = [LOG_LEVEL.info, LOG_LEVEL.warning, LOG_LEVEL.error];
            if (levels.indexOf(this.logLevel) >= 0) {
                console.log("[ERROR] " + message);
            }
            this.log(message, LOG_LEVEL.error);
        };
        /**
         * @param {?} message
         * @param {?} severity
         * @return {?}
         */
        TraceService.prototype.log = /**
         * @param {?} message
         * @param {?} severity
         * @return {?}
         */
        function (message, severity) {
            // TODO: log somewhere on server...
        };
        TraceService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TraceService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
        ]; };
        return TraceService;
    }());

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var /** @type {?} */ errorCodes = {
        ERR_GENERIC: 'ERR_GENERIC',
        ERR_NGRX_MISSING: 'ERR_NGRX_MISSING',
        ERR_TRANSLATION_FILE_MISSING: 'ERR_TRANSLATION_FILE_MISSING',
        ERR_QUEUE_METHOD_NOT_ALLOWED: 'ERR_QUEUE_METHOD_NOT_ALLOWED',
    };
    var /** @type {?} */ getMessage = function (text) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return util.format.apply(util, [text].concat(args));
    };
    var ɵ1 = function (lang) { return getMessage('Translation file not found for language "%s"', lang); };
    var /** @type {?} */ messages = {
        ERR_GENERIC: 'An error occured',
        ERR_NGRX_MISSING: 'NGRX missing. "store.dispatch" and "store.select" are not available.',
        ERR_TRANSLATION_FILE_MISSING: ɵ1,
    };
    var ErrorSubClass = (function () {
        function ErrorSubClass(code, msg, args) {
            var _this = this;
            if (!msg && code && code in messages) {
                if (typeof messages[code] === 'function') {
                    msg = messages[code].apply(messages, args.messageParams);
                }
                else {
                    msg = messages[code];
                }
            }
            this.name = 'ErrorSubClass';
            this.message = msg;
            this.code = code;
            this.stack = (new Error(msg)).stack;
            if (args) {
                Object.keys(args).forEach(function (k) {
                    if (k !== 'messageParams') {
                        _this[k] = args[k];
                    }
                });
            }
        }
        return ErrorSubClass;
    }());
    // This replaces the "extends" on the Class
    ErrorSubClass.prototype = /** @type {?} */ (Object.create(Error.prototype));
    var EuiError = (function (_super) {
        __extends(EuiError, _super);
        function EuiError(code, msg, args) {
            if (code === void 0) { code = errorCodes.ERR_GENERIC; }
            var _this = _super.call(this, code, msg, args) || this;
            _this.name = 'EuiError';
            return _this;
        }
        return EuiError;
    }(ErrorSubClass));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // import { type } from './shared/utils/ngrx-store';
    var /** @type {?} */ CORE_INIT_STORE = '[Core] Init Store';
    var /** @type {?} */ APP_CHANGE_MODULE = '[App] Change module';
    var /** @type {?} */ APP_CONNECTION_UPDATE = '[App] Connection update';
    var /** @type {?} */ APP_STATUS_UPDATE = '[App] Status update';
    var /** @type {?} */ APP_CONNECTION_UPDATE_CONFIRMED = '[App] Connection update confirmed';
    var /** @type {?} */ UPDATE_ROUTE = '[Route] Update';
    var /** @type {?} */ API_QUEUE_ADD = '[API Queue] Add';
    var /** @type {?} */ API_QUEUE_REMOVE = '[API Queue] Remove';
    // Notifications
    var /** @type {?} */ NOTIFS_UPDATE_LIST = '[NOTIFS] Update list';
    // User
    var /** @type {?} */ USER_UPDATE_DETAIL = '[User] Update detail';
    var /** @type {?} */ USER_UPDATE_PREFERENCES = '[User] Update preferences';

    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };
    var StoreService = (function () {
        function StoreService(store$$1, logger) {
            this.store = store$$1;
            this.logger = logger;
            /**
             * autoSave handlers to call before saving in local Storage
             */
            this._autoSaveHandlers = {};
        }
        /**
         * @return {?}
         */
        StoreService.loadState = /**
         * @return {?}
         */
        function () {
            try {
                var /** @type {?} */ serializedState = localStorage.getItem('state');
                if (serializedState === null) {
                    return undefined;
                }
                return JSON.parse(serializedState);
            }
            catch (/** @type {?} */ err) {
                return undefined;
            }
        };
        /**
         * @param {?} versions
         * @param {?=} user
         * @return {?}
         */
        StoreService.prototype.initializeStore = /**
         * @param {?} versions
         * @param {?=} user
         * @return {?}
         */
        function (versions, user) {
            this.dispatch({ type: CORE_INIT_STORE, payload: { versions: versions, user: user } });
        };
        /**
         * @param {?} stateSlice
         * @param {?} handler
         * @return {?}
         */
        StoreService.prototype.addAutoSaveHandler = /**
         * @param {?} stateSlice
         * @param {?} handler
         * @return {?}
         */
        function (stateSlice, handler) {
            if (!this.store) {
                this.logger.warning('StoreService.addAutoSaveHandler() not available withouth ngrx');
                return;
            }
            this._autoSaveHandlers[stateSlice] = handler;
        };
        /**
         * @return {?}
         */
        StoreService.prototype.handleAutoSave = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.store) {
                return;
            }
            this.store.debounceTime(1000)
                .distinctUntilChanged()
                .subscribe(function (state) {
                _this.saveState(state);
            });
        };
        /**
         * Proxy to ngrx store.dispatch()
         * that allows to intercept if the store is present
         */
        /**
         * Proxy to ngrx store.dispatch()
         * that allows to intercept if the store is present
         * @param {?} action
         * @return {?}
         */
        StoreService.prototype.dispatch = /**
         * Proxy to ngrx store.dispatch()
         * that allows to intercept if the store is present
         * @param {?} action
         * @return {?}
         */
        function (action) {
            if (this.store) {
                return this.store.dispatch(action);
            }
        };
        /**
         * Proxy to ngrx store.select()
         * that allows to intercept if the store is present
         */
        /**
         * Proxy to ngrx store.select()
         * that allows to intercept if the store is present
         * @param {?} key
         * @return {?}
         */
        StoreService.prototype.select = /**
         * Proxy to ngrx store.select()
         * that allows to intercept if the store is present
         * @param {?} key
         * @return {?}
         */
        function (key) {
            if (!this.store) {
                return _throw$1._throw(new EuiError(errorCodes.ERR_NGRX_MISSING));
            }
            return this.store.select(key);
        };
        /**
         * @param {?} state
         * @return {?}
         */
        StoreService.prototype.saveState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            var _this = this;
            var /** @type {?} */ stateToSave = {
                app: state.app,
            };
            if (state.user) {
                var _a = state.user, userId = _a.userId, preferences = _a.preferences, rest = __rest(_a, ["userId", "preferences"]);
                stateToSave.user = { userId: userId, preferences: preferences };
            }
            Object.keys(this._autoSaveHandlers).forEach(function (sliceState) {
                var /** @type {?} */ handler = _this._autoSaveHandlers[sliceState];
                stateToSave = Object.assign(stateToSave, (_a = {}, _a[sliceState] = handler(state[sliceState]), _a));
                var _a;
            });
            try {
                var /** @type {?} */ serializedState = JSON.stringify(stateToSave);
                localStorage.setItem('state', serializedState);
            }
            catch (/** @type {?} */ err) {
                // Ignore write errors.
            }
        };
        StoreService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        StoreService.ctorParameters = function () { return [
            { type: store.Store, decorators: [{ type: core.Optional },] },
            { type: TraceService, },
        ]; };
        return StoreService;
    }());

    var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    // Initial State (can be overriden when creating the store)
    var /** @type {?} */ initialState = {
        currentModule: '',
        version: '0.0.0',
        connected: true,
        status: 'idle',
        apiQueue: {},
    };
    // --------
    // Reducers
    // --------
    var /** @type {?} */ changeModule = function (state, action) {
        return Object.assign({}, state, { currentModule: action.payload });
    };
    var /** @type {?} */ appConnectionUpdate = function (state, action) {
        return __assign({}, state, { connected: action.payload });
    };
    var /** @type {?} */ appStatusUpdate = function (state, action) { return (__assign({}, state, { status: action.payload })); };
    var /** @type {?} */ apiQueueAdd = function (state, action) {
        var /** @type {?} */ data = Object.assign({}, action.payload.data, { timestamp: new Date().getTime() });
        var /** @type {?} */ apiQueue = Object.assign({}, state.apiQueue, (_a = {}, _a[action.payload.id] = data, _a));
        return Object.assign({}, state, { apiQueue: apiQueue });
        var _a;
    };
    var /** @type {?} */ apiQueueRemove = function (state, action) {
        var /** @type {?} */ apiQueue = Object.keys(state.apiQueue)
            .filter(function (k) { return k !== action.payload; })
            .reduce(function (acc, key) {
            acc[key] = state.apiQueue[key];
            return acc;
        }, {});
        return Object.assign({}, state, { apiQueue: apiQueue });
    };
    // ----------------------
    var /** @type {?} */ actionToReducerMap = (_a = {},
        _a[APP_CHANGE_MODULE] = changeModule,
        _a[APP_CONNECTION_UPDATE_CONFIRMED] = appConnectionUpdate,
        _a[API_QUEUE_ADD] = apiQueueAdd,
        _a[API_QUEUE_REMOVE] = apiQueueRemove,
        _a[APP_STATUS_UPDATE] = appStatusUpdate,
        _a);
    var /** @type {?} */ reducer = function (state, action) {
        if (state === void 0) { state = initialState; }
        if (actionToReducerMap[action.type]) {
            return actionToReducerMap[action.type](state, action);
        }
        return state;
    };
    var _a;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ initialState$1 = {
        list: [],
    };
    // Reducers
    var /** @type {?} */ updateList = function (state, action) {
        return Object.assign({}, state, { list: action.payload.slice() });
    };
    // ----------------------
    var /** @type {?} */ actionToReducerMap$1 = (_a$1 = {},
        _a$1[NOTIFS_UPDATE_LIST] = updateList,
        _a$1);
    var /** @type {?} */ reducer$1 = function (state, action) {
        if (state === void 0) { state = initialState$1; }
        if (actionToReducerMap$1[action.type]) {
            return actionToReducerMap$1[action.type](state, action);
        }
        return state;
    };
    var _a$1;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ initialState$2 = {
        userId: '',
        firstName: '',
        lastName: '',
        fullName: '',
        preferences: {},
    };
    // --------
    // Reducers
    // --------
    var /** @type {?} */ userUpdateDetail = function (state, action) {
        var /** @type {?} */ fullName = ((action.payload.firstName || '') + " " + (action.payload.lastName || '')).trim();
        return Object.assign({}, state, action.payload, { fullName: fullName });
    };
    var /** @type {?} */ userUpdatePreferences = function (state, action) {
        var /** @type {?} */ preferences = Object.assign({}, state.preferences, action.payload);
        return Object.assign({}, state, { preferences: preferences });
    };
    // ----------------------
    var /** @type {?} */ actionToReducerMap$2 = (_a$2 = {},
        _a$2[USER_UPDATE_DETAIL] = userUpdateDetail,
        _a$2[USER_UPDATE_PREFERENCES] = userUpdatePreferences,
        _a$2);
    var /** @type {?} */ reducer$2 = function (state, action) {
        if (state === void 0) { state = initialState$2; }
        if (actionToReducerMap$2[action.type]) {
            return actionToReducerMap$2[action.type](state, action);
        }
        return state;
    };
    // ----------------
    // State Selectors
    // ----------------
    var /** @type {?} */ getUserId = function (state) { return state.userId; };
    var /** @type {?} */ getUserPreferences = function (state) { return state.preferences; };
    var _a$2;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ reducers = {
        app: reducer,
        user: reducer$2,
        notifications: reducer$1,
    };
    /**
     * @param {?} reducer
     * @return {?}
     */
    function localStorageSync(reducer$$1) {
        return function (state, action) {
            if (action.type === CORE_INIT_STORE) {
                /**
                 * This action is dispatched from the startupConfigurator
                 * We load the state from local storage and compare the version
                 * with the one provided. If the version are the same we merge
                 * the local storage state into the initial state.
                 * If there is a version mismatch, we don't merge the local storage state
                 * and we just update the state app version.
                 */
                var /** @type {?} */ localStorageState = StoreService.loadState();
                var /** @type {?} */ payloadUser = action.payload && action.payload.user && action.payload.user.userId;
                var /** @type {?} */ payloadVersion = action.payload && action.payload.versions && action.payload.versions.app;
                if (localStorageState) {
                    var /** @type {?} */ localUser = localStorageState.user && localStorageState.user.userId;
                    var /** @type {?} */ localVersion = localStorageState && localStorageState.app && localStorageState.app.version;
                    var /** @type {?} */ isVersionOK = (!localVersion || !payloadVersion || localVersion === payloadVersion);
                    var /** @type {?} */ isUserOK = localUser === payloadUser;
                    if (isVersionOK && isUserOK) {
                        state = Object.assign({}, state, localStorageState);
                    }
                }
                if (payloadUser) {
                    var /** @type {?} */ user = Object.assign({}, state.user, action.payload.user);
                    state = Object.assign({}, state, { user: user });
                }
                if (payloadVersion) {
                    state = Object.assign({}, state, { app: Object.assign({}, state.app, { version: payloadVersion }) });
                }
            }
            var /** @type {?} */ nextState = reducer$$1(state, action);
            return nextState;
        };
    }
    /**
     * A selector function is a map function factory. We pass it parameters and it
     * returns a function that maps from the larger state tree into a smaller
     */
    var /** @type {?} */ getAppState = function (state) { return state.app; };
    var /** @type {?} */ getAppConnection = reselect.createSelector(getAppState, function (state) { return state.connected; });
    var /** @type {?} */ getAppStatus = reselect.createSelector(getAppState, function (state) { return state.status; });
    var /** @type {?} */ getApiQueue = reselect.createSelector(getAppState, function (state) { return state.apiQueue; });
    var /** @type {?} */ getApiQueueById = function (id) { return reselect.createSelector(getAppState, function (state) { return state.apiQueue[id]; }); };
    // User
    var /** @type {?} */ getUserState = function (state) { return state.user; };
    var /** @type {?} */ getUserIdState = reselect.createSelector(getUserState, getUserId);
    var /** @type {?} */ getUserPrefsState = reselect.createSelector(getUserState, getUserPreferences);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Action Creators
     */
    var  /**
     * Action Creators
     */
    ChangeModuleAction = (function () {
        function ChangeModuleAction(payload) {
            this.payload = payload;
            this.type = APP_CHANGE_MODULE;
        }
        return ChangeModuleAction;
    }());
    var RouteUpdateAction = (function () {
        function RouteUpdateAction(payload) {
            this.payload = payload;
            this.type = UPDATE_ROUTE;
        }
        return RouteUpdateAction;
    }());
    var AppConnectionUpdate = (function () {
        function AppConnectionUpdate(payload) {
            this.payload = payload;
            this.type = APP_CONNECTION_UPDATE;
        }
        return AppConnectionUpdate;
    }());
    var AppStatusUpdate = (function () {
        function AppStatusUpdate(payload) {
            this.payload = payload;
            this.type = APP_STATUS_UPDATE;
        }
        return AppStatusUpdate;
    }());
    var ApiQueueAdd = (function () {
        function ApiQueueAdd(payload) {
            this.payload = payload;
            this.type = API_QUEUE_ADD;
        }
        return ApiQueueAdd;
    }());
    var ApiQueueRemove = (function () {
        function ApiQueueRemove(payload) {
            this.payload = payload;
            this.type = API_QUEUE_REMOVE;
        }
        return ApiQueueRemove;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UpdateListAction = (function () {
        function UpdateListAction(payload) {
            this.payload = payload;
            this.type = NOTIFS_UPDATE_LIST;
        }
        return UpdateListAction;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UpdateUserDetailAction = (function () {
        function UpdateUserDetailAction(payload) {
            this.payload = payload;
            this.type = USER_UPDATE_DETAIL;
        }
        return UpdateUserDetailAction;
    }());
    var UpdateUserPreferencesAction = (function () {
        function UpdateUserPreferencesAction(payload) {
            this.payload = payload;
            this.type = USER_UPDATE_PREFERENCES;
        }
        return UpdateUserPreferencesAction;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ UX_COLORS = {
        primary: '#004494',
        primaryDark: '#003675',
        primaryDarker: '#002857',
        primaryDarkest: '#001a38',
        primaryDarkester: '#000c1a',
        primaryLight: '#0052b3',
        primaryLighter: '#0060d1',
        primaryLightest: '#1a83ff',
        primaryLightester: '#52a1ff',
        primaryLightester2: '#9ecbff',
        accent: '#ffeb3b',
        accentDark: '#fdd835',
        accentDarker: '#fbc02d',
        accentDarkest: '#f9a825',
        accentDarkester: '#f57f17',
        accentLight: '#ffee58',
        accentLighter: '#fff176',
        accentLightest: '#fff59d',
        accentLightester: '#fff9c4',
        accentLightester2: '#fffde7',
        info: '#03a9f4',
        infoDark: '#039be5',
        infoDarker: '#0288d1',
        infoDarkest: '#0277bd',
        infoDarkester: '#01579b',
        infoLight: '#29b6f6',
        infoLighter: '#4fc3f7',
        infoLightest: '#81d4fa',
        infoLightester: '#b3e5fc',
        infoLightester2: '#e1f5fe',
        success: '#4caf50',
        successDark: '#43a047',
        successDarker: '#388e3c',
        successDarkest: '#2e7d32',
        successDarkester: '#1b5e20',
        successLight: '#66bb6a',
        successLighter: '#81c784',
        successLightest: '#a5d6a7',
        successLightester: '#c8e6c9',
        successLightester2: '#e8f5e9',
        warning: '#ff9800',
        warningDark: '#fb8c00',
        warningDarker: '#f57c00',
        warningDarkest: '#ef6c00',
        warningDarkester: '#e65100',
        warningLight: '#ffa726',
        warningLighter: '#ffb74d',
        warningLightest: '#ffcc80',
        warningLightester: '#fff3e0',
        warningLightester2: '#fff3e0',
        danger: '#f44336',
        dangerDark: '#e53935',
        dangerDarker: '#d32f2f',
        dangerDarkest: '#c62828',
        dangerDarkester: '#b71c1c',
        dangerLight: '#ef5350',
        dangerLighter: '#e57373',
        dangerLightest: '#ef9a9a',
        dangerLightester: '#ffcdd2',
        dangerLightester2: '#ffebee',
        grey: '#9e9e9e',
        greyDark: '#757575',
        greyDarker: '#616161',
        greyDarkest: '#424242',
        greyDarkester: '#212121',
        greyLight: '#bdbdbd',
        greyLighter: '#e0e0e0',
        greyLightest: '#eeeeee',
        greyLightester: '#f5f5f5',
        greyLightester2: '#fafafa'
    };
    var /** @type {?} */ UX_I18N = {
        fr: {
            expandAll: 'Etendre tout',
            collapseAll: 'Fermer tout',
            filter: 'Filtrer',
            today: 'aujourd\'hui',
            oneDayAgo: 'il y a un jour',
            inOneDay: 'dans un jour',
            xDaysAgo: 'il y a %PARAM% jours',
            inXDays: 'dans %PARAM% jours',
            YES: 'OUI',
            NO: 'NON',
            yes: 'Oui',
            no: 'Non',
            viewAllNotifications: 'Voir toutes les notifications',
            myNotifications: 'Mes notifications',
            noNotificationFound: 'Pas de notification trouvée',
            notificationMarkAsRead: 'Marquer comme lu',
            notificationMarkAsUnRead: 'Marquer comme non-lu',
            notificationsToday: 'Notification du jour',
            notificationsOldest: 'Notifications précédentes',
            notificationsUnread: 'non lues',
            notificationsTotal: 'Total',
            autocompleteTagRequiredItemsValidation: 'Vous devez sélectionner encore %PARAM% élément(s)',
            autocompleteTagMaxRequiredItemsValidation: 'Le nombre maximum d\'élements a été dépassé (maximum : %PARAM_1% / actuel: %PARAM_2%)',
            filters: 'Filtres',
            advancedFilter: 'Filtre avancé',
            quickFilter: 'Filtre rapide',
            search: 'Chercher',
            results: 'Résultats',
        },
        en: {
            expandAll: 'Expand all',
            collapseAll: 'Collapse all',
            filter: 'Filter',
            today: 'today',
            oneDayAgo: 'one day ago',
            inOneDay: 'in one day',
            xDaysAgo: '%PARAM% days ago',
            inXDays: 'in %PARAM% days',
            YES: 'YES',
            NO: 'NO',
            yes: 'Yes',
            no: 'No',
            viewAllNotifications: 'View all notifications',
            myNotifications: 'My notifications',
            noNotificationFound: 'No notification found',
            notificationMarkAsRead: 'Mark as read',
            notificationMarkAsUnRead: 'Mark as unread',
            notificationsToday: 'Today\'s notifications',
            notificationsOldest: 'Oldest notifications',
            notificationsUnread: 'unread',
            notificationsTotal: 'Total',
            autocompleteTagRequiredItemsValidation: 'You must select %PARAM% more item(s) in the list',
            autocompleteTagMaxRequiredItemsValidation: 'Maximum number of elements exceeded (maximum : %PARAM_1% / actual: %PARAM_2%)',
            filters: 'Filters',
            advancedFilter: 'Advanced filter',
            quickFilter: 'Quick filter',
            search: 'Search',
            results: 'Results',
        }
    };
    var /** @type {?} */ UX_COUNTRIES = {
        AF: 'Afghanistan',
        AX: 'Aland Islands',
        AL: 'Albania',
        DZ: 'Algeria',
        AS: 'American Samoa',
        AD: 'Andorra',
        AO: 'Angola',
        AI: 'Anguilla',
        AQ: 'Antarctica',
        AG: 'Antigua and Barbuda',
        AR: 'Argentina',
        AM: 'Armenia',
        AW: 'Aruba',
        AU: 'Australia',
        AT: 'Austria',
        AZ: 'Azerbaijan',
        BS: 'Bahamas',
        BH: 'Bahrain',
        BD: 'Bangladesh',
        BB: 'Barbados',
        BY: 'Belarus',
        BE: 'Belgium',
        BZ: 'Belize',
        BJ: 'Benin',
        BM: 'Bermuda',
        BT: 'Bhutan',
        BO: 'Bolivia',
        BA: 'Bosnia and Herzegovina',
        BW: 'Botswana',
        BV: 'Bouvet Island',
        BR: 'Brazil',
        VG: 'British Virgin Islands',
        IO: 'British Indian Ocean Territory',
        BN: 'Brunei Darussalam',
        BG: 'Bulgaria',
        BF: 'Burkina Faso',
        BI: 'Burundi',
        KH: 'Cambodia',
        CM: 'Cameroon',
        CA: 'Canada',
        CV: 'Cape Verde',
        KY: 'Cayman Islands',
        CF: 'Central African Republic',
        TD: 'Chad',
        CL: 'Chile',
        CN: 'China',
        HK: 'Hong Kong',
        MO: 'Macao',
        CX: 'Christmas Island',
        CC: 'Cocos (Keeling) Islands',
        CO: 'Colombia',
        KM: 'Comoros',
        CG: 'Congo (Brazzaville)',
        CD: 'Congo, (Kinshasa)',
        CK: 'Cook Islands',
        CR: 'Costa Rica',
        CI: 'Côte d\'Ivoire',
        HR: 'Croatia',
        CU: 'Cuba',
        CY: 'Cyprus',
        CZ: 'Czech Republic',
        DK: 'Denmark',
        DJ: 'Djibouti',
        DM: 'Dominica',
        DO: 'Dominican Republic',
        EC: 'Ecuador',
        EG: 'Egypt',
        SV: 'El Salvador',
        GQ: 'Equatorial Guinea',
        ER: 'Eritrea',
        EE: 'Estonia',
        ET: 'Ethiopia',
        FK: 'Falkland Islands (Malvinas)',
        FO: 'Faroe Islands',
        FJ: 'Fiji',
        FI: 'Finland',
        FR: 'France',
        GF: 'French Guiana',
        PF: 'French Polynesia',
        TF: 'French Southern Territories',
        GA: 'Gabon',
        GM: 'Gambia',
        GE: 'Georgia',
        DE: 'Germany',
        GH: 'Ghana',
        GI: 'Gibraltar',
        GR: 'Greece',
        GL: 'Greenland',
        GD: 'Grenada',
        GP: 'Guadeloupe',
        GU: 'Guam',
        GT: 'Guatemala',
        GG: 'Guernsey',
        GN: 'Guinea',
        GW: 'Guinea-Bissau',
        GY: 'Guyana',
        HT: 'Haiti',
        HM: 'Heard and Mcdonald Islands',
        VA: 'Vatican City State',
        HN: 'Honduras',
        HU: 'Hungary',
        IS: 'Iceland',
        IN: 'India',
        ID: 'Indonesia',
        IR: 'Iran',
        IQ: 'Iraq',
        IE: 'Ireland',
        IM: 'Isle of Man',
        IL: 'Israel',
        IT: 'Italy',
        JM: 'Jamaica',
        JP: 'Japan',
        JE: 'Jersey',
        JO: 'Jordan',
        KZ: 'Kazakhstan',
        KE: 'Kenya',
        KI: 'Kiribati',
        KP: 'Korea (North)',
        KR: 'Korea (South)',
        KW: 'Kuwait',
        KG: 'Kyrgyzstan',
        LA: 'Lao PDR',
        LV: 'Latvia',
        LB: 'Lebanon',
        LS: 'Lesotho',
        LR: 'Liberia',
        LY: 'Libya',
        LI: 'Liechtenstein',
        LT: 'Lithuania',
        LU: 'Luxembourg',
        MK: 'Macedonia',
        MG: 'Madagascar',
        MW: 'Malawi',
        MY: 'Malaysia',
        MV: 'Maldives',
        ML: 'Mali',
        MT: 'Malta',
        MH: 'Marshall Islands',
        MQ: 'Martinique',
        MR: 'Mauritania',
        MU: 'Mauritius',
        YT: 'Mayotte',
        MX: 'Mexico',
        FM: 'Micronesia',
        MD: 'Moldova',
        MC: 'Monaco',
        MN: 'Mongolia',
        ME: 'Montenegro',
        MS: 'Montserrat',
        MA: 'Morocco',
        MZ: 'Mozambique',
        MM: 'Myanmar',
        NA: 'Namibia',
        NR: 'Nauru',
        NP: 'Nepal',
        NL: 'Netherlands',
        AN: 'Netherlands Antilles',
        NC: 'New Caledonia',
        NZ: 'New Zealand',
        NI: 'Nicaragua',
        NE: 'Niger',
        NG: 'Nigeria',
        NU: 'Niue',
        NF: 'Norfolk Island',
        MP: 'Northern Mariana Islands',
        NO: 'Norway',
        OM: 'Oman',
        PK: 'Pakistan',
        PW: 'Palau',
        PS: 'Palestinian Territory',
        PA: 'Panama',
        PG: 'Papua New Guinea',
        PY: 'Paraguay',
        PE: 'Peru',
        PH: 'Philippines',
        PN: 'Pitcairn',
        PL: 'Poland',
        PT: 'Portugal',
        PR: 'Puerto Rico',
        QA: 'Qatar',
        RE: 'Réunion',
        RO: 'Romania',
        RU: 'Russian Federation',
        RW: 'Rwanda',
        BL: 'Saint-Barthélemy',
        SH: 'Saint Helena',
        KN: 'Saint Kitts and Nevis',
        LC: 'Saint Lucia',
        MF: 'Saint-Martin (French part)',
        PM: 'Saint Pierre and Miquelon',
        VC: 'Saint Vincent and Grenadines',
        WS: 'Samoa',
        SM: 'San Marino',
        ST: 'Sao Tome and Principe',
        SA: 'Saudi Arabia',
        SN: 'Senegal',
        RS: 'Serbia',
        SC: 'Seychelles',
        SL: 'Sierra Leone',
        SG: 'Singapore',
        SK: 'Slovakia',
        SI: 'Slovenia',
        SB: 'Solomon Islands',
        SO: 'Somalia',
        ZA: 'South Africa',
        GS: 'South Georgia and the South Sandwich Islands',
        SS: 'South Sudan',
        ES: 'Spain',
        LK: 'Sri Lanka',
        SD: 'Sudan',
        SR: 'Suriname',
        SJ: 'Svalbard and Jan Mayen Islands',
        SZ: 'Swaziland',
        SE: 'Sweden',
        CH: 'Switzerland',
        SY: 'Syria',
        TW: 'Taiwan',
        TJ: 'Tajikistan',
        TZ: 'Tanzania',
        TH: 'Thailand',
        TL: 'Timor-Leste',
        TG: 'Togo',
        TK: 'Tokelau',
        TO: 'Tonga',
        TT: 'Trinidad and Tobago',
        TN: 'Tunisia',
        TR: 'Turkey',
        TM: 'Turkmenistan',
        TC: 'Turks and Caicos Islands',
        TV: 'Tuvalu',
        UG: 'Uganda',
        UA: 'Ukraine',
        AE: 'United Arab Emirates',
        GB: 'United Kingdom (GB)',
        US: 'United States of America (USA)',
        UM: 'US Minor Outlying Islands',
        UY: 'Uruguay',
        UZ: 'Uzbekistan',
        VU: 'Vanuatu',
        VE: 'Venezuela',
        VN: 'Viet Nam',
        VI: 'Virgin Islands, US',
        WF: 'Wallis and Futuna Islands',
        EH: 'Western Sahara',
        YE: 'Yemen',
        ZM: 'Zambia',
        ZW: 'Zimbabwe'
    };
    var /** @type {?} */ UX_TIMEZONES = [
        { name: 'Europe/Andorra', desc: 'Andorra - Andorra (GMT+02:00)' },
        { name: 'Asia/Dubai', desc: 'United Arab Emirates - Dubai (GMT+04:00)' },
        { name: 'Asia/Kabul', desc: 'Afghanistan - Kabul (GMT+04:30)' },
        { name: 'America/Antigua', desc: 'Antigua and Barbuda - Antigua (GMT-04:00)' },
        { name: 'America/Anguilla', desc: 'Anguilla - Anguilla (GMT-04:00)' },
        { name: 'Europe/Tirane', desc: 'Albania - Tirane (GMT+02:00)' },
        { name: 'Asia/Yerevan', desc: 'Armenia - Yerevan (GMT+04:00)' },
        { name: 'Africa/Luanda', desc: 'Angola - Luanda (GMT+01:00)' },
        { name: 'Antarctica/McMurdo', desc: 'Antarctica - McMurdo (GMT+12:00)' },
        { name: 'Antarctica/Rothera', desc: 'Antarctica - Rothera (GMT-03:00)' },
        { name: 'Antarctica/Palmer', desc: 'Antarctica - Palmer (GMT-03:00)' },
        { name: 'Antarctica/Mawson', desc: 'Antarctica - Mawson (GMT+05:00)' },
        { name: 'Antarctica/Davis', desc: 'Antarctica - Davis (GMT+07:00)' },
        { name: 'Antarctica/Casey', desc: 'Antarctica - Casey (GMT+08:00)' },
        { name: 'Antarctica/Vostok', desc: 'Antarctica - Vostok (GMT+06:00)' },
        { name: 'Antarctica/DumontDUrville', desc: 'Antarctica - DumontDUrville (GMT+10:00)' },
        { name: 'Antarctica/Syowa', desc: 'Antarctica - Syowa (GMT+03:00)' },
        { name: 'Antarctica/Troll', desc: 'Antarctica - Troll (GMT+02:00)' },
        { name: 'America/Argentina/Buenos_Aires', desc: 'Argentina - Buenos Aires (GMT-03:00)' },
        { name: 'America/Argentina/Cordoba', desc: 'Argentina - Cordoba (GMT-03:00)' },
        { name: 'America/Argentina/Salta', desc: 'Argentina - Salta (GMT-03:00)' },
        { name: 'America/Argentina/Jujuy', desc: 'Argentina - Jujuy (GMT-03:00)' },
        { name: 'America/Argentina/Tucuman', desc: 'Argentina - Tucuman (GMT-03:00)' },
        { name: 'America/Argentina/Catamarca', desc: 'Argentina - Catamarca (GMT-03:00)' },
        { name: 'America/Argentina/La_Rioja', desc: 'Argentina - La Rioja (GMT-03:00)' },
        { name: 'America/Argentina/San_Juan', desc: 'Argentina - San Juan (GMT-03:00)' },
        { name: 'America/Argentina/Mendoza', desc: 'Argentina - Mendoza (GMT-03:00)' },
        { name: 'America/Argentina/San_Luis', desc: 'Argentina - San Luis (GMT-03:00)' },
        { name: 'America/Argentina/Rio_Gallegos', desc: 'Argentina - Rio Gallegos (GMT-03:00)' },
        { name: 'America/Argentina/Ushuaia', desc: 'Argentina - Ushuaia (GMT-03:00)' },
        { name: 'Pacific/Pago_Pago', desc: 'American Samoa - Pago Pago (GMT-11:00)' },
        { name: 'Pacific/Samoa', desc: 'American Samoa - Samoa (GMT-11:00)' },
        { name: 'Europe/Vienna', desc: 'Austria - Vienna (GMT+02:00)' },
        { name: 'Australia/Lord_Howe', desc: 'Australia - Lord Howe (GMT+10:30)' },
        { name: 'Antarctica/Macquarie', desc: 'Australia - Macquarie (GMT+11:00)' },
        { name: 'Australia/Hobart', desc: 'Australia - Hobart (GMT+10:00)' },
        { name: 'Australia/Currie', desc: 'Australia - Currie (GMT+10:00)' },
        { name: 'Australia/Melbourne', desc: 'Australia - Melbourne (GMT+10:00)' },
        { name: 'Australia/Sydney', desc: 'Australia - Sydney (GMT+10:00)' },
        { name: 'Australia/Broken_Hill', desc: 'Australia - Broken Hill (GMT+09:30)' },
        { name: 'Australia/Brisbane', desc: 'Australia - Brisbane (GMT+10:00)' },
        { name: 'Australia/Lindeman', desc: 'Australia - Lindeman (GMT+10:00)' },
        { name: 'Australia/Adelaide', desc: 'Australia - Adelaide (GMT+09:30)' },
        { name: 'Australia/Darwin', desc: 'Australia - Darwin (GMT+09:30)' },
        { name: 'Australia/Perth', desc: 'Australia - Perth (GMT+08:00)' },
        { name: 'Australia/Eucla', desc: 'Australia - Eucla (GMT+08:45)' },
        { name: 'Australia/Canberra', desc: 'Australia - Canberra (GMT+10:00)' },
        { name: 'Australia/Queensland', desc: 'Australia - Queensland (GMT+10:00)' },
        { name: 'Australia/Tasmania', desc: 'Australia - Tasmania (GMT+10:00)' },
        { name: 'Australia/Victoria', desc: 'Australia - Victoria (GMT+10:00)' },
        { name: 'America/Aruba', desc: 'Aruba - Aruba (GMT-04:00)' },
        { name: 'Europe/Mariehamn', desc: 'Aland Islands - Mariehamn (GMT+03:00)' },
        { name: 'Asia/Baku', desc: 'Azerbaijan - Baku (GMT+04:00)' },
        { name: 'Europe/Sarajevo', desc: 'Bosnia and Herzegovina - Sarajevo (GMT+02:00)' },
        { name: 'America/Barbados', desc: 'Barbados - Barbados (GMT-04:00)' },
        { name: 'Asia/Dhaka', desc: 'Bangladesh - Dhaka (GMT+06:00)' },
        { name: 'Europe/Brussels', desc: 'Belgium - Brussels (GMT+02:00)' },
        { name: 'Africa/Ouagadougou', desc: 'Burkina Faso - Ouagadougou (GMT+00:00)' },
        { name: 'Europe/Sofia', desc: 'Bulgaria - Sofia (GMT+03:00)' },
        { name: 'Asia/Bahrain', desc: 'Bahrain - Bahrain (GMT+03:00)' },
        { name: 'Africa/Bujumbura', desc: 'Burundi - Bujumbura (GMT+02:00)' },
        { name: 'Africa/Porto-Novo', desc: 'Benin - Porto-Novo (GMT+01:00)' },
        { name: 'America/St_Barthelemy', desc: 'Saint-Barthélemy - St Barthelemy (GMT-04:00)' },
        { name: 'Atlantic/Bermuda', desc: 'Bermuda - Bermuda (GMT-03:00)' },
        { name: 'Asia/Brunei', desc: 'Brunei Darussalam - Brunei (GMT+08:00)' },
        { name: 'America/La_Paz', desc: 'Bolivia - La Paz (GMT-04:00)' },
        { name: 'America/Kralendijk', desc: 'BQ - Kralendijk (GMT-04:00)' },
        { name: 'America/Noronha', desc: 'Brazil - Noronha (GMT-02:00)' },
        { name: 'America/Belem', desc: 'Brazil - Belem (GMT-03:00)' },
        { name: 'America/Fortaleza', desc: 'Brazil - Fortaleza (GMT-03:00)' },
        { name: 'America/Recife', desc: 'Brazil - Recife (GMT-03:00)' },
        { name: 'America/Araguaina', desc: 'Brazil - Araguaina (GMT-03:00)' },
        { name: 'America/Maceio', desc: 'Brazil - Maceio (GMT-03:00)' },
        { name: 'America/Bahia', desc: 'Brazil - Bahia (GMT-03:00)' },
        { name: 'America/Sao_Paulo', desc: 'Brazil - Sao Paulo (GMT-03:00)' },
        { name: 'America/Campo_Grande', desc: 'Brazil - Campo Grande (GMT-04:00)' },
        { name: 'America/Cuiaba', desc: 'Brazil - Cuiaba (GMT-04:00)' },
        { name: 'America/Santarem', desc: 'Brazil - Santarem (GMT-03:00)' },
        { name: 'America/Porto_Velho', desc: 'Brazil - Porto Velho (GMT-04:00)' },
        { name: 'America/Boa_Vista', desc: 'Brazil - Boa Vista (GMT-04:00)' },
        { name: 'America/Manaus', desc: 'Brazil - Manaus (GMT-04:00)' },
        { name: 'America/Eirunepe', desc: 'Brazil - Eirunepe (GMT-05:00)' },
        { name: 'America/Rio_Branco', desc: 'Brazil - Rio Branco (GMT-05:00)' },
        { name: 'America/Nassau', desc: 'Bahamas - Nassau (GMT-04:00)' },
        { name: 'Asia/Thimphu', desc: 'Bhutan - Thimphu (GMT+06:00)' },
        { name: 'Africa/Gaborone', desc: 'Botswana - Gaborone (GMT+02:00)' },
        { name: 'Europe/Minsk', desc: 'Belarus - Minsk (GMT+03:00)' },
        { name: 'America/Belize', desc: 'Belize - Belize (GMT-06:00)' },
        { name: 'America/St_Johns', desc: 'Canada - St Johns (GMT-02:30)' },
        { name: 'America/Halifax', desc: 'Canada - Halifax (GMT-03:00)' },
        { name: 'America/Glace_Bay', desc: 'Canada - Glace Bay (GMT-03:00)' },
        { name: 'America/Moncton', desc: 'Canada - Moncton (GMT-03:00)' },
        { name: 'America/Goose_Bay', desc: 'Canada - Goose Bay (GMT-03:00)' },
        { name: 'America/Blanc-Sablon', desc: 'Canada - Blanc-Sablon (GMT-04:00)' },
        { name: 'America/Toronto', desc: 'Canada - Toronto (GMT-04:00)' },
        { name: 'America/Nipigon', desc: 'Canada - Nipigon (GMT-04:00)' },
        { name: 'America/Thunder_Bay', desc: 'Canada - Thunder Bay (GMT-04:00)' },
        { name: 'America/Iqaluit', desc: 'Canada - Iqaluit (GMT-04:00)' },
        { name: 'America/Pangnirtung', desc: 'Canada - Pangnirtung (GMT-04:00)' },
        { name: 'America/Resolute', desc: 'Canada - Resolute (GMT-05:00)' },
        { name: 'America/Atikokan', desc: 'Canada - Atikokan (GMT-05:00)' },
        { name: 'America/Rankin_Inlet', desc: 'Canada - Rankin Inlet (GMT-05:00)' },
        { name: 'America/Winnipeg', desc: 'Canada - Winnipeg (GMT-05:00)' },
        { name: 'America/Rainy_River', desc: 'Canada - Rainy River (GMT-05:00)' },
        { name: 'America/Regina', desc: 'Canada - Regina (GMT-06:00)' },
        { name: 'America/Swift_Current', desc: 'Canada - Swift Current (GMT-06:00)' },
        { name: 'America/Edmonton', desc: 'Canada - Edmonton (GMT-06:00)' },
        { name: 'America/Cambridge_Bay', desc: 'Canada - Cambridge Bay (GMT-06:00)' },
        { name: 'America/Yellowknife', desc: 'Canada - Yellowknife (GMT-06:00)' },
        { name: 'America/Inuvik', desc: 'Canada - Inuvik (GMT-06:00)' },
        { name: 'America/Creston', desc: 'Canada - Creston (GMT-07:00)' },
        { name: 'America/Dawson_Creek', desc: 'Canada - Dawson Creek (GMT-07:00)' },
        { name: 'America/Vancouver', desc: 'Canada - Vancouver (GMT-07:00)' },
        { name: 'America/Whitehorse', desc: 'Canada - Whitehorse (GMT-07:00)' },
        { name: 'America/Dawson', desc: 'Canada - Dawson (GMT-07:00)' },
        { name: 'America/Montreal', desc: 'Canada - Montreal (GMT-04:00)' },
        { name: 'Canada/Atlantic', desc: 'Canada - Atlantic (GMT-03:00)' },
        { name: 'Canada/Central', desc: 'Canada - Central (GMT-05:00)' },
        { name: 'Canada/Eastern', desc: 'Canada - Eastern (GMT-04:00)' },
        { name: 'Canada/Mountain', desc: 'Canada - Mountain (GMT-06:00)' },
        { name: 'Canada/Newfoundland', desc: 'Canada - Newfoundland (GMT-02:30)' },
        { name: 'Canada/Pacific', desc: 'Canada - Pacific (GMT-07:00)' },
        { name: 'Canada/Saskatchewan', desc: 'Canada - Saskatchewan (GMT-06:00)' },
        { name: 'Canada/Yukon', desc: 'Canada - Yukon (GMT-07:00)' },
        { name: 'Indian/Cocos', desc: 'Cocos (Keeling) Islands - Cocos (GMT+06:30)' },
        { name: 'Africa/Kinshasa', desc: 'Congo, (Kinshasa) - Kinshasa (GMT+01:00)' },
        { name: 'Africa/Lubumbashi', desc: 'Congo, (Kinshasa) - Lubumbashi (GMT+02:00)' },
        { name: 'Africa/Bangui', desc: 'Central African Republic - Bangui (GMT+01:00)' },
        { name: 'Africa/Brazzaville', desc: 'Congo (Brazzaville) - Brazzaville (GMT+01:00)' },
        { name: 'Europe/Zurich', desc: 'Switzerland - Zurich (GMT+02:00)' },
        { name: 'Africa/Abidjan', desc: 'Côte d\'Ivoire - Abidjan (GMT+00:00)' },
        { name: 'Pacific/Rarotonga', desc: 'Cook Islands - Rarotonga (GMT-10:00)' },
        { name: 'America/Santiago', desc: 'Chile - Santiago (GMT-04:00)' },
        { name: 'Pacific/Easter', desc: 'Chile - Easter (GMT-06:00)' },
        { name: 'Chile/Continental', desc: 'Chile - Continental (GMT-04:00)' },
        { name: 'Chile/EasterIsland', desc: 'Chile - EasterIsland (GMT-06:00)' },
        { name: 'Africa/Douala', desc: 'Cameroon - Douala (GMT+01:00)' },
        { name: 'Asia/Shanghai', desc: 'China - Shanghai (GMT+08:00)' },
        { name: 'Asia/Harbin', desc: 'China - Harbin (GMT+08:00)' },
        { name: 'Asia/Chongqing', desc: 'China - Chongqing (GMT+08:00)' },
        { name: 'Asia/Urumqi', desc: 'China - Urumqi (GMT+06:00)' },
        { name: 'Asia/Kashgar', desc: 'China - Kashgar (GMT+06:00)' },
        { name: 'America/Bogota', desc: 'Colombia - Bogota (GMT-05:00)' },
        { name: 'America/Costa_Rica', desc: 'Costa Rica - Costa Rica (GMT-06:00)' },
        { name: 'America/Havana', desc: 'Cuba - Havana (GMT-04:00)' },
        { name: 'Atlantic/Cape_Verde', desc: 'Cape Verde - Cape Verde (GMT-01:00)' },
        { name: 'America/Curacao', desc: 'CW - Curacao (GMT-04:00)' },
        { name: 'Indian/Christmas', desc: 'Christmas Island - Christmas (GMT+07:00)' },
        { name: 'Asia/Nicosia', desc: 'Cyprus - Nicosia (GMT+03:00)' },
        { name: 'Europe/Prague', desc: 'Czech Republic - Prague (GMT+02:00)' },
        { name: 'Europe/Berlin', desc: 'Germany - Berlin (GMT+02:00)' },
        { name: 'Africa/Djibouti', desc: 'Djibouti - Djibouti (GMT+03:00)' },
        { name: 'Europe/Copenhagen', desc: 'Denmark - Copenhagen (GMT+02:00)' },
        { name: 'America/Dominica', desc: 'Dominica - Dominica (GMT-04:00)' },
        { name: 'America/Santo_Domingo', desc: 'Dominican Republic - Santo Domingo (GMT-04:00)' },
        { name: 'Africa/Algiers', desc: 'Algeria - Algiers (GMT+01:00)' },
        { name: 'America/Guayaquil', desc: 'Ecuador - Guayaquil (GMT-05:00)' },
        { name: 'Pacific/Galapagos', desc: 'Ecuador - Galapagos (GMT-06:00)' },
        { name: 'Europe/Tallinn', desc: 'Estonia - Tallinn (GMT+03:00)' },
        { name: 'Egypt', desc: 'Egypt - Egypt (GMT+02:00)' },
        { name: 'Africa/El_Aaiun', desc: 'Western Sahara - El Aaiun (GMT+00:00)' },
        { name: 'Africa/Asmara', desc: 'Eritrea - Asmara (GMT+03:00)' },
        { name: 'Europe/Madrid', desc: 'Spain - Madrid (GMT+02:00)' },
        { name: 'Africa/Ceuta', desc: 'Spain - Ceuta (GMT+02:00)' },
        { name: 'Atlantic/Canary', desc: 'Spain - Canary (GMT+01:00)' },
        { name: 'Africa/Addis_Ababa', desc: 'Ethiopia - Addis Ababa (GMT+03:00)' },
        { name: 'Europe/Helsinki', desc: 'Finland - Helsinki (GMT+03:00)' },
        { name: 'Pacific/Fiji', desc: 'Fiji - Fiji (GMT+12:00)' },
        { name: 'Atlantic/Stanley', desc: 'Falkland Islands (Malvinas) - Stanley (GMT-03:00)' },
        { name: 'Pacific/Chuuk', desc: 'Micronesia - Chuuk (GMT+10:00)' },
        { name: 'Pacific/Pohnpei', desc: 'Micronesia - Pohnpei (GMT+11:00)' },
        { name: 'Pacific/Kosrae', desc: 'Micronesia - Kosrae (GMT+11:00)' },
        { name: 'Atlantic/Faroe', desc: 'Faroe Islands - Faroe (GMT+01:00)' },
        { name: 'Europe/Paris', desc: 'France - Paris (GMT+02:00)' },
        { name: 'Africa/Libreville', desc: 'Gabon - Libreville (GMT+01:00)' },
        { name: 'Europe/London', desc: 'United Kingdom (GB) - London (GMT+01:00)' },
        { name: 'America/Grenada', desc: 'Grenada - Grenada (GMT-04:00)' },
        { name: 'Asia/Tbilisi', desc: 'Georgia - Tbilisi (GMT+04:00)' },
        { name: 'America/Cayenne', desc: 'French Guiana - Cayenne (GMT-03:00)' },
        { name: 'Europe/Guernsey', desc: 'Guernsey - Guernsey (GMT+01:00)' },
        { name: 'Africa/Accra', desc: 'Ghana - Accra (GMT+00:00)' },
        { name: 'Europe/Gibraltar', desc: 'Gibraltar - Gibraltar (GMT+02:00)' },
        { name: 'America/Godthab', desc: 'Greenland - Godthab (GMT-02:00)' },
        { name: 'America/Danmarkshavn', desc: 'Greenland - Danmarkshavn (GMT+00:00)' },
        { name: 'America/Scoresbysund', desc: 'Greenland - Scoresbysund (GMT+00:00)' },
        { name: 'America/Thule', desc: 'Greenland - Thule (GMT-03:00)' },
        { name: 'Africa/Banjul', desc: 'Gambia - Banjul (GMT+00:00)' },
        { name: 'Africa/Conakry', desc: 'Guinea - Conakry (GMT+00:00)' },
        { name: 'America/Guadeloupe', desc: 'Guadeloupe - Guadeloupe (GMT-04:00)' },
        { name: 'Africa/Malabo', desc: 'Equatorial Guinea - Malabo (GMT+01:00)' },
        { name: 'Europe/Athens', desc: 'Greece - Athens (GMT+03:00)' },
        { name: 'Atlantic/South_Georgia', desc: 'South Georgia and the South Sandwich Islands - South Georgia (GMT-02:00)' },
        { name: 'America/Guatemala', desc: 'Guatemala - Guatemala (GMT-06:00)' },
        { name: 'Pacific/Guam', desc: 'Guam - Guam (GMT+10:00)' },
        { name: 'Africa/Bissau', desc: 'Guinea-Bissau - Bissau (GMT+00:00)' },
        { name: 'America/Guyana', desc: 'Guyana - Guyana (GMT-04:00)' },
        { name: 'Asia/Hong_Kong', desc: 'Hong Kong - Hong Kong (GMT+08:00)' },
        { name: 'America/Tegucigalpa', desc: 'Honduras - Tegucigalpa (GMT-06:00)' },
        { name: 'Europe/Zagreb', desc: 'Croatia - Zagreb (GMT+02:00)' },
        { name: 'America/Port-au-Prince', desc: 'Haiti - Port-au-Prince (GMT-04:00)' },
        { name: 'Europe/Budapest', desc: 'Hungary - Budapest (GMT+02:00)' },
        { name: 'Asia/Jakarta', desc: 'Indonesia - Jakarta (GMT+07:00)' },
        { name: 'Asia/Pontianak', desc: 'Indonesia - Pontianak (GMT+07:00)' },
        { name: 'Asia/Makassar', desc: 'Indonesia - Makassar (GMT+08:00)' },
        { name: 'Asia/Jayapura', desc: 'Indonesia - Jayapura (GMT+09:00)' },
        { name: 'Europe/Dublin', desc: 'Ireland - Dublin (GMT+01:00)' },
        { name: 'Asia/Jerusalem', desc: 'Israel - Jerusalem (GMT+03:00)' },
        { name: 'Europe/Isle_of_Man', desc: 'Isle of Man - Isle of_Man (GMT+01:00)' },
        { name: 'Asia/Kolkata', desc: 'India - Kolkata (GMT+05:30)' },
        { name: 'Indian/Chagos', desc: 'British Indian Ocean Territory - Chagos (GMT+06:00)' },
        { name: 'Asia/Baghdad', desc: 'Iraq - Baghdad (GMT+03:00)' },
        { name: 'Asia/Tehran', desc: 'Iran - Tehran (GMT+04:30)' },
        { name: 'Atlantic/Reykjavik', desc: 'Iceland - Reykjavik (GMT+00:00)' },
        { name: 'Europe/Rome', desc: 'Italy - Rome (GMT+02:00)' },
        { name: 'Europe/Jersey', desc: 'Jersey - Jersey (GMT+01:00)' },
        { name: 'America/Jamaica', desc: 'Jamaica - Jamaica (GMT-05:00)' },
        { name: 'Asia/Amman', desc: 'Jordan - Amman (GMT+03:00)' },
        { name: 'Asia/Tokyo', desc: 'Japan - Tokyo (GMT+09:00)' },
        { name: 'Africa/Nairobi', desc: 'Kenya - Nairobi (GMT+03:00)' },
        { name: 'Asia/Bishkek', desc: 'Kyrgyzstan - Bishkek (GMT+06:00)' },
        { name: 'Asia/Phnom_Penh', desc: 'Cambodia - Phnom Penh (GMT+07:00)' },
        { name: 'Pacific/Tarawa', desc: 'Kiribati - Tarawa (GMT+12:00)' },
        { name: 'Pacific/Enderbury', desc: 'Kiribati - Enderbury (GMT+13:00)' },
        { name: 'Pacific/Kiritimati', desc: 'Kiribati - Kiritimati (GMT+14:00)' },
        { name: 'Indian/Comoro', desc: 'Comoros - Comoro (GMT+03:00)' },
        { name: 'America/St_Kitts', desc: 'Saint Kitts and Nevis - St Kitts (GMT-04:00)' },
        { name: 'Asia/Pyongyang', desc: 'Korea (North) - Pyongyang (GMT+09:00)' },
        { name: 'Asia/Seoul', desc: 'Korea (South) - Seoul (GMT+09:00)' },
        { name: 'Asia/Kuwait', desc: 'Kuwait - Kuwait (GMT+03:00)' },
        { name: 'America/Cayman', desc: 'Cayman Islands - Cayman (GMT-05:00)' },
        { name: 'Asia/Almaty', desc: 'Kazakhstan - Almaty (GMT+06:00)' },
        { name: 'Asia/Qyzylorda', desc: 'Kazakhstan - Qyzylorda (GMT+06:00)' },
        { name: 'Asia/Aqtobe', desc: 'Kazakhstan - Aqtobe (GMT+05:00)' },
        { name: 'Asia/Aqtau', desc: 'Kazakhstan - Aqtau (GMT+05:00)' },
        { name: 'Asia/Oral', desc: 'Kazakhstan - Oral (GMT+05:00)' },
        { name: 'Asia/Vientiane', desc: 'Lao PDR - Vientiane (GMT+07:00)' },
        { name: 'Asia/Beirut', desc: 'Lebanon - Beirut (GMT+03:00)' },
        { name: 'America/St_Lucia', desc: 'Saint Lucia - St Lucia (GMT-04:00)' },
        { name: 'Europe/Vaduz', desc: 'Liechtenstein - Vaduz (GMT+02:00)' },
        { name: 'Asia/Colombo', desc: 'Sri Lanka - Colombo (GMT+05:30)' },
        { name: 'Africa/Monrovia', desc: 'Liberia - Monrovia (GMT+00:00)' },
        { name: 'Africa/Maseru', desc: 'Lesotho - Maseru (GMT+02:00)' },
        { name: 'Europe/Vilnius', desc: 'Lithuania - Vilnius (GMT+03:00)' },
        { name: 'Europe/Luxembourg', desc: 'Luxembourg - Luxembourg (GMT+02:00)' },
        { name: 'Europe/Riga', desc: 'Latvia - Riga (GMT+03:00)' },
        { name: 'Africa/Tripoli', desc: 'Libya - Tripoli (GMT+02:00)' },
        { name: 'Africa/Casablanca', desc: 'Morocco - Casablanca (GMT+00:00)' },
        { name: 'Europe/Monaco', desc: 'Monaco - Monaco (GMT+02:00)' },
        { name: 'Europe/Chisinau', desc: 'Moldova - Chisinau (GMT+03:00)' },
        { name: 'Europe/Podgorica', desc: 'Montenegro - Podgorica (GMT+02:00)' },
        { name: 'America/Marigot', desc: 'Saint-Martin (French part) - Marigot (GMT-04:00)' },
        { name: 'Indian/Antananarivo', desc: 'Madagascar - Antananarivo (GMT+03:00)' },
        { name: 'Pacific/Majuro', desc: 'Marshall Islands - Majuro (GMT+12:00)' },
        { name: 'Pacific/Kwajalein', desc: 'Marshall Islands - Kwajalein (GMT+12:00)' },
        { name: 'Europe/Skopje', desc: 'Macedonia - Skopje (GMT+02:00)' },
        { name: 'Africa/Bamako', desc: 'Mali - Bamako (GMT+00:00)' },
        { name: 'Asia/Rangoon', desc: 'Myanmar - Rangoon (GMT+06:30)' },
        { name: 'Asia/Ulaanbaatar', desc: 'Mongolia - Ulaanbaatar (GMT+08:00)' },
        { name: 'Asia/Hovd', desc: 'Mongolia - Hovd (GMT+07:00)' },
        { name: 'Asia/Choibalsan', desc: 'Mongolia - Choibalsan (GMT+08:00)' },
        { name: 'Asia/Macau', desc: 'Macao - Macau (GMT+08:00)' },
        { name: 'Pacific/Saipan', desc: 'Northern Mariana Islands - Saipan (GMT+10:00)' },
        { name: 'America/Martinique', desc: 'Martinique - Martinique (GMT-04:00)' },
        { name: 'Africa/Nouakchott', desc: 'Mauritania - Nouakchott (GMT+00:00)' },
        { name: 'America/Montserrat', desc: 'Montserrat - Montserrat (GMT-04:00)' },
        { name: 'Europe/Malta', desc: 'Malta - Malta (GMT+02:00)' },
        { name: 'Indian/Mauritius', desc: 'Mauritius - Mauritius (GMT+04:00)' },
        { name: 'Indian/Maldives', desc: 'Maldives - Maldives (GMT+05:00)' },
        { name: 'Africa/Blantyre', desc: 'Malawi - Blantyre (GMT+02:00)' },
        { name: 'America/Mexico_City', desc: 'Mexico - Mexico City (GMT-05:00)' },
        { name: 'America/Cancun', desc: 'Mexico - Cancun (GMT-05:00)' },
        { name: 'America/Merida', desc: 'Mexico - Merida (GMT-05:00)' },
        { name: 'America/Monterrey', desc: 'Mexico - Monterrey (GMT-05:00)' },
        { name: 'America/Matamoros', desc: 'Mexico - Matamoros (GMT-05:00)' },
        { name: 'America/Mazatlan', desc: 'Mexico - Mazatlan (GMT-06:00)' },
        { name: 'America/Chihuahua', desc: 'Mexico - Chihuahua (GMT-06:00)' },
        { name: 'America/Ojinaga', desc: 'Mexico - Ojinaga (GMT-06:00)' },
        { name: 'America/Hermosillo', desc: 'Mexico - Hermosillo (GMT-07:00)' },
        { name: 'America/Tijuana', desc: 'Mexico - Tijuana (GMT-07:00)' },
        { name: 'America/Santa_Isabel', desc: 'Mexico - Santa Isabel (GMT-07:00)' },
        { name: 'America/Bahia_Banderas', desc: 'Mexico - Bahia Banderas (GMT-05:00)' },
        { name: 'Asia/Kuala_Lumpur', desc: 'Malaysia - Kuala Lumpur (GMT+08:00)' },
        { name: 'Asia/Kuching', desc: 'Malaysia - Kuching (GMT+08:00)' },
        { name: 'Africa/Maputo', desc: 'Mozambique - Maputo (GMT+02:00)' },
        { name: 'Africa/Windhoek', desc: 'Namibia - Windhoek (GMT+02:00)' },
        { name: 'Pacific/Noumea', desc: 'New Caledonia - Noumea (GMT+11:00)' },
        { name: 'Africa/Niamey', desc: 'Niger - Niamey (GMT+01:00)' },
        { name: 'Pacific/Norfolk', desc: 'Norfolk Island - Norfolk (GMT+11:00)' },
        { name: 'Africa/Lagos', desc: 'Nigeria - Lagos (GMT+01:00)' },
        { name: 'America/Managua', desc: 'Nicaragua - Managua (GMT-06:00)' },
        { name: 'Europe/Amsterdam', desc: 'Netherlands - Amsterdam (GMT+02:00)' },
        { name: 'Europe/Oslo', desc: 'Norway - Oslo (GMT+02:00)' },
        { name: 'Asia/Kathmandu', desc: 'Nepal - Kathmandu (GMT+05:45)' },
        { name: 'Pacific/Nauru', desc: 'Nauru - Nauru (GMT+12:00)' },
        { name: 'Pacific/Niue', desc: 'Niue - Niue (GMT-11:00)' },
        { name: 'Pacific/Auckland', desc: 'New Zealand - Auckland (GMT+12:00)' },
        { name: 'Pacific/Chatham', desc: 'New Zealand - Chatham (GMT+12:45)' },
        { name: 'Asia/Muscat', desc: 'Oman - Muscat (GMT+04:00)' },
        { name: 'America/Panama', desc: 'Panama - Panama (GMT-05:00)' },
        { name: 'America/Lima', desc: 'Peru - Lima (GMT-05:00)' },
        { name: 'Pacific/Tahiti', desc: 'French Polynesia - Tahiti (GMT-10:00)' },
        { name: 'Pacific/Marquesas', desc: 'French Polynesia - Marquesas (GMT-09:30)' },
        { name: 'Pacific/Gambier', desc: 'French Polynesia - Gambier (GMT-09:00)' },
        { name: 'Pacific/Port_Moresby', desc: 'Papua New Guinea - Port Moresby (GMT+10:00)' },
        { name: 'Asia/Manila', desc: 'Philippines - Manila (GMT+08:00)' },
        { name: 'Asia/Karachi', desc: 'Pakistan - Karachi (GMT+05:00)' },
        { name: 'Europe/Warsaw', desc: 'Poland - Warsaw (GMT+02:00)' },
        { name: 'Poland', desc: 'Poland - Poland (GMT+02:00)' },
        { name: 'America/Miquelon', desc: 'Saint Pierre and Miquelon - Miquelon (GMT-02:00)' },
        { name: 'Pacific/Pitcairn', desc: 'Pitcairn - Pitcairn (GMT-08:00)' },
        { name: 'America/Puerto_Rico', desc: 'Puerto Rico - Puerto Rico (GMT-04:00)' },
        { name: 'Asia/Gaza', desc: 'Palestinian Territory - Gaza (GMT+03:00)' },
        { name: 'Asia/Hebron', desc: 'Palestinian Territory - Hebron (GMT+03:00)' },
        { name: 'Europe/Lisbon', desc: 'Portugal - Lisbon (GMT+01:00)' },
        { name: 'Atlantic/Madeira', desc: 'Portugal - Madeira (GMT+01:00)' },
        { name: 'Atlantic/Azores', desc: 'Portugal - Azores (GMT+00:00)' },
        { name: 'Pacific/Palau', desc: 'Palau - Palau (GMT+09:00)' },
        { name: 'America/Asuncion', desc: 'Paraguay - Asuncion (GMT-04:00)' },
        { name: 'Asia/Qatar', desc: 'Qatar - Qatar (GMT+03:00)' },
        { name: 'Indian/Reunion', desc: 'Réunion - Reunion (GMT+04:00)' },
        { name: 'Europe/Bucharest', desc: 'Romania - Bucharest (GMT+03:00)' },
        { name: 'Europe/Belgrade', desc: 'Serbia - Belgrade (GMT+02:00)' },
        { name: 'Europe/Kaliningrad', desc: 'Russian Federation - Kaliningrad (GMT+02:00)' },
        { name: 'Europe/Moscow', desc: 'Russian Federation - Moscow (GMT+03:00)' },
        { name: 'Europe/Volgograd', desc: 'Russian Federation - Volgograd (GMT+03:00)' },
        { name: 'Europe/Samara', desc: 'Russian Federation - Samara (GMT+04:00)' },
        { name: 'Europe/Simferopol', desc: 'Russian Federation - Simferopol (GMT+03:00)' },
        { name: 'Asia/Yekaterinburg', desc: 'Russian Federation - Yekaterinburg (GMT+05:00)' },
        { name: 'Asia/Omsk', desc: 'Russian Federation - Omsk (GMT+06:00)' },
        { name: 'Asia/Novosibirsk', desc: 'Russian Federation - Novosibirsk (GMT+07:00)' },
        { name: 'Asia/Novokuznetsk', desc: 'Russian Federation - Novokuznetsk (GMT+07:00)' },
        { name: 'Asia/Krasnoyarsk', desc: 'Russian Federation - Krasnoyarsk (GMT+07:00)' },
        { name: 'Asia/Irkutsk', desc: 'Russian Federation - Irkutsk (GMT+08:00)' },
        { name: 'Asia/Yakutsk', desc: 'Russian Federation - Yakutsk (GMT+09:00)' },
        { name: 'Asia/Khandyga', desc: 'Russian Federation - Khandyga (GMT+09:00)' },
        { name: 'Asia/Vladivostok', desc: 'Russian Federation - Vladivostok (GMT+10:00)' },
        { name: 'Asia/Sakhalin', desc: 'Russian Federation - Sakhalin (GMT+11:00)' },
        { name: 'Asia/Ust-Nera', desc: 'Russian Federation - Ust-Nera (GMT+10:00)' },
        { name: 'Asia/Magadan', desc: 'Russian Federation - Magadan (GMT+11:00)' },
        { name: 'Asia/Kamchatka', desc: 'Russian Federation - Kamchatka (GMT+12:00)' },
        { name: 'Asia/Anadyr', desc: 'Russian Federation - Anadyr (GMT+12:00)' },
        { name: 'Africa/Kigali', desc: 'Rwanda - Kigali (GMT+02:00)' },
        { name: 'Asia/Riyadh', desc: 'Saudi Arabia - Riyadh (GMT+03:00)' },
        { name: 'Pacific/Guadalcanal', desc: 'Solomon Islands - Guadalcanal (GMT+11:00)' },
        { name: 'Indian/Mahe', desc: 'Seychelles - Mahe (GMT+04:00)' },
        { name: 'Africa/Khartoum', desc: 'Sudan - Khartoum (GMT+02:00)' },
        { name: 'Europe/Stockholm', desc: 'Sweden - Stockholm (GMT+02:00)' },
        { name: 'Asia/Singapore', desc: 'Singapore - Singapore (GMT+08:00)' },
        { name: 'Atlantic/St_Helena', desc: 'Saint Helena - St Helena (GMT+00:00)' },
        { name: 'Europe/Ljubljana', desc: 'Slovenia - Ljubljana (GMT+02:00)' },
        { name: 'Arctic/Longyearbyen', desc: 'Svalbard and Jan Mayen Islands - Longyearbyen (GMT+02:00)' },
        { name: 'Europe/Bratislava', desc: 'Slovakia - Bratislava (GMT+02:00)' },
        { name: 'Africa/Freetown', desc: 'Sierra Leone - Freetown (GMT+00:00)' },
        { name: 'Europe/San_Marino', desc: 'San Marino - San Marino (GMT+02:00)' },
        { name: 'Africa/Dakar', desc: 'Senegal - Dakar (GMT+00:00)' },
        { name: 'Africa/Mogadishu', desc: 'Somalia - Mogadishu (GMT+03:00)' },
        { name: 'America/Paramaribo', desc: 'Suriname - Paramaribo (GMT-03:00)' },
        { name: 'Africa/Juba', desc: 'South Sudan - Juba (GMT+03:00)' },
        { name: 'Africa/Sao_Tome', desc: 'Sao Tome and Principe - Sao Tome (GMT+01:00)' },
        { name: 'America/El_Salvador', desc: 'El Salvador - El Salvador (GMT-06:00)' },
        { name: 'America/Lower_Princes', desc: 'SX - Lower Princes (GMT-04:00)' },
        { name: 'Asia/Damascus', desc: 'Syria - Damascus (GMT+03:00)' },
        { name: 'Africa/Mbabane', desc: 'Swaziland - Mbabane (GMT+02:00)' },
        { name: 'America/Grand_Turk', desc: 'Turks and Caicos Islands - Grand Turk (GMT-04:00)' },
        { name: 'Africa/Ndjamena', desc: 'Chad - Ndjamena (GMT+01:00)' },
        { name: 'Indian/Kerguelen', desc: 'French Southern Territories - Kerguelen (GMT+05:00)' },
        { name: 'Africa/Lome', desc: 'Togo - Lome (GMT+00:00)' },
        { name: 'Asia/Bangkok', desc: 'Thailand - Bangkok (GMT+07:00)' },
        { name: 'Asia/Dushanbe', desc: 'Tajikistan - Dushanbe (GMT+05:00)' },
        { name: 'Pacific/Fakaofo', desc: 'Tokelau - Fakaofo (GMT+13:00)' },
        { name: 'Asia/Dili', desc: 'Timor-Leste - Dili (GMT+09:00)' },
        { name: 'Asia/Ashgabat', desc: 'Turkmenistan - Ashgabat (GMT+05:00)' },
        { name: 'Africa/Tunis', desc: 'Tunisia - Tunis (GMT+01:00)' },
        { name: 'Pacific/Tongatapu', desc: 'Tonga - Tongatapu (GMT+13:00)' },
        { name: 'Europe/Istanbul', desc: 'Turkey - Istanbul (GMT+03:00)' },
        { name: 'America/Port_of_Spain', desc: 'Trinidad and Tobago - Port of_Spain (GMT-04:00)' },
        { name: 'Pacific/Funafuti', desc: 'Tuvalu - Funafuti (GMT+12:00)' },
        { name: 'Asia/Taipei', desc: 'Taiwan - Taipei (GMT+08:00)' },
        { name: 'Africa/Dar_es_Salaam', desc: 'Tanzania - Dar es_Salaam (GMT+03:00)' },
        { name: 'Europe/Kiev', desc: 'Ukraine - Kiev (GMT+03:00)' },
        { name: 'Europe/Uzhgorod', desc: 'Ukraine - Uzhgorod (GMT+03:00)' },
        { name: 'Europe/Zaporozhye', desc: 'Ukraine - Zaporozhye (GMT+03:00)' },
        { name: 'Africa/Kampala', desc: 'Uganda - Kampala (GMT+03:00)' },
        { name: 'Pacific/Johnston', desc: 'US Minor Outlying Islands - Johnston (GMT-10:00)' },
        { name: 'Pacific/Midway', desc: 'US Minor Outlying Islands - Midway (GMT-11:00)' },
        { name: 'Pacific/Wake', desc: 'US Minor Outlying Islands - Wake (GMT+12:00)' },
        { name: 'America/New_York', desc: 'United States of America (USA) - New York (GMT-04:00)' },
        { name: 'America/Detroit', desc: 'United States of America (USA) - Detroit (GMT-04:00)' },
        { name: 'America/Kentucky/Louisville', desc: 'United States of America (USA) - Louisville (GMT-04:00)' },
        { name: 'America/Kentucky/Monticello', desc: 'United States of America (USA) - Monticello (GMT-04:00)' },
        { name: 'America/Indiana/Indianapolis', desc: 'United States of America (USA) - Indianapolis (GMT-04:00)' },
        { name: 'America/Indiana/Vincennes', desc: 'United States of America (USA) - Vincennes (GMT-04:00)' },
        { name: 'America/Indiana/Winamac', desc: 'United States of America (USA) - Winamac (GMT-04:00)' },
        { name: 'America/Indiana/Marengo', desc: 'United States of America (USA) - Marengo (GMT-04:00)' },
        { name: 'America/Indiana/Petersburg', desc: 'United States of America (USA) - Petersburg (GMT-04:00)' },
        { name: 'America/Indiana/Vevay', desc: 'United States of America (USA) - Vevay (GMT-04:00)' },
        { name: 'America/Chicago', desc: 'United States of America (USA) - Chicago (GMT-05:00)' },
        { name: 'America/Indiana/Tell_City', desc: 'United States of America (USA) - Tell City (GMT-05:00)' },
        { name: 'America/Indiana/Knox', desc: 'United States of America (USA) - Knox (GMT-05:00)' },
        { name: 'America/Menominee', desc: 'United States of America (USA) - Menominee (GMT-05:00)' },
        { name: 'America/North_Dakota/Center', desc: 'United States of America (USA) - Center (GMT-05:00)' },
        { name: 'America/North_Dakota/New_Salem', desc: 'United States of America (USA) - New Salem (GMT-05:00)' },
        { name: 'America/North_Dakota/Beulah', desc: 'United States of America (USA) - Beulah (GMT-05:00)' },
        { name: 'America/Denver', desc: 'United States of America (USA) - Denver (GMT-06:00)' },
        { name: 'America/Boise', desc: 'United States of America (USA) - Boise (GMT-06:00)' },
        { name: 'America/Phoenix', desc: 'United States of America (USA) - Phoenix (GMT-07:00)' },
        { name: 'America/Los_Angeles', desc: 'United States of America (USA) - Los Angeles (GMT-07:00)' },
        { name: 'America/Anchorage', desc: 'United States of America (USA) - Anchorage (GMT-08:00)' },
        { name: 'America/Juneau', desc: 'United States of America (USA) - Juneau (GMT-08:00)' },
        { name: 'America/Sitka', desc: 'United States of America (USA) - Sitka (GMT-08:00)' },
        { name: 'America/Yakutat', desc: 'United States of America (USA) - Yakutat (GMT-08:00)' },
        { name: 'America/Nome', desc: 'United States of America (USA) - Nome (GMT-08:00)' },
        { name: 'America/Adak', desc: 'United States of America (USA) - Adak (GMT-09:00)' },
        { name: 'America/Metlakatla', desc: 'United States of America (USA) - Metlakatla (GMT-08:00)' },
        { name: 'Pacific/Honolulu', desc: 'United States of America (USA) - Honolulu (GMT-10:00)' },
        { name: 'America/Montevideo', desc: 'Uruguay - Montevideo (GMT-03:00)' },
        { name: 'Asia/Samarkand', desc: 'Uzbekistan - Samarkand (GMT+05:00)' },
        { name: 'Asia/Tashkent', desc: 'Uzbekistan - Tashkent (GMT+05:00)' },
        { name: 'Europe/Vatican', desc: 'Vatican City State - Vatican (GMT+02:00)' },
        { name: 'America/St_Vincent', desc: 'Saint Vincent and Grenadines - St Vincent (GMT-04:00)' },
        { name: 'America/Caracas', desc: 'Venezuela - Caracas (GMT-04:00)' },
        { name: 'America/Tortola', desc: 'British Virgin Islands - Tortola (GMT-04:00)' },
        { name: 'America/St_Thomas', desc: 'Virgin Islands, US - St Thomas (GMT-04:00)' },
        { name: 'Asia/Ho_Chi_Minh', desc: 'Viet Nam - Ho Chi_Minh (GMT+07:00)' },
        { name: 'Pacific/Efate', desc: 'Vanuatu - Efate (GMT+11:00)' },
        { name: 'Pacific/Wallis', desc: 'Wallis and Futuna Islands - Wallis (GMT+12:00)' },
        { name: 'Pacific/Apia', desc: 'Samoa - Apia (GMT+13:00)' },
        { name: 'Asia/Aden', desc: 'Yemen - Aden (GMT+03:00)' },
        { name: 'Indian/Mayotte', desc: 'Mayotte - Mayotte (GMT+03:00)' },
        { name: 'Africa/Johannesburg', desc: 'South Africa - Johannesburg (GMT+02:00)' },
        { name: 'Africa/Lusaka', desc: 'Zambia - Lusaka (GMT+02:00)' },
        { name: 'Africa/Harare', desc: 'Zimbabwe - Harare (GMT+02:00)' },
    ];

    var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var /** @type {?} */ initialState$3 = {
        isSidebarOpen: false,
        isSidebarActive: false,
        isSidebarInnerActive: false,
        isSidebarStateCloseWithIcons: false,
        windowWidth: 0,
        windowHeight: 0,
        wrapperClasses: '',
        breakpoint: '',
        breakpoints: {
            isMobile: false,
            isTablet: false,
            isLtDesktop: false,
            isDesktop: false,
            isXL: false,
            isXXL: false,
        },
        menuLinks: [],
        sidebarLinks: [],
        combinedLinks: [],
        isBlockDocumentActive: false,
    };
    var UxAppShellService = (function () {
        function UxAppShellService() {
            this._state$ = new BehaviorSubject.BehaviorSubject(initialState$3);
            this._breakpoint$ = new BehaviorSubject.BehaviorSubject('');
            this._breakpoints$ = new BehaviorSubject.BehaviorSubject({});
        }
        Object.defineProperty(UxAppShellService.prototype, "state$", {
            // -------------------
            // exposed observables
            // -------------------
            get: /**
             * @return {?}
             */
            function () {
                return this._state$.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxAppShellService.prototype, "breakpoint$", {
            get: /**
             * @return {?}
             */
            function () {
                return this._breakpoint$.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxAppShellService.prototype, "breakpoints$", {
            get: /**
             * @return {?}
             */
            function () {
                return this._breakpoints$.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxAppShellService.prototype, "state", {
            // ----------------
            // state operations
            // ----------------
            get: /**
             * @return {?}
             */
            function () {
                return this._state$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} nextState
         * @return {?}
         */
        UxAppShellService.prototype.setState = /**
         * @param {?} nextState
         * @return {?}
         */
        function (nextState) {
            var /** @type {?} */ breakpoint, /** @type {?} */ breakpoints, /** @type {?} */ wrapperClasses;
            var /** @type {?} */ combinedLinks;
            var /** @type {?} */ state = this.state;
            // check if window width has been updated from previous state
            if (this.state.windowWidth !== nextState.windowWidth) {
                breakpoint = this.getBreakpoint(nextState.windowWidth);
                breakpoints = this.getBreakpoints(breakpoint);
                this._breakpoint$.next(breakpoint);
                this._breakpoints$.next(breakpoints);
                // if not propagate the old ones without doing any calculations
            }
            else {
                breakpoint = state.breakpoint;
                breakpoints = state.breakpoints;
            }
            // finally get the wrapper classes when both the state and breakpoint are known
            wrapperClasses = this.getWrapperClasses(nextState, breakpoint);
            // check if the menuLinks or sidebarLinks have changed from previous state
            if (this.state.menuLinks !== nextState.menuLinks || this.state.sidebarLinks !== nextState.sidebarLinks) {
                combinedLinks = nextState.menuLinks.concat(nextState.sidebarLinks);
            }
            else {
                combinedLinks = this.state.combinedLinks;
            }
            // we put it all together with the calculated properties
            this._state$.next(__assign$1({}, nextState, { wrapperClasses: wrapperClasses,
                breakpoint: breakpoint,
                breakpoints: breakpoints,
                combinedLinks: combinedLinks }));
        };
        Object.defineProperty(UxAppShellService.prototype, "isSidebarOpen", {
            // ----------------------------
            // public setters and functions
            // ----------------------------
            set: /**
             * @param {?} isOpen
             * @return {?}
             */
            function (isOpen) {
                this.setState(__assign$1({}, this.state, { isSidebarOpen: isOpen }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxAppShellService.prototype.sidebarToggle = /**
         * @return {?}
         */
        function () {
            this.isSidebarOpen = !this.state.isSidebarOpen;
        };
        Object.defineProperty(UxAppShellService.prototype, "sidebarLinks", {
            set: /**
             * @param {?} links
             * @return {?}
             */
            function (links) {
                this.setState(__assign$1({}, this.state, { sidebarLinks: links }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxAppShellService.prototype, "menuLinks", {
            set: /**
             * @param {?} links
             * @return {?}
             */
            function (links) {
                this.setState(__assign$1({}, this.state, { menuLinks: links }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxAppShellService.prototype, "isBlockDocumentActive", {
            set: /**
             * @param {?} isActive
             * @return {?}
             */
            function (isActive) {
                this.setState(__assign$1({}, this.state, { isBlockDocumentActive: isActive }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @param {?} breakpoint
         * @return {?}
         */
        UxAppShellService.prototype.getWrapperClasses = /**
         * @param {?} state
         * @param {?} breakpoint
         * @return {?}
         */
        function (state, breakpoint) {
            var /** @type {?} */ classes = [];
            classes.push(breakpoint);
            if (state.isSidebarOpen && (state.isSidebarActive || state.isSidebarInnerActive)) {
                classes.push('sidebar-state-open');
            }
            if (!state.isSidebarOpen && (state.isSidebarActive || state.isSidebarInnerActive)) {
                classes.push('sidebar-state-close');
            }
            if (state.isSidebarActive) {
                classes.push('sidebar-active');
            }
            if (state.isSidebarInnerActive) {
                classes.push('sidebar-inner-active');
            }
            if (state.isSidebarStateCloseWithIcons) {
                classes.push('sidebar-state-close-with-icons');
            }
            return classes.join(' ');
        };
        /**
         * @param {?} windowWidth
         * @return {?}
         */
        UxAppShellService.prototype.getBreakpoint = /**
         * @param {?} windowWidth
         * @return {?}
         */
        function (windowWidth) {
            var /** @type {?} */ bkp = '';
            switch (true) {
                case (windowWidth >= 0 && windowWidth < 576):
                    bkp = 'xs';
                    break;
                case (windowWidth >= 576 && windowWidth < 768):
                    bkp = 'sm';
                    break;
                case (windowWidth >= 768 && windowWidth < 992):
                    bkp = 'md';
                    break;
                case (windowWidth >= 992 && windowWidth < 1200):
                    bkp = 'lg';
                    break;
                case (windowWidth >= 1200 && windowWidth < 1400):
                    bkp = 'xl';
                    break;
                case (windowWidth >= 1400):
                    bkp = 'xxl';
                    break;
            }
            return bkp;
        };
        /**
         * @param {?} bkp
         * @return {?}
         */
        UxAppShellService.prototype.getBreakpoints = /**
         * @param {?} bkp
         * @return {?}
         */
        function (bkp) {
            return {
                isMobile: (bkp === 'xs' || bkp === 'sm'),
                isTablet: bkp === 'md',
                isLtDesktop: (bkp === 'xs' || bkp === 'sm' || bkp === 'md'),
                isDesktop: bkp === 'lg',
                isXL: bkp === 'xl',
                isXXL: bkp === 'xxl',
            };
        };
        UxAppShellService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxAppShellService.ctorParameters = function () { return []; };
        return UxAppShellService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxModal = (function () {
        function UxModal(values) {
            if (values === void 0) { values = {}; }
            Object.assign(this, values);
        }
        return UxModal;
    }());
    var UxService = (function () {
        function UxService(router$$1, componentFactoryResolver, appRef, injector, asService, platformId) {
            var _this = this;
            this.router = router$$1;
            this.componentFactoryResolver = componentFactoryResolver;
            this.appRef = appRef;
            this.injector = injector;
            this.asService = asService;
            this.platformId = platformId;
            this.isNavigationBlockDocumentActive = false;
            this.isLoggingActive = false;
            this.activeLanguage = {
                code: 'en',
                label: 'English'
            };
            this.growlMessages = [];
            this.isGrowlSticky = false;
            this.growlLife = 3000;
            this.growlPosition = 'bottom-right';
            // DEPRECATED start
            this.isBlockDocumentActive = false;
            this.activeBreakpoint = new BehaviorSubject.BehaviorSubject('');
            this.windowWidth$ = new BehaviorSubject.BehaviorSubject(0);
            this.windowHeight = new BehaviorSubject.BehaviorSubject(0);
            this.sidebarLinks = [];
            // DEPRECATED end
            this.activeModals = [];
            this.openModalId = new BehaviorSubject.BehaviorSubject('');
            if (common.isPlatformBrowser(this.platformId)) {
                router$$1.events
                    .subscribe(function (event) {
                    if (event instanceof router.NavigationStart) {
                        _this.navigationStartHandler(event);
                    }
                    if (event instanceof router.NavigationEnd) {
                        _this.navigationEndHandler(event);
                    }
                });
            }
        }
        Object.defineProperty(UxService.prototype, "appRouter", {
            get: /**
             * @return {?}
             */
            function () {
                return this.router;
            },
            enumerable: true,
            configurable: true
        });
        // Common functions
        // --------------------------
        /**
         * @param {?} querySelector
         * @return {?}
         */
        UxService.prototype.shadowDomQuery = /**
         * @param {?} querySelector
         * @return {?}
         */
        function (querySelector) {
            return this.shadowDomRoot.nativeElement.querySelector(querySelector);
        };
        /**
         * @return {?}
         */
        UxService.prototype.uniqueId = /**
         * @return {?}
         */
        function () {
            return Math.random().toString(36).substr(2, 9);
        };
        // Sidebar functions
        // -----------------
        /**
         * @param {?} links
         * @return {?}
         */
        UxService.prototype.setSidebarLinks = /**
         * @param {?} links
         * @return {?}
         */
        function (links) {
            this.sidebarLinks = links;
        };
        // Breadcrumbs helpers - TODO
        // --------------------------
        // Growl helpers
        // -------------
        /**
         * displays a growl UxMessage item, isStycky
         */
        /**
         * displays a growl UxMessage item, isStycky
         * @param {?} msg
         * @param {?=} isSticky
         * @param {?=} isMultiple
         * @param {?=} life
         * @param {?=} position
         * @return {?}
         */
        UxService.prototype.growl = /**
         * displays a growl UxMessage item, isStycky
         * @param {?} msg
         * @param {?=} isSticky
         * @param {?=} isMultiple
         * @param {?=} life
         * @param {?=} position
         * @return {?}
         */
        function (msg, isSticky, isMultiple, life, position) {
            if (msg.severity !== 'info' && msg.severity !== 'warning' && msg.severity !== 'success' && msg.severity !== 'danger') {
                throw new Error('UxService.growl() ERROR : message severity must be either : success,warning,info,danger');
            }
            else {
                if (isMultiple === undefined || !isMultiple) {
                    this.growlMessages = [];
                }
                this.growlMessages = this.growlMessages.concat(msg);
                if (life === undefined || isNaN(life)) {
                    this.growlLife = 3000;
                }
                else {
                    this.growlLife = life;
                }
                if (isSticky) {
                    this.isGrowlSticky = isSticky;
                }
                else {
                    this.isGrowlSticky = false;
                }
                if (position) {
                    this.growlPosition = position;
                }
            }
        };
        /**
         * @return {?}
         */
        UxService.prototype.clearGrowl = /**
         * @return {?}
         */
        function () {
            this.growlMessages = [];
        };
        /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        UxService.prototype.growlSuccess = /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        function (msg, position) {
            this.growl({ severity: 'success', summary: 'SUCCESS', detail: msg }, false, false, undefined, position);
        };
        /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        UxService.prototype.growlError = /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        function (msg, position) {
            this.growl({ severity: 'danger', summary: 'ERROR', detail: msg }, false, false, undefined, position);
        };
        /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        UxService.prototype.growlWarning = /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        function (msg, position) {
            this.growl({ severity: 'warning', summary: 'WARNING', detail: msg }, false, false, undefined, position);
        };
        /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        UxService.prototype.growlInfo = /**
         * @param {?} msg
         * @param {?=} position
         * @return {?}
         */
        function (msg, position) {
            this.growl({ severity: 'info', summary: 'INFO', detail: msg }, false, false, undefined, position);
        };
        // DEPRECATED start
        // BlockUI helpers
        // ---------------
        /**
         * @return {?}
         */
        UxService.prototype.blockDocument = /**
         * @return {?}
         */
        function () {
            console.warn("\n            ****** eUI 4 DEPRECATED WARNING ******\n            uxService.blockDocument() will be deprecated and replaced by UxAppShellService.isBlockDocumentActive = true\n        ");
            this.asService.isBlockDocumentActive = true;
            // setTimeout(() => this.isBlockDocumentActive = true);
        };
        /**
         * @return {?}
         */
        UxService.prototype.unblockDocument = /**
         * @return {?}
         */
        function () {
            console.warn("\n            ****** eUI 4 DEPRECATED WARNING ******\n            uxService.unblockDocument() will be deprecated and replaced by UxAppShellService.isBlockDocumentActive = false\n        ");
            this.asService.isBlockDocumentActive = false;
            // setTimeout(() => this.isBlockDocumentActive = false);
        };
        // Responsive helpers
        // ------------------
        /**
         * @param {?} width
         * @return {?}
         */
        UxService.prototype.setActiveBreakpoint = /**
         * @param {?} width
         * @return {?}
         */
        function (width) {
            this.windowWidth = width;
            this.windowWidth$.next(width);
            switch (true) {
                case (width >= 0 && width < 576):
                    this.activeBreakpoint.next('xs');
                    break;
                case (width >= 576 && width < 768):
                    this.activeBreakpoint.next('sm');
                    break;
                case (width >= 768 && width < 992):
                    this.activeBreakpoint.next('md');
                    break;
                case (width >= 992 && width < 1200):
                    this.activeBreakpoint.next('lg');
                    break;
                case (width >= 1200 && width < 1400):
                    this.activeBreakpoint.next('xl');
                    break;
                case (width >= 1400):
                    this.activeBreakpoint.next('xxl');
                    break;
            }
            return this.activeBreakpoint.value;
        };
        /**
         * @return {?}
         */
        UxService.prototype.isMobile = /**
         * @return {?}
         */
        function () {
            return (this.activeBreakpoint.value === 'xs' || this.activeBreakpoint.value === 'sm');
        };
        /**
         * @return {?}
         */
        UxService.prototype.isTablet = /**
         * @return {?}
         */
        function () {
            return this.activeBreakpoint.value === 'md';
        };
        /**
         * @return {?}
         */
        UxService.prototype.isLtDesktop = /**
         * @return {?}
         */
        function () {
            return (this.activeBreakpoint.value === 'xs'
                || this.activeBreakpoint.value === 'sm'
                || this.activeBreakpoint.value === 'md');
        };
        /**
         * @return {?}
         */
        UxService.prototype.isDesktop = /**
         * @return {?}
         */
        function () {
            return this.activeBreakpoint.value === 'lg';
        };
        /**
         * @return {?}
         */
        UxService.prototype.isLargeDesktop = /**
         * @return {?}
         */
        function () {
            return (this.activeBreakpoint.value === 'xl');
        };
        /**
         * @return {?}
         */
        UxService.prototype.isExtraLargeDesktop = /**
         * @return {?}
         */
        function () {
            return (this.activeBreakpoint.value === 'xxl');
        };
        /**
         * @param {?} height
         * @return {?}
         */
        UxService.prototype.setWindowHeight = /**
         * @param {?} height
         * @return {?}
         */
        function (height) {
            this.windowHeight.next(height);
        };
        /**
         * @param {?} width
         * @return {?}
         */
        UxService.prototype.setWindowWidth = /**
         * @param {?} width
         * @return {?}
         */
        function (width) {
            this.windowWidth$.next(width);
        };
        // DEPRECATED end
        // i18n helpers
        // ------------
        /**
         * @param {?} key
         * @param {?=} languageCode
         * @return {?}
         */
        UxService.prototype.translate = /**
         * @param {?} key
         * @param {?=} languageCode
         * @return {?}
         */
        function (key, languageCode) {
            var /** @type {?} */ code = 'en';
            if (languageCode) {
                if (languageCode === 'en' || languageCode === 'fr') {
                    code = languageCode;
                }
            }
            else {
                if (this.activeLanguage) {
                    code = this.activeLanguage.code;
                }
            }
            return UX_I18N[code][key];
        };
        // date helpers
        // ------------
        /**
         * @param {?} dateStart
         * @param {?} dateEnd
         * @return {?}
         */
        UxService.prototype.diffDays = /**
         * @param {?} dateStart
         * @param {?} dateEnd
         * @return {?}
         */
        function (dateStart, dateEnd) {
            return Math.round((dateEnd.getTime() - dateStart.getTime()) / 1000 / 60 / 60 / 24);
        };
        /**
         * @param {?} date
         * @return {?}
         */
        UxService.prototype.diffDaysFromToday = /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            return this.diffDays(new Date(), date);
        };
        // DEPRECATED start
        // AppWrapper sidebar classes
        // --------------------------
        /**
         * @return {?}
         */
        UxService.prototype.toggleInnerSidebar = /**
         * @return {?}
         */
        function () {
            console.warn("\n            ****** eUI 4 DEPRECATED WARNING ******\n            uxService.toggleInnerSidebar() will be deprecated and replaced by UxAppShellService.sidebarToggle()\n        ");
            this.asService.sidebarToggle();
        };
        Object.defineProperty(UxService.prototype, "isSidebarStateOpen", {
            get: /**
             * @return {?}
             */
            function () {
                console.warn("\n            ****** eUI 4 DEPRECATED WARNING ******\n            uxService.isSidebarStateOpen() will be deprecated and replaced by UxAppShellService.state$.isSidebarOpen.getValue()\n        ");
                return this.asService.isSidebarOpen;
            },
            set: /**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                console.warn("\n            ****** eUI 4 DEPRECATED WARNING ******\n            uxService.isSidebarStateOpen() will be deprecated and replaced by UxAppShellService.isSidebarOpen = true | false\n        ");
                this.asService.isSidebarOpen = state;
            },
            enumerable: true,
            configurable: true
        });
        // DEPRECATED end
        // Error Handling from HTTP subscribe
        // ----------------------------------
        /**
         * @param {?} error
         * @return {?}
         */
        UxService.prototype.handleError = /**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            var /** @type {?} */ errMsg = (error.message) ? error.message :
                error.status ? error.status + " - " + error.statusText : 'Server error';
            // console.error(errMsg);
            return Observable.Observable.throw(errMsg);
        };
        // Modal functions
        // ---------------
        /**
         * @param {?=} modalId
         * @return {?}
         */
        UxService.prototype.openModal = /**
         * @param {?=} modalId
         * @return {?}
         */
        function (modalId) {
            document.body.classList.add('modal-open');
            if (!modalId) {
                modalId = 'single_modal';
            }
            this.activeModals.push(new UxModal({
                id: modalId,
                isOpen: true
            }));
            setTimeout(function () {
                var /** @type {?} */ el = document.getElementById(modalId + '-close-button');
                if (el) {
                    el.focus();
                }
            }, 100);
        };
        /**
         * @param {?=} messageBoxId
         * @return {?}
         */
        UxService.prototype.openMessageBox = /**
         * @param {?=} messageBoxId
         * @return {?}
         */
        function (messageBoxId) {
            if (!messageBoxId) {
                messageBoxId = 'messagebox_modal';
            }
            this.openModal(messageBoxId);
        };
        /**
         * @param {?=} messageBoxId
         * @return {?}
         */
        UxService.prototype.closeMessageBox = /**
         * @param {?=} messageBoxId
         * @return {?}
         */
        function (messageBoxId) {
            if (!messageBoxId) {
                messageBoxId = 'messagebox_modal';
            }
            this.closeModal(messageBoxId);
        };
        /**
         * @param {?=} modalId
         * @return {?}
         */
        UxService.prototype.isModalOpen = /**
         * @param {?=} modalId
         * @return {?}
         */
        function (modalId) {
            if (!modalId) {
                modalId = 'single_modal';
            }
            if (this.activeModals.length) {
                var /** @type {?} */ modalIndex = this.findModalIndex(modalId);
                if (modalIndex !== -1) {
                    return this.activeModals[modalIndex].isOpen;
                }
            }
            return false;
        };
        /**
         * @param {?=} modalId
         * @return {?}
         */
        UxService.prototype.closeModal = /**
         * @param {?=} modalId
         * @return {?}
         */
        function (modalId) {
            if (!modalId) {
                modalId = 'single_modal';
            }
            /**
             * Make sure we find the modal before splicing the activeModals array
             */
            var /** @type {?} */ index = this.findModalIndex(modalId);
            if (index >= 0) {
                this.activeModals.splice(index, 1);
            }
            if (this.activeModals && this.activeModals.length <= 0) {
                document.body.classList.remove('modal-open');
            }
            else {
                // If there is still another (parent) modal dialog open, ensure it is focused upon to be able to close is with the ESC key:
                var /** @type {?} */ lastModalId_1 = this.activeModals[this.activeModals.length - 1].id;
                if (lastModalId_1) {
                    setTimeout(function () {
                        var /** @type {?} */ el = document.getElementById(lastModalId_1 + '-close-button');
                        if (el) {
                            el.focus();
                        }
                    }, 100);
                }
            }
        };
        /**
         * @param {?} modalId
         * @return {?}
         */
        UxService.prototype.findModalIndex = /**
         * @param {?} modalId
         * @return {?}
         */
        function (modalId) {
            var /** @type {?} */ index = -1;
            if (this.activeModals.length) {
                for (var /** @type {?} */ i = 0; i < this.activeModals.length; i++) {
                    if (this.activeModals[i].id === modalId) {
                        index = i;
                        break;
                    }
                }
            }
            return index;
        };
        // Positions helpers
        /**
         * Provides read-only equivalent of jQuery's position function:
         * http://api.jquery.com/position/
         */
        /**
         * Provides read-only equivalent of jQuery's position function:
         * http://api.jquery.com/position/
         * @param {?} nativeEl
         * @return {?}
         */
        UxService.prototype.position = /**
         * Provides read-only equivalent of jQuery's position function:
         * http://api.jquery.com/position/
         * @param {?} nativeEl
         * @return {?}
         */
        function (nativeEl) {
            var /** @type {?} */ elBCR = this.offset(nativeEl);
            var /** @type {?} */ offsetParentBCR = { top: 0, left: 0 };
            var /** @type {?} */ offsetParentEl = this.parentOffsetEl(nativeEl);
            if (offsetParentEl !== this.document) {
                offsetParentBCR = this.offset(offsetParentEl);
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
                offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
            return {
                width: boundingClientRect.width || nativeEl.offsetWidth,
                height: boundingClientRect.height || nativeEl.offsetHeight,
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        };
        /**
         * Provides read-only equivalent of jQuery's offset function:
         * http://api.jquery.com/offset/
         */
        /**
         * Provides read-only equivalent of jQuery's offset function:
         * http://api.jquery.com/offset/
         * @param {?} nativeEl
         * @return {?}
         */
        UxService.prototype.offset = /**
         * Provides read-only equivalent of jQuery's offset function:
         * http://api.jquery.com/offset/
         * @param {?} nativeEl
         * @return {?}
         */
        function (nativeEl) {
            var /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
            return {
                width: boundingClientRect.width || nativeEl.offsetWidth,
                height: boundingClientRect.height || nativeEl.offsetHeight,
                top: boundingClientRect.top + (this.window.pageYOffset || this.document.documentElement.scrollTop),
                left: boundingClientRect.left + (this.window.pageXOffset || this.document.documentElement.scrollLeft)
            };
        };
        // OTHERS helpers
        /**
         * @param {?} event
         * @return {?}
         */
        UxService.prototype.consumeEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.cancelBubble = true;
            }
            return false;
        };
        // FORMS helpers and VALIDATORS
        /**
         * @param {?} c
         * @return {?}
         */
        UxService.prototype.validateEmail = /**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            /* tslint:disable */
            var /** @type {?} */ EMAIL_REGEXP = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
            /* tslint:enable */
            return EMAIL_REGEXP.test(c.value) ? null : {
                validateEmail: {
                    valid: false
                }
            };
        };
        /**
         * @param {?} FormControls
         * @return {?}
         */
        UxService.prototype.markFormGroupTouched = /**
         * @param {?} FormControls
         * @return {?}
         */
        function (FormControls) {
            var _this = this;
            var /** @type {?} */ markFormGroupTouchedRecursive = function (controls) {
                _this.forOwn(controls, function (c, controlKey) {
                    if (c instanceof forms.FormGroup || c instanceof forms.FormArray) {
                        markFormGroupTouchedRecursive(c.controls);
                    }
                    else {
                        c.markAsTouched();
                        c.updateValueAndValidity();
                    }
                });
            };
            markFormGroupTouchedRecursive(FormControls);
        };
        /**
         * @return {?}
         */
        UxService.prototype.getDecimalSeparator = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ n = 1.1;
            n = n.toLocaleString().substring(1, 2);
            return n;
        };
        /**
         * @param {?} value
         * @param {?=} fractionSize
         * @param {?=} inDecimalSeparator
         * @param {?=} inThousandSeparator
         * @return {?}
         */
        UxService.prototype.formatNumber = /**
         * @param {?} value
         * @param {?=} fractionSize
         * @param {?=} inDecimalSeparator
         * @param {?=} inThousandSeparator
         * @return {?}
         */
        function (value, fractionSize, inDecimalSeparator, inThousandSeparator) {
            if (fractionSize === void 0) { fractionSize = 2; }
            if (inDecimalSeparator === void 0) { inDecimalSeparator = null; }
            if (inThousandSeparator === void 0) { inThousandSeparator = null; }
            var /** @type {?} */ decimalSeparator;
            var /** @type {?} */ thousandsSeparator;
            if (value === null || value === undefined) {
                return null;
            }
            // console.log(inDecimalSeparator)
            // console.log(inThousandSeparator)
            if (inDecimalSeparator) {
                decimalSeparator = inDecimalSeparator;
                if (inDecimalSeparator === ',') {
                    thousandsSeparator = ' ';
                    inThousandSeparator = ' ';
                }
                else {
                    thousandsSeparator = '';
                }
            }
            else {
                decimalSeparator = ',';
            }
            if (inThousandSeparator) {
                thousandsSeparator = inThousandSeparator;
                if (inThousandSeparator === ',') {
                    decimalSeparator = '.';
                }
                else {
                    decimalSeparator = !inDecimalSeparator || (inDecimalSeparator !== '.' && inDecimalSeparator !== ',') ?
                        ',' :
                        inDecimalSeparator;
                }
            }
            else {
                thousandsSeparator = '';
            }
            var /** @type {?} */ maxFractions = [];
            for (var /** @type {?} */ i = 0; i < fractionSize; i++) {
                maxFractions.push('0');
            }
            var /** @type {?} */ maxFraction = maxFractions.join('');
            var _a = (value || '0').toString().split('.'), integer = _a[0], _b = _a[1], fraction = _b === void 0 ? maxFraction : _b;
            fraction = fractionSize > 0 ? (fraction + maxFraction).substring(0, fractionSize) : '';
            if (fraction === maxFraction) {
                fraction = '';
            }
            // console.log(decimalSeparator)
            // console.log(thousandsSeparator)
            integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSeparator);
            return integer + (fraction.length > 0 ? decimalSeparator + fraction : '');
        };
        /**
         * @param {?} object
         * @param {?} iteratee
         * @return {?}
         */
        UxService.prototype.forOwn = /**
         * @param {?} object
         * @param {?} iteratee
         * @return {?}
         */
        function (object, iteratee) {
            object = Object(object);
            Object.keys(object).forEach(function (key) { return iteratee(object[key], key, object); });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxService.prototype.navigationStartHandler = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /*
                    if (this.isNavigationBlockDocumentActive) {
                        this.blockDocument();
                    }
                    */
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxService.prototype.navigationEndHandler = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /*
                    if (this.isNavigationBlockDocumentActive) {
                        this.unblockDocument();
                    }
                    */
            window.scrollTo(0, 0);
        };
        Object.defineProperty(UxService.prototype, "window", {
            get: /**
             * @return {?}
             */
            function () {
                return window;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxService.prototype, "document", {
            get: /**
             * @return {?}
             */
            function () {
                return window.document;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} nativeEl
         * @param {?} cssProp
         * @return {?}
         */
        UxService.prototype.getStyle = /**
         * @param {?} nativeEl
         * @param {?} cssProp
         * @return {?}
         */
        function (nativeEl, cssProp) {
            // IE
            if (nativeEl.currentStyle) {
                return nativeEl.currentStyle[cssProp];
            }
            if (this.window.getComputedStyle) {
                return this.window.getComputedStyle(nativeEl)[cssProp];
            }
            // finally try and get inline style
            return nativeEl.style[cssProp];
        };
        /**
         * Checks if a given element is statically positioned
         * @param {?} nativeEl
         * @return {?}
         */
        UxService.prototype.isStaticPositioned = /**
         * Checks if a given element is statically positioned
         * @param {?} nativeEl
         * @return {?}
         */
        function (nativeEl) {
            return (this.getStyle(nativeEl, 'position') || 'static') === 'static';
        };
        /**
         * returns the closest, non-statically positioned parentOffset of a given element
         * @param {?} nativeEl
         * @return {?}
         */
        UxService.prototype.parentOffsetEl = /**
         * returns the closest, non-statically positioned parentOffset of a given element
         * @param {?} nativeEl
         * @return {?}
         */
        function (nativeEl) {
            var /** @type {?} */ offsetParent = nativeEl.offsetParent || this.document;
            while (offsetParent && offsetParent !== this.document &&
                this.isStaticPositioned(offsetParent)) {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || this.document;
        };
        UxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxService.ctorParameters = function () { return [
            { type: router.Router, },
            { type: core.ComponentFactoryResolver, },
            { type: core.ApplicationRef, },
            { type: core.Injector, },
            { type: UxAppShellService, },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] },] },
        ]; };
        return UxService;
    }());

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var AppEffects = (function () {
        function AppEffects(actions, store$$1, uxService) {
            var _this = this;
            this.actions = actions;
            this.store = store$$1;
            this.uxService = uxService;
            this.connectionUpdate = this.actions.ofType(APP_CONNECTION_UPDATE)
                .switchMap(function (action) {
                if (action.payload === true) {
                    return Observable.Observable.of({
                        type: APP_CONNECTION_UPDATE_CONFIRMED,
                        payload: true,
                    })
                        .do(function () { return _this.store.dispatch(new AppStatusUpdate('connecting')); })
                        .delay(2500)
                        .do(function () { return _this.store.dispatch(new AppStatusUpdate('idle')); });
                }
                else {
                    return Observable.Observable.of({
                        type: APP_CONNECTION_UPDATE_CONFIRMED,
                        payload: false,
                    })
                        .do(function () { return _this.store.dispatch(new AppStatusUpdate('idle')); });
                }
            });
            this.connectionUpdateConfirmed = this.actions.ofType(APP_CONNECTION_UPDATE_CONFIRMED)
                .do(function (action) {
                if (!action.payload) {
                    _this.uxService.growl({ severity: 'danger', summary: 'ERROR', detail: 'You are not connected' }, true, false);
                }
                else {
                    _this.uxService.growl({ severity: 'success', summary: 'MESSAGE', detail: 'You are connected' }, true, false);
                }
            });
        }
        AppEffects.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AppEffects.ctorParameters = function () { return [
            { type: effects.Actions, },
            { type: StoreService, },
            { type: UxService, },
        ]; };
        __decorate([
            effects.Effect(),
            __metadata("design:type", Object)
        ], AppEffects.prototype, "connectionUpdate", void 0);
        __decorate([
            effects.Effect({ dispatch: false }),
            __metadata("design:type", Object)
        ], AppEffects.prototype, "connectionUpdateConfirmed", void 0);
        return AppEffects;
    }());

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * @param {?} action
     * @return {?}
     */
    function toPayload(action) {
        return (/** @type {?} */ (action)).payload;
    }
    var RoutesEffects = (function () {
        function RoutesEffects(actions) {
            this.actions = actions;
            this.routeUpdate = this.actions.ofType(UPDATE_ROUTE)
                .map(toPayload)
                .mergeMap(function (route) {
                var /** @type {?} */ module = route.snapshot.data['module'] || 'undefined';
                return [
                    new ChangeModuleAction(module),
                ];
            });
        }
        RoutesEffects.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        RoutesEffects.ctorParameters = function () { return [
            { type: effects.Actions, },
        ]; };
        __decorate$1([
            effects.Effect(),
            __metadata$1("design:type", Observable.Observable)
        ], RoutesEffects.prototype, "routeUpdate", void 0);
        return RoutesEffects;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CoreModuleEffects = [AppEffects, RoutesEffects];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OpenidConnectService = (function () {
        function OpenidConnectService(config, http$$1) {
            this.config = config;
            this.http = http$$1;
            this.SESSION_STORAGE_KEY_ID_TOKEN = 'ux-openid-connect-id-token';
            this.SESSION_STORAGE_KEY_USER_DETAILS = 'ux-openid-connect-user-details';
            this.REQUEST_PARAMETER_ORIGINAL_URL = 'ux-openid-connect-original-url';
            this.DEFAULT_OPENID_SCOPE = 'openid email profile';
        }
        /**
         * @return {?}
         */
        OpenidConnectService.prototype.getIdToken = /**
         * @return {?}
         */
        function () {
            return sessionStorage.getItem(this.SESSION_STORAGE_KEY_ID_TOKEN);
        };
        /**
         * @return {?}
         */
        OpenidConnectService.prototype.getUserDetails = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ detailsString = sessionStorage.getItem(this.SESSION_STORAGE_KEY_USER_DETAILS);
            if (detailsString) {
                return JSON.parse(detailsString);
            }
            else {
                return null;
            }
        };
        /**
         * @return {?}
         */
        OpenidConnectService.prototype.renewIdToken = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ openIdConnectConfig = this.config.openIdConnect;
            sessionStorage.removeItem(this.SESSION_STORAGE_KEY_ID_TOKEN);
            var /** @type {?} */ redirectUrl = openIdConnectConfig.spaRedirectUrl;
            if (redirectUrl.indexOf(this.REQUEST_PARAMETER_ORIGINAL_URL) < 0) {
                var /** @type {?} */ delimiter = (redirectUrl.indexOf('?') >= 0 ? '&' : '?');
                redirectUrl += delimiter + this.REQUEST_PARAMETER_ORIGINAL_URL + '=' + encodeURIComponent(window.location.href);
            }
            var /** @type {?} */ nounce = new Date().getTime();
            window.location.href = openIdConnectConfig.authorizeUrl +
                '?client_id=' + openIdConnectConfig.spaClientId +
                '&response_type=id_token&scope=' + (openIdConnectConfig.scope || this.DEFAULT_OPENID_SCOPE) +
                '&redirect_uri=' + encodeURIComponent(redirectUrl) +
                '&nonce=' + nounce;
        };
        /**
         * @param {?} jwtToken
         * @return {?}
         */
        OpenidConnectService.prototype.decodeJwtToken = /**
         * @param {?} jwtToken
         * @return {?}
         */
        function (jwtToken) {
            var /** @type {?} */ base64Url = jwtToken.split('.')[1];
            var /** @type {?} */ base64 = base64Url.replace('-', '+').replace('_', '/');
            return JSON.parse(window.atob(base64));
        };
        OpenidConnectService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        OpenidConnectService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
            { type: http.HttpClient, },
        ]; };
        return OpenidConnectService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ GET = 'GET';
    var /** @type {?} */ POST = 'POST';
    var /** @type {?} */ PUT = 'PUT';
    var /** @type {?} */ DELETE = 'DELETE';
    var /** @type {?} */ requestOptions = function (options) {
        var /** @type {?} */ defaultOptions = {
            withCredentials: true,
            headers: new http.HttpHeaders({ 'X-Csrf-Request': 'X-Csrf-Request' }),
        };
        return options ? Object.assign({}, defaultOptions, options) : defaultOptions;
    };
    var HttpService = (function () {
        function HttpService(http$$1, translateService) {
            this.http = http$$1;
            this.translateService = translateService;
            /**
             * The request initialized event emitter
             */
            this.requestInit = new core.EventEmitter();
            /**
             * The request resolved event emitter
             */
            this.requestResolved = new core.EventEmitter();
            /**
             * The request failed event emitter
             */
            this.requestFailed = new core.EventEmitter();
        }
        /**
         * @param {?} uri
         * @param {?=} options
         * @return {?}
         */
        HttpService.prototype.get = /**
         * @param {?} uri
         * @param {?=} options
         * @return {?}
         */
        function (uri, options) {
            var _this = this;
            options = requestOptions(options);
            if (options.addLang !== false) {
                uri = this.addLangToUri(uri);
            }
            this.emitRequestInitEvent(GET, uri, options);
            return this.http.get(uri, options)
                .do(function (response) { return _this.emitRequestResolvedEvent(GET, uri, options, response); })
                .catch(function (error) {
                _this.emitRequestFailedEvent(GET, uri, options);
                return Observable.Observable.throw(error);
            });
        };
        /**
         * @param {?} uri
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        HttpService.prototype.post = /**
         * @param {?} uri
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        function (uri, body, options) {
            var _this = this;
            options = requestOptions(options);
            if (options.addLang !== false) {
                uri = this.addLangToUri(uri);
            }
            this.emitRequestInitEvent(POST, uri, options);
            return this.http.post(uri, body, options)
                .do(function (response) { return _this.emitRequestResolvedEvent(POST, uri, options, response); })
                .catch(function (error) {
                _this.emitRequestFailedEvent(POST, uri, options);
                return Observable.Observable.throw(error);
            });
        };
        /**
         * @param {?} uri
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        HttpService.prototype.put = /**
         * @param {?} uri
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        function (uri, body, options) {
            var _this = this;
            options = requestOptions(options);
            if (options.addLang !== false) {
                uri = this.addLangToUri(uri);
            }
            this.emitRequestInitEvent(PUT, uri, options);
            return this.http.put(uri, body, options)
                .do(function (response) { return _this.emitRequestResolvedEvent(PUT, uri, options, response); })
                .catch(function (error) {
                _this.emitRequestFailedEvent(PUT, uri, options);
                return Observable.Observable.throw(error);
            });
        };
        /**
         * @param {?} uri
         * @param {?=} options
         * @return {?}
         */
        HttpService.prototype.delete = /**
         * @param {?} uri
         * @param {?=} options
         * @return {?}
         */
        function (uri, options) {
            var _this = this;
            options = requestOptions(options);
            this.emitRequestInitEvent(DELETE, uri, options);
            return this.http.delete(uri, options)
                .do(function (response) { return _this.emitRequestResolvedEvent(DELETE, uri, options, response); })
                .catch(function (error) {
                _this.emitRequestFailedEvent(DELETE, uri, options);
                return Observable.Observable.throw(error);
            });
        };
        /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @return {?}
         */
        HttpService.prototype.emitRequestInitEvent = /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @return {?}
         */
        function (verb, uri, options) {
            this.requestInit.emit({
                verb: verb,
                options: options,
                uri: uri,
            });
        };
        /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @param {?} response
         * @return {?}
         */
        HttpService.prototype.emitRequestResolvedEvent = /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @param {?} response
         * @return {?}
         */
        function (verb, uri, options, response) {
            this.requestResolved.emit({
                verb: verb,
                options: options,
                uri: uri,
                response: response,
            });
        };
        /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @return {?}
         */
        HttpService.prototype.emitRequestFailedEvent = /**
         * @param {?} verb
         * @param {?} uri
         * @param {?} options
         * @return {?}
         */
        function (verb, uri, options) {
            this.requestFailed.emit({
                verb: verb,
                options: options,
                uri: uri,
            });
        };
        /**
         * @param {?} uri
         * @return {?}
         */
        HttpService.prototype.addLangToUri = /**
         * @param {?} uri
         * @return {?}
         */
        function (uri) {
            var /** @type {?} */ lang = this.translateService.currentLang;
            if (uri.indexOf('?') > 0) {
                return uri += "&lang=" + lang;
            }
            return uri += "?lang=" + lang;
        };
        HttpService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        HttpService.ctorParameters = function () { return [
            { type: http.HttpClient, },
            { type: core$1.TranslateService, },
        ]; };
        return HttpService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UserService = (function () {
        function UserService(config, store$$1, http$$1) {
            this.config = config;
            this.store = store$$1;
            this.http = http$$1;
        }
        /**
         * @return {?}
         */
        UserService.prototype.loadUserDetail = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ url = this.getEndPoint('detail');
            var /** @type {?} */ user = { userId: 'anonymous' };
            if (!url) {
                this.store.dispatch(new UpdateUserDetailAction(user));
                return of$1.of(/** @type {?} */ (user));
            }
            return this.http.get(url)
                .do(function (data) {
                _this.store.dispatch(new UpdateUserDetailAction(data));
            }).catch(function (e) { return of$1.of(/** @type {?} */ (user)); });
        };
        /**
         * @return {?}
         */
        UserService.prototype.observePreferencesUpdate = /**
         * @return {?}
         */
        function () {
            var _this = this;
            (/** @type {?} */ (this.store.select(getUserPrefsState)))
                .filter(function (prefs) { return Object.keys(prefs).length > 0; })
                .switchMap(function (prefs) { return _this.saveUserPreferences(prefs).catch(function () { return of$1.of(prefs); }); })
                .subscribe(function (prefs) {
                console.log('Prefs saved!', prefs);
            });
        };
        /**
         * @return {?}
         */
        UserService.prototype.loadUserPreferences = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ url = this.getEndPoint('preferences');
            if (!url) {
                return of$1.of({});
            }
            var /** @type {?} */ userId = this.getUserId();
            return this.http.get(url + "?userId=" + userId)
                .switchMap(function (dbPrefs) { return _this.userPreferences().map(function (localPrefs) { return Object.assign({}, localPrefs, dbPrefs); }); })
                .do(function (preferences) {
                _this.store.dispatch(new UpdateUserPreferencesAction(preferences));
            }).catch(function (e) { return of$1.of({}); });
        };
        /**
         * @param {?} prefs
         * @return {?}
         */
        UserService.prototype.saveUserPreferences = /**
         * @param {?} prefs
         * @return {?}
         */
        function (prefs) {
            var /** @type {?} */ url = this.getEndPoint('preferences');
            if (!url) {
                return of$1.of({});
            }
            var /** @type {?} */ userId = this.getUserId();
            return this.http.put(url + "?userId=" + userId, prefs);
        };
        /**
         * @return {?}
         */
        UserService.prototype.userPreferences = /**
         * @return {?}
         */
        function () {
            return this.store.select(getUserPrefsState).take(1);
        };
        /**
         * @return {?}
         */
        UserService.prototype.getUserId = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ userId;
            this.store.select(getUserIdState)
                .take(1)
                .subscribe(function (id) {
                userId = id;
            });
            return userId;
        };
        /**
         * @return {?}
         */
        UserService.prototype.getCoreApiConfig = /**
         * @return {?}
         */
        function () {
            return this.config.modules && this.config.modules.core && this.config.modules.core.api;
        };
        /**
         * @param {?=} target
         * @return {?}
         */
        UserService.prototype.getEndPoint = /**
         * @param {?=} target
         * @return {?}
         */
        function (target) {
            if (target === void 0) { target = 'detail'; }
            var /** @type {?} */ coreApiConfig = this.getCoreApiConfig();
            if (!coreApiConfig || !coreApiConfig.user || !coreApiConfig.user[target]) {
                return;
            }
            var /** @type {?} */ base = coreApiConfig.base || '';
            var /** @type {?} */ baseUser = coreApiConfig.user.base || '';
            if (coreApiConfig.user[target].indexOf('http') > -1) {
                return coreApiConfig.user[target];
            }
            else {
                return "" + (base + baseUser + coreApiConfig.user[target]);
            }
        };
        UserService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UserService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
            { type: StoreService, },
            { type: HttpService, },
        ]; };
        return UserService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalizationService = (function () {
        function LocalizationService(translateService, userService, logger) {
            this.translateService = translateService;
            this.userService = userService;
            this.logger = logger;
            this.modulesTranslation = {};
        }
        /**
         * @param {?=} languages
         * @param {?=} defaultLanguage
         * @return {?}
         */
        LocalizationService.prototype.init = /**
         * @param {?=} languages
         * @param {?=} defaultLanguage
         * @return {?}
         */
        function (languages, defaultLanguage) {
            var _this = this;
            if (languages === void 0) { languages = []; }
            if (defaultLanguage === void 0) { defaultLanguage = 'en'; }
            return this.userService.userPreferences()
                .mergeMap(function (preferences) {
                var /** @type {?} */ lang = preferences.lang;
                // This is not safe (depends on navigator)... should be wrapped in platform
                if (!lang) {
                    lang = (/** @type {?} */ (navigator)).languages
                        && (/** @type {?} */ (navigator)).languages[0]
                        || navigator.language
                        || (/** @type {?} */ (navigator)).userLanguage;
                    // SSR temp fix in case navigator does not exist
                    if (!lang) {
                        lang = defaultLanguage;
                    }
                }
                lang = lang.substr(0, 2);
                lang = languages.indexOf(lang) < 0 ? defaultLanguage : lang;
                if (languages.length === 0) {
                    languages.push(lang);
                }
                _this.logger.info("App language set: " + lang);
                _this.translateService.addLangs(languages);
                _this.translateService.setDefaultLang(lang);
                return _this.translateService.use(lang);
            });
        };
        LocalizationService.decorators = [
            { type: core.Injectable },
        ];
        // /**
        //  * Deactivated for now (all translations are in the common file)
        //  * @param module -- Angular module
        //  */
        // loadTranslationModule(module: string): Observable<any> {
        //     this.logger.warning('loadTranslationModule() should not be used. Add translations to global translation file.');
        //     return Observable.of({});
        //     // const lang = this.translate.currentLang || 'en';
        //     // if (this.modulesTranslation[module] && this.modulesTranslation[module][lang]) {
        //     //     return Observable.of(this.modulesTranslation[module][lang]);
        //     // }
        //     // const uri = `assets/${module}/i18n/${lang}.json`;
        //     // return this.http.get(uri)
        //     //     .map(res => res.json())
        //     //     .do((i18n: any) => {
        //     //         if (!this.modulesTranslation[module]) {
        //     //             this.modulesTranslation[module] = {};
        //     //         }
        //     //         this.modulesTranslation[module][lang] = i18n;
        //     //         this.translate.setTranslation(lang, i18n, true);
        //     //         console.log(`[Localization] lang (${lang}) loaded for module (${module})...`);
        //     //     })
        //     //     .catch((err: any) => {
        //     //         console.log(`[Localization] lang (${lang}) not found for module (${module})`);
        //     //         return Observable.of({});
        //     //     });
        // }
        /** @nocollapse */
        LocalizationService.ctorParameters = function () { return [
            { type: core$1.TranslateService, },
            { type: UserService, },
            { type: TraceService, },
        ]; };
        return LocalizationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ cacheTranslations = {};
    var TranslateHttpLoader = (function () {
        function TranslateHttpLoader(http$$1, prefix, suffix, queryParams) {
            if (prefix === void 0) { prefix = '/assets/i18n-compiled/'; }
            if (suffix === void 0) { suffix = '.json'; }
            if (queryParams === void 0) { queryParams = false; }
            this.http = http$$1;
            this.prefix = prefix;
            this.suffix = suffix;
            this.queryParams = queryParams;
        }
        /**
         * Gets the translations from the server
         * @param {?} lang
         * @return {?} any
         */
        TranslateHttpLoader.prototype.getTranslation = /**
         * Gets the translations from the server
         * @param {?} lang
         * @return {?} any
         */
        function (lang) {
            if (cacheTranslations[lang]) {
                var /** @type {?} */ translation = Object.assign({}, cacheTranslations[lang]);
                return Observable.Observable.of(translation);
            }
            if (this.queryParams) {
                return this.http.get(this.prefix + "?" + this.queryParams + "=" + lang)
                    .map(function (translation) {
                    cacheTranslations[lang] = translation;
                    return translation;
                })
                    .catch(function () {
                    Observable.Observable.throw(new EuiError(errorCodes.ERR_TRANSLATION_FILE_MISSING, null, { lang: lang }));
                    return Observable.Observable.of({});
                });
            }
            return this.http.get("" + this.prefix + lang + this.suffix)
                .map(function (translation) {
                cacheTranslations[lang] = translation;
                return translation;
            })
                .catch(function () {
                Observable.Observable.throw(new EuiError(errorCodes.ERR_TRANSLATION_FILE_MISSING, null, { lang: lang }));
                return Observable.Observable.of({});
            });
        };
        return TranslateHttpLoader;
    }());
    var /** @type {?} */ translateConfig = {
        loader: {
            provide: core$1.TranslateLoader,
            useFactory: translateStaticLoader,
            deps: [http.HttpClient, CONFIG_TOKEN],
        },
    };
    /**
     * @param {?} http
     * @param {?} config
     * @return {?}
     */
    function translateStaticLoader(http$$1, config) {
        if (config && config.global && config.global.i18nFolder) {
            var /** @type {?} */ i18nFolder = config.global.i18nFolder;
            return new TranslateHttpLoader(http$$1, "assets/" + i18nFolder + "/");
        }
        else if (config && config.global && config.global.i18nSource) {
            var /** @type {?} */ i18nSource = config.global.i18nSource;
            // checking query parameter if exists
            var /** @type {?} */ queryParams = config.global.i18nQueryParam ? config.global.i18nQueryParam : false;
            return new TranslateHttpLoader(http$$1, "/" + config.global.baseUrl + "/" + i18nSource, '', queryParams);
        }
        return new TranslateHttpLoader(http$$1, 'assets/i18n-compiled/');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalstorageService = (function () {
        function LocalstorageService() {
        }
        /**
         * @param {?} key
         * @param {?} data
         * @return {?}
         */
        LocalstorageService.prototype.set = /**
         * @param {?} key
         * @param {?} data
         * @return {?}
         */
        function (key, data) {
            try {
                var /** @type {?} */ serialized = JSON.stringify(data);
                localStorage.setItem(key, serialized);
            }
            catch (/** @type {?} */ err) {
                return undefined;
            }
        };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalstorageService.prototype.get = /**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            try {
                var /** @type {?} */ serialized = localStorage.getItem(key);
                if (serialized === null) {
                    return undefined;
                }
                return JSON.parse(serialized);
            }
            catch (/** @type {?} */ err) {
                return undefined;
            }
        };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalstorageService.prototype.delete = /**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            localStorage.removeItem(key);
        };
        LocalstorageService.decorators = [
            { type: core.Injectable },
        ];
        return LocalstorageService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StorageService = (function () {
        function StorageService(localStorageService, logger) {
            this.localStorageService = localStorageService;
            this.logger = logger;
            this._storage = 'localStorage';
        }
        /**
         * @param {?} key
         * @param {?} data
         * @param {?=} storage
         * @return {?}
         */
        StorageService.prototype.set = /**
         * @param {?} key
         * @param {?} data
         * @param {?=} storage
         * @return {?}
         */
        function (key, data, storage) {
            if (storage === void 0) { storage = this._storage; }
            if (storage === 'localStorage') {
                return this.localStorageService.set(key, data);
            }
            var /** @type {?} */ msg = '[Storage Service] Error setting data, storage must be be "localStorage"';
            this.logger.error(msg);
            throw new EuiError(undefined, msg);
        };
        /**
         * @param {?} key
         * @param {?=} storage
         * @return {?}
         */
        StorageService.prototype.get = /**
         * @param {?} key
         * @param {?=} storage
         * @return {?}
         */
        function (key, storage) {
            if (storage === void 0) { storage = this._storage; }
            if (storage === 'localStorage') {
                return this.localStorageService.get(key);
            }
            var /** @type {?} */ msg = '[Storage] Error getting data, storage has to be "localStorage"';
            this.logger.error(msg);
            throw new EuiError(undefined, msg);
        };
        /**
         * @param {?} key
         * @param {?=} storage
         * @return {?}
         */
        StorageService.prototype.delete = /**
         * @param {?} key
         * @param {?=} storage
         * @return {?}
         */
        function (key, storage) {
            if (storage === void 0) { storage = this._storage; }
            if (storage === 'localStorage') {
                return this.localStorageService.delete(key);
            }
            var /** @type {?} */ msg = '[Storage] Error deleting data, storage has to be "localStorage"';
            this.logger.error(msg);
            throw new EuiError(undefined, msg);
        };
        Object.defineProperty(StorageService.prototype, "storage", {
            set: /**
             * @param {?} storage
             * @return {?}
             */
            function (storage) {
                this._storage = storage;
            },
            enumerable: true,
            configurable: true
        });
        StorageService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        StorageService.ctorParameters = function () { return [
            { type: LocalstorageService, },
            { type: TraceService, },
        ]; };
        return StorageService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAuthService = (function () {
        function UxAuthService(config) {
            this.config = config;
            // default must be false, it should be update after login
            this.isLoggedIn = true;
            var /** @type {?} */ authExist = config && config.global && config.global.auth;
            this.redirectUrl = authExist && config.global.auth.redirectUrl ? config.global.auth.redirectUrl : '';
            this.isLoggedIn = authExist && config.global.auth.isLoggedIn ? config.global.auth.isLoggedIn : true;
            this.loginPageUrl = authExist && config.global.auth.loginPageUrl ? config.global.auth.loginPageUrl : '';
        }
        /**
         * @param {?} status
         * @return {?}
         */
        UxAuthService.prototype.setLoggedIn = /**
         * @param {?} status
         * @return {?}
         */
        function (status) {
            this.isLoggedIn = status;
        };
        /**
         * @param {?} url
         * @return {?}
         */
        UxAuthService.prototype.setRedirectUrl = /**
         * @param {?} url
         * @return {?}
         */
        function (url) {
            this.redirectUrl = url;
        };
        UxAuthService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxAuthService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
        ]; };
        return UxAuthService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ getUserState$1 = function (state) { return state.user; };
    var /** @type {?} */ getRights = function (state) { return state.rights; };
    var /** @type {?} */ getUserRights = reselect.createSelector(getUserState$1, getRights);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPermissionService = (function () {
        function UxPermissionService(store$$1) {
            // Listening rights & links from State
            var _this = this;
            this.store = store$$1;
            this.userRights = [];
            this.store.select(getUserRights).subscribe(function (rights) {
                _this.userRights = rights;
            });
        }
        /**
         * @return {?}
         */
        UxPermissionService.prototype.getRights = /**
         * @return {?}
         */
        function () {
            return this.userRights;
        };
        /**
         * @param {?} routeId
         * @return {?}
         */
        UxPermissionService.prototype.checkRightToActivateRoute = /**
         * @param {?} routeId
         * @return {?}
         */
        function (routeId) {
            var /** @type {?} */ userRights = this.getRights();
            return this.checkRight(userRights, routeId);
        };
        /**
         * @param {?} permStr
         * @return {?}
         */
        UxPermissionService.prototype.checkAttributePermission = /**
         * @param {?} permStr
         * @return {?}
         */
        function (permStr) {
            var /** @type {?} */ userRights = this.getRights();
            var /** @type {?} */ permProps = permStr.split('.');
            if (permProps.length > 1) {
                var /** @type {?} */ right = permProps[0];
                var /** @type {?} */ permission = permProps[1];
                return this.checkPermission(userRights, right, permission);
            }
            else {
                var /** @type {?} */ rightId = permStr;
                return this.checkRight(userRights, rightId);
            }
        };
        /**
         * @param {?} rights
         * @param {?} rightId
         * @return {?}
         */
        UxPermissionService.prototype.checkRight = /**
         * @param {?} rights
         * @param {?} rightId
         * @return {?}
         */
        function (rights, rightId) {
            return rights.findIndex(function (right) {
                return right.id === rightId;
            }) > -1;
        };
        /**
         * @param {?} rights
         * @param {?} rightId
         * @param {?} permissionId
         * @return {?}
         */
        UxPermissionService.prototype.checkPermission = /**
         * @param {?} rights
         * @param {?} rightId
         * @param {?} permissionId
         * @return {?}
         */
        function (rights, rightId, permissionId) {
            var /** @type {?} */ indexOfRight = rights.findIndex(function (right) {
                return right.id === rightId;
            });
            if (indexOfRight > -1) {
                return rights[indexOfRight].permissions.includes(permissionId);
            }
            return false;
        };
        UxPermissionService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxPermissionService.ctorParameters = function () { return [
            { type: store.Store, },
        ]; };
        return UxPermissionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAuthGuardService = (function () {
        function UxAuthGuardService(authService, permissionService) {
            this.authService = authService;
            this.permissionService = permissionService;
        }
        /**
         * @param {?} url
         * @return {?}
         */
        UxAuthGuardService.prototype.checkLogin = /**
         * @param {?} url
         * @return {?}
         */
        function (url) {
            if (this.authService.isLoggedIn) {
                return true;
            }
            // Store the attempted URL for redirecting
            this.authService.redirectUrl = url;
            // Navigate to the login page with extras
            // this.router.navigate(['/login']);
            return false;
        };
        /**
         * @param {?} id
         * @return {?}
         */
        UxAuthGuardService.prototype.checkRouteRight = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            return this.permissionService.checkRightToActivateRoute(id);
        };
        UxAuthGuardService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxAuthGuardService.ctorParameters = function () { return [
            { type: UxAuthService, },
            { type: UxPermissionService, },
        ]; };
        return UxAuthGuardService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicMenuService = (function () {
        function UxDynamicMenuService(config, uxPermission, store$$1) {
            var _this = this;
            this.config = config;
            this.uxPermission = uxPermission;
            this.store = store$$1;
            this.menuLinks = [];
            this.store.select(getUserState).subscribe(function (user) {
                if (user.menuLinks) {
                    _this.menuLinks = user.menuLinks;
                }
            });
        }
        /**
         * @return {?}
         */
        UxDynamicMenuService.prototype.getMenuLinks = /**
         * @return {?}
         */
        function () {
            return this.menuLinks;
        };
        /**
         * @param {?} links
         * @return {?}
         */
        UxDynamicMenuService.prototype.filterUxLinksWithRights = /**
         * @param {?} links
         * @return {?}
         */
        function (links) {
            var _this = this;
            var /** @type {?} */ userRights = this.uxPermission.getRights() ? this.uxPermission.getRights() : [];
            return links.filter(function (link) {
                if (link.hasChildren) {
                    link.children = _this.filterUxLinksWithRights(link.children);
                }
                if (link.allowedRightId) {
                    return userRights.findIndex(function (right) {
                        return right.id === link.allowedRightId;
                    }) > -1;
                }
                else {
                    return true;
                }
            });
        };
        UxDynamicMenuService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicMenuService.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
            { type: UxPermissionService, },
            { type: StoreService, },
        ]; };
        return UxDynamicMenuService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ mapTypeIdToRoute = {
        '31084141': 'financial-instrument',
        '31084142': 'mip',
        '31084143': 'action',
        '31084144': 'programme',
        '31084145': 'project',
        '31084146': 'contract',
        '31087247': 'component',
        '31084348': 'instrument-domain',
        '31084349': 'sub-project',
        '31084350': 'commission-decision',
        '31086952': 'operational-entity',
    };
    var RouteService = (function () {
        function RouteService() {
        }
        /**
         * @param {?} oe
         * @return {?}
         */
        RouteService.prototype.urlOperationalEntity = /**
         * @param {?} oe
         * @return {?}
         */
        function (oe) {
            if (!oe.typeId || !oe.key) {
                return;
            }
            if (oe.typeId in mapTypeIdToRoute) {
                return mapTypeIdToRoute[oe.typeId] + "/" + oe.key;
            }
        };
        RouteService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        RouteService.ctorParameters = function () { return []; };
        return RouteService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ResponseErrorHandlerTypes = {
        Redirect: 1,
        Notify: 2,
        None: 3,
    };
    ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.Redirect] = "Redirect";
    ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.Notify] = "Notify";
    ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.None] = "None";
    /**
     * Search in the configuration if the Url that gave an error has a handler
     * @param url Url from the Router
     * @param configs Http Error Routes configuration
     */
    var /** @type {?} */ getRouteConfig = function (url, httpStatus, configs) {
        return (configs.filter(function (conf) {
            if (conf.match === '*') {
                return typeof conf[httpStatus] !== 'undefined';
            }
            var /** @type {?} */ re = new RegExp(conf.match);
            return re.exec(url) !== null && typeof conf[httpStatus] !== 'undefined';
        })[0]);
    };
    var /** @type {?} */ defaultRouteRedirect = {
        '404': '/404',
        '401': '/401',
        '500': '/500',
    };
    var RequestErrorInterceptor = (function () {
        function RequestErrorInterceptor(appConfig, logger, router$$1, uxService) {
            this.appConfig = appConfig;
            this.logger = logger;
            this.router = router$$1;
            this.uxService = uxService;
        }
        /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        RequestErrorInterceptor.prototype.intercept = /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        function (req, next) {
            var _this = this;
            return next.handle(req)
                .do(function () { }, function (err) {
                _this.logError(err);
                if (!_this.appConfig.httpResponseHandlers) {
                    return;
                }
                if (err instanceof http.HttpErrorResponse) {
                    var _a = _this.appConfig.httpResponseHandlers, routesHandlers = _a.routesHandlers, routesRedirect = _a.routesRedirect;
                    routesRedirect = Object.assign({}, defaultRouteRedirect, routesRedirect);
                    var /** @type {?} */ config = getRouteConfig(err.url, err.status, routesHandlers);
                    var /** @type {?} */ rule = config && config[err.status];
                    if (typeof rule === 'function') {
                        rule.call(null, err);
                    }
                    else if (rule === ResponseErrorHandlerTypes.Notify) {
                        _this.showNotificationError(err);
                    }
                    else if (rule !== ResponseErrorHandlerTypes.None) {
                        var /** @type {?} */ statusManaged = err.status === 404 || err.status === 401 || err.status === 500;
                        if (rule === ResponseErrorHandlerTypes.Redirect || (statusManaged && !rule)) {
                            _this.router.navigate([routesRedirect[err.status]]);
                        }
                        else {
                            _this.showNotificationError(err);
                        }
                    }
                }
            });
        };
        /**
         * @param {?} err
         * @return {?}
         */
        RequestErrorInterceptor.prototype.showNotificationError = /**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            this.uxService.growlError(err.statusText);
        };
        /**
         * @param {?} err
         * @return {?}
         */
        RequestErrorInterceptor.prototype.logError = /**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            var /** @type {?} */ message = err.message ? err.message : err.toString();
            this.logger.error(message);
        };
        RequestErrorInterceptor.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        RequestErrorInterceptor.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
            { type: TraceService, },
            { type: router.Router, },
            { type: UxService, },
        ]; };
        return RequestErrorInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GlobalErrorHandler = (function (_super) {
        __extends$1(GlobalErrorHandler, _super);
        function GlobalErrorHandler(injector) {
            var _this = _super.call(this) || this;
            _this.injector = injector;
            return _this;
        }
        /**
         * @param {?} error
         * @return {?}
         */
        GlobalErrorHandler.prototype.handleError = /**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            var /** @type {?} */ traceService = this.injector.get(TraceService);
            var /** @type {?} */ message = error.message ? error.message : error.toString();
            traceService.error(message);
            // throw error;
            _super.prototype.handleError.call(this, error);
        };
        GlobalErrorHandler.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GlobalErrorHandler.ctorParameters = function () { return [
            { type: core.Injector, },
        ]; };
        return GlobalErrorHandler;
    }(core.ErrorHandler));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var QueueApiService = (function () {
        function QueueApiService(store$$1, http$$1, logger) {
            this.store = store$$1;
            this.http = http$$1;
            this.logger = logger;
        }
        /**
         * @param {?} queueId
         * @param {?} uri
         * @param {?} method
         * @param {?=} payload
         * @return {?}
         */
        QueueApiService.prototype.queue = /**
         * @param {?} queueId
         * @param {?} uri
         * @param {?} method
         * @param {?=} payload
         * @return {?}
         */
        function (queueId, uri, method, payload) {
            var /** @type {?} */ allowedMethods = ['post', 'put', 'get'];
            if (allowedMethods.indexOf(method) < 0) {
                throw new EuiError(errorCodes.ERR_QUEUE_METHOD_NOT_ALLOWED, "[Queue Api] method \"" + method + "\" is not alllowed");
            }
            var /** @type {?} */ data = {
                uri: uri,
                method: method,
                payload: payload,
            };
            this.store.dispatch(new ApiQueueAdd({ id: queueId, data: data }));
        };
        /**
         * @param {?} id
         * @return {?}
         */
        QueueApiService.prototype.removeQueue = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            this.store.dispatch(new ApiQueueRemove(id));
        };
        /**
         * @param {?} queueId
         * @return {?}
         */
        QueueApiService.prototype.processQueue = /**
         * @param {?} queueId
         * @return {?}
         */
        function (queueId) {
            var _this = this;
            return this.store.select(getApiQueueById(queueId))
                .take(1)
                .switchMap(function (queue) {
                if (!queue) {
                    _this.logger.warning("Queue with id \"" + queueId + "\" does not exist");
                    return Observable.Observable.of(null);
                }
                return _this.http[queue.method](queue.uri, queue.payload)
                    .do(function () { return _this.removeQueue(queueId); });
            });
        };
        QueueApiService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        QueueApiService.ctorParameters = function () { return [
            { type: StoreService, },
            { type: HttpService, },
            { type: TraceService, },
        ]; };
        return QueueApiService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AppService = (function () {
        function AppService(store$$1) {
            this.store = store$$1;
        }
        /**
         * Start listening for navigator disconnection
         * and updates the store
         */
        /**
         * Start listening for navigator disconnection
         * and updates the store
         * @return {?}
         */
        AppService.prototype.listenForConnectionUpdate = /**
         * Start listening for navigator disconnection
         * and updates the store
         * @return {?}
         */
        function () {
            var _this = this;
            window.addEventListener('offline', function () { return _this.store.dispatch(new AppConnectionUpdate(false)); });
            window.addEventListener('online', function () { return _this.store.dispatch(new AppConnectionUpdate(true)); });
        };
        AppService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AppService.ctorParameters = function () { return [
            { type: StoreService, },
        ]; };
        return AppService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDomService = (function () {
        function UxDomService() {
        }
        /**
         * @param {?} target
         * @param {?} className
         * @return {?}
         */
        UxDomService.prototype.closestMatchingParent = /**
         * @param {?} target
         * @param {?} className
         * @return {?}
         */
        function (target, className) {
            var /** @type {?} */ element = target;
            while (element && element.nodeType === Node.ELEMENT_NODE) {
                if (element.classList.contains(className)) {
                    return element;
                }
                element = element.parentElement;
            }
            return null;
        };
        UxDomService.zIndex = 1045;
        UxDomService.decorators = [
            { type: core.Injectable },
        ];
        return UxDomService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAssetsService = (function () {
        function UxAssetsService(http$$1, uxService) {
            this.http = http$$1;
            this.uxService = uxService;
        }
        /**
         * @param {?} assetId
         * @param {?} languageCode
         * @param {?=} remoteUrl
         * @return {?}
         */
        UxAssetsService.prototype.getAssetsContents = /**
         * @param {?} assetId
         * @param {?} languageCode
         * @param {?=} remoteUrl
         * @return {?}
         */
        function (assetId, languageCode, remoteUrl) {
            if (assetId) {
                if (!languageCode && this.uxService.activeLanguage) {
                    languageCode = this.uxService.activeLanguage.code;
                }
                if (languageCode) {
                    var /** @type {?} */ url = void 0;
                    if (!remoteUrl) {
                        url = "assets/" + assetId + "_" + languageCode.toUpperCase() + ".json";
                    }
                    else {
                        url = remoteUrl + "/" + assetId + "_" + languageCode.toUpperCase() + ".json";
                    }
                    return this.http.get(url);
                }
            }
            return Observable.Observable.of(null);
        };
        UxAssetsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxAssetsService.ctorParameters = function () { return [
            { type: HttpService, },
            { type: UxService, },
        ]; };
        return UxAssetsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimezoneService = (function () {
        function UxTimezoneService() {
        }
        /**
         * Convert country ISO code to country name (in english)
         */
        /**
         * Convert country ISO code to country name (in english)
         * @param {?} iso
         * @return {?}
         */
        UxTimezoneService.prototype.iso2country = /**
         * Convert country ISO code to country name (in english)
         * @param {?} iso
         * @return {?}
         */
        function (iso) {
            return UX_COUNTRIES[iso] ? UX_COUNTRIES[iso] : iso;
        };
        /**
         * Gets the list of ISO-codes for all countries
         */
        /**
         * Gets the list of ISO-codes for all countries
         * @return {?}
         */
        UxTimezoneService.prototype.getCountries = /**
         * Gets the list of ISO-codes for all countries
         * @return {?}
         */
        function () {
            var /** @type {?} */ res = [];
            for (var _i = 0, _a = Object.keys(UX_COUNTRIES); _i < _a.length; _i++) {
                var prop = _a[_i];
                res.push(prop);
            }
            return res;
        };
        /**
         * @return {?}
         */
        UxTimezoneService.prototype.getTimezones = /**
         * @return {?}
         */
        function () {
            return UX_TIMEZONES;
        };
        /**
         * @param {?} tz
         * @return {?}
         */
        UxTimezoneService.prototype.getTimezone = /**
         * @param {?} tz
         * @return {?}
         */
        function (tz) {
            return UX_TIMEZONES.find(function (item) {
                return item.name === tz;
            });
        };
        UxTimezoneService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxTimezoneService.ctorParameters = function () { return []; };
        return UxTimezoneService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ extend$1 = (/** @type {?} */ (extendProxy)).default || extendProxy;
    var EnvConfigService = (function () {
        function EnvConfigService(http$$1, config) {
            this.http = http$$1;
            this.config = config;
        }
        /**
         * @return {?}
         */
        EnvConfigService.prototype.loadEnvConfigFile = /**
         * @return {?}
         */
        function () {
            return this.http.get(this.config.configFilePath);
        };
        /**
         * @param {?} fileConfig
         * @return {?}
         */
        EnvConfigService.prototype.loadEnvConfigService = /**
         * @param {?} fileConfig
         * @return {?}
         */
        function (fileConfig) {
            var /** @type {?} */ configServiceURI = 'configServiceURI';
            if (!fileConfig[configServiceURI]) {
                return of$1.of({});
            }
            return this.http.get(fileConfig[configServiceURI]);
        };
        /**
         * @return {?}
         */
        EnvConfigService.prototype.loadDynamicConfig = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.config.configFilePath) {
                // No config file in asset folder
                return of$1.of({});
            }
            return this.loadEnvConfigFile()
                .do(function (tsConfig) {
                // PreMerge hook (if necessary add logic)
                extend$1(true, _this.config, tsConfig);
                // PosMerge hook (if necessary add logic)
            })
                .switchMap(function (fileConfig) { return _this.loadEnvConfigService(fileConfig); })
                .do(function (wsconfig) {
                // PreMerge hook (if necessary add logic)
                extend$1(true, _this.config, wsconfig);
                // PosMerge hook (if necessary add logic)
            })
                .catch(function (error) {
                console.error(error);
                return of$1.of({});
            });
        };
        EnvConfigService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        EnvConfigService.ctorParameters = function () { return [
            { type: HttpService, },
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
        ]; };
        return EnvConfigService;
    }());

    var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxErrorOutput = (function () {
        function UxErrorOutput(info, errorFeedback, subErrors) {
            this.severity = UxMessageSeverity.danger;
            if (!subErrors) {
                Object.assign(this, __assign$2({}, info), __assign$2({}, errorFeedback));
            }
            else {
                Object.assign(this, __assign$2({}, info), __assign$2({}, errorFeedback), { subErrors: subErrors });
            }
        }
        /**
         * @param {?=} byKey
         * @return {?}
         */
        UxErrorOutput.prototype.getFeedBacks = /**
         * @param {?=} byKey
         * @return {?}
         */
        function (byKey) {
            var _this = this;
            if (this.subErrors) {
                return this.subErrors.filter(function (err) {
                    if (err instanceof UxValidationErrorClass) {
                        if (byKey && err.attributes) {
                            return _this.checkAttribute(byKey, err.attributes);
                        }
                        else if (byKey && !err.attributes) {
                            return false;
                        }
                        else if (!byKey) {
                            return true;
                        }
                    }
                }).map(function (err) { return ({ msgId: err.msgId, defaultMsg: err.defaultMsg, severity: err.severity }); });
            }
            else {
                if (!byKey) {
                    return [{ msgId: this.msgId, defaultMsg: this.defaultMsg, severity: this.severity }];
                }
                else {
                    return [];
                }
            }
        };
        /**
         * @param {?} key
         * @param {?} attributes
         * @return {?}
         */
        UxErrorOutput.prototype.checkAttribute = /**
         * @param {?} key
         * @param {?} attributes
         * @return {?}
         */
        function (key, attributes) {
            return attributes.some(function (attr) {
                return key === attr.key;
            });
        };
        return UxErrorOutput;
    }());
    /** @enum {string} */
    var UxMessageSeverity = {
        info: 'info',
        warning: 'warning',
        danger: 'danger',
        success: 'success',
    };
    var UxValidationErrorClass = (function () {
        function UxValidationErrorClass(data) {
            this.severity = UxMessageSeverity.danger;
            Object.assign(this, data);
        }
        return UxValidationErrorClass;
    }());
    /**
     * @param {?} resp
     * @param {?} mapper
     * @return {?}
     */
    function transformToUxHttpResponse(resp, mapper) {
        var /** @type {?} */ updatedErr = /** @type {?} */ (resp);
        updatedErr.uxHttpErrorOutput = mapper(resp.error);
        return updatedErr;
    }
    var UxPublishErrorFeedbackEvent = (function () {
        function UxPublishErrorFeedbackEvent(err, id) {
            this.err = err;
            this.id = id;
        }
        return UxPublishErrorFeedbackEvent;
    }());
    var UxClearErrorFeedbackEvent = (function () {
        function UxClearErrorFeedbackEvent(id) {
            this.id = id;
        }
        return UxClearErrorFeedbackEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxRequestErrorModelInterceptor = (function () {
        function UxRequestErrorModelInterceptor(appConfig) {
            this.appConfig = appConfig;
        }
        /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        UxRequestErrorModelInterceptor.prototype.intercept = /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        function (req, next) {
            var _this = this;
            return next.handle(req)
                .do(function (err) {
            }, function (err) {
                if (_this.appConfig.errorMappingHandler) {
                    if (err instanceof http.HttpErrorResponse) {
                        err = /** @type {?} */ (transformToUxHttpResponse(err, _this.appConfig.errorMappingHandler));
                    }
                }
            });
        };
        UxRequestErrorModelInterceptor.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxRequestErrorModelInterceptor.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
        ]; };
        return UxRequestErrorModelInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @template T
     * @param {?=} errorManager
     * @return {?}
     */
    function withUxErrorManager(errorManager) {
        return function (source$) {
            return new Observable.Observable(function (observer) {
                var /** @type {?} */ wrapper = {
                    next: function (value) {
                        errorManager.clearError();
                        observer.next(value);
                    },
                    error: function (err) {
                        errorManager.publishError(err.uxHttpErrorOutput);
                    },
                };
                return source$.subscribe(wrapper);
            });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxErrorFeedbackService = (function () {
        function UxErrorFeedbackService() {
            this.errors = new Subject.Subject();
        }
        /**
         * @param {?} err
         * @param {?=} id
         * @return {?}
         */
        UxErrorFeedbackService.prototype.publishError = /**
         * @param {?} err
         * @param {?=} id
         * @return {?}
         */
        function (err, id) {
            if (id) {
                this.errors.next(new UxPublishErrorFeedbackEvent(err, id));
            }
            else {
                this.errors.next(new UxPublishErrorFeedbackEvent(err));
            }
        };
        /**
         * @param {?=} id
         * @return {?}
         */
        UxErrorFeedbackService.prototype.clearError = /**
         * @param {?=} id
         * @return {?}
         */
        function (id) {
            this.errors.next(new UxClearErrorFeedbackEvent(id));
        };
        /**
         * @return {?}
         */
        UxErrorFeedbackService.prototype.createLocalErrorManager = /**
         * @return {?}
         */
        function () {
            return new UxErrorManager(this);
        };
        /**
         * @return {?}
         */
        UxErrorFeedbackService.prototype.createGlobalErrorManager = /**
         * @return {?}
         */
        function () {
            return new UxErrorManager(this, true);
        };
        return UxErrorFeedbackService;
    }());
    var UxErrorManager = (function () {
        function UxErrorManager(uxErrorFeedbackService, isGlobal) {
            this.uxErrorFeedbackService = uxErrorFeedbackService;
            this.isGlobal = isGlobal;
            this.id = Math.random().toString();
            this.httpErrorOperator = withUxErrorManager(this);
        }
        /**
         * @param {?} err
         * @return {?}
         */
        UxErrorManager.prototype.publishError = /**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            if (!this.isGlobal) {
                this.uxErrorFeedbackService.publishError(err, this.id);
            }
            else {
                this.uxErrorFeedbackService.publishError(err);
            }
        };
        /**
         * @return {?}
         */
        UxErrorManager.prototype.clearError = /**
         * @return {?}
         */
        function () {
            if (!this.isGlobal) {
                this.uxErrorFeedbackService.clearError(this.id);
            }
            else {
                this.uxErrorFeedbackService.clearError();
            }
        };
        /**
         * @return {?}
         */
        UxErrorManager.prototype.errors = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.isGlobal) {
                return this.uxErrorFeedbackService.errors.pipe(operators.filter(function (evt) { return evt.id === _this.id; }));
            }
            else {
                return this.uxErrorFeedbackService.errors.pipe(operators.filter(function (evt) { return !evt.id; }));
            }
        };
        return UxErrorManager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ appConfigDefault = {
        global: {
            languages: ['en'],
            defaultLanguage: 'en',
        },
    };
    var OptionalDeps = (function () {
        function OptionalDeps(store$$1) {
            this.store = store$$1;
        }
        OptionalDeps.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        OptionalDeps.ctorParameters = function () { return [
            { type: store.Store, decorators: [{ type: core.Optional },] },
        ]; };
        return OptionalDeps;
    }());
    /**
     * @param {?} appConfig
     * @param {?=} environment
     * @return {?}
     */
    function providersModule(appConfig, environment) {
        if (environment === void 0) { environment = {}; }
        return [
            StorageService,
            LocalstorageService,
            UserService,
            RouteService,
            HttpService,
            UxDomService,
            TraceService,
            UxService,
            UxAppShellService,
            UxAssetsService,
            UxTimezoneService,
            GlobalErrorHandler,
            QueueApiService,
            AppService,
            EnvConfigService,
            OptionalDeps,
            OpenidConnectService,
            { provide: APP_CONFIG_TOKEN, useValue: appConfig },
            { provide: ENVIRONMENT_TOKEN, useValue: environment },
            { provide: CONFIG_TOKEN, useFactory: getConfig, deps: [APP_CONFIG_TOKEN, ENVIRONMENT_TOKEN] },
            {
                provide: http.HTTP_INTERCEPTORS,
                useClass: UxRequestErrorModelInterceptor,
                multi: true
            },
            { provide: StoreService, useFactory: storeServiceFactory, deps: [OptionalDeps, TraceService] },
            { provide: UxAuthService, useFactory: uxAuthServiceFactory, deps: [CONFIG_TOKEN] },
            { provide: UxAuthGuardService, useFactory: uxAuthGuardServiceFactory, deps: [UxAuthService, UxPermissionService] },
            { provide: UxPermissionService, useFactory: uxPermissionsServiceFactory, deps: [OptionalDeps] },
            { provide: UxErrorFeedbackService, useFactory: errorFeedbackServiceFactory, deps: [OptionalDeps] },
            {
                provide: UxDynamicMenuService,
                useFactory: uxDynamicMenuServiceFactory,
                deps: [CONFIG_TOKEN, UxPermissionService, OptionalDeps]
            },
            { provide: LocalizationService, useFactory: localizationServiceFactory, deps: [core$1.TranslateService, UserService, TraceService] },
            {
                provide: core.APP_INITIALIZER,
                useFactory: initApp,
                deps: [CONFIG_TOKEN, StoreService, UserService, LocalizationService, core.Injector, AppService, EnvConfigService],
                multi: true,
            },
            {
                provide: core.ErrorHandler,
                useClass: GlobalErrorHandler,
            },
        ];
    }
    var ɵ0$6 = translateStaticLoader;
    var CoreModule = (function () {
        function CoreModule(parentModule) {
            if (parentModule) {
                throw new Error('CoreModule is already loaded. Import it in the AppModule only');
            }
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        CoreModule.forRoot = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            if (config === void 0) { config = { appConfig: appConfigDefault, environment: {} }; }
            return {
                ngModule: CoreModule,
                providers: providersModule(config.appConfig, config.environment),
            };
        };
        CoreModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            http.HttpClientModule,
                            effects.EffectsModule.forRoot([AppEffects]),
                            core$1.TranslateModule.forChild({
                                loader: {
                                    provide: core$1.TranslateLoader,
                                    useFactory: ɵ0$6,
                                    deps: [http.HttpClient],
                                },
                            }),
                        ],
                    },] },
        ];
        /** @nocollapse */
        CoreModule.ctorParameters = function () { return [
            { type: CoreModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
        ]; };
        return CoreModule;
    }());
    /**
     * @param {?} optionalDeps
     * @param {?} logger
     * @return {?}
     */
    function storeServiceFactory(optionalDeps, logger) {
        return new StoreService(optionalDeps.store, logger);
    }
    /**
     * @param {?} config
     * @return {?}
     */
    function uxAuthServiceFactory(config) {
        return new UxAuthService(config);
    }
    /**
     * @param {?} uxAuthService
     * @param {?} uxPermissionService
     * @return {?}
     */
    function uxAuthGuardServiceFactory(uxAuthService, uxPermissionService) {
        return new UxAuthGuardService(uxAuthService, uxPermissionService);
    }
    /**
     * @param {?} optionalDeps
     * @return {?}
     */
    function uxPermissionsServiceFactory(optionalDeps) {
        return new UxPermissionService(optionalDeps.store);
    }
    /**
     * @param {?} config
     * @param {?} uxPermission
     * @param {?} optionalDeps
     * @return {?}
     */
    function uxDynamicMenuServiceFactory(config, uxPermission, optionalDeps) {
        return new UxDynamicMenuService(config, uxPermission, optionalDeps.store);
    }
    /**
     * @param {?} translate
     * @param {?} userService
     * @param {?} logger
     * @return {?}
     */
    function localizationServiceFactory(translate, userService, logger) {
        return new LocalizationService(translate, userService, logger);
    }
    /**
     * @return {?}
     */
    function errorFeedbackServiceFactory() {
        return new UxErrorFeedbackService();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DYNAMIC_COMPONENT_CONFIG = new core.InjectionToken('DYNAMIC_COMPONENT_CONFIG');
    var UxDynamicComponentService = (function () {
        function UxDynamicComponentService(componentFactoryResolver, injector, appRef) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
            this.appRef = appRef;
        }
        /**
         * @param {?} component
         * @param {?=} el
         * @param {?=} config
         * @return {?}
         */
        UxDynamicComponentService.prototype.add = /**
         * @param {?} component
         * @param {?=} el
         * @param {?=} config
         * @return {?}
         */
        function (component, el, config) {
            // this.portal = new ComponentPortal(component);
            // Create a portalHost from a DOM element
            this.portalHost = new portal.DomPortalHost(el ? el.nativeElement : document.body, this.componentFactoryResolver, this.appRef, this.injector);
            // Locate the component factory for the ComponentToIncludeDynamicallyComponent
            this.portal = new portal.ComponentPortal(component, null, config ? this.createInjector(config) : null);
            // Attach portal to host
            this.portalComponentInstance = this.portalHost.attach(this.portal);
            var /** @type {?} */ portalHost = this.portalHost;
            var /** @type {?} */ portal$$1 = this.portal;
            var /** @type {?} */ portalComponentInstance = this.portalComponentInstance;
            return { portalHost: portalHost, portal: portal$$1, portalComponentInstance: portalComponentInstance };
        };
        /**
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @return {?}
         */
        UxDynamicComponentService.prototype.remove = /**
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @return {?}
         */
        function (portalHostRef, portalRef) {
            portalHostRef.detach();
        };
        /**
         * @param {?} data
         * @return {?}
         */
        UxDynamicComponentService.prototype.createInjector = /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            var /** @type {?} */ injectorTokens = new WeakMap();
            var /** @type {?} */ dataConfig = Object.assign(data, {
                portalHostRef: this.portalHost,
                portalRef: this.portal,
                portalComponentInstanceRef: this.portalComponentInstance,
            });
            injectorTokens.set(DYNAMIC_COMPONENT_CONFIG, data);
            return new portal.PortalInjector(this.injector, injectorTokens);
        };
        UxDynamicComponentService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicComponentService.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver, },
            { type: core.Injector, },
            { type: core.ApplicationRef, },
        ]; };
        return UxDynamicComponentService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CachePreventionInterceptor = (function () {
        function CachePreventionInterceptor() {
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        CachePreventionInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        function (request, next) {
            return next.handle(request.clone({
                headers: request.headers.set('Cache-Control', 'No-Cache'),
            }));
        };
        CachePreventionInterceptor.decorators = [
            { type: core.Injectable },
        ];
        return CachePreventionInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CorsSecurityInterceptor = (function () {
        function CorsSecurityInterceptor() {
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        CorsSecurityInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        function (request, next) {
            return next.handle(request.clone({
                withCredentials: true
            }));
        };
        CorsSecurityInterceptor.decorators = [
            { type: core.Injectable },
        ];
        return CorsSecurityInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CsrfPreventionInterceptor = (function () {
        function CsrfPreventionInterceptor() {
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        CsrfPreventionInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        function (request, next) {
            return next.handle(request.clone({
                headers: request.headers.set('X-Requested-With', 'XMLHttpRequest'),
            }));
        };
        CsrfPreventionInterceptor.decorators = [
            { type: core.Injectable },
        ];
        return CsrfPreventionInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EuLoginSessionTimeoutHandlingInterceptor = (function () {
        function EuLoginSessionTimeoutHandlingInterceptor() {
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        EuLoginSessionTimeoutHandlingInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        function (request, next) {
            var _this = this;
            return next.handle(request).do(function (event) {
                _this.checkRequestSuccessForEULoginSessionTimeout(request, event);
                return event;
            }, function (error) {
                _this.checkRequestErrorForEULoginSessionTimeout(request, error);
            });
        };
        /**
         * @param {?} request
         * @param {?} event
         * @return {?}
         */
        EuLoginSessionTimeoutHandlingInterceptor.prototype.checkRequestSuccessForEULoginSessionTimeout = /**
         * @param {?} request
         * @param {?} event
         * @return {?}
         */
        function (request, event) {
            if (event instanceof http.HttpResponse) {
                if (this.isSsoResponse((/** @type {?} */ (event)).body)) {
                    this.reauthenticate(request, /** @type {?} */ (event));
                }
            }
        };
        /**
         * @param {?} request
         * @param {?} response
         * @return {?}
         */
        EuLoginSessionTimeoutHandlingInterceptor.prototype.checkRequestErrorForEULoginSessionTimeout = /**
         * @param {?} request
         * @param {?} response
         * @return {?}
         */
        function (request, response) {
            // intentionally blank; meant for overriding
        };
        /**
         * @param {?} body
         * @return {?}
         */
        EuLoginSessionTimeoutHandlingInterceptor.prototype.isSsoResponse = /**
         * @param {?} body
         * @return {?}
         */
        function (body) {
            if (body) {
                if (typeof body !== 'string') {
                    return (body.success === false &&
                        body.status === 'ECAS_AUTHENTICATION_REQUIRED' &&
                        body.code === 303 &&
                        body.message === 'session expired');
                }
                else {
                    var /** @type {?} */ html = body;
                    return ((html.indexOf('<meta name="Keywords" content="EU Login, ECAS, Authentication, Security" />') >= 0 &&
                        html.indexOf('<meta name="Description" content="EU Login" />') >= 0) ||
                        html.indexOf('<meta name="Description" content="European Commission Authentication Service" />') >= 0 ||
                        html.indexOf('<title>Mock Login Form</title>') >= 0 ||
                        html.indexOf('<title>Redirecting To ECAS</title>') >= 0 ||
                        html === '{ success : false, status : "ECAS_AUTHENTICATION_REQUIRED", code : 303, message : "session expired" }' ||
                        html === '{ "success" : false, "status" : "ECAS_AUTHENTICATION_REQUIRED", "code" : 303, "message": "session expired" }');
                }
            }
            else {
                return false;
            }
        };
        /**
         * @param {?} request
         * @param {?} response
         * @return {?}
         */
        EuLoginSessionTimeoutHandlingInterceptor.prototype.reauthenticate = /**
         * @param {?} request
         * @param {?} response
         * @return {?}
         */
        function (request, response) {
            document.location.reload(true);
        };
        EuLoginSessionTimeoutHandlingInterceptor.decorators = [
            { type: core.Injectable },
        ];
        return EuLoginSessionTimeoutHandlingInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OpenidConnectInterceptor = (function () {
        function OpenidConnectInterceptor(config, openidConnectService) {
            this.config = config;
            this.openidConnectService = openidConnectService;
            // By default, the original request should at least be retries once in case the cached API Gateway token expires:
            this.maximumRequestRetries = 1;
            if (this.config && this.config.openIdConnect && this.config.openIdConnect.maximumRequestRetries) {
                this.maximumRequestRetries = this.config.openIdConnect.maximumRequestRetries;
            }
        }
        /**
         * @param {?} request
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.intercept = /**
         * @param {?} request
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        function (request, next, retryCount) {
            if (retryCount === void 0) { retryCount = 0; }
            if (this.config && this.config.openIdConnect && this.config.openIdConnect.enabled) {
                var /** @type {?} */ config = this.config.openIdConnect;
                if (config.apiGatewayServices) {
                    var /** @type {?} */ service = this.getMatchingServiceFromConfiguration(request, config.apiGatewayServices);
                    if (service && service.audienceId) {
                        return this.makeApiGatewayServiceCall(request, next, service.audienceId, retryCount);
                    }
                }
                if (config.services) {
                    var /** @type {?} */ service = this.getMatchingServiceFromConfiguration(request, config.services);
                    if (service && service.audienceId) {
                        return this.makeServiceCall(request, next, service.audienceId, retryCount);
                    }
                }
            }
            return next.handle(request);
        };
        /**
         * @param {?} request
         * @param {?} configuredServices
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.getMatchingServiceFromConfiguration = /**
         * @param {?} request
         * @param {?} configuredServices
         * @return {?}
         */
        function (request, configuredServices) {
            if (configuredServices) {
                for (var /** @type {?} */ serviceId in configuredServices) {
                    if (configuredServices.hasOwnProperty(serviceId)) {
                        var /** @type {?} */ service = configuredServices[serviceId];
                        if (this.urlMatches(request.url, service.endpoint)) {
                            return service;
                        }
                    }
                }
            }
            return null;
        };
        /**
         * @param {?} request
         * @param {?} next
         * @param {?} audienceId
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.makeApiGatewayServiceCall = /**
         * @param {?} request
         * @param {?} next
         * @param {?} audienceId
         * @param {?=} retryCount
         * @return {?}
         */
        function (request, next, audienceId, retryCount) {
            var _this = this;
            if (retryCount === void 0) { retryCount = 0; }
            // Check if we already have an API Gateway access token cached in memory:
            if (this.cachedApiGatewayAccessTokenHasExpired()) {
                // Get an EU Login access token for the API Gateway and for the target service:
                var /** @type {?} */ apiGatewayAccessTokenAudienceId = this.config.openIdConnect.apiGatewayAccessTokenAudienceId;
                return Observable.Observable.zip(next.handle(this.getServiceAccessTokenRequest(apiGatewayAccessTokenAudienceId)).catch(function (response) {
                    return _this.handleErrorResponse(response, request, next, retryCount);
                }), next.handle(this.getServiceAccessTokenRequest(audienceId)).catch(function (response) {
                    return _this.handleErrorResponse(response, request, next, retryCount);
                })).flatMap(function (_a) {
                    var apiGatewayServiceAccessTokenEvent = _a[0], serviceAccessTokenEvent = _a[1];
                    if (apiGatewayServiceAccessTokenEvent instanceof http.HttpResponse && serviceAccessTokenEvent instanceof http.HttpResponse) {
                        // We now have an EU Login access token for the API Gateway and the target service.
                        // Continue by asking an access token to the gateway itself. It requires the EU Login access token...
                        var /** @type {?} */ apiGatewayServiceAccessToken = (/** @type {?} */ (apiGatewayServiceAccessTokenEvent)).body;
                        var /** @type {?} */ apiGatewayConsumerKey = _this.config.openIdConnect.apiGatewayConsumerKey;
                        var /** @type {?} */ apiGatewayHeaders = new http.HttpHeaders();
                        apiGatewayHeaders = apiGatewayHeaders.append('Authorization', 'Basic ' + apiGatewayConsumerKey);
                        apiGatewayHeaders = apiGatewayHeaders.append('Content-type', 'application/x-www-form-urlencoded');
                        var /** @type {?} */ body = 'grant_type=oauth2:eui&eul_access_token=' + apiGatewayServiceAccessToken.access_token;
                        return next.handle(new http.HttpRequest('POST', _this.config.openIdConnect.apiGatewayAccessTokenUrl, body, {
                            headers: apiGatewayHeaders,
                            withCredentials: false,
                        })).flatMap(function (apiGatewayAccessTokenEvent) {
                            if (apiGatewayAccessTokenEvent instanceof http.HttpResponse) {
                                // We now have access to the API Gateway.
                                // Continue by calling the gateway (using the API Gateway access token),
                                // and by propagating the EU Login access token for the target service...
                                var /** @type {?} */ apiGatewayAccessToken = (/** @type {?} */ (apiGatewayAccessTokenEvent)).body;
                                _this.cachedApiGatewayAccessTokenResponseTimestamp = new Date();
                                _this.cachedApiGatewayAccessToken = apiGatewayAccessToken;
                                var /** @type {?} */ serviceAccessToken = (/** @type {?} */ (serviceAccessTokenEvent)).body;
                                return _this.callApiGatewayService(request, next, apiGatewayAccessToken, serviceAccessToken, retryCount);
                            }
                            else {
                                return Observable.Observable.of(null);
                            }
                        });
                    }
                    else {
                        return Observable.Observable.of(null);
                    }
                });
            }
            else {
                // We already have an API Gateway access token.
                // Now request an EU Login access token for the target service.
                return next.handle(this.getServiceAccessTokenRequest(audienceId)).catch(function (response) {
                    return _this.handleErrorResponse(response, request, next, retryCount);
                }).flatMap(function (serviceAccessTokenEvent) {
                    if (serviceAccessTokenEvent instanceof http.HttpResponse) {
                        // We have now both the API Gateway access token and a EU Login access token for the target service;
                        // we can call the API Gateway.
                        var /** @type {?} */ serviceAccessToken = (/** @type {?} */ (serviceAccessTokenEvent)).body;
                        return _this.callApiGatewayService(request, next, _this.cachedApiGatewayAccessToken, serviceAccessToken);
                    }
                    else {
                        return Observable.Observable.of(null);
                    }
                });
            }
        };
        /**
         * @param {?} request
         * @param {?} next
         * @param {?} audienceId
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.makeServiceCall = /**
         * @param {?} request
         * @param {?} next
         * @param {?} audienceId
         * @param {?=} retryCount
         * @return {?}
         */
        function (request, next, audienceId, retryCount) {
            var _this = this;
            if (retryCount === void 0) { retryCount = 0; }
            return next.handle(this.getServiceAccessTokenRequest(audienceId)).flatMap(function (httpEvent) {
                if (httpEvent instanceof http.HttpResponse) {
                    var /** @type {?} */ accessToken = (/** @type {?} */ (httpEvent)).body;
                    return next.handle(request.clone({
                        headers: request.headers.set('Authorization', accessToken.token_type + ' ' + accessToken.access_token),
                    }));
                }
                else {
                    return Observable.Observable.of(httpEvent);
                }
            }).catch(function (response) { return _this.handleErrorResponse(response, request, next, retryCount); });
        };
        /**
         * @param {?} audienceId
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.getServiceAccessTokenRequest = /**
         * @param {?} audienceId
         * @return {?}
         */
        function (audienceId) {
            var /** @type {?} */ parameters = new http.HttpParams();
            parameters = parameters.append('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer');
            parameters = parameters.append('scope', (this.config.openIdConnect.scope || this.openidConnectService.DEFAULT_OPENID_SCOPE));
            parameters = parameters.append('assertion', this.openidConnectService.getIdToken());
            parameters = parameters.append('audience', audienceId);
            parameters = parameters.append('client_id', this.config.openIdConnect.spaClientId);
            return new http.HttpRequest('POST', this.config.openIdConnect.euLoginAccessTokenUrl, null, {
                headers: new http.HttpHeaders().set('Content-type', 'application/x-www-form-urlencoded'),
                params: parameters,
                withCredentials: true,
            });
        };
        /**
         * @param {?} originalRequest
         * @param {?} next
         * @param {?} apiGatewayAccessToken
         * @param {?} serviceAccessToken
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.callApiGatewayService = /**
         * @param {?} originalRequest
         * @param {?} next
         * @param {?} apiGatewayAccessToken
         * @param {?} serviceAccessToken
         * @param {?=} retryCount
         * @return {?}
         */
        function (originalRequest, next, apiGatewayAccessToken, serviceAccessToken, retryCount) {
            var _this = this;
            if (retryCount === void 0) { retryCount = 0; }
            var /** @type {?} */ authorizationHeaders = originalRequest.headers;
            authorizationHeaders = authorizationHeaders.set('Authorization', apiGatewayAccessToken.token_type + ' ' + apiGatewayAccessToken.access_token);
            authorizationHeaders = authorizationHeaders.set('Authorization-Propagation', serviceAccessToken.access_token);
            return next.handle(originalRequest.clone({
                withCredentials: false,
                headers: authorizationHeaders,
            })).catch(function (response) {
                return _this.handleErrorResponse(response, originalRequest, next, retryCount);
            });
        };
        /**
         * @param {?} requestUrl
         * @param {?} serviceUrl
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.urlMatches = /**
         * @param {?} requestUrl
         * @param {?} serviceUrl
         * @return {?}
         */
        function (requestUrl, serviceUrl) {
            return new RegExp('^' + serviceUrl.replace(/\*/g, '.*')).test(requestUrl);
        };
        /**
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.cachedApiGatewayAccessTokenHasExpired = /**
         * @return {?}
         */
        function () {
            if (this.cachedApiGatewayAccessTokenResponseTimestamp &&
                this.cachedApiGatewayAccessToken &&
                this.cachedApiGatewayAccessToken.expires_in) {
                // OpenID access token expires_in field is in seconds:
                var /** @type {?} */ expiresInMilliseconds = 1000 * this.cachedApiGatewayAccessToken.expires_in;
                return new Date().getTime() >= this.cachedApiGatewayAccessTokenResponseTimestamp.getTime() + expiresInMilliseconds;
            }
            else {
                return true;
            }
        };
        /**
         * @param {?} response
         * @param {?} originalRequest
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.handleErrorResponse = /**
         * @param {?} response
         * @param {?} originalRequest
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        function (response, originalRequest, next, retryCount) {
            if (retryCount === void 0) { retryCount = 0; }
            if (response) {
                if (response.error && response.error.error === 'invalid_request') {
                    // The ID token is invalid or incorrect; retrieve another one:
                    this.openidConnectService.renewIdToken();
                }
                else if (response.status === 401 || response.status === 403) {
                    // Can be one of the following conditions:
                    // * The client ID is invalid or incorrect; fail the request.
                    //   Either the developer needs to use a valid client ID or the administrator should allow the client ID access.
                    // * The API Gateway access token is invalid. (401)
                    // * The EU Login access token is invalid. (403)
                    if (retryCount < this.maximumRequestRetries) {
                        return this.retryRequest(originalRequest, next, retryCount);
                    }
                    else {
                        console.error('The OpenID Connect call may have issues:\n' +
                            '* the client ID could be invalid\n' +
                            '* the API Gateway access token could be invalid\n' +
                            '* the EU Login access token for the target service could be invalid.');
                    }
                }
                else if (response.status === 0) {
                    // One of the access token requests or the original request was not sent.
                    // Most likely one of the CORS pre-flight requests failed, or the browser is offline.
                    console.warn('The OpenID Connect call may have issues:\n' +
                        '* the CORS pre-flight requests for the OpenID Connect access tokens or for the REST call could be failing\n' +
                        '* the browser could be currently offline.');
                }
            }
            throw (response);
        };
        /**
         * @param {?} originalRequest
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        OpenidConnectInterceptor.prototype.retryRequest = /**
         * @param {?} originalRequest
         * @param {?} next
         * @param {?=} retryCount
         * @return {?}
         */
        function (originalRequest, next, retryCount) {
            if (retryCount === void 0) { retryCount = 0; }
            // Clear cached tokens before retrying in case the API Gateway access token is invalid:
            this.cachedApiGatewayAccessToken = null;
            return this.intercept(originalRequest, next, retryCount + 1);
        };
        OpenidConnectInterceptor.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        OpenidConnectInterceptor.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [CONFIG_TOKEN,] },] },
            { type: OpenidConnectService, },
        ]; };
        return OpenidConnectInterceptor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBadge = (function () {
        function UxBadge(values) {
            if (values === void 0) { values = {}; }
            this.typeClass = 'secondary';
            Object.assign(this, values);
        }
        return UxBadge;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLink = (function () {
        function UxLink(values) {
            if (values === void 0) { values = {}; }
            this.disabled = false;
            this.hasIconBg = false;
            this.active = false;
            this.visible = true;
            this.expanded = false;
            this.hasMarker = false;
            this.hasTag = false;
            this.badgeTypeClass = 'secondary';
            this.isHome = false;
            this.isSeparator = false;
            this.isScreenReaderClickable = false;
            this.selected = false;
            Object.assign(this, values);
        }
        Object.defineProperty(UxLink.prototype, "hasChildren", {
            get: /**
             * @return {?}
             */
            function () {
                return this.children != null;
            },
            enumerable: true,
            configurable: true
        });
        return UxLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxOrderByPipe = (function () {
        function UxOrderByPipe() {
        }
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        UxOrderByPipe._orderByComparator = /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            if ((isNaN(parseFloat(a)) || !isFinite(a)) || (isNaN(parseFloat(b)) || !isFinite(b))) {
                // Isn't a number so lowercase the string to properly compare
                if (a.toLowerCase() < b.toLowerCase()) {
                    return -1;
                }
                if (a.toLowerCase() > b.toLowerCase()) {
                    return 1;
                }
            }
            else {
                // Parse strings as numbers to compare properly
                if (parseFloat(a) < parseFloat(b)) {
                    return -1;
                }
                if (parseFloat(a) > parseFloat(b)) {
                    return 1;
                }
            }
            return 0; // equal each other
        };
        /**
         * @param {?} input
         * @param {?} __1
         * @return {?}
         */
        UxOrderByPipe.prototype.transform = /**
         * @param {?} input
         * @param {?} __1
         * @return {?}
         */
        function (input, _a) {
            var _b = _a[0], config = _b === void 0 ? '+' : _b;
            if (!Array.isArray(input)) {
                return input;
            }
            if (!Array.isArray(config) || (Array.isArray(config) && config.length === 1)) {
                var /** @type {?} */ propertyToCheck = !Array.isArray(config) ? config : config[0];
                var /** @type {?} */ desc_1 = propertyToCheck.substr(0, 1) === '-';
                // Basic array
                if (!propertyToCheck || propertyToCheck === '-' || propertyToCheck === '+') {
                    return !desc_1 ? input.sort() : input.sort().reverse();
                }
                else {
                    var /** @type {?} */ property_1 = propertyToCheck.substr(0, 1) === '+' || propertyToCheck.substr(0, 1) === '-'
                        ? propertyToCheck.substr(1)
                        : propertyToCheck;
                    return input.sort(function (a, b) {
                        return !desc_1
                            ? UxOrderByPipe._orderByComparator(a[property_1], b[property_1])
                            : -UxOrderByPipe._orderByComparator(a[property_1], b[property_1]);
                    });
                }
            }
            else {
                // Loop over property of the array in order and sort
                return input.sort(function (a, b) {
                    for (var /** @type {?} */ i = 0; i < config.length; i++) {
                        var /** @type {?} */ desc = config[i].substr(0, 1) === '-';
                        var /** @type {?} */ property = config[i].substr(0, 1) === '+' || config[i].substr(0, 1) === '-'
                            ? config[i].substr(1)
                            : config[i];
                        var /** @type {?} */ comparison = !desc
                            ? UxOrderByPipe._orderByComparator(a[property], b[property])
                            : -UxOrderByPipe._orderByComparator(a[property], b[property]);
                        // Don't return 0 yet in case of needing to sort by next property
                        if (comparison !== 0) {
                            return comparison;
                        }
                    }
                    return 0; // equal each other
                });
            }
        };
        UxOrderByPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'uxOrderBy', pure: false },] },
        ];
        return UxOrderByPipe;
    }());
    var UxOrderByPipeModule = (function () {
        function UxOrderByPipeModule() {
        }
        UxOrderByPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxOrderByPipe],
                        declarations: [UxOrderByPipe]
                    },] },
        ];
        return UxOrderByPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFilterPipe = (function () {
        function UxFilterPipe() {
        }
        /**
         * @param {?} value
         * @param {?} args
         * @return {?}
         */
        UxFilterPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} args
         * @return {?}
         */
        function (value, args) {
            if (!args[0]) {
                return value;
            }
            else if (value) {
                return value.filter(function (item) {
                    for (var /** @type {?} */ key in item) {
                        if ((typeof item[key] === 'string' || item[key] instanceof String)) {
                            if (item[key].indexOf(args) !== -1) {
                                return true;
                            }
                        }
                    }
                });
            }
        };
        UxFilterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'uxFilter'
                    },] },
        ];
        return UxFilterPipe;
    }());
    var UxFilterPipeModule = (function () {
        function UxFilterPipeModule() {
        }
        UxFilterPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxFilterPipe],
                        declarations: [UxFilterPipe]
                    },] },
        ];
        return UxFilterPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTruncatePipe = (function () {
        function UxTruncatePipe() {
        }
        // transform(value: string, args: string[]): string {
        // let limit = args.length > 0 ? parseInt(args[0], 10) : 10;
        // let trail = args.length > 1 ? args[1] : '...';
        /**
         * @param {?} value
         * @param {?=} limit
         * @param {?=} trail
         * @return {?}
         */
        UxTruncatePipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} limit
         * @param {?=} trail
         * @return {?}
         */
        function (value, limit, trail) {
            if (limit === void 0) { limit = 40; }
            if (trail === void 0) { trail = '\u2026'; }
            if (value) {
                if (limit < 0) {
                    limit *= -1;
                    return value.length > limit ? trail + value.substring(value.length - limit, value.length) : value;
                }
                else {
                    return value.length > limit ? value.substring(0, limit) + trail : value;
                }
            }
            return;
        };
        UxTruncatePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'uxTruncate'
                    },] },
        ];
        return UxTruncatePipe;
    }());
    var UxTruncatePipeModule = (function () {
        function UxTruncatePipeModule() {
        }
        UxTruncatePipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTruncatePipe],
                        declarations: [UxTruncatePipe]
                    },] },
        ];
        return UxTruncatePipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCurrencyPipe = (function () {
        function UxCurrencyPipe() {
            this.decimalSeparator = '.';
            this.thousandsSeparator = ',';
        }
        /**
         * @param {?} value
         * @param {?=} fractionSize
         * @return {?}
         */
        UxCurrencyPipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} fractionSize
         * @return {?}
         */
        function (value, fractionSize) {
            if (fractionSize === void 0) { fractionSize = 2; }
            var /** @type {?} */ maxFractions = [];
            for (var /** @type {?} */ i = 0; i < fractionSize; i++) {
                maxFractions.push('0');
            }
            var /** @type {?} */ maxFraction = maxFractions.join('');
            var _a = (value || '0').toString().split(this.decimalSeparator), integer = _a[0], _b = _a[1], fraction = _b === void 0 ? maxFraction : _b;
            fraction = fractionSize > 0 ? (fraction + maxFraction).substring(0, fractionSize) : '';
            if (fraction === maxFraction) {
                fraction = '';
            }
            integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
            return '€ ' + integer + (fraction.length > 0 ? this.decimalSeparator + fraction : '');
        };
        UxCurrencyPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'uxCurrency' },] },
        ];
        return UxCurrencyPipe;
    }());
    var UxCurrencyPipeModule = (function () {
        function UxCurrencyPipeModule() {
        }
        UxCurrencyPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxCurrencyPipe],
                        declarations: [UxCurrencyPipe]
                    },] },
        ];
        return UxCurrencyPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxNumberFormatPipe = (function () {
        function UxNumberFormatPipe(uxService) {
            this.uxService = uxService;
        }
        /**
         * @param {?} value
         * @param {?=} decimalSeparator
         * @param {?=} fractionSize
         * @param {?=} thousandSeparator
         * @return {?}
         */
        UxNumberFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} decimalSeparator
         * @param {?=} fractionSize
         * @param {?=} thousandSeparator
         * @return {?}
         */
        function (value, decimalSeparator, fractionSize, thousandSeparator) {
            if (decimalSeparator === void 0) { decimalSeparator = ','; }
            if (fractionSize === void 0) { fractionSize = 2; }
            if (thousandSeparator === void 0) { thousandSeparator = '.'; }
            return this.uxService.formatNumber(value, fractionSize, decimalSeparator, thousandSeparator);
        };
        UxNumberFormatPipe.decorators = [
            { type: core.Pipe, args: [{ name: 'uxNumberFormat' },] },
        ];
        /** @nocollapse */
        UxNumberFormatPipe.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        return UxNumberFormatPipe;
    }());
    var UxNumberFormatPipeModule = (function () {
        function UxNumberFormatPipeModule() {
        }
        UxNumberFormatPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxNumberFormatPipe],
                        declarations: [UxNumberFormatPipe]
                    },] },
        ];
        return UxNumberFormatPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxMomentTzPipe = (function () {
        function UxMomentTzPipe() {
        }
        /**
         * inspired by https://www.npmjs.com/package/angular-moment-timezone
         */
        /**
         * inspired by https://www.npmjs.com/package/angular-moment-timezone
         * @param {?} value
         * @param {?} tzdata
         * @param {?=} parseInZone
         * @return {?}
         */
        UxMomentTzPipe.prototype.transform = /**
         * inspired by https://www.npmjs.com/package/angular-moment-timezone
         * @param {?} value
         * @param {?} tzdata
         * @param {?=} parseInZone
         * @return {?}
         */
        function (value, tzdata, parseInZone) {
            if (parseInZone === void 0) { parseInZone = false; }
            if (parseInZone) {
                return moment.tz(value, tzdata);
            }
            return moment(value).tz(tzdata);
        };
        UxMomentTzPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'uxMomentTz',
                    },] },
        ];
        return UxMomentTzPipe;
    }());
    var UxMomentTzPipeModule = (function () {
        function UxMomentTzPipeModule() {
        }
        UxMomentTzPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxMomentTzPipe],
                        declarations: [UxMomentTzPipe]
                    },] },
        ];
        return UxMomentTzPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Transforms any input value
     */
    var UxIsoToCountryPipe = (function () {
        function UxIsoToCountryPipe(service) {
            this.service = service;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        UxIsoToCountryPipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return this.service.iso2country(value);
        };
        UxIsoToCountryPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'uxIsoToCountry'
                    },] },
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxIsoToCountryPipe.ctorParameters = function () { return [
            { type: UxTimezoneService, },
        ]; };
        return UxIsoToCountryPipe;
    }());
    var UxIsoToCountryPipeModule = (function () {
        function UxIsoToCountryPipeModule() {
        }
        UxIsoToCountryPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxIsoToCountryPipe],
                        declarations: [UxIsoToCountryPipe]
                    },] },
        ];
        return UxIsoToCountryPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxScrollHandlerDirective = (function () {
        function UxScrollHandlerDirective(document) {
            this.document = document;
            this.uxScrollHandler = false;
            this.navIsFixed = false;
            this.appHeaderHeight = 0;
        }
        /**
         * @return {?}
         */
        UxScrollHandlerDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.appWrapper = this.document.getElementById('app-wrapper');
            this.appHeader = this.document.getElementById('app-header');
            if (this.appHeader) {
                this.appHeaderHeight = this.appHeader.scrollHeight;
            }
        };
        /**
         * @return {?}
         */
        UxScrollHandlerDirective.prototype.onWindowScroll = /**
         * @return {?}
         */
        function () {
            if (this.uxScrollHandler && this.appHeaderHeight !== 0) {
                var /** @type {?} */ number = this.document.body.scrollTop || this.document.documentElement.scrollTop; // Chrome || IE/FF
                if (number > this.appHeaderHeight) {
                    this.navIsFixed = true;
                    this.appWrapper.classList.add('shrink-header-active');
                }
                else if (this.navIsFixed && number < this.appHeaderHeight) {
                    this.navIsFixed = false;
                    this.appWrapper.classList.remove('shrink-header-active');
                }
            }
        };
        UxScrollHandlerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollHandler]'
                    },] },
        ];
        /** @nocollapse */
        UxScrollHandlerDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
        ]; };
        UxScrollHandlerDirective.propDecorators = {
            "uxScrollHandler": [{ type: core.Input },],
            "onWindowScroll": [{ type: core.HostListener, args: ['window:scroll', [],] },],
        };
        return UxScrollHandlerDirective;
    }());
    var UxScrollHandlerElementDirective = (function () {
        function UxScrollHandlerElementDirective(document) {
            this.document = document;
            this.navIsFixed = false;
        }
        /**
         * @return {?}
         */
        UxScrollHandlerElementDirective.prototype.onWindowScroll = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ element = this.document.getElementById(this.uxScrollHandlerElement);
            var /** @type {?} */ number = this.document.body.scrollTop || this.document.documentElement.scrollTop; // Chrome || IE/FF
            if (number > this.toggleActiveHeight) {
                this.navIsFixed = true;
                element.classList.add(this.toggleClass);
            }
            else if (this.navIsFixed && number < this.toggleActiveHeight) {
                this.navIsFixed = false;
                element.classList.remove(this.toggleClass);
            }
        };
        UxScrollHandlerElementDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollHandlerElement]'
                    },] },
        ];
        /** @nocollapse */
        UxScrollHandlerElementDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
        ]; };
        UxScrollHandlerElementDirective.propDecorators = {
            "uxScrollHandlerElement": [{ type: core.Input },],
            "toggleClass": [{ type: core.Input },],
            "toggleActiveHeight": [{ type: core.Input },],
            "onWindowScroll": [{ type: core.HostListener, args: ['window:scroll', [],] },],
        };
        return UxScrollHandlerElementDirective;
    }());
    var UxScrollHandlerDirectiveModule = (function () {
        function UxScrollHandlerDirectiveModule() {
        }
        UxScrollHandlerDirectiveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxScrollHandlerDirective, UxScrollHandlerElementDirective],
                        declarations: [UxScrollHandlerDirective, UxScrollHandlerElementDirective]
                    },] },
        ];
        return UxScrollHandlerDirectiveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxMaxlengthDirective = (function () {
        function UxMaxlengthDirective(el) {
            this.el = el;
            this.validityChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxMaxlengthDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._element) {
                var /** @type {?} */ parent_1 = this._element.parentElement;
                parent_1.removeChild(this._element);
            }
        };
        /**
         * @return {?}
         */
        UxMaxlengthDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.length) {
                setTimeout(function () {
                    _this._element = document.createElement('span');
                    _this._element.classList.add('input-maxlength');
                    _this._element.innerHTML = _this.length.toString();
                    var /** @type {?} */ nativeElement = _this.el.nativeElement;
                    if (nativeElement != null) {
                        var /** @type {?} */ parent_2 = nativeElement.parentNode;
                        var /** @type {?} */ wrapper = document.createElement('div');
                        if (parent_2 != null) {
                            parent_2.replaceChild(wrapper, nativeElement);
                            wrapper.appendChild(nativeElement);
                            if (nativeElement.parentElement != null) {
                                nativeElement.parentElement.appendChild(_this._element);
                                nativeElement.parentElement.classList.add('input-maxlength-wrapper');
                            }
                        }
                    }
                    _this._refreshValue();
                });
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxMaxlengthDirective.prototype.onChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            setTimeout(function () {
                _this._refreshValue();
            }, 100);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxMaxlengthDirective.prototype.onInput = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._refreshValue();
        };
        /**
         * @return {?}
         */
        UxMaxlengthDirective.prototype._refreshValue = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ input = /** @type {?} */ (this.el.nativeElement);
            var /** @type {?} */ remainingLength = this.length - input.value.length;
            if (remainingLength < 0) {
                this._element.classList.add('error');
                input.value = input.value.substr(0, this.length);
                this._element.innerHTML = "0";
                this.validityChange.emit(false);
            }
            else {
                if (remainingLength <= 0) {
                    this._element.classList.add('error');
                    this.validityChange.emit(false);
                    if (remainingLength < 0) {
                        input.value = input.value.substr(0, input.value.length - 1);
                    }
                }
                if (remainingLength >= 0) {
                    this._element.innerHTML = (this.length - input.value.length).toString();
                }
                if (remainingLength > 0) {
                    this._element.classList.remove('error');
                    this.validityChange.emit(true);
                }
            }
        };
        UxMaxlengthDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMaxlength]',
                        host: { '(input)': 'onInput($event)' }
                    },] },
        ];
        /** @nocollapse */
        UxMaxlengthDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxMaxlengthDirective.propDecorators = {
            "length": [{ type: core.Input, args: ['uxMaxlength',] },],
            "validityChange": [{ type: core.Output },],
            "onChange": [{ type: core.HostListener, args: ['change', ['$event'],] },],
        };
        return UxMaxlengthDirective;
    }());
    var UxMaxlengthModule = (function () {
        function UxMaxlengthModule() {
        }
        UxMaxlengthModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxMaxlengthDirective],
                        declarations: [UxMaxlengthDirective]
                    },] },
        ];
        return UxMaxlengthModule;
    }());
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTooltip = (function () {
        function UxTooltip(el) {
            this.text = '';
            this.position = 'top';
            this.color = 'none';
            this.size = 'auto';
            this.rounded = false;
            this.always = false;
            this._el = el.nativeElement;
        }
        /**
         * @return {?}
         */
        UxTooltip.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.always) {
                this._el.classList.add("hint--always");
                this.show();
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxTooltip.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            for (var /** @type {?} */ i = 0; i < this._el.classList.length; i++) {
                var /** @type {?} */ currentClass = this._el.classList[i];
                if (currentClass.indexOf("hint--") !== -1) {
                    this._el.classList.remove(currentClass);
                }
            }
            if (this.always) {
                this._el.classList.add("hint--always");
                this.show();
            }
        };
        /**
         * @return {?}
         */
        UxTooltip.prototype.show = /**
         * @return {?}
         */
        function () {
            if (!this.text || this.text.length == 0)
                return;
            this.hide();
            this._el.setAttribute("data-hint", this.text);
            for (var /** @type {?} */ i = 0; i < this._el.classList.length; i++) {
                var /** @type {?} */ currentClass = this._el.classList[i];
                if (currentClass.indexOf("hint") !== -1)
                    this._el.classList.remove(currentClass);
            }
            if (this.always) {
                this._el.classList.add("hint--always");
            }
            this._el.classList.add("hint--" + this.position);
            switch (this.color) {
                case "danger":
                    this._el.classList.add("hint--error");
                    break;
                case "warning":
                    this._el.classList.add("hint--warning");
                    break;
                case "info":
                    this._el.classList.add("hint--info");
                    break;
                case "success":
                    this._el.classList.add("hint--success");
                    break;
                default:
            }
            switch (this.size) {
                case "small":
                    this._el.classList.add("hint--small");
                    break;
                case "medium":
                    this._el.classList.add("hint--medium");
                    break;
                case "large":
                    this._el.classList.add("hint--large");
                    break;
                default:
            }
            if (this.rounded)
                this._el.classList.add("hint--rounded");
        };
        /**
         * @return {?}
         */
        UxTooltip.prototype.hide = /**
         * @return {?}
         */
        function () {
            if (this.always)
                return;
            this._el.removeAttribute("data-hint");
        };
        UxTooltip.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTooltip]',
                        host: {
                            '(mouseover)': 'show()',
                            '(mouseout)': 'hide()',
                            '(focus)': 'show()',
                            '(unfocus)': 'hide()'
                        }
                    },] },
        ];
        /** @nocollapse */
        UxTooltip.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxTooltip.propDecorators = {
            "text": [{ type: core.Input, args: ['uxTooltip',] },],
            "position": [{ type: core.Input },],
            "color": [{ type: core.Input },],
            "size": [{ type: core.Input },],
            "rounded": [{ type: core.Input },],
            "always": [{ type: core.Input },],
        };
        return UxTooltip;
    }());
    var UxTooltipModule = (function () {
        function UxTooltipModule() {
        }
        UxTooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTooltip],
                        declarations: [UxTooltip]
                    },] },
        ];
        return UxTooltipModule;
    }());
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAutoResizeDirective = (function () {
        function UxAutoResizeDirective(el, uxService, controlContainer) {
            var _this = this;
            this.el = el;
            this.uxService = uxService;
            this.controlContainer = controlContainer;
            this.defaultRows = 1;
            this.windowResizedSubscription = fromEvent.fromEvent(window, 'resize')
                .debounceTime(300)
                .subscribe(function (event) {
                _this.resize();
            });
        }
        Object.defineProperty(UxAutoResizeDirective.prototype, "minRows", {
            set: /**
             * @param {?} minRows
             * @return {?}
             */
            function (minRows) {
                this.defaultRows = minRows;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} textArea
         * @return {?}
         */
        UxAutoResizeDirective.prototype.onInput = /**
         * @param {?} textArea
         * @return {?}
         */
        function (textArea) {
            if (!this.isUsingFormsApi()) {
                this.resize();
            }
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.el.nativeElement.rows = this.defaultRows;
            this.el.nativeElement.style.overflow = 'hidden';
            this.el.nativeElement.style.resize = 'none';
            if (this.isUsingFormsApi()) {
                this.handleFormControlChanges();
            }
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // In case auto-resize inputs are being used inside modal dialogs, we have to wait until the modal dialog is open before we resize:
            var /** @type {?} */ modalParent = this.findAncestorByClass(this.el.nativeElement, 'ux-modal');
            if (modalParent != null) {
                this.parentModalId = modalParent.id;
                this.openModalIdSubscription = this.uxService.openModalId.subscribe(function (modalId) {
                    if (modalId === _this.parentModalId) {
                        setTimeout(function () {
                            _this.resize();
                        }, 0);
                    }
                });
            }
            this.resize();
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.openModalIdSubscription) {
                this.openModalIdSubscription.unsubscribe();
            }
            if (this.windowResizedSubscription) {
                this.windowResizedSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.resize = /**
         * @return {?}
         */
        function () {
            this.el.nativeElement.style.height = 'auto';
            var /** @type {?} */ offset = this.el.nativeElement.offsetHeight, /** @type {?} */
            scroll = this.el.nativeElement.scrollHeight;
            var /** @type {?} */ height = (offset > scroll ? offset : scroll);
            if (height <= 0) {
                height = 'auto';
            }
            else {
                height += 'px';
            }
            this.el.nativeElement.style.height = height;
        };
        /**
         * @param {?} el
         * @param {?} cls
         * @return {?}
         */
        UxAutoResizeDirective.prototype.findAncestorByClass = /**
         * @param {?} el
         * @param {?} cls
         * @return {?}
         */
        function (el, cls) {
            while ((el = el.parentElement) && !el.classList.contains(cls)) { }
            return el;
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.handleFormControlChanges = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ fg = this.getFormGroup();
            if (fg && fg.controls[this.formControlName]) {
                fg.controls[this.formControlName]
                    .valueChanges
                    .subscribe(function (v) {
                    _this.resize();
                });
            }
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.isUsingFormsApi = /**
         * @return {?}
         */
        function () {
            return !!this.getFormGroup();
        };
        /**
         * @return {?}
         */
        UxAutoResizeDirective.prototype.getFormGroup = /**
         * @return {?}
         */
        function () {
            if (this.controlContainer && this.controlContainer.formDirective) {
                return (/** @type {?} */ (this.controlContainer.formDirective)).form;
            }
            return null;
        };
        UxAutoResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'textarea[uxAutoResize]'
                    },] },
        ];
        /** @nocollapse */
        UxAutoResizeDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: UxService, },
            { type: forms.ControlContainer, decorators: [{ type: core.Optional },] },
        ]; };
        UxAutoResizeDirective.propDecorators = {
            "formControlName": [{ type: core.Input },],
            "minRows": [{ type: core.Input },],
            "onInput": [{ type: core.HostListener, args: ['input', ['$event.target'],] },],
        };
        return UxAutoResizeDirective;
    }());
    var UxAutoResizeModule = (function () {
        function UxAutoResizeModule() {
        }
        UxAutoResizeModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxAutoResizeDirective],
                        declarations: [UxAutoResizeDirective]
                    },] },
        ];
        return UxAutoResizeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCollapsibleDirective = (function () {
        function UxCollapsibleDirective(el) {
            this.el = el;
            this.isFinishedMoving = true;
            this.isExpanded = true;
            this.isMoving = false;
            this.uxExpanded = true;
            this.uxCollapsed = false;
            this.transitionDuration = '0.35s';
            this.container = el.nativeElement;
            this.containerStyle = this.container.style;
            this.containerStyle.overflow = 'hidden';
            this.containerStyle.transform = 'translate3d(0, 0, 0)';
            var /** @type {?} */ display = this.containerStyle.display;
            if (display == null || display.length <= 0) {
                this.containerStyle.display = 'block';
            }
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        UxCollapsibleDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ change = changes['uxCollapsed'];
            if (change != null && !change.isFirstChange()) {
                if (this.uxCollapsed) {
                    this.collapse();
                }
                else {
                    this.expand();
                }
            }
            change = changes['uxExpanded'];
            if (change != null && !change.isFirstChange()) {
                if (this.uxExpanded) {
                    this.expand();
                }
                else {
                    this.collapse();
                }
            }
        };
        /**
         * @return {?}
         */
        UxCollapsibleDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.containerStyle.transitionDuration = '0';
            if (this.uxCollapsed || !this.uxExpanded || this.container.getAttribute('aria-expanded') === 'false') {
                this.isExpanded = false;
                this.containerStyle.height = '0';
            }
            else {
                this.containerStyle.height = 'auto'; // Set it to auto to ensure a working resizing.
            }
        };
        /**
         * @return {?}
         */
        UxCollapsibleDirective.prototype.collapse = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isExpanded) {
                if (this.animation != null) {
                    this.animation.unsubscribe();
                }
                this.animation = Observable.Observable.concat(Observable.Observable.of(function () {
                    _this.disableFocus();
                    _this.isMoving = true;
                    _this.isFinishedMoving = false;
                    // Temporarily disable the transition to ensure a transition from and actual height value.
                    // Temporarily disable the transition to ensure a transition from and actual height value.
                    _this.containerStyle.transitionDuration = '0';
                }), Observable.Observable.timer(20).switchMapTo(Observable.Observable.of(function () {
                    // Set it to the current height first to ensure the animation on the 'height' property.
                    // Set it to the current height first to ensure the animation on the 'height' property.
                    _this.containerStyle.height = _this.container.offsetHeight + 'px';
                    _this.containerStyle.transitionDuration = _this.transitionDuration;
                })), Observable.Observable.timer(20).switchMapTo(Observable.Observable.of(function () {
                    _this.containerStyle.opacity = '1.0';
                    _this.containerStyle.height = '0';
                })), Observable.Observable.timer(350).switchMapTo(Observable.Observable.of(function () {
                    _this.isExpanded = false;
                    _this.isFinishedMoving = true;
                    _this.isMoving = false;
                    _this.containerStyle.transitionDuration = '0';
                }))).subscribe(function (f) { return f(); });
            }
        };
        /**
         * @return {?}
         */
        UxCollapsibleDirective.prototype.expand = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.isExpanded) {
                if (this.animation != null) {
                    this.animation.unsubscribe();
                }
                var /** @type {?} */ height_1 = 0;
                this.animation = Observable.Observable.concat(Observable.Observable.of(function () {
                    _this.enableFocus();
                    _this.isMoving = false;
                    _this.isFinishedMoving = false;
                    // Temporarily disable the transition to ensure a transition from an actual height value.
                    // Temporarily disable the transition to ensure a transition from an actual height value.
                    _this.containerStyle.transitionDuration = '0';
                    // Also make the content invisible to know the actual current height.
                    // Also make the content invisible to know the actual current height.
                    _this.containerStyle.opacity = '0';
                }), Observable.Observable.timer(0).switchMapTo(Observable.Observable.of(function () {
                    _this.containerStyle.height = 'auto';
                    height_1 = _this.container.offsetHeight;
                    _this.containerStyle.height = '0'; // Set it first back to 0 to ensure the animation on the 'height' property.
                })), Observable.Observable.timer(20).switchMapTo(Observable.Observable.of(function () {
                    _this.containerStyle.transitionDuration = _this.transitionDuration;
                    _this.containerStyle.opacity = '1.0';
                })), Observable.Observable.timer(20).switchMapTo(Observable.Observable.of(function () {
                    _this.containerStyle.height = height_1 + 'px';
                })), Observable.Observable.timer(350).switchMapTo(Observable.Observable.of(function () {
                    _this.isExpanded = true;
                    _this.isFinishedMoving = true;
                    _this.isMoving = false;
                    _this.containerStyle.height = 'auto'; // Set it to auto to ensure a working resizing.
                    _this.containerStyle.transitionDuration = '0';
                }))).subscribe(function (f) { return f(); });
            }
        };
        /**
         * @return {?}
         */
        UxCollapsibleDirective.prototype.disableFocus = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ focusedElement = this.container.querySelector(':focus');
            if (focusedElement != null) {
                focusedElement.blur();
            }
            var /** @type {?} */ elements = this.container.querySelectorAll('*');
            for (var /** @type {?} */ i = 0; i < elements.length; i++) {
                var /** @type {?} */ element = elements[i];
                var /** @type {?} */ tabIndex = element.getAttribute('tabindex');
                if (tabIndex != null) {
                    element.setAttribute('data-prev-tabindex', tabIndex);
                }
                element.setAttribute('tabindex', '-1');
            }
        };
        /**
         * @return {?}
         */
        UxCollapsibleDirective.prototype.enableFocus = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ elements = this.container.querySelectorAll('*');
            for (var /** @type {?} */ i = 0; i < elements.length; i++) {
                var /** @type {?} */ element = elements[i];
                var /** @type {?} */ prevTabIndex = element.getAttribute('data-prev-tabindex');
                if (prevTabIndex != null) {
                    element.setAttribute('tabindex', prevTabIndex);
                }
                else {
                    element.removeAttribute('tabindex');
                }
            }
        };
        UxCollapsibleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCollapsible]',
                        exportAs: 'uxCollapsible'
                    },] },
        ];
        /** @nocollapse */
        UxCollapsibleDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxCollapsibleDirective.propDecorators = {
            "isFinishedMoving": [{ type: core.HostBinding, args: ['class.collapse',] },],
            "isExpanded": [{ type: core.HostBinding, args: ['class.in',] }, { type: core.HostBinding, args: ['attr.aria-expanded',] },],
            "isMoving": [{ type: core.HostBinding, args: ['class.collapsing',] },],
            "uxExpanded": [{ type: core.Input },],
            "uxCollapsed": [{ type: core.Input },],
        };
        return UxCollapsibleDirective;
    }());
    var UxCollapsibleDirectiveModule = (function () {
        function UxCollapsibleDirectiveModule() {
        }
        UxCollapsibleDirectiveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxCollapsibleDirective],
                        declarations: [UxCollapsibleDirective]
                    },] },
        ];
        return UxCollapsibleDirectiveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxHasPermissionDirective = (function () {
        function UxHasPermissionDirective(element, templateRef, viewContainer, permissionService) {
            this.element = element;
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.permissionService = permissionService;
            this.permissions = [];
            this.isHidden = true;
        }
        Object.defineProperty(UxHasPermissionDirective.prototype, "hasPermission", {
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this.permissions = val;
                this.updateView();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxHasPermissionDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.updateView();
        };
        /**
         * @return {?}
         */
        UxHasPermissionDirective.prototype.updateView = /**
         * @return {?}
         */
        function () {
            if (this.checkPermission()) {
                if (this.isHidden) {
                    this.viewContainer.createEmbeddedView(this.templateRef);
                    this.isHidden = false;
                }
            }
            else {
                this.isHidden = true;
                this.viewContainer.clear();
            }
        };
        /**
         * @return {?}
         */
        UxHasPermissionDirective.prototype.checkPermission = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ hasPermission = true;
            // for start it checks with and operator
            this.permissions.forEach(function (permission) {
                hasPermission = _this.permissionService.checkAttributePermission(permission) && hasPermission;
            });
            return hasPermission;
        };
        UxHasPermissionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[hasPermission]'
                    },] },
        ];
        /** @nocollapse */
        UxHasPermissionDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.TemplateRef, },
            { type: core.ViewContainerRef, },
            { type: UxPermissionService, },
        ]; };
        UxHasPermissionDirective.propDecorators = {
            "hasPermission": [{ type: core.Input },],
        };
        return UxHasPermissionDirective;
    }());
    var UxHasPermissionDirectiveModule = (function () {
        function UxHasPermissionDirectiveModule() {
        }
        UxHasPermissionDirectiveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxHasPermissionDirective],
                        declarations: [UxHasPermissionDirective]
                    },] },
        ];
        return UxHasPermissionDirectiveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxSmoothScrollToDirective = (function () {
        function UxSmoothScrollToDirective() {
        }
        /**
         * @return {?}
         */
        UxSmoothScrollToDirective.prototype.onClick = /**
         * @return {?}
         */
        function () {
            this.targetElement = document.getElementById(this.scrollTo);
            if (!this.targetElement) {
                return;
            }
            new SmoothScroll(this.targetElement, {
                duration: this.duration,
                offset: this.offset,
                easing: this.easing,
                callbackBefore: this.callbackBefore,
                callbackAfter: this.callbackAfter,
                containerId: this.containerId,
                middleAlign: this.middleAlign
            });
        };
        UxSmoothScrollToDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollTo]'
                    },] },
        ];
        /** @nocollapse */
        UxSmoothScrollToDirective.ctorParameters = function () { return []; };
        UxSmoothScrollToDirective.propDecorators = {
            "scrollTo": [{ type: core.Input, args: ['uxScrollTo',] },],
            "duration": [{ type: core.Input, args: ['duration',] },],
            "offset": [{ type: core.Input, args: ['offset',] },],
            "easing": [{ type: core.Input, args: ['easing',] },],
            "callbackBefore": [{ type: core.Input, args: ['callbackBefore',] },],
            "callbackAfter": [{ type: core.Input, args: ['callbackAfter',] },],
            "containerId": [{ type: core.Input, args: ['containerId',] },],
            "middleAlign": [{ type: core.Input, args: ['middleAlign',] },],
            "onClick": [{ type: core.HostListener, args: ['click',] },],
        };
        return UxSmoothScrollToDirective;
    }());
    var UxSmoothScrollDirective = (function () {
        function UxSmoothScrollDirective(el) {
            this.el = el;
        }
        /**
         * @param {?} target
         * @return {?}
         */
        UxSmoothScrollDirective.prototype.onClick = /**
         * @param {?} target
         * @return {?}
         */
        function (target) {
            if (this.scrollOnClick) {
                this.scroll();
            }
        };
        /**
         * @return {?}
         */
        UxSmoothScrollDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.scroll();
        };
        /**
         * @return {?}
         */
        UxSmoothScrollDirective.prototype.scroll = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (typeof this.scrollIf === 'undefined' || this.scrollIf === true) {
                setTimeout(function () {
                    new SmoothScroll(_this.el.nativeElement, {
                        duration: _this.duration,
                        offset: _this.offset,
                        easing: _this.easing,
                        callbackBefore: _this.callbackBefore,
                        callbackAfter: _this.callbackAfter,
                        containerId: _this.containerId,
                        middleAlign: _this.middleAlign
                    });
                }, 0);
            }
        };
        UxSmoothScrollDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSmoothScroll]'
                    },] },
        ];
        /** @nocollapse */
        UxSmoothScrollDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxSmoothScrollDirective.propDecorators = {
            "scrollIf": [{ type: core.Input, args: ['scrollIf',] },],
            "duration": [{ type: core.Input, args: ['duration',] },],
            "offset": [{ type: core.Input, args: ['offset',] },],
            "easing": [{ type: core.Input, args: ['easing',] },],
            "callbackBefore": [{ type: core.Input, args: ['callbackBefore',] },],
            "callbackAfter": [{ type: core.Input, args: ['callbackAfter',] },],
            "containerId": [{ type: core.Input, args: ['containerId',] },],
            "scrollOnClick": [{ type: core.Input, args: ['scrollOnClick',] },],
            "middleAlign": [{ type: core.Input, args: ['middleAlign',] },],
            "onClick": [{ type: core.HostListener, args: ['click', ['$event.target'],] },],
        };
        return UxSmoothScrollDirective;
    }());
    var SmoothScroll = (function () {
        function SmoothScroll(element, options) {
            this.smoothScroll(element, options);
        }
        /**
         * @param {?} element
         * @param {?} options
         * @return {?}
         */
        SmoothScroll.prototype.smoothScroll = /**
         * @param {?} element
         * @param {?} options
         * @return {?}
         */
        function (element, options) {
            options = options || {};
            // Options
            var /** @type {?} */ duration = options.duration || 800, /** @type {?} */
            offset = options.offset || 0, /** @type {?} */
            easing = options.easing || 'easeInOutQuart', /** @type {?} */
            callbackBefore = options.callbackBefore || function () { }, /** @type {?} */
            callbackAfter = options.callbackAfter || function () { }, /** @type {?} */
            container = document.getElementById(options.containerId) || null, /** @type {?} */
            containerPresent = (container != undefined && container != null), /** @type {?} */
            middleAlign = options.middleAlign || false;
            /**
             * Retrieve current location
             */
            var /** @type {?} */ getScrollLocation = function () {
                if (containerPresent) {
                    return container.scrollTop;
                }
                else {
                    if (window.pageYOffset) {
                        return window.pageYOffset;
                    }
                    else {
                        return document.documentElement.scrollTop;
                    }
                }
            };
            /**
             * Calculate easing pattern.
             *
             * 20150713 edit - zephinzer
             * - changed if-else to switch
             * @see http://archive.oreilly.com/pub/a/server-administration/excerpts/even-faster-websites/writing-efficient-javascript.html
             */
            var /** @type {?} */ getEasingPattern = function (type, time) {
                switch (type) {
                    case 'easeInQuad': return time * time; // accelerating from zero velocity
                    case 'easeOutQuad': return time * (2 - time); // decelerating to zero velocity
                    case 'easeInOutQuad': return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration
                    case 'easeInCubic': return time * time * time; // accelerating from zero velocity
                    case 'easeOutCubic': return (--time) * time * time + 1; // decelerating to zero velocity
                    case 'easeInOutCubic': return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration
                    case 'easeInQuart': return time * time * time * time; // accelerating from zero velocity
                    case 'easeOutQuart': return 1 - (--time) * time * time * time; // decelerating to zero velocity
                    case 'easeInOutQuart': return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time; // acceleration until halfway, then deceleration
                    case 'easeInQuint': return time * time * time * time * time; // accelerating from zero velocity
                    case 'easeOutQuint': return 1 + (--time) * time * time * time * time; // decelerating to zero velocity
                    case 'easeInOutQuint': return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time; // acceleration until halfway, then deceleration
                    default: return time;
                }
            };
            /**
             * Calculate how far to scroll
             */
            var /** @type {?} */ getEndLocation = function (element) {
                var /** @type {?} */ location = 0, /** @type {?} */
                elementRect = element.getBoundingClientRect(), /** @type {?} */
                absoluteElementTop = elementRect.top + window.pageYOffset;
                if (middleAlign) {
                    location = (absoluteElementTop + (element.offsetHeight / 2)) - (window.innerHeight / 2);
                }
                else {
                    location = absoluteElementTop;
                }
                if (offset) {
                    location = location - offset;
                }
                return Math.max(location, 0);
            };
            // Initialize the whole thing
            setTimeout(function () {
                var /** @type {?} */ currentLocation = null, /** @type {?} */
                startLocation = getScrollLocation(), /** @type {?} */
                endLocation = getEndLocation(element), /** @type {?} */
                timeLapsed = 0, /** @type {?} */
                distance = endLocation - startLocation, /** @type {?} */
                percentage, /** @type {?} */
                position, /** @type {?} */
                scrollHeight, /** @type {?} */
                internalHeight;
                /**
                 * Stop the scrolling animation when the anchor is reached (or at the top/bottom of the page)
                 */
                var /** @type {?} */ stopAnimation = function () {
                    currentLocation = getScrollLocation();
                    if (containerPresent) {
                        scrollHeight = container.scrollHeight;
                        internalHeight = container.clientHeight + currentLocation;
                    }
                    else {
                        scrollHeight = document.body.scrollHeight;
                        internalHeight = window.innerHeight + currentLocation;
                    }
                    if ((
                    // condition 1
                    position == endLocation) ||
                        (
                        // condition 2
                        currentLocation == endLocation) ||
                        (
                        // condition 3
                        internalHeight > scrollHeight)) {
                        // stop
                        clearInterval(runAnimation);
                        callbackAfter(element);
                    }
                };
                /**
                 * Scroll the page by an increment, and check if it's time to stop
                 */
                var /** @type {?} */ animateScroll = function () {
                    timeLapsed += 16;
                    percentage = (timeLapsed / duration);
                    percentage = (percentage > 1) ? 1 : percentage;
                    position = startLocation + (distance * getEasingPattern(easing, percentage));
                    if (containerPresent) {
                        container.scrollTop = position;
                    }
                    else {
                        window.scrollTo(0, position);
                    }
                    stopAnimation();
                };
                callbackBefore(element);
                var /** @type {?} */ runAnimation = setInterval(animateScroll, 16);
            }, 0);
        };
        return SmoothScroll;
    }());
    var UxSmoothScrollDirectiveModule = (function () {
        function UxSmoothScrollDirectiveModule() {
        }
        UxSmoothScrollDirectiveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxSmoothScrollToDirective, UxSmoothScrollDirective],
                        declarations: [UxSmoothScrollToDirective, UxSmoothScrollDirective]
                    },] },
        ];
        return UxSmoothScrollDirectiveModule;
    }());
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ availableTypes = [
        'creditCard',
        'phone',
        'date',
        'numeral'
    ];
    var UxCleaveDirective = (function () {
        function UxCleaveDirective(el, uxService) {
            this.el = el;
            this.uxService = uxService;
            this.cleaveInstance = null;
            this.el = el;
        }
        /**
         * @return {?}
         */
        UxCleaveDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ cleaveOpts = null;
            // simple type (see availableTypes)
            if (typeof this.options === 'string' && availableTypes.indexOf(this.options) !== -1) {
                cleaveOpts = {};
                cleaveOpts[this.options] = true;
                var /** @type {?} */ numeralDecimalMark = void 0;
                var /** @type {?} */ delimiter = void 0;
                if (this.options === 'numeral') {
                    if (this.decimalSeparator) {
                        numeralDecimalMark = this.decimalSeparator;
                        if (this.decimalSeparator === ',') {
                            delimiter = ' ';
                        }
                        else {
                            delimiter = '';
                        }
                    }
                    else {
                        numeralDecimalMark = ',';
                    }
                    if (this.thousandSeparator) {
                        delimiter = this.thousandSeparator;
                        if (this.thousandSeparator === ',') {
                            numeralDecimalMark = '.';
                        }
                        else {
                            numeralDecimalMark = !this.decimalSeparator || (this.decimalSeparator !== '.' && this.decimalSeparator !== ',') ?
                                ',' :
                                this.decimalSeparator;
                        }
                    }
                    else {
                        delimiter = '';
                    }
                    cleaveOpts = {
                        numeral: true,
                        numeralDecimalMark: numeralDecimalMark,
                        delimiter: delimiter,
                    };
                }
            }
            // literal options object
            if (typeof this.options === 'string' && this.options.match(/^\{/)) {
                try {
                    cleaveOpts = JSON.parse(this.options);
                }
                catch (/** @type {?} */ e) {
                    console.error('Angular2 Cleave : options object could not be parsed. Check that JSON syntax is correct.');
                }
            }
            // handle error if option is not available
            if (typeof this.options === 'string' && cleaveOpts === null) {
                console.error('Angular2 Cleave : option is not valid (%s).\n Available options : %s', this.options, availableTypes.join(', '));
            }
            // Cleave.js options object
            if (typeof this.options === 'object') {
                cleaveOpts = this.options;
            }
            // let's go !
            if (cleaveOpts !== null) {
                this.initCleave(cleaveOpts);
            }
        };
        /**
         * @param {?} opts
         * @return {?}
         */
        UxCleaveDirective.prototype.initCleave = /**
         * @param {?} opts
         * @return {?}
         */
        function (opts) {
            this.cleaveInstance = new Cleave(this.el.nativeElement, opts);
        };
        UxCleaveDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCleave]'
                    },] },
        ];
        /** @nocollapse */
        UxCleaveDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: UxService, },
        ]; };
        UxCleaveDirective.propDecorators = {
            "options": [{ type: core.Input, args: ['uxCleave',] },],
            "decimalSeparator": [{ type: core.Input },],
            "thousandSeparator": [{ type: core.Input },],
        };
        return UxCleaveDirective;
    }());
    var UxCleaveModule = (function () {
        function UxCleaveModule() {
        }
        UxCleaveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxCleaveDirective],
                        declarations: [UxCleaveDirective]
                    },] },
        ];
        return UxCleaveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTemplateDirective = (function () {
        function UxTemplateDirective(template) {
            this.template = template;
        }
        /**
         * @return {?}
         */
        UxTemplateDirective.prototype.getType = /**
         * @return {?}
         */
        function () {
            return this.name;
        };
        UxTemplateDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTemplate]'
                    },] },
        ];
        /** @nocollapse */
        UxTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef, },
        ]; };
        UxTemplateDirective.propDecorators = {
            "type": [{ type: core.Input },],
            "name": [{ type: core.Input, args: ['uxTemplate',] },],
        };
        return UxTemplateDirective;
    }());
    var UxTemplateDirectiveModule = (function () {
        function UxTemplateDirectiveModule() {
        }
        UxTemplateDirectiveModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTemplateDirective],
                        declarations: [UxTemplateDirective]
                    },] },
        ];
        return UxTemplateDirectiveModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NguiAutoCompleteDropdownButtonDirective = (function () {
        function NguiAutoCompleteDropdownButtonDirective(el) {
            this.el = el;
            this.hasDropdownButton = false;
        }
        /**
         * @return {?}
         */
        NguiAutoCompleteDropdownButtonDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.hasDropdownButton) {
                var /** @type {?} */ input = this.el.nativeElement;
                if (input && input.offsetParent) {
                    this.inputParent = input.offsetParent;
                    this.inputButton = document.createElement('div');
                    this.inputButton.className = 'ngui-auto-complete-wrapper__button';
                    input.style.paddingRight = '2rem';
                    this.inputButton.addEventListener('click', this.onClickListener.bind(this));
                    this.inputParent.appendChild(this.inputButton);
                }
            }
        };
        /**
         * @return {?}
         */
        NguiAutoCompleteDropdownButtonDirective.prototype.onClickListener = /**
         * @return {?}
         */
        function () {
            this.el.nativeElement.focus();
        };
        /**
         * @return {?}
         */
        NguiAutoCompleteDropdownButtonDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.inputButton) {
                this.inputButton.removeEventListener('click', this.onClickListener);
                this.inputButton.remove();
            }
        };
        NguiAutoCompleteDropdownButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'input[ngui-auto-complete]'
                    },] },
        ];
        /** @nocollapse */
        NguiAutoCompleteDropdownButtonDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        NguiAutoCompleteDropdownButtonDirective.propDecorators = {
            "hasDropdownButton": [{ type: core.Input },],
        };
        return NguiAutoCompleteDropdownButtonDirective;
    }());
    var NguiAutoCompleteDropdownButtonModule = (function () {
        function NguiAutoCompleteDropdownButtonModule() {
        }
        NguiAutoCompleteDropdownButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [NguiAutoCompleteDropdownButtonDirective],
                        declarations: [NguiAutoCompleteDropdownButtonDirective]
                    },] },
        ];
        return NguiAutoCompleteDropdownButtonModule;
    }());
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLanguage = (function () {
        function UxLanguage() {
        }
        return UxLanguage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxGrowlComponent = (function () {
        function UxGrowlComponent(el, differs) {
            this.el = el;
            this.sticky = false;
            this.life = 3000;
            this.differ = differs.find([]).create(undefined);
        }
        /**
         * @return {?}
         */
        UxGrowlComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.container = /** @type {?} */ (this.containerViewChild.nativeElement);
        };
        /**
         * @return {?}
         */
        UxGrowlComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ changes = this.differ.diff(this.value);
            if (changes && this.container) {
                if (this.stopDoCheckPropagation) {
                    this.stopDoCheckPropagation = false;
                }
                else if (this.value && this.value.length) {
                    if (!this.sticky) {
                        if (this.timeout) {
                            clearTimeout(this.timeout);
                        }
                        this.timeout = setTimeout(function () {
                            _this.removeAll();
                        }, this.life);
                    }
                }
            }
        };
        /**
         * @param {?} msg
         * @param {?} msgel
         * @return {?}
         */
        UxGrowlComponent.prototype.remove = /**
         * @param {?} msg
         * @param {?} msgel
         * @return {?}
         */
        function (msg, msgel) {
            var _this = this;
            this.stopDoCheckPropagation = true;
            setTimeout(function () {
                _this.value.splice(_this.findMessageIndex(msg), 1);
            }, 250);
        };
        /**
         * @return {?}
         */
        UxGrowlComponent.prototype.removeAll = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.value && this.value.length) {
                this.stopDoCheckPropagation = true;
                setTimeout(function () {
                    _this.value.splice(0, _this.value.length);
                }, 250);
            }
        };
        /**
         * @param {?} msg
         * @return {?}
         */
        UxGrowlComponent.prototype.findMessageIndex = /**
         * @param {?} msg
         * @return {?}
         */
        function (msg) {
            var /** @type {?} */ index = -1;
            if (this.value && this.value.length) {
                for (var /** @type {?} */ i = 0; i < this.value.length; i++) {
                    if (this.value[i] === msg) {
                        index = i;
                        break;
                    }
                }
            }
            return index;
        };
        /**
         * @return {?}
         */
        UxGrowlComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (!this.sticky) {
                clearTimeout(this.timeout);
            }
        };
        UxGrowlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-growl',
                        template: "\n        <div #container class=\"ux-growl {{styleClass}} ux-growl--{{position}}\">\n            <div #msgel *ngFor=\"let msg of value\"\n                 class=\"ux-growl-item-container fx slideInUp\" aria-live=\"polite\"\n                 [ngClass]=\"{'ux-growl-item-container--info':msg.severity == 'info',\n                             'ux-growl-item-container--warning':msg.severity == 'warning',\n                             'ux-growl-item-container--danger':msg.severity == 'danger',\n                             'ux-growl-item-container--success':msg.severity == 'success'}\">\n                <div class=\"ux-growl-item\">\n                     <div class=\"ux-growl-item-close ux-icon ux-icon-close\" (click)=\"remove(msg,msgel)\"></div>\n                     <span class=\"ux-growl-item-image ux-icon ux-icon-2x\"\n                        [ngClass]=\"{'ux-icon-info-circle':msg.severity == 'info',\n                                    'ux-icon-exclamation-circle':msg.severity == 'warning',\n                                    'ux-icon-times-circle':msg.severity == 'danger',\n                                    'ux-icon-check-circle':msg.severity == 'success'}\"></span>\n                     <div class=\"ux-growl-item-message\">\n                        <span class=\"ux-growl-item-message-title\">{{msg.summary}}</span>\n                        <p class=\"ux-growl-item-message-detail\" [innerHTML]=\"msg.detail\"></p>\n                     </div>\n                </div>\n            </div>\n        </div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxGrowlComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.IterableDiffers, },
        ]; };
        UxGrowlComponent.propDecorators = {
            "sticky": [{ type: core.Input },],
            "life": [{ type: core.Input },],
            "value": [{ type: core.Input },],
            "style": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "position": [{ type: core.Input },],
            "containerViewChild": [{ type: core.ViewChild, args: ['container',] },],
        };
        return UxGrowlComponent;
    }());
    var UxGrowlComponentModule = (function () {
        function UxGrowlComponentModule() {
        }
        UxGrowlComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxGrowlComponent],
                        declarations: [UxGrowlComponent]
                    },] },
        ];
        return UxGrowlComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBlockDocumentComponent = (function () {
        function UxBlockDocumentComponent() {
        }
        UxBlockDocumentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-block-document',
                        template: "<div class=\"ux-block-document\" [ngStyle]=\"{display: isBlocked ? 'block' : 'none'}\"> <div class=\"ux-block-document-loading\"></div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxBlockDocumentComponent.ctorParameters = function () { return []; };
        UxBlockDocumentComponent.propDecorators = {
            "isBlocked": [{ type: core.Input },],
        };
        return UxBlockDocumentComponent;
    }());
    var UxBlockDocumentComponentModule = (function () {
        function UxBlockDocumentComponentModule() {
        }
        UxBlockDocumentComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxBlockDocumentComponent],
                        declarations: [UxBlockDocumentComponent]
                    },] },
        ];
        return UxBlockDocumentComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxEuLanguages = (function () {
        function UxEuLanguages() {
        }
        /**
         * @param {?=} codes
         * @return {?}
         */
        UxEuLanguages.getLanguages = /**
         * @param {?=} codes
         * @return {?}
         */
        function (codes) {
            if (codes == null || codes.length <= 0) {
                codes = this.defaultCodes;
            }
            var /** @type {?} */ languages = [];
            for (var /** @type {?} */ c = 0; c < codes.length; c++) {
                var /** @type {?} */ language = this.languagesByCode[codes[c]];
                if (language != null) {
                    languages.push(language);
                }
            }
            return languages;
        };
        UxEuLanguages.languagesByCode = {
            bg: {
                code: 'bg',
                label: 'български'
            },
            cs: {
                code: 'cs',
                label: 'čeština'
            },
            da: {
                code: 'da',
                label: 'dansk'
            },
            de: {
                code: 'de',
                label: 'Deutsch'
            },
            et: {
                code: 'et',
                label: 'eesti keel'
            },
            el: {
                code: 'el',
                label: 'ελληνικά'
            },
            en: {
                code: 'en',
                label: 'English'
            },
            es: {
                code: 'es',
                label: 'español'
            },
            fr: {
                code: 'fr',
                label: 'français'
            },
            ga: {
                code: 'ga',
                label: 'Gaeilge'
            },
            it: {
                code: 'it',
                label: 'italiano'
            },
            lv: {
                code: 'lv',
                label: 'latviešu valoda'
            },
            lt: {
                code: 'lt',
                label: 'lietuvių kalba'
            },
            hu: {
                code: 'hu',
                label: 'magyar'
            },
            mt: {
                code: 'mt',
                label: 'Malti'
            },
            nl: {
                code: 'nl',
                label: 'Nederlands'
            },
            pl: {
                code: 'pl',
                label: 'polski'
            },
            pt: {
                code: 'pt',
                label: 'português'
            },
            ro: {
                code: 'ro',
                label: 'română'
            },
            sk: {
                code: 'sk',
                label: 'slovenčina'
            },
            sl: {
                code: 'sl',
                label: 'slovenščina'
            },
            fi: {
                code: 'fi',
                label: 'suomi'
            },
            sv: {
                code: 'sv',
                label: 'svenska'
            },
            hr: {
                code: 'hr',
                label: 'hrvatski'
            },
            is: {
                code: 'is',
                label: 'íslenska'
            },
            mk: {
                code: 'mk',
                label: 'македонски'
            },
            no: {
                code: 'no',
                label: 'norsk'
            },
            tr: {
                code: 'tr',
                label: 'türkçe'
            }
        };
        UxEuLanguages.defaultCodes = [
            'bg', 'cs', 'da', 'de', 'et', 'el', 'en',
            'es', 'fr', 'ga', 'it', 'lv', 'lt', 'hu',
            'mt', 'nl', 'pl', 'pt', 'ro', 'sk', 'sl',
            'fi', 'sv', 'hr', 'is', 'mk', 'no', 'tr'
        ];
        return UxEuLanguages;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxModalComponent = (function () {
        function UxModalComponent(uxService) {
            this.uxService = uxService;
            this.dismissActionLabel = 'Cancel';
            this.dismissActionDisabled = false;
            this.acceptActionLabel = 'OK';
            this.acceptActionDisabled = false;
            this.isFooterVisible = true;
            this.isVisible = false;
            this.isKeepBodyScroll = false;
            this.isSizeSmall = false;
            this.isSizeLarge = false;
            this.isSizeFullScreen = false;
            this.isSizeFullHeight = false;
            this.isSizeMediumHeight = false;
            this.isShowActionIcons = false;
            this.acceptIconClass = 'ux-icon ux-icon-check';
            this.dismissIconClass = 'ux-icon ux-icon-close';
            this.hasNoBodyPadding = false;
            this.isFooterCustomAlignment = false;
            this.isCloseModalOnEscape = true;
            this.isShowCloseButton = true;
            this.isMessageBox = false;
            this.isHandleCloseOnDismiss = true;
            this.isHandleCloseOnAccept = true;
            this.isHandleCloseOnClose = true;
            this.isOverflowVisible = false;
            this.isDismissActionVisible = true;
            this.isAcceptActionVisible = true;
            this.onDismiss = new core.EventEmitter();
            this.onAccept = new core.EventEmitter();
            this.onClose = new core.EventEmitter();
            // modal states
            this.stateClasses = '';
        }
        Object.defineProperty(UxModalComponent.prototype, "isModalOpen", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.uxService.isModalOpen(this.id)) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxModalComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.isVisible) {
                this.uxService.openModal(this.id);
            }
            // setting modal states
            if (this.isSizeSmall) {
                this.stateClasses = 'ux-modal--small';
            }
            if (this.isSizeLarge) {
                this.stateClasses = 'ux-modal--large';
            }
            if (this.isSizeFullScreen) {
                this.stateClasses = 'ux-modal--full-screen';
            }
            if (!this.isAcceptActionVisible && !this.isDismissActionVisible) {
                this.isFooterVisible = false;
            }
            // this.openModalIdSubscription = this.uxService.openModalId.subscribe((modalId) => {
            //     if (modalId === this.id) {
            //         this.vcCloseButton.nativeElement.focus();
            //     }
            // });
        };
        /**
         * @return {?}
         */
        UxModalComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.openModalIdSubscription) {
                this.openModalIdSubscription.unsubscribe();
            }
            if (this.uxService.isModalOpen(this.id)) {
                this.close({});
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxModalComponent.prototype.close = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isHandleCloseOnClose) {
                this.uxService.closeModal(this.id);
            }
            this.onClose.emit(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxModalComponent.prototype.closeModalOnEscape = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isCloseModalOnEscape) {
                if (event.keyCode === 27) {
                    // 27 = escape
                    this.close(event);
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxModalComponent.prototype.onAcceptActionClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isHandleCloseOnAccept) {
                this.uxService.closeModal(this.id);
            }
            this.onAccept.emit(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxModalComponent.prototype.onDismissActionClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isHandleCloseOnDismiss) {
                this.uxService.closeModal(this.id);
            }
            this.onDismiss.emit(event);
        };
        UxModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-modal',
                        template: "\n        <div id=\"{{id}}\" cdkTrapFocus class=\"modal fx ux-modal {{styleClass}} {{stateClasses}}\" [class.show]=\"isModalOpen\"\n                                         tabindex=\"-1\"\n                                         role=\"dialog\"\n                                         [class.slideInDown]=\"!isMessageBox\"\n                                         [class.flipInY]=\"isMessageBox\"\n                                         [class.ux-modal--full-height]=\"isSizeFullHeight\"\n                                         [class.ux-modal--medium-height]=\"isSizeMediumHeight\"\n                                         [attr.aria-hidden]=\"!isModalOpen\"\n                                         [style.display]=\"isModalOpen ? 'block' : 'none'\"\n                                         (keydown)=\"closeModalOnEscape($event)\" tabIndex=\"-1\">\n            <div class=\"modal-dialog ux-modal__dialog\" role=\"document\" [style.max-width]=\"customWidth\">\n              <div class=\"modal-content ux-modal__content\" [class.ux-u-overflow-visible]=\"isOverflowVisible\">\n                <div class=\"modal-header ux-modal__header\">\n                  <ng-template [ngIf]=\"customHeaderContent\">\n                      <ng-content select=\"uxModalHeader\"></ng-content>\n                  </ng-template>\n                  <ng-template [ngIf]=\"!customHeaderContent\">\n                      <h5 class=\"modal-title ux-modal__header-title\">{{titleLabel}}</h5>\n                  </ng-template>\n                  <button #closeButton type=\"button\" id=\"{{id}}-close-button\"\n                          class=\"ux-modal__header-close close\"\n                          data-dismiss=\"modal\" aria-label=\"Close\"\n                          (click)=\"close($event)\" [class.ux-u-opacity-0]=\"!isShowCloseButton\">\n                    <span>&times;</span>\n                  </button>\n                </div>\n                <div class=\"modal-body ux-modal__body {{bodyStyleClass}}\"\n                     [class.p-0]=\"hasNoBodyPadding\" [class.ux-u-overflow-visible]=\"isOverflowVisible\">\n                  <ng-content select=\"uxModalBody\"></ng-content>\n                </div>\n                <div *ngIf=\"isFooterVisible\"\n                        class=\"modal-footer ux-modal__footer {{footerStyleClass}}\"\n                        [class.ux-modal__footer--custom-alignment]=\"isFooterCustomAlignment\">\n                  <ng-template [ngIf]=\"customFooterContent\">\n                      <ng-content select=\"uxModalFooter\"></ng-content>\n                  </ng-template>\n                  <ng-template [ngIf]=\"!customFooterContent\">\n                      <button type=\"button\"\n                              class=\"btn btn-secondary\" *ngIf=\"isDismissActionVisible\"\n                              [disabled]=\"dismissActionDisabled\" (click)=\"onDismissActionClick($event)\" >\n                        <i *ngIf=\"isShowActionIcons\" class=\"{{dismissIconClass}}\"></i>\n                        {{dismissActionLabel}}\n                      </button>\n                      <button type=\"button\"\n                              class=\"btn btn-primary\" *ngIf=\"isAcceptActionVisible\"\n                              [disabled]=\"acceptActionDisabled\" (click)=\"onAcceptActionClick($event)\">\n                        <i *ngIf=\"isShowActionIcons\" class=\"{{acceptIconClass}}\"></i>\n                        {{acceptActionLabel}}\n                      </button>\n                  </ng-template>\n                </div>\n              </div>\n            </div>\n        </div>\n        <div class=\"modal-backdrop\" [class.show]=\"isModalOpen\"\n                                    [ngClass]=\"{fade: isModalOpen, in: isModalOpen}\"\n                                    [style.display]=\"isModalOpen ? 'block' : 'none'\" (focus)=\"close($event)\"></div>\n        "
                    },] },
        ];
        /** @nocollapse */
        UxModalComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxModalComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "titleLabel": [{ type: core.Input },],
            "dismissActionLabel": [{ type: core.Input },],
            "dismissActionDisabled": [{ type: core.Input },],
            "acceptActionLabel": [{ type: core.Input },],
            "acceptActionDisabled": [{ type: core.Input },],
            "isFooterVisible": [{ type: core.Input },],
            "isVisible": [{ type: core.Input },],
            "isKeepBodyScroll": [{ type: core.Input },],
            "isSizeSmall": [{ type: core.Input },],
            "isSizeLarge": [{ type: core.Input },],
            "isSizeFullScreen": [{ type: core.Input },],
            "isSizeFullHeight": [{ type: core.Input },],
            "isSizeMediumHeight": [{ type: core.Input },],
            "isShowActionIcons": [{ type: core.Input },],
            "acceptIconClass": [{ type: core.Input },],
            "dismissIconClass": [{ type: core.Input },],
            "hasNoBodyPadding": [{ type: core.Input },],
            "customWidth": [{ type: core.Input },],
            "isFooterCustomAlignment": [{ type: core.Input },],
            "isCloseModalOnEscape": [{ type: core.Input },],
            "isShowCloseButton": [{ type: core.Input },],
            "isMessageBox": [{ type: core.Input },],
            "isHandleCloseOnDismiss": [{ type: core.Input },],
            "isHandleCloseOnAccept": [{ type: core.Input },],
            "isHandleCloseOnClose": [{ type: core.Input },],
            "bodyStyleClass": [{ type: core.Input },],
            "footerStyleClass": [{ type: core.Input },],
            "isOverflowVisible": [{ type: core.Input },],
            "isDismissActionVisible": [{ type: core.Input },],
            "isAcceptActionVisible": [{ type: core.Input },],
            "onDismiss": [{ type: core.Output },],
            "onAccept": [{ type: core.Output },],
            "onClose": [{ type: core.Output },],
            "vcCloseButton": [{ type: core.ViewChild, args: ['closeButton',] },],
            "customFooterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxModalFooterTagDirective; }),] },],
            "customHeaderContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxModalHeaderTagDirective; }),] },],
        };
        return UxModalComponent;
    }());
    var UxModalBodyTagDirective = (function () {
        function UxModalBodyTagDirective() {
        }
        UxModalBodyTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxModalBody' },] },
        ];
        return UxModalBodyTagDirective;
    }());
    var UxModalFooterTagDirective = (function () {
        function UxModalFooterTagDirective() {
        }
        UxModalFooterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxModalFooter' },] },
        ];
        return UxModalFooterTagDirective;
    }());
    var UxModalHeaderTagDirective = (function () {
        function UxModalHeaderTagDirective() {
        }
        UxModalHeaderTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxModalHeader' },] },
        ];
        return UxModalHeaderTagDirective;
    }());
    var UxModalComponentModule = (function () {
        function UxModalComponentModule() {
        }
        UxModalComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, a11y.A11yModule],
                        exports: [UxModalComponent, UxModalBodyTagDirective, UxModalFooterTagDirective, UxModalHeaderTagDirective],
                        declarations: [UxModalComponent, UxModalBodyTagDirective, UxModalFooterTagDirective, UxModalHeaderTagDirective]
                    },] },
        ];
        return UxModalComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLanguageSelectorComponent = (function () {
        function UxLanguageSelectorComponent(shadowDomRoot, uxService, storageService, translateService) {
            this.shadowDomRoot = shadowDomRoot;
            this.uxService = uxService;
            this.storageService = storageService;
            this.translateService = translateService;
            this.isShowLabel = true;
            this.languageChanged = new core.EventEmitter();
            this.modalId = 'ux-language-selector-modal';
            this.dropDownIsOpen = false;
        }
        Object.defineProperty(UxLanguageSelectorComponent.prototype, "isShowDropDown", {
            get: /**
             * @return {?}
             */
            function () {
                return this.languages.length > 1 && this.languages.length < 4;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxLanguageSelectorComponent.prototype, "isShowModal", {
            get: /**
             * @return {?}
             */
            function () {
                return this.languages.length >= 4;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.languageCodes != null) {
                var /** @type {?} */ codes = this.languageCodes.split(/[ ,]+/g);
                this.languages = UxEuLanguages.getLanguages(codes);
            }
            else {
                this.languages = UxEuLanguages.getLanguages();
            }
            if (this.additionalLanguages) {
                for (var _i = 0, _a = this.additionalLanguages; _i < _a.length; _i++) {
                    var additionalLanguage = _a[_i];
                    this.languages.push(additionalLanguage);
                }
            }
            this.languageRows = this.prepareLanguageRows();
            this.selectedLanguage = this.selectedLanguage || {
                code: this.translateService.currentLang,
                label: this.getLanguageLabel(this.translateService.currentLang)
            };
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes && (changes['languageCodes'] || changes['additionalLanguages'])) {
                this.ngOnInit();
            }
        };
        /**
         * @param {?} querySelector
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.shadowDomQuery = /**
         * @param {?} querySelector
         * @return {?}
         */
        function (querySelector) {
            return this.shadowDomRoot.nativeElement.querySelector(querySelector);
        };
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.prepareLanguageRows = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ rows = [];
            var /** @type {?} */ row = [];
            for (var /** @type {?} */ i = 0; i < this.languages.length; i++) {
                if (i % 4 === 0) {
                    if (row.length > 0) {
                        rows.push(row);
                        row = [];
                    }
                }
                row.push(this.languages[i]);
            }
            if (row.length > 0) {
                rows.push(row);
            }
            return rows;
        };
        /**
         * @param {?} languageCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.selectLanguage = /**
         * @param {?} languageCode
         * @return {?}
         */
        function (languageCode) {
            if (this.selectedLanguage != null && this.selectedLanguage.code !== languageCode) {
                for (var _i = 0, _a = this.languages; _i < _a.length; _i++) {
                    var language = _a[_i];
                    if (language.code === languageCode) {
                        this.selectedLanguage = language;
                        break;
                    }
                }
                // Save the Language preference to local storage...
                var /** @type {?} */ state = this.storageService.get('state');
                if (!state) {
                    state = { user: { preferences: {} } };
                }
                state.user.preferences.lang = this.selectedLanguage.code;
                this.storageService.set('state', state);
                this.languageChanged.emit(this.selectedLanguage);
            }
            this.close();
        };
        /**
         * @param {?} languageCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.getLanguageLabel = /**
         * @param {?} languageCode
         * @return {?}
         */
        function (languageCode) {
            for (var _i = 0, _a = this.languages; _i < _a.length; _i++) {
                var language = _a[_i];
                if (language.code === languageCode) {
                    return language.label;
                }
            }
            return;
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.toggleOutside = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (!this.shadowDomRoot.nativeElement.contains(evt.target)) {
                this.dropDownIsOpen = false;
            }
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.openKeyDown = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 13) {
                this.open();
            }
        };
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.open = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.uxService.openModal(this.modalId);
            setTimeout(function () {
                _this.shadowDomQuery('.btn-primary').focus();
            }, 0);
        };
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.close = /**
         * @return {?}
         */
        function () {
            this.uxService.closeModal(this.modalId);
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.closeModalOnEscape = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 27) {
                // 27 = escape
                this.close();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.consumeEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            event.cancelBubble = true;
            return false;
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.toggleDropDownKeyDown = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 13) {
                this.toggleDropDown();
            }
        };
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.toggleDropDown = /**
         * @return {?}
         */
        function () {
            this.dropDownIsOpen = !this.dropDownIsOpen;
            if (this.dropDownIsOpen) {
                var /** @type {?} */ selectedItem_1 = this.shadowDomQuery('.dropdown-item[data-language-code=' + this.selectedLanguage.code + ']');
                if (selectedItem_1 != null) {
                    setTimeout(function () {
                        selectedItem_1.focus();
                    }, 100);
                }
            }
        };
        /**
         * @param {?} languageCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.selectDropdownLanguage = /**
         * @param {?} languageCode
         * @return {?}
         */
        function (languageCode) {
            this.selectLanguage(languageCode);
            this.dropDownIsOpen = false;
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.closeDropDownOnEscape = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 27) {
                // 27 = escape
                this.dropDownIsOpen = false;
            }
        };
        /**
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.closeOnBlur = /**
         * @return {?}
         */
        function () {
            var _this = this;
            setTimeout(function () {
                if (_this.shadowDomQuery('.dropdown-item:focus') == null) {
                    _this.dropDownIsOpen = false;
                }
            }, 0);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLanguageSelectorComponent.prototype.navigateDropDownSelection = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ keyCode = event.keyCode;
            /*
                     38 = arrow up
                     40 = arrow down
                     */
            var /** @type {?} */ focusedItem = this.shadowDomQuery('.dropdown-item:focus');
            if (focusedItem != null) {
                var /** @type {?} */ next = void 0;
                if (keyCode === 40) {
                    // arrow down:
                    next = (/** @type {?} */ (focusedItem)).nextElementSibling;
                    if (!next) {
                        next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).firstElementChild;
                    }
                }
                else if (keyCode === 38) {
                    // arrow up:
                    next = (/** @type {?} */ (focusedItem)).previousElementSibling;
                    if (!next) {
                        next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).lastElementChild;
                    }
                }
                if (next) {
                    (/** @type {?} */ (next)).focus();
                    this.consumeEvent(event);
                }
            }
        };
        UxLanguageSelectorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-language-selector',
                        template: "<div class=\"ecl-typography ux-language-selector\"> <ng-container *ngIf=\"isShowDropDown\"> <div class=\"btn-group\"> <a class=\"ecl-lang-select-sites__link\" tabindex=\"1\" aria-haspopup=\"true\" (click)=\"toggleDropDown()\" (keydown)=\"toggleDropDownKeyDown($event.keyCode)\"> <span class=\"ecl-lang-select-sites__label\" *ngIf=\"isShowLabel\">{{selectedLanguage.label}}</span> <span class=\"ecl-lang-select-sites__code\"> <span class=\"ecl-icon ecl-icon--language ecl-lang-select-sites__icon\"></span> <span class=\"ecl-lang-select-sites__code-text\">{{selectedLanguage.code | uppercase}}</span> </span> </a> <div class=\"dropdown-menu\" [style.display]=\"dropDownIsOpen ? 'block' : 'none'\" style=\"left: initial;right: 0;\" (keydown)=\"closeDropDownOnEscape($event.keyCode)\"> <a *ngFor=\"let language of languages\" href=\"javascript:void(0);\" class=\"dropdown-item\" [attr.data-language-code]=\"language.code\" (click)=\"selectDropdownLanguage(language.code)\" (blur)=\"closeOnBlur()\" (keydown)=\"navigateDropDownSelection($event)\" > <label>{{language.label}} ({{language.code}})</label> </a> </div> </div> </ng-container> <ng-container *ngIf=\"isShowModal\"> <a class=\"ecl-lang-select-sites__link\" tabindex=\"1\" (click)=\"open()\" (keydown)=\"openKeyDown($event.keyCode)\"> <span class=\"ecl-lang-select-sites__label\" *ngIf=\"isShowLabel\">{{selectedLanguage.label}}</span> <span class=\"ecl-lang-select-sites__code\"> <span class=\"ecl-icon ecl-icon--language ecl-lang-select-sites__icon\"></span> <span class=\"ecl-lang-select-sites__code-text\">{{selectedLanguage.code | uppercase}}</span> </span> </a> <ux-modal id=\"{{modalId}}\" titleLabel=\"Select language\" [isFooterVisible]=\"false\" styleClass=\"ux-language-selector-modal\"> <uxModalBody> <div *ngFor=\"let row of languageRows\" class=\"row mt-2\"> <div *ngFor=\"let language of row\" class=\"col-md-3 col-sm-6\"> <button class=\"btn btn-block\" [class.btn-secondary]=\"language.code != selectedLanguage.code\" [class.btn-primary]=\"language.code == selectedLanguage.code\" (click)=\"selectLanguage(language.code)\"> <label>{{language.label}} ({{language.code}})</label> </button> </div> </div> </uxModalBody> </ux-modal> </ng-container> </div> "
                    },] },
        ];
        /** @nocollapse */
        UxLanguageSelectorComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: UxService, },
            { type: StorageService, },
            { type: core$1.TranslateService, },
        ]; };
        UxLanguageSelectorComponent.propDecorators = {
            "languageCodes": [{ type: core.Input },],
            "additionalLanguages": [{ type: core.Input },],
            "selectedLanguage": [{ type: core.Input },],
            "isShowLabel": [{ type: core.Input },],
            "languageChanged": [{ type: core.Output },],
            "toggleOutside": [{ type: core.HostListener, args: ['body:click', ['$event'],] },],
        };
        return UxLanguageSelectorComponent;
    }());
    var UxLanguageSelectorComponentModule = (function () {
        function UxLanguageSelectorComponentModule() {
        }
        UxLanguageSelectorComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxModalComponentModule],
                        exports: [UxLanguageSelectorComponent],
                        declarations: [UxLanguageSelectorComponent]
                    },] },
        ];
        return UxLanguageSelectorComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTagComponent = (function () {
        function UxTagComponent() {
            this.isRounded = false;
            this.isSmall = false;
            this.tabindex = '0';
        }
        /**
         * @return {?}
         */
        UxTagComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.stateClasses = '';
            if (!this.subLabel && this.isRounded) {
                this.stateClasses += 'ux-a-tag--rounded ';
            }
            if (this.isSmall) {
                this.stateClasses += 'ux-a-tag--small';
            }
        };
        UxTagComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-tag',
                        template: "<div *ngIf=\"label\" class=\"ux-a-tag {{stateClasses}} {{styleClass}}\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}}\"> <span class=\"ux-a-tag__label ux-u-bg-color-{{typeClass}}\"> {{label}} </span> <span *ngIf=\"subLabel\" class=\"ux-a-tag__sub-label ux-u-bg-color-{{typeClass}}-dark\"> {{subLabel}} </span> </div> ",
                        styles: [":host{flex:0 1 auto !important}.ux-a-tag{color:white;display:flex;max-width:100% !important;padding:0;width:100%}.ux-a-tag__label{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#9e9e9e;padding:.66rem 1.25rem}.ux-a-tag__sub-label{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#757575;padding:.66rem 1.25rem}.ux-a-tag--small .ux-a-tag__label{padding:.33rem .66rem}.ux-a-tag--small .ux-a-tag__sub-label{padding:.33rem .66rem}.ux-a-tag--large .ux-a-tag__label{padding:1.25rem 1rem}.ux-a-tag--large .ux-a-tag__sub-label{padding:1.25rem 1rem}.ux-a-tag--rounded .ux-a-tag__label{border-radius:10rem} /*# sourceMappingURL=ux-a-tag.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxTagComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "isRounded": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
        };
        return UxTagComponent;
    }());
    var UxTagComponentModule = (function () {
        function UxTagComponentModule() {
        }
        UxTagComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTagComponent],
                        declarations: [UxTagComponent]
                    },] },
        ];
        return UxTagComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxIconComponent = (function () {
        function UxIconComponent() {
            this.isRounded = true;
            this.isTiny = false;
            this.isSmall = false;
            this.isLarge = false;
            this.isHoverable = false;
            this.tagTypeClass = 'danger';
            this.tagSizeClass = 'tiny';
            this.isShowTag = true;
            this.isEmptyTag = false;
            this.tabindexValue = -1;
        }
        /**
         * @return {?}
         */
        UxIconComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.iconStateClasses = '';
            if (this.iconClass) {
                if (this.isRounded) {
                    if (this.isLarge) {
                        this.iconStateClasses += 'ux-a-icon--rounded-large ';
                    }
                    else if (this.isSmall) {
                        this.iconStateClasses += 'ux-a-icon--rounded-small ';
                    }
                    else if (this.isTiny) {
                        this.iconStateClasses += 'ux-a-icon--rounded-tiny ';
                    }
                    else {
                        this.iconStateClasses += 'ux-a-icon--rounded ';
                    }
                }
                else {
                    if (this.isTiny) {
                        this.iconStateClasses += 'ux-a-icon--tiny ';
                    }
                    if (this.isSmall) {
                        this.iconStateClasses += 'ux-a-icon--small ';
                    }
                    if (this.isLarge) {
                        this.iconStateClasses += 'ux-a-icon--large ';
                    }
                    if (this.isHoverable) {
                        this.iconStateClasses += 'ux-a-icon--hoverable';
                        this.tabindexValue = 0;
                    }
                }
                if (this.typeClass) {
                    this.iconStateClasses += 'ux-a-icon--' + this.typeClass;
                }
            }
        };
        UxIconComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-icon',
                        template: "<div *ngIf=\"iconClass\" class=\"ux-a-icon {{iconStateClasses}} {{styleClass}} ux-u-color-{{typeClass}}\" tabindex=\"{{tabindexValue}}\"> <span class=\"ux-icon-fw {{iconClass}} ux-a-icon__icon\"> <span *ngIf=\"(tagLabel || isEmptyTag) && isShowTag\" class=\"ux-a-icon__tag badge badge--{{tagSizeClass}} badge-pill badge-{{tagTypeClass}}\" [class.ux-a-icon__tag--empty]=\"isEmptyTag\"> <span *ngIf=\"!isEmptyTag\">{{tagLabel}}</span> </span> </span> </div> ",
                        styles: [".ux-a-icon{position:relative;text-align:center}.ux-a-icon__icon{font-size:1.42857rem;position:relative}.ux-a-icon__tag{min-width:20px;position:absolute;right:-9px;top:-9px;z-index:1;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-icon__tag--empty{min-height:10px;min-width:10px;right:-4px;top:-4px}.ux-a-icon__label-wrapper{color:#333;margin-top:1.25rem}.ux-a-icon--hoverable{color:#757575}.ux-a-icon--hoverable:hover,.ux-a-icon--hoverable:focus{color:#004494;cursor:pointer}.ux-a-icon--hoverable .ux-a-icon__icon{padding:.33rem}.ux-a-icon--hoverable:focus .ux-a-icon__icon{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-a-icon--tiny .ux-a-icon__icon{font-size:.85714rem}.ux-a-icon--small .ux-a-icon__icon{font-size:1rem}.ux-a-icon--large .ux-a-icon__icon{font-size:2rem}.ux-a-icon--rounded{padding-top:0.5rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#757575}.ux-a-icon--rounded .ux-a-icon__icon{margin-top:0.25rem}.ux-a-icon--rounded-large{padding-top:0.75rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#757575}.ux-a-icon--rounded-small{padding-top:0.25rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#757575}.ux-a-icon--rounded-large .ux-a-icon__icon{font-size:2rem;margin:0.3rem}.ux-a-icon--rounded.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#e0e9f2}.ux-a-icon--rounded.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#b3d4e9}.ux-a-icon--rounded.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#c8d7c4}.ux-a-icon--rounded.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#f9ca93}.ux-a-icon--rounded.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#f4bcc1}.ux-a-icon--rounded-large.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#e0e9f2}.ux-a-icon--rounded-large.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#b3d4e9}.ux-a-icon--rounded-large.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#c8d7c4}.ux-a-icon--rounded-large.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#f9ca93}.ux-a-icon--rounded-large.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#f4bcc1}.ux-a-icon--rounded-small.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#e0e9f2}.ux-a-icon--rounded-small.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#b3d4e9}.ux-a-icon--rounded-small.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#c8d7c4}.ux-a-icon--rounded-small.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#f9ca93}.ux-a-icon--rounded-small.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#f4bcc1}.ux-a-icon-toggle{cursor:pointer}.ux-a-icon-toggle:focus{outline:2px solid #ffd617;outline-offset:0;-moz-outline-radius:4px;position:relative;z-index:2} /*# sourceMappingURL=ux-a-icon.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxIconComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isRounded": [{ type: core.Input },],
            "isTiny": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isHoverable": [{ type: core.Input },],
            "tagLabel": [{ type: core.Input },],
            "tagTypeClass": [{ type: core.Input },],
            "tagSizeClass": [{ type: core.Input },],
            "isShowTag": [{ type: core.Input },],
            "isEmptyTag": [{ type: core.Input },],
        };
        return UxIconComponent;
    }());
    var UxIconComponentModule = (function () {
        function UxIconComponentModule() {
        }
        UxIconComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxIconComponent],
                        declarations: [UxIconComponent]
                    },] },
        ];
        return UxIconComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxMarkerComponent = (function () {
        function UxMarkerComponent() {
        }
        UxMarkerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-marker',
                        template: "<div class=\"ux-a-marker {{styleClass}}\"> <span class=\"ux-icon ux-icon-circle ux-a-marker__icon ux-u-color-{{typeClass}}\"></span> </div> ",
                        styles: [".ux-a-marker__icon{color:#757575;font-size:14px}.ux-a-marker--small{padding:.33rem}.ux-a-marker--large{padding:1.25rem} /*# sourceMappingURL=ux-a-marker.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxMarkerComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
        };
        return UxMarkerComponent;
    }());
    var UxMarkerComponentModule = (function () {
        function UxMarkerComponentModule() {
        }
        UxMarkerComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxMarkerComponent],
                        declarations: [UxMarkerComponent]
                    },] },
        ];
        return UxMarkerComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBadgeComponent = (function () {
        function UxBadgeComponent() {
            this.typeClass = 'default';
            this.isSmall = false;
            this.isLarge = false;
            this.isTiny = false;
            this.isPill = false;
            this.isOutline = false;
        }
        UxBadgeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-badge',
                        template: "<span class=\"badge ux-c-badge badge-{{typeClass}} ux-c-badge--{{typeClass}} {{styleClass}}\" [class.ux-c-badge--outline]=\"isOutline\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\" [class.badge--tiny]=\"isTiny\"> <ng-content></ng-content> </span> ",
                    },] },
        ];
        /** @nocollapse */
        UxBadgeComponent.ctorParameters = function () { return []; };
        UxBadgeComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isTiny": [{ type: core.Input },],
            "isPill": [{ type: core.Input },],
            "isOutline": [{ type: core.Input },],
        };
        return UxBadgeComponent;
    }());
    var UxBadgeComponentModule = (function () {
        function UxBadgeComponentModule() {
        }
        UxBadgeComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxBadgeComponent],
                        declarations: [UxBadgeComponent]
                    },] },
        ];
        return UxBadgeComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLabelComponent = (function () {
        function UxLabelComponent(uxService) {
            this.uxService = uxService;
            this.isIconRounded = false;
            this.isIconSmall = false;
            this.isIconTiny = false;
            this.isIconLarge = false;
            this.hasMarker = false;
            this.isClickable = false;
            this.badgeTypeClass = 'primary';
            this.isDisabled = false;
            this.isBoldLabel = false;
            this.isSmall = false;
            this.isLarge = false;
            this.isRenderHTML = false;
            this.tabindex = '0';
            this.labelClicked = new core.EventEmitter();
            this.stateClasses = '';
        }
        /**
         * @return {?}
         */
        UxLabelComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this.subLabel && !this.customSubLabel && !this.isBoldLabel) {
                this.stateClasses += 'ux-a-label--has-no-sub-label ';
            }
            if (this.isLarge) {
                this.stateClasses += 'ux-a-label--large';
            }
            if (this.isSmall) {
                this.stateClasses += 'ux-a-label--small';
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxLabelComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ subLabelChange = changes && changes['subLabel'];
            if (subLabelChange) {
                var /** @type {?} */ subLabel = subLabelChange.currentValue;
                if (this.subLabelSizeLimit) {
                    if (subLabel && subLabel.length > this.subLabelSizeLimit) {
                        this.subLabel = subLabel.substr(0, this.subLabelSizeLimit) + '...';
                    }
                    else {
                        this.subLabel = subLabel;
                    }
                }
                else {
                    this.subLabel = subLabel;
                }
            }
        };
        /**
         * @return {?}
         */
        UxLabelComponent.prototype.onLabelClicked = /**
         * @return {?}
         */
        function () {
            this.labelClicked.emit();
        };
        UxLabelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-label',
                        template: "<div class=\"ux-a-label {{styleClass}} ux-a-label--t-{{themeClass}} {{stateClasses}}\" [class.ux-a-label--disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.role]=\"ariaRole\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{infos}}\" [attr.aria-expanded]=\"ariaExpanded\" [attr.aria-controls]=\"ariaControls\"> <ux-a-marker *ngIf=\"hasMarker\" typeClass=\"{{markerTypeClass}}\" styleClass=\"mr-2\"> </ux-a-marker> <ux-a-icon *ngIf=\"iconClass\" typeClass=\"{{iconTypeClass}}\" iconClass=\"{{iconClass}}\" [isRounded]=\"isIconRounded\" [isSmall]=\"isIconSmall\" [isTiny]=\"isIconTiny\" [isLarge]=\"isIconLarge\" styleClass=\"mr-2\"> </ux-a-icon> <div class=\"ux-a-label__content\"> <div *ngIf=\"!customLabel\" class=\"ux-a-label__label {{labelStyleClass}}\" role=\"presentation\"> <ng-template [ngIf]=\"isClickable\"> <a class=\"ux-a-label__label--clickable\" [tabindex]=\"tabindex\" (click)=\"onLabelClicked()\"> {{label}} </a> </ng-template> <ng-template [ngIf]=\"!isClickable\"> <span *ngIf=\"isRenderHTML\" [innerHTML]=\"label\"></span> <span *ngIf=\"!isRenderHTML\"> {{label}} </span> </ng-template> </div> <div *ngIf=\"customLabel\" class=\"ux-a-label__custom-label\" role=\"presentation\"> <ng-content select=\"uxLabelContent\"></ng-content> </div> <ng-template [ngIf]=\"!customSubLabel\"> <div *ngIf=\"subLabel\" class=\"ux-a-label__sub-label\"> <span *ngIf=\"isRenderHTML\" [innerHTML]=\"subLabel\"></span> <span *ngIf=\"!isRenderHTML\"> {{subLabel}} </span> </div> </ng-template> <ng-template [ngIf]=\"customSubLabel\"> <div class=\"ux-a-label__sub-label\"> <ng-content select=\"uxLabelSubLabel\"></ng-content> </div> </ng-template> </div> <ux-badge *ngIf=\"badgeLabel\" typeClass=\"{{badgeTypeClass}}\" styleClass=\"ml-2\" [isSmall]=\"isSmall\" [isPill]=\"true\"> {{badgeLabel}} </ux-badge> <span *ngIf=\"infos\" class=\"ux-a-label__label-infos\"> {{infos}} </span> </div> ",
                        styles: [":host{-ms-flex:0 1 100%;flex:0 1 auto}ux-a-label{flex:0 1 100% !important}.ux-a-label{align-items:center;display:flex}.ux-a-label__label{color:#616161;font-size:1.14286rem;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label__label--clickable:hover{color:#004494;text-decoration:underline}.ux-a-label__custom-label{color:#616161;font-size:1.14286rem;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label__label-infos{margin-left:.66rem}.ux-a-label__sub-label{color:#757575;margin-top:.33rem}.ux-a-label--disabled .ux-a-label__icon,.ux-a-label--disabled .ux-a-label__label,.ux-a-label--disabled .ux-a-label__sub-label{color:#bdbdbd !important}.ux-a-label--large{padding:.66rem}.ux-a-label--small .ux-a-label__label{font-size:1rem}.ux-a-label--small .ux-a-label__sub-label{font-size:.85714rem}.ux-a-label--small .ux-a-icon{margin-right:0.325rem !important}.ux-a-label--has-no-sub-label .ux-a-label__label{font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label--t-white .ux-a-label__label,.ux-a-label--t-white .ux-a-label__sub-label{color:white} /*# sourceMappingURL=ux-a-label.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxLabelComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxLabelComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "labelStyleClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "isIconRounded": [{ type: core.Input },],
            "isIconSmall": [{ type: core.Input },],
            "isIconTiny": [{ type: core.Input },],
            "isIconLarge": [{ type: core.Input },],
            "hasMarker": [{ type: core.Input },],
            "markerTypeClass": [{ type: core.Input },],
            "isClickable": [{ type: core.Input },],
            "badgeLabel": [{ type: core.Input },],
            "badgeTypeClass": [{ type: core.Input },],
            "infos": [{ type: core.Input },],
            "themeClass": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "isBoldLabel": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "subLabelSizeLimit": [{ type: core.Input },],
            "isRenderHTML": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "ariaRole": [{ type: core.Input },],
            "ariaExpanded": [{ type: core.Input },],
            "ariaControls": [{ type: core.Input },],
            "labelClicked": [{ type: core.Output },],
            "customLabel": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxLabelContentTagDirective; }),] },],
            "customSubLabel": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxLabelSubLabelTagDirective; }),] },],
        };
        return UxLabelComponent;
    }());
    var UxLabelContentTagDirective = (function () {
        function UxLabelContentTagDirective() {
        }
        UxLabelContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLabelContent' },] },
        ];
        return UxLabelContentTagDirective;
    }());
    var UxLabelSubLabelTagDirective = (function () {
        function UxLabelSubLabelTagDirective() {
        }
        UxLabelSubLabelTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLabelSubLabel' },] },
        ];
        return UxLabelSubLabelTagDirective;
    }());
    var UxLabelComponentModule = (function () {
        function UxLabelComponentModule() {
        }
        UxLabelComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxBadgeComponentModule, UxMarkerComponentModule, UxIconComponentModule],
                        exports: [UxLabelComponent, UxLabelContentTagDirective, UxLabelSubLabelTagDirective],
                        declarations: [UxLabelComponent, UxLabelContentTagDirective, UxLabelSubLabelTagDirective]
                    },] },
        ];
        return UxLabelComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxItemConfig = (function () {
        function UxItemConfig() {
            this.hasBorder = true;
        }
        UxItemConfig.decorators = [
            { type: core.Injectable },
        ];
        return UxItemConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxItemComponent = (function () {
        function UxItemComponent(config) {
            this.isIconRounded = false;
            this.hasMarker = false;
            this.isTagRounded = false;
            this.isLarge = false;
            this.isSmall = false;
            this.hasBorder = true;
            this.isExpanded = true;
            this.isLeftPositioned = false;
            this.isDisabled = false;
            this.isActive = false;
            this.isHoverable = true;
            this.isScreenReaderClickable = false;
            this.listItemClick = new core.EventEmitter();
            this.isHovered = false;
            Object.assign(this, config);
        }
        /**
         * @return {?}
         */
        UxItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.item) {
                this.id = this.item.id;
                this.label = this.item.label;
                this.subLabel = this.item.subLabel;
                this.iconClass = this.item.iconClass;
                this.iconTypeClass = this.item.iconTypeClass;
                this.typeClass = this.item.typeClass;
                this.isDisabled = this.item.disabled;
            }
        };
        /**
         * @return {?}
         */
        UxItemComponent.prototype.onClick = /**
         * @return {?}
         */
        function () {
            this.listItemClick.next(this.item);
        };
        /**
         * @return {?}
         */
        UxItemComponent.prototype.onMouseenter = /**
         * @return {?}
         */
        function () {
            this.isHovered = true;
        };
        /**
         * @return {?}
         */
        UxItemComponent.prototype.onMouseleave = /**
         * @return {?}
         */
        function () {
            this.isHovered = false;
        };
        UxItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-item',
                        template: '<div></div>'
                    },] },
        ];
        /** @nocollapse */
        UxItemComponent.ctorParameters = function () { return [
            { type: UxItemConfig, },
        ]; };
        UxItemComponent.propDecorators = {
            "item": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "isIconRounded": [{ type: core.Input },],
            "hasMarker": [{ type: core.Input },],
            "markerTypeClass": [{ type: core.Input },],
            "tagTypeClass": [{ type: core.Input },],
            "tagLabel": [{ type: core.Input },],
            "tagCount": [{ type: core.Input },],
            "isTagRounded": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "hasBorder": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "isLeftPositioned": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "isHoverable": [{ type: core.Input },],
            "isScreenReaderClickable": [{ type: core.Input },],
            "listItemClick": [{ type: core.Output },],
        };
        return UxItemComponent;
    }());
    var UxItemComponentModule = (function () {
        function UxItemComponentModule() {
        }
        /**
         * @return {?}
         */
        UxItemComponentModule.forRoot = /**
         * @return {?}
         */
        function () { return { ngModule: UxItemComponentModule, providers: [UxItemConfig] }; };
        UxItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxTagComponentModule,
                            UxIconComponentModule,
                            UxMarkerComponentModule,
                            UxLabelComponentModule
                        ],
                        exports: [
                            UxItemComponent,
                            UxTagComponentModule,
                            UxIconComponentModule,
                            UxMarkerComponentModule,
                            UxLabelComponentModule
                        ],
                        declarations: [UxItemComponent]
                    },] },
        ];
        return UxItemComponentModule;
    }());

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var UxListItemConfig = (function (_super) {
        __extends$2(UxListItemConfig, _super);
        function UxListItemConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.hasBorder = true;
            return _this;
        }
        UxListItemConfig.decorators = [
            { type: core.Injectable },
        ];
        return UxListItemConfig;
    }(UxItemConfig));

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var UxListItemComponent = (function (_super) {
        __extends$3(UxListItemComponent, _super);
        function UxListItemComponent(config) {
            return _super.call(this, config) || this;
        }
        UxListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-list-item',
                        template: "<div class=\"ux-list-item-wrapper\" [class.ux-list-item-wrapper--hovered]=\"isHovered && !isExpanded\" [attr.role]=\"! isScreenReaderClickable ? 'presentation' : ''\" (click)=\"onClick()\" (mouseenter)=\"onMouseenter()\" (mouseleave)=\"onMouseleave()\"> <div *ngIf=\"isHovered && !isExpanded\" class=\"ux-list-item-hover-content\" [class.ux-list-item-hover-content--left-positioned]=\"isLeftPositioned\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" tabindex=\"-1\"></ux-a-label> </div> <div class=\"ux-list-item ux-list-item--{{typeClass}} {{styleClass}}\" [class.ux-list-item--small]=\"isSmall\" [class.ux-list-item--large]=\"isLarge\" [class.ux-list-item--hovered]=\"isHovered && !isExpanded\" [class.ux-list-item--not-hoverable]=\"!isHoverable\" [class.ux-list-item--bordered]=\"hasBorder\" [class.ux-list-item--collapsed]=\"!isExpanded\" [class.ux-list-item--active]=\"isActive\" [class.ux-list-item--seperator]=\"!label && !subLabel && !customContent\" [class.ux-list-item--disabled]=\"isDisabled\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxListItemContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isDisabled]=\"isDisabled\" tabindex=\"-1\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-list-item__right-content\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\" [isRounded]=\"isTagRounded\" tabindex=\"-1\"> </ux-a-tag> </div> </ng-template> </div> </div> "
                    },] },
        ];
        /** @nocollapse */
        UxListItemComponent.ctorParameters = function () { return [
            { type: UxListItemConfig, },
        ]; };
        UxListItemComponent.propDecorators = {
            "customContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxListtemContentTagDirective; }),] },],
            "customSubLabel": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxListItemSubLabelTagDirective; }),] },],
        };
        return UxListItemComponent;
    }(UxItemComponent));
    var UxListItemSubLabelTagDirective = (function () {
        function UxListItemSubLabelTagDirective() {
        }
        UxListItemSubLabelTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxListItemSubLabel' },] },
        ];
        return UxListItemSubLabelTagDirective;
    }());
    var UxListtemContentTagDirective = (function () {
        function UxListtemContentTagDirective() {
        }
        UxListtemContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxListItemContent' },] },
        ];
        return UxListtemContentTagDirective;
    }());
    var UxListItemComponentModule = (function () {
        function UxListItemComponentModule() {
        }
        /**
         * @return {?}
         */
        UxListItemComponentModule.forRoot = /**
         * @return {?}
         */
        function () { return { ngModule: UxItemComponentModule, providers: [UxListItemConfig] }; };
        UxListItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxItemComponentModule],
                        exports: [UxListItemComponent, UxListItemSubLabelTagDirective, UxListtemContentTagDirective],
                        declarations: [
                            UxListItemComponent,
                            UxListItemSubLabelTagDirective,
                            UxListtemContentTagDirective
                        ]
                    },] },
        ];
        return UxListItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDropdownButtonItemComponent = (function () {
        function UxDropdownButtonItemComponent(uxDropdownButtonComponent) {
            this.isDisabled = false;
            this.isActive = false;
            this.uxDropdownButtonComponent = uxDropdownButtonComponent;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        UxDropdownButtonItemComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.uxDropdownButtonComponent.navigateDropDownSelection(event);
        };
        /**
         * @return {?}
         */
        UxDropdownButtonItemComponent.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this.uxDropdownButtonComponent.closeOnBlur();
        };
        /**
         * @return {?}
         */
        UxDropdownButtonItemComponent.prototype.onClick = /**
         * @return {?}
         */
        function () {
            if (this.uxDropdownButtonComponent) {
                this.uxDropdownButtonComponent.closeOnBlur();
            }
        };
        UxDropdownButtonItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dropdown-button-item',
                        template: "\n    <ux-list-item id=\"{{id}}\"\n                  [isActive]=\"isActive\"\n                  (blur)=\"onBlur()\"\n                  (keydown)=\"onKeydown($event)\"\n                  iconClass=\"{{iconClass}}\"\n                  label=\"{{label}}\"\n                  [isDisabled]=\"isDisabled\"\n                  styleClass=\"ux-dropdown-button-item {{stateClass}}\"\n                  (click)=\"onClick()\">\n    </ux-list-item>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxDropdownButtonItemComponent.ctorParameters = function () { return [
            { type: UxDropdownButtonComponent, decorators: [{ type: core.Optional }, { type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxDropdownButtonComponent; }),] },] },
        ]; };
        UxDropdownButtonItemComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
        };
        return UxDropdownButtonItemComponent;
    }());
    var UxDropdownButtonItemComponentModule = (function () {
        function UxDropdownButtonItemComponentModule() {
        }
        UxDropdownButtonItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxListItemComponentModule],
                        exports: [UxDropdownButtonItemComponent],
                        declarations: [UxDropdownButtonItemComponent]
                    },] },
        ];
        return UxDropdownButtonItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ UX_DROPDOWNBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return UxDropdownButtonComponent; }),
        multi: true,
    };
    var UxDropdownButtonComponent = (function () {
        function UxDropdownButtonComponent(uxService, shadowDomRoot) {
            this.uxService = uxService;
            this.shadowDomRoot = shadowDomRoot;
            this.links = [];
            this.typeClass = 'secondary';
            this.isSplitButtonToggle = false;
            this.isDropDownRightAligned = false;
            this.isLinkToggle = false;
            this.isUpdateLabelFromSelectedItem = false;
            this.isOutline = false;
            this.isShowDropdownToggle = true;
            this.hasItems = false;
            this.isDisabled = false;
            this.width = '10rem';
            this.dropdownMaxHeight = '200px';
            this.isSmall = false;
            this.isLarge = false;
            this.linkSelected = new core.EventEmitter();
            this.isShown = true;
            this.dropDownIsOpen = false;
        }
        /**
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this.label && !this.iconClass && !this.isSplitButtonToggle) {
                this.iconClass = 'ux-icon ux-icon-bars';
            }
            if (this.isSmall) {
                this.btnSizeClass = 'btn-sm';
            }
            if (this.isLarge) {
                this.btnSizeClass = 'btn-lg';
            }
        };
        Object.defineProperty(UxDropdownButtonComponent.prototype, "toggleClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isLinkToggle) {
                    return 'ux-dropdown-button__toggle--link-toggle';
                }
                else {
                    if (this.label || this.isSplitButtonToggle) {
                        if (!this.isSplitButtonToggle) {
                            if (this.isOutline) {
                                return 'btn btn-outline-' + this.typeClass;
                            }
                            else {
                                return 'btn btn-' + this.typeClass;
                            }
                        }
                        else {
                            if (this.isOutline) {
                                return 'btn btn-outline-' + this.typeClass + ' ux-dropdown-button__toggle--split-toggle-outline';
                            }
                            else {
                                return 'btn btn-' + this.typeClass + ' ux-dropdown-button__toggle--split-toggle';
                            }
                        }
                    }
                    else if (this.iconClass && !this.label && !this.isSplitButtonToggle) {
                        return 'ux-dropdown-button__toggle--icon-toggle';
                    }
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} evt
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.toggleOutside = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (!this.shadowDomRoot.nativeElement.contains(evt.target)) {
                this.dropDownIsOpen = false;
            }
        };
        /**
         * @param {?} querySelector
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.shadowDomQuery = /**
         * @param {?} querySelector
         * @return {?}
         */
        function (querySelector) {
            return this.shadowDomRoot.nativeElement.querySelector(querySelector);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.toggleDropDownKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode === 13) {
                this.toggleDropDown(event);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.toggleDropDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.dropDownIsOpen = !this.dropDownIsOpen;
            var /** @type {?} */ selectedItem;
            if (this.dropDownIsOpen) {
                if (this.activeLink) {
                    selectedItem = this.shadowDomQuery('.dropdown-item[data-link-id=' + this.activeLink.id + ']');
                }
                else {
                    selectedItem = this.shadowDomQuery('.dropdown-item');
                }
                if (selectedItem) {
                    setTimeout(function () {
                        if (selectedItem != null) {
                            selectedItem.focus();
                        }
                    }, 0);
                }
            }
        };
        /**
         * @param {?} event
         * @param {?} link
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.selectDropdownItemKeydown = /**
         * @param {?} event
         * @param {?} link
         * @return {?}
         */
        function (event, link) {
            if (event.keyCode === 13) {
                this.selectDropdownItem(event, link);
            }
        };
        /**
         * @param {?} event
         * @param {?} link
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.selectDropdownItem = /**
         * @param {?} event
         * @param {?} link
         * @return {?}
         */
        function (event, link) {
            this.uxService.consumeEvent(event);
            if (!link.disabled) {
                this.linkSelected.emit(link);
                if (link && link.command) {
                    link.command();
                }
                if (this.isUpdateLabelFromSelectedItem && link) {
                    this.label = link.label;
                }
                if (this.isUpdateLabelFromSelectedItem) {
                    this.links.forEach(function (lnk) {
                        lnk.active = false;
                    });
                    link.active = true;
                }
            }
            this.dropDownIsOpen = false;
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.closeDropDownOnEscape = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 27) {
                // 27 = escape
                this.dropDownIsOpen = false;
            }
        };
        /**
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.closeOnBlur = /**
         * @return {?}
         */
        function () {
            var _this = this;
            setTimeout(function () {
                if (_this.shadowDomQuery('.dropdown-item:focus') == null) {
                    _this.dropDownIsOpen = false;
                }
            }, 0);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.navigateDropDownSelection = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ keyCode = event.keyCode;
            /*
                     38 = arrow up
                     40 = arrow down
                     */
            var /** @type {?} */ focusedItem = this.shadowDomQuery('.dropdown-item:focus');
            if (focusedItem != null) {
                var /** @type {?} */ next = void 0;
                if (keyCode === 40) {
                    // arrow down:
                    next = (/** @type {?} */ (focusedItem)).nextElementSibling;
                    if (!next) {
                        next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).firstElementChild;
                    }
                }
                else if (keyCode === 38) {
                    // arrow up:
                    next = (/** @type {?} */ (focusedItem)).previousElementSibling;
                    if (!next) {
                        next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).lastElementChild;
                    }
                }
                if (next) {
                    (/** @type {?} */ (next)).focus();
                    this.uxService.consumeEvent(event);
                }
            }
        };
        /**
         * @param {?} links
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.writeValue = /**
         * @param {?} links
         * @return {?}
         */
        function (links) {
            this.links = links;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        UxDropdownButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.isDisabled = isDisabled;
        };
        UxDropdownButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dropdown-button',
                        template: "\n    <div class=\"ux-dropdown-button {{styleClass}} {{btnSizeClass}}\" [class.ux-o-disabled]=\"isDisabled\">\n        <div class=\"btn-group\">\n            <a class=\"ux-dropdown-button__toggle {{btnSizeClass}} {{toggleClass}}\" tabindex=\"0\"\n                [class.dropdown-toggle]=\"isShowDropdownToggle\"\n                aria-haspopup=\"true\" data-toggle=\"dropdown\"\n                [attr.aria-expanded]=\"!dropDownIsOpen\"\n                (click)=\"toggleDropDown($event)\"\n                (keydown)=\"toggleDropDownKeyDown($event)\">\n                <span *ngIf=\"iconClass\" class=\"ux-dropdown-button__toggle-icon {{iconClass}}\"></span>\n                <span *ngIf=\"label\" class=\"ux-dropdown-button__toggle-label ux-button__content\"\n                    [class.ux-dropdown-button__toggle-label--with-icon]=\"iconClass\">\n                    {{label}}\n                </span>\n            </a>\n            <div class=\"ux-dropdown-button__menu dropdown-menu\"\n                [style.min-width]=\"width\"\n                [style.max-height]=\"dropdownMaxHeight\"\n                [style.display]=\"dropDownIsOpen ? 'block' : 'none'\"\n                [class.ux-dropdown-button__menu--right-aligned]=\"isDropDownRightAligned\"\n                [class.ux-dropdown-button__menu--link-toggle]=\"isLinkToggle\"\n                (keydown)=\"closeDropDownOnEscape($event.keyCode)\"\n                (click)=\"closeOnBlur()\" *ngIf=\"(items && items.length > 0) || (links && links.length > 0) || hasItems\">\n\n                <ng-template [ngIf]=\"items.length === 0 && !hasItems\">\n                    <ux-dropdown-button-item *ngFor=\"let link of links\"\n                        id=\"{{link.id}}\"\n                        label=\"{{link.label}}\"\n                        iconClass=\"{{link.iconClass}}\"\n                        [isDisabled]=\"link.disabled\"\n                        [isActive]=\"link.active\"\n                        (click)=\"selectDropdownItem($event, link)\"\n                        (keydown)=\"selectDropdownItemKeydown($event, link)\"\n                        (click)=\"closeOnBlur()\">\n                    </ux-dropdown-button-item>\n                </ng-template>\n\n                <ng-template [ngIf]=\"items.length !== 0 || hasItems\">\n                    <ng-content></ng-content>\n                </ng-template>\n\n            </div>\n        </div>\n    </div>\n    ",
                        providers: [UX_DROPDOWNBUTTON_VALUE_ACCESSOR],
                    },] },
        ];
        /** @nocollapse */
        UxDropdownButtonComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: core.ElementRef, },
        ]; };
        UxDropdownButtonComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "links": [{ type: core.Input },],
            "activeLink": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "isSplitButtonToggle": [{ type: core.Input },],
            "isDropDownRightAligned": [{ type: core.Input },],
            "isLinkToggle": [{ type: core.Input },],
            "isUpdateLabelFromSelectedItem": [{ type: core.Input },],
            "isOutline": [{ type: core.Input },],
            "isShowDropdownToggle": [{ type: core.Input },],
            "hasItems": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "dropdownMaxHeight": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "linkSelected": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxDropdownButtonItemComponent; }),] },],
            "toggleOutside": [{ type: core.HostListener, args: ['body:click', ['$event'],] },],
        };
        return UxDropdownButtonComponent;
    }());
    var UxDropdownButtonComponentModule = (function () {
        function UxDropdownButtonComponentModule() {
        }
        UxDropdownButtonComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxDropdownButtonItemComponentModule],
                        exports: [UxDropdownButtonComponent],
                        declarations: [UxDropdownButtonComponent]
                    },] },
        ];
        return UxDropdownButtonComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutHeaderComponent = (function () {
        function UxLayoutHeaderComponent(translateService, cd) {
            var _this = this;
            this.translateService = translateService;
            this.cd = cd;
            this.appFullName = '';
            this.appShortName = '';
            this.appSubtitle = '';
            this.envLabel = '';
            this.languageCodes = '';
            this.isCustomRightContent = false;
            this.isCustomTitleContent = false;
            this.isShowExtraButtonAction = false;
            this.isShowLanguageSelector = true;
            this.homeUrl = '/screen/home';
            this.isHideLogo = false;
            this.isHomeUrlActive = true;
            this.isErrorState = false;
            this.languageChanged = new core.EventEmitter();
            this.userProfileLinkSelected = new core.EventEmitter();
            translateService.onLangChange.subscribe(function () { return _this.cd.detectChanges(); });
        }
        Object.defineProperty(UxLayoutHeaderComponent.prototype, "hasSubtitle", {
            get: /**
             * @return {?}
             */
            function () {
                return this.appSubtitle !== '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxLayoutHeaderComponent.prototype, "activeLanguageCode", {
            get: /**
             * @return {?}
             */
            function () {
                return this.selectedLanguage && this.selectedLanguage.code || this.translateService.currentLang;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxLayoutHeaderComponent.prototype, "appShortNameGen", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.appShortName === '') {
                    return this.appFullName;
                }
                else {
                    return this.appShortName;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} language
         * @return {?}
         */
        UxLayoutHeaderComponent.prototype.onLanguageChanged = /**
         * @param {?} language
         * @return {?}
         */
        function (language) {
            this.languageChanged.emit(language);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxLayoutHeaderComponent.prototype.onUserProfileLinkSelected = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.userProfileLinkSelected.emit(uxLink);
        };
        UxLayoutHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-header',
                        template: "<div id=\"app-header\"> <ng-template [ngIf]=\"isHomeUrlActive\"> <a [routerLink]=\"homeUrl\" *ngIf=\"!isHideLogo\"> <div class=\"logo logo--{{activeLanguageCode}}\"> <div *ngIf=\"envLabel\" class=\"env\">{{envLabel}}</div> </div> </a> </ng-template> <ng-template [ngIf]=\"!isHomeUrlActive\"> <a href=\"javascript:void(0)\" *ngIf=\"!isHideLogo\"> <div class=\"logo logo--{{activeLanguageCode}}\"> <div *ngIf=\"envLabel\" class=\"env\">{{envLabel}}</div> </div> </a> </ng-template> <div *ngIf=\"isCustomTitleContent\" class=\"title\"> <ng-content select=\"uxLayoutHeaderTitleContent\"></ng-content> </div> <div *ngIf=\"!isCustomTitleContent\" class=\"title\"> <h1 [class.with-subtitle]=\"hasSubtitle\" [class.no-margin-left]=\"isHideLogo\" class=\"full\" [ngClass]=\"appFullNameStyleClass\">{{appFullName}}</h1> <h1 class=\"short\">{{appShortNameGen}}</h1> <h2 *ngIf=\"appSubtitle\"> {{appSubtitle}} </h2> </div> <div *ngIf=\"!isCustomRightContent && !isErrorState\" class=\"right-links\"> <div *ngIf=\"isShowLanguageSelector\" class=\"links\"> <ul> <li> <ux-language-selector *ngIf=\"languageCodes && !additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [languageCodes]=\"languageCodes\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes && !additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes && additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [additionalLanguages]=\"additionalLanguages\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"languageCodes && additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [languageCodes]=\"languageCodes\" [additionalLanguages]=\"additionalLanguages\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> </li> </ul> </div> <div class=\"user-infos\" *ngIf=\"userInfos\"> <ng-template [ngIf]=\"userProfileLinks\"> <ux-dropdown-button label=\"{{userInfos}}\" [iconClass]=\"userInfosIcon\" [isLinkToggle]=\"true\" [isDropDownRightAligned]=\"true\" [links]=\"userProfileLinks\" (linkSelected)=\"onUserProfileLinkSelected($event)\"> </ux-dropdown-button> </ng-template> <ng-template [ngIf]=\"!userProfileLinks\"> {{userInfos}} </ng-template> </div> </div> <div *ngIf=\"isCustomRightContent && !isErrorState\" class=\"right-content\"> <ng-content select=\"uxLayoutHeaderRightContent\"></ng-content> </div> </div> ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutHeaderComponent.ctorParameters = function () { return [
            { type: core$1.TranslateService, },
            { type: core.ChangeDetectorRef, },
        ]; };
        UxLayoutHeaderComponent.propDecorators = {
            "appFullName": [{ type: core.Input },],
            "appFullNameStyleClass": [{ type: core.Input },],
            "appShortName": [{ type: core.Input },],
            "appSubtitle": [{ type: core.Input },],
            "envLabel": [{ type: core.Input },],
            "userInfos": [{ type: core.Input },],
            "userInfosIcon": [{ type: core.Input },],
            "languageCodes": [{ type: core.Input },],
            "additionalLanguages": [{ type: core.Input },],
            "isCustomRightContent": [{ type: core.Input },],
            "isCustomTitleContent": [{ type: core.Input },],
            "isShowExtraButtonAction": [{ type: core.Input },],
            "isShowLanguageSelector": [{ type: core.Input },],
            "homeUrl": [{ type: core.Input },],
            "isHideLogo": [{ type: core.Input },],
            "userProfileLinks": [{ type: core.Input },],
            "selectedLanguage": [{ type: core.Input },],
            "isHomeUrlActive": [{ type: core.Input },],
            "isErrorState": [{ type: core.Input },],
            "languageChanged": [{ type: core.Output },],
            "userProfileLinkSelected": [{ type: core.Output },],
        };
        return UxLayoutHeaderComponent;
    }());
    var UxLayoutHeaderRightContentTagDirective = (function () {
        function UxLayoutHeaderRightContentTagDirective() {
        }
        UxLayoutHeaderRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderRightContent' },] },
        ];
        return UxLayoutHeaderRightContentTagDirective;
    }());
    var UxLayoutHeaderUserProfileLinksTagDirective = (function () {
        function UxLayoutHeaderUserProfileLinksTagDirective() {
        }
        UxLayoutHeaderUserProfileLinksTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderUserProfileLinks' },] },
        ];
        return UxLayoutHeaderUserProfileLinksTagDirective;
    }());
    var UxLayoutHeaderTitleContentTagDirective = (function () {
        function UxLayoutHeaderTitleContentTagDirective() {
        }
        UxLayoutHeaderTitleContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderTitleContent' },] },
        ];
        return UxLayoutHeaderTitleContentTagDirective;
    }());
    var UxLayoutHeaderComponentModule = (function () {
        function UxLayoutHeaderComponentModule() {
        }
        UxLayoutHeaderComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule, UxLanguageSelectorComponentModule,
                            UxDropdownButtonComponentModule, UxDropdownButtonItemComponentModule],
                        exports: [UxLayoutHeaderComponent, UxLayoutHeaderRightContentTagDirective, UxLayoutHeaderTitleContentTagDirective,
                            UxLayoutHeaderUserProfileLinksTagDirective],
                        declarations: [UxLayoutHeaderComponent, UxLayoutHeaderRightContentTagDirective, UxLayoutHeaderTitleContentTagDirective,
                            UxLayoutHeaderUserProfileLinksTagDirective]
                    },] },
        ];
        return UxLayoutHeaderComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutFooterComponent = (function () {
        function UxLayoutFooterComponent() {
            this.isStyleInverse = false;
            this.isCompact = false;
        }
        UxLayoutFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-footer',
                        template: "\n        <ng-template [ngIf]=\"isCompact\">\n            <div id=\"app-footer\" class=\"compact\" [class.inverse]=\"isStyleInverse\">\n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!isCompact\">\n            <div id=\"app-footer\" [class.inverse]=\"isStyleInverse\">\n                <div class=\"links\">\n                    <ng-content select=\"uxLayoutFooterLinks\"></ng-content>\n                </div>\n                <div class=\"app-infos\">\n                    <ng-content select=\"uxLayoutFooterAppInfos\"></ng-content>\n                </div>\n            </div>\n        </ng-template>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutFooterComponent.propDecorators = {
            "isStyleInverse": [{ type: core.Input },],
            "isCompact": [{ type: core.Input },],
        };
        return UxLayoutFooterComponent;
    }());
    var UxLayoutFooterAppInfosTagDirective = (function () {
        function UxLayoutFooterAppInfosTagDirective() {
        }
        UxLayoutFooterAppInfosTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutFooterAppInfos' },] },
        ];
        return UxLayoutFooterAppInfosTagDirective;
    }());
    var UxLayoutFooterLinksTagDirective = (function () {
        function UxLayoutFooterLinksTagDirective() {
        }
        UxLayoutFooterLinksTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutFooterLinks' },] },
        ];
        return UxLayoutFooterLinksTagDirective;
    }());
    var UxLayoutFooterComponentModule = (function () {
        function UxLayoutFooterComponentModule() {
        }
        UxLayoutFooterComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            UxLayoutFooterComponent, UxLayoutFooterAppInfosTagDirective,
                            UxLayoutFooterLinksTagDirective
                        ],
                        declarations: [
                            UxLayoutFooterComponent, UxLayoutFooterAppInfosTagDirective,
                            UxLayoutFooterLinksTagDirective
                        ]
                    },] },
        ];
        return UxLayoutFooterComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarComponent = (function () {
        function UxLayoutNavBarComponent() {
            this.isMuted = false;
        }
        UxLayoutNavBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar',
                        template: "\n        <div id=\"nav-bar\" class=\"ux-layout-nav-bar {{styleClass}}\"\n             [class.ux-layout-nav-bar--muted]=\"isMuted\">\n            <ng-content select=\"uxLayoutNavBarLeftActionsContent\"></ng-content>\n            <ng-content select=\"uxLayoutNavBarElementsContent\"></ng-content>\n            <ng-content></ng-content>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarComponent.propDecorators = {
            "isMuted": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
        };
        return UxLayoutNavBarComponent;
    }());
    var UxLayoutNavBarElementsContentTagDirective = (function () {
        function UxLayoutNavBarElementsContentTagDirective() {
        }
        UxLayoutNavBarElementsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutNavBarElementsContent' },] },
        ];
        return UxLayoutNavBarElementsContentTagDirective;
    }());
    var UxLayoutNavBarLeftActionsContentTagDirective = (function () {
        function UxLayoutNavBarLeftActionsContentTagDirective() {
        }
        UxLayoutNavBarLeftActionsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutNavBarLeftActionsContent' },] },
        ];
        return UxLayoutNavBarLeftActionsContentTagDirective;
    }());
    var UxLayoutNavBarComponentModule = (function () {
        function UxLayoutNavBarComponentModule() {
        }
        UxLayoutNavBarComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutNavBarComponent, UxLayoutNavBarElementsContentTagDirective, UxLayoutNavBarLeftActionsContentTagDirective],
                        declarations: [UxLayoutNavBarComponent, UxLayoutNavBarElementsContentTagDirective, UxLayoutNavBarLeftActionsContentTagDirective]
                    },] },
        ];
        return UxLayoutNavBarComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutSidebarItemComponent = (function () {
        function UxLayoutSidebarItemComponent(uxService, router$$1, activatedRoute, asService) {
            this.uxService = uxService;
            this.router = router$$1;
            this.activatedRoute = activatedRoute;
            this.asService = asService;
            this.isLarge = false;
            this.isActive = false;
            this.isExpanded = false;
            this.isSeparator = false;
            this.isHome = false;
            this.isItemTogglingSubitems = true;
            this.isInnerSidebarItem = false;
            this.clicked = new core.EventEmitter();
            this.toggled = new core.EventEmitter();
            this.crlf = String.fromCharCode(10, 13);
        }
        /**
         * @return {?}
         */
        UxLayoutSidebarItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.isInnerSidebarItem && !this.iconClass) {
                this.iconClass = 'ux-icon ux-icon-circle-o ux-u-font-size-h7';
            }
        };
        Object.defineProperty(UxLayoutSidebarItemComponent.prototype, "hasSub", {
            get: /**
             * @return {?}
             */
            function () {
                //  to prevent self inclusion : https://github.com/angular/angular/issues/10098#issuecomment-235157642
                if (this.subItems.length > 1) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxLayoutSidebarItemComponent.prototype, "isCurrentRouteActive", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.url) {
                    if (this.router.isActive(this.router.createUrlTree([this.url], { relativeTo: this.activatedRoute }), this.isHome)) {
                        return true;
                    }
                }
                else if (this.id && this.isActive) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        // as routerLink is defined on the main <div> we need to trap the ENTER key for keyboard navigation
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutSidebarItemComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.keyCode === 13) {
                this.navigateTo();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutSidebarItemComponent.prototype.toggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.isExpanded = !this.isExpanded;
            this.toggled.next(this);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutSidebarItemComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.clicked.emit(this.id);
            if (this.url) {
                this.navigateTo();
            }
            if (this.urlExternal) {
                window.open(this.urlExternal, '_blank');
            }
            if (this.hasSub && this.isItemTogglingSubitems) {
                this.toggle(event);
            }
            if (typeof (this.command) === 'function') {
                this.command();
            }
            event.preventDefault();
            event.stopPropagation();
        };
        /**
         * @return {?}
         */
        UxLayoutSidebarItemComponent.prototype.navigateTo = /**
         * @return {?}
         */
        function () {
            if (this.url) {
                this.router.navigate([this.url], { relativeTo: this.activatedRoute });
                window.scrollTo(0, 0);
            }
        };
        UxLayoutSidebarItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-sidebar-item',
                        template: "\n    <div *ngIf=\"!isSeparator\" class=\"sidebar-item\"\n                              (keydown)=\"onKeyDown($event)\"\n                              (click)=\"onClick($event)\"\n                              [pTooltip]=\"!(asService.state$ | async).isSidebarOpen &&\n                                          !(asService.breakpoints$ | async).isMobile &&\n                                          !isExpanded ? subLabel ? label + crlf + subLabel : label : ''\">\n\n        <a [routerLink]=\"[url]\" *ngIf=\"url\">\n            <div class=\"sidebar-item__header\" (click)=\"onClick($event)\"\n                                            [class.sidebar-item__header--title]=\"!(url || id || command || urlExternal)\"\n                                            [class.sidebar-item__header--large]=\"isLarge\"\n                                            [class.sidebar-item__header--active]=\"isCurrentRouteActive\"\n                                            [class.sidebar-item__header--is-toggling-subitems]=\"isItemTogglingSubitems\"\n                                            tabindex=\"0\">\n                <div *ngIf=\"iconClass\" class=\"sidebar-item__header-icon-wrapper\">\n                    <span class=\"sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw\"></span>\n                </div>\n                <div class=\"sidebar-item__header-label-wrapper\">\n                    <div class=\"sidebar-item__header-label-wrapper-label\">\n                        {{label}}\n                    </div>\n                    <div *ngIf=\"subLabel\" class=\"sidebar-item__header-label-wrapper-sub-label\">\n                        {{subLabel}}\n                    </div>\n                </div>\n                <span *ngIf=\"hasSub\" class=\"sidebar-item__header-expand-toggle\" (click)=\"toggle($event)\">\n                    <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span>\n                </span>\n            </div>\n        </a>\n\n        <a href=\"{{ urlExternal }}\" *ngIf=\"urlExternal\">\n            <div class=\"sidebar-item__header\" (click)=\"onClick($event)\"\n                                            [class.sidebar-item__header--title]=\"!(url || id || command || urlExternal)\"\n                                            [class.sidebar-item__header--large]=\"isLarge\"\n                                            [class.sidebar-item__header--active]=\"isCurrentRouteActive\"\n                                            [class.sidebar-item__header--is-toggling-subitems]=\"isItemTogglingSubitems\"\n                                            tabindex=\"0\">\n                <div *ngIf=\"iconClass\" class=\"sidebar-item__header-icon-wrapper\">\n                    <span class=\"sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw\"></span>\n                </div>\n                <div class=\"sidebar-item__header-label-wrapper\">\n                    <div class=\"sidebar-item__header-label-wrapper-label\">\n                        {{label}}\n                    </div>\n                    <div *ngIf=\"subLabel\" class=\"sidebar-item__header-label-wrapper-sub-label\">\n                        {{subLabel}}\n                    </div>\n                </div>\n                <span *ngIf=\"hasSub\" class=\"sidebar-item__header-expand-toggle\" (click)=\"toggle($event)\">\n                    <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span>\n                </span>\n            </div>\n        </a>\n\n        <div class=\"sidebar-item__header\" *ngIf=\"!url && !urlExternal\" (click)=\"onClick($event)\"\n                                        [class.sidebar-item__header--title]=\"!(url || id || command || urlExternal)\"\n                                        [class.sidebar-item__header--large]=\"isLarge\"\n                                        [class.sidebar-item__header--active]=\"isCurrentRouteActive\"\n                                        [class.sidebar-item__header--is-toggling-subitems]=\"isItemTogglingSubitems\"\n                                        tabindex=\"0\">\n            <div *ngIf=\"iconClass\" class=\"sidebar-item__header-icon-wrapper\">\n                <span class=\"sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw\"></span>\n            </div>\n            <div class=\"sidebar-item__header-label-wrapper\">\n                <div class=\"sidebar-item__header-label-wrapper-label\">\n                    {{label}}\n                </div>\n                <div *ngIf=\"subLabel\" class=\"sidebar-item__header-label-wrapper-sub-label\">\n                    {{subLabel}}\n                </div>\n            </div>\n            <span *ngIf=\"hasSub\" class=\"sidebar-item__header-expand-toggle\" (click)=\"toggle($event)\">\n                <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span>\n            </span>\n        </div>\n\n        <ng-template [ngIf]=\"isExpanded\">\n            <div class=\"sidebar-item__sub\">\n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    </div>\n    <div *ngIf=\"isSeparator\" class=\"sidebar-item\">\n        <div class=\"sidebar-item-separator\"></div>\n    </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutSidebarItemComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: router.Router, },
            { type: router.ActivatedRoute, },
            { type: UxAppShellService, },
        ]; };
        UxLayoutSidebarItemComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "urlExternal": [{ type: core.Input },],
            "command": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "isSeparator": [{ type: core.Input },],
            "isHome": [{ type: core.Input },],
            "isItemTogglingSubitems": [{ type: core.Input },],
            "isInnerSidebarItem": [{ type: core.Input },],
            "clicked": [{ type: core.Output },],
            "toggled": [{ type: core.Output },],
            "subItems": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxLayoutSidebarItemComponent; }),] },],
        };
        return UxLayoutSidebarItemComponent;
    }());
    var UxLayoutSidebarItemComponentModule = (function () {
        function UxLayoutSidebarItemComponentModule() {
        }
        UxLayoutSidebarItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule, tooltip.TooltipModule],
                        exports: [UxLayoutSidebarItemComponent],
                        declarations: [UxLayoutSidebarItemComponent]
                    },] },
        ];
        return UxLayoutSidebarItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutSidebarItemsComponent = (function () {
        function UxLayoutSidebarItemsComponent(uxService) {
            this.uxService = uxService;
            this.links = [];
            this.isLargeItems = false;
            this.isInnerNavigationSidebar = false;
            this.isInnerSidebar = false;
            this.toggled = new core.EventEmitter();
            this.clicked = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxLayoutSidebarItemsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.sidebarItems && this.sidebarItems.length > 0) {
                this.sidebarItems.forEach(function (item) {
                    item.isLarge = _this.isLargeItems;
                });
            }
        };
        Object.defineProperty(UxLayoutSidebarItemsComponent.prototype, "hasLinks", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.links) {
                    return this.links.length !== 0;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @return {?}
         */
        UxLayoutSidebarItemsComponent.prototype.onSidebarItemToggle = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.toggled.emit(item);
        };
        /**
         * @param {?} id
         * @return {?}
         */
        UxLayoutSidebarItemsComponent.prototype.onClick = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            this.clicked.emit(id);
        };
        UxLayoutSidebarItemsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-sidebar-items',
                        template: "\n        <div class=\"sidebar-items\"\n             [class.sidebar-items--inner-navigation-sidebar]=\"isInnerNavigationSidebar\">\n\n            <ng-template [ngIf]=\"!hasLinks\">\n                <ng-content></ng-content>\n            </ng-template>\n\n            <ng-template [ngIf]=\"hasLinks\">\n                <ux-layout-sidebar-item *ngFor=\"let link of links\"\n                                        id=\"{{link.id}}\"\n                                        label=\"{{link.label}}\"\n                                        subLabel=\"{{link.subLabel}}\"\n                                        url=\"{{link.url}}\"\n                                        urlExternal=\"{{link.urlExternal}}\"\n                                        [hidden]=\"!link.visible\"\n                                        [command]=\"link.command\"\n                                        [isActive]=\"link.active\"\n                                        [isLarge]=\"isLargeItems\"\n                                        iconClass=\"{{link.iconClass}}\"\n                                        [isHome]=\"link.isHome\"\n                                        [isSeparator]=\"link.isSeparator\"\n                                        [isExpanded]=\"link.expanded\"\n                                        (toggled)=\"onSidebarItemToggle($event)\"\n                                        (clicked)=\"onClick($event)\"\n                                        [isInnerSidebarItem]=\"isInnerSidebar\">\n                    <ux-layout-sidebar-item *ngFor=\"let childLink of link.children\"\n                                            id=\"{{childLink.id}}\"\n                                            label=\"{{childLink.label}}\"\n                                            subLabel=\"{{childLink.subLabel}}\"\n                                            url=\"{{childLink.url}}\"\n                                            urlExternal=\"{{childLink.urlExternal}}\"\n                                            [hidden]=\"!childLink.visible\"\n                                            [command]=\"childLink.command\"\n                                            [isActive]=\"childLink.active\"\n                                            [isLarge]=\"isLargeItems\"\n                                            iconClass=\"{{childLink.iconClass}}\"\n                                            [isSeparator]=\"childLink.isSeparator\"\n                                            [isExpanded]=\"childLink.expanded\"\n                                            (toggled)=\"onSidebarItemToggle($event)\"\n                                            (clicked)=\"onClick($event)\"\n                                            [isInnerSidebarItem]=\"isInnerSidebar\">\n                        <ux-layout-sidebar-item *ngFor=\"let childLinkSub of childLink.children\"\n                                                id=\"{{childLinkSub.id}}\"\n                                                label=\"{{childLinkSub.label}}\"\n                                                subLabel=\"{{childLinkSub.subLabel}}\"\n                                                url=\"{{childLinkSub.url}}\"\n                                                urlExternal=\"{{childLinkSub.urlExternal}}\"\n                                                [hidden]=\"!childLinkSub.visible\"\n                                                [command]=\"childLinkSub.command\"\n                                                [isActive]=\"childLinkSub.active\"\n                                                [isLarge]=\"isLargeItems\"\n                                                iconClass=\"{{childLinkSub.iconClass}}\"\n                                                [isSeparator]=\"childLinkSub.isSeparator\"\n                                                [isExpanded]=\"childLinkSub.expanded\"\n                                                (toggled)=\"onSidebarItemToggle($event)\"\n                                                (clicked)=\"onClick($event)\"\n                                                [isInnerSidebarItem]=\"isInnerSidebar\">\n                        </ux-layout-sidebar-item>\n                    </ux-layout-sidebar-item>\n                </ux-layout-sidebar-item>\n            </ng-template>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutSidebarItemsComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxLayoutSidebarItemsComponent.propDecorators = {
            "links": [{ type: core.Input },],
            "isLargeItems": [{ type: core.Input },],
            "isInnerNavigationSidebar": [{ type: core.Input },],
            "isInnerSidebar": [{ type: core.Input },],
            "sidebarItems": [{ type: core.ContentChildren, args: [UxLayoutSidebarItemComponent,] },],
            "toggled": [{ type: core.Output },],
            "clicked": [{ type: core.Output },],
        };
        return UxLayoutSidebarItemsComponent;
    }());
    var UxLayoutSidebarItemsComponentModule = (function () {
        function UxLayoutSidebarItemsComponentModule() {
        }
        UxLayoutSidebarItemsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, UxLayoutSidebarItemComponentModule
                        ],
                        exports: [
                            UxLayoutSidebarItemsComponent,
                        ],
                        declarations: [
                            UxLayoutSidebarItemsComponent,
                        ]
                    },] },
        ];
        return UxLayoutSidebarItemsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutOverlayPanelComponent = (function () {
        function UxLayoutOverlayPanelComponent() {
            this.isActive = false;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutOverlayPanelComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isActive = !this.isActive;
        };
        UxLayoutOverlayPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-overlay-panel',
                        template: "\n        <div class=\"overlay-panel\" [class.active]=\"isActive\" (click)=\"onClick($event)\">\n            <ng-content></ng-content>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutOverlayPanelComponent.propDecorators = {
            "isActive": [{ type: core.Input },],
        };
        return UxLayoutOverlayPanelComponent;
    }());
    var UxLayoutOverlayPanelComponentModule = (function () {
        function UxLayoutOverlayPanelComponentModule() {
        }
        UxLayoutOverlayPanelComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            UxLayoutOverlayPanelComponent
                        ],
                        declarations: [
                            UxLayoutOverlayPanelComponent
                        ]
                    },] },
        ];
        return UxLayoutOverlayPanelComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarActionItemComponent = (function () {
        function UxLayoutNavBarActionItemComponent(uxService, asService) {
            this.uxService = uxService;
            this.asService = asService;
            this.isToggleContent = true;
            this.isOverlayPanel = false;
            this.isOverlayPanelCustomContent = false;
            this.isOverlayPanelBg = false;
            this.links = [];
            this.isShowHome = true;
            this.homeUrl = '/screen/home';
            this.isIconLarge = false;
            this.itemClass = '';
            this.contentClass = '';
            this.tagCount = 0;
            this.isShowTagAsBullet = false;
            this.isHiddenMobile = false;
            this.isMobileOnly = false;
            this.isHiddenDesktop = false;
            this.isUseSidebarTemplateAsLinks = false;
            this.isActive = false;
            this.isContentFixedHeight = false;
            this.isShowLanguageSelector = true;
            this.isShowBadge = false;
            this.hideBagdeOnClick = false;
            this.languageChanged = new core.EventEmitter();
            this.clicked = new core.EventEmitter();
            this.toggled = new core.EventEmitter();
            this.userProfileLinkSelected = new core.EventEmitter();
            this.genIconClass = '';
        }
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.unToggleAll = /**
         * @return {?}
         */
        function () {
            this.isActive = false;
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.genIconClass = this.iconClass;
            if (this.isIconLarge) {
                this.genIconClass += ' ux-a-icon--large';
            }
        };
        /**
         * @param {?} language
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.onLanguageChanged = /**
         * @param {?} language
         * @return {?}
         */
        function (language) {
            this.languageChanged.emit(language);
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.onUserProfileLinkSelected = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            this.userProfileLinkSelected.next(link);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.toggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isToggleContent) {
                this.isActive = !this.isActive;
                event.stopImmediatePropagation();
                event.preventDefault();
                if (this.isActive) {
                    this.toggled.emit(this);
                }
            }
            else {
                this.clicked.emit(this);
            }
            if (this.hideBagdeOnClick) {
                this.isShowBadge = false;
                this.clicked.emit(this);
            }
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.showBadge = /**
         * @return {?}
         */
        function () {
            this.isShowBadge = true;
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.hideBadge = /**
         * @return {?}
         */
        function () {
            this.isShowBadge = false;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopImmediatePropagation();
            event.preventDefault();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.onSidebarItemClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isActive = !this.isActive;
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemComponent.prototype.getResponsiveClasses = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ classes = '';
            if (this.isHiddenMobile) {
                classes = 'd-sm-none d-md-block';
            }
            if (this.isMobileOnly) {
                classes = 'd-none d-sm-block d-md-none';
            }
            if (this.isHiddenDesktop) {
                classes = 'd-lg-none';
            }
            return classes;
        };
        UxLayoutNavBarActionItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-action-item',
                        template: "\n        <div class=\"ux-layout-nav-bar__action-item {{itemClass}} {{getResponsiveClasses()}}\" (click)=\"toggle($event)\"\n            [class.selected]=\"isActive\"\n            [class.not-hoverable]=\"customItemContent\">\n            <ng-template [ngIf]=\"customItemContent\">\n                <ng-content select=\"uxLayoutNavBarItemContent\"></ng-content>\n            </ng-template>\n            <ng-template [ngIf]=\"!customItemContent\">\n                <ux-a-icon styleClass=\"ux-layout-nav-bar__action-item-icon\"\n                           iconClass=\"{{genIconClass}}\"\n                           [isShowTag]=\"tagCount && tagCount != 0 && isShowBadge\"\n                           [isEmptyTag]=\"isShowTagAsBullet\"\n                           tagLabel=\"{{tagCount}}\"\n                           tagSizeClass=\"tinier\"\n                           [isRounded]=\"false\">\n                </ux-a-icon>\n            </ng-template>\n        </div>\n\n        <ng-template [ngIf]=\"isOverlayPanel\">\n            <ng-template [ngIf]=\"isOverlayPanelCustomContent\">\n                <ux-layout-overlay-panel [isActive]=\"isActive\">\n                    <ng-content select=\"uxLayoutNavBarOverlayPanelContent\"></ng-content>\n                </ux-layout-overlay-panel>\n            </ng-template>\n\n            <ng-template [ngIf]=\"!isOverlayPanelCustomContent\">\n                <div class=\"overlay-panel\" [class.active]=\"isActive\" (click)=\"onClick($event)\">\n                    <div class=\"overlay-panel__header\">\n                        <div class=\"overlay-panel__header-profile\">\n                            <span *ngIf=\"isShowLanguageSelector\">\n                                <ux-language-selector\n                                    (languageChanged)=\"onLanguageChanged($event)\"\n                                    [languageCodes]=\"languageCodes\"\n                                    [selectedLanguage]=\"selectedLanguage\">\n                                </ux-language-selector>\n                            </span>\n\n                            <div class=\"overlay-panel__header-custom-content\">\n                                <ng-content select=\"uxLayoutNavBarOverlayPanelHeaderContent\"></ng-content>\n                            </div>\n\n                            <span class=\"overlay-panel__header-profile-infos\">\n                                <ng-template [ngIf]=\"headerUserProfileLinks\">\n                                    <ux-dropdown-button label=\"{{userInfos}}\"\n                                                        styleClass=\"mobile\"\n                                                        [isLinkToggle]=\"true\"\n                                                        [isDropDownRightAligned]=\"true\"\n                                                        [links]=\"headerUserProfileLinks\"\n                                                        (linkSelected)=\"onUserProfileLinkSelected($event)\">\n                                    </ux-dropdown-button>\n                                </ng-template>\n                                <ng-template [ngIf]=\"!headerUserProfileLinks\">\n                                    {{userInfos}}\n                                </ng-template>\n                            </span>\n                        </div>\n                    </div>\n\n                    <div class=\"overlay-panel__inner\">\n                        <ux-layout-sidebar-items [links]=\"(asService.state$ | async).combinedLinks\"\n                                                 (clicked)=\"onSidebarItemClick($event)\">\n                        </ux-layout-sidebar-items>\n                    </div>\n                </div>\n            </ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!isOverlayPanel\">\n            <aside class=\"inner-content {{contentClass}}\"\n                [class.hidden]=\"!isActive\"\n                [class.fixed-height]=\"isContentFixedHeight\">\n                <ng-content></ng-content>\n            </aside>\n        </ng-template>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarActionItemComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxAppShellService, },
        ]; };
        UxLayoutNavBarActionItemComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "isToggleContent": [{ type: core.Input },],
            "isOverlayPanel": [{ type: core.Input },],
            "isOverlayPanelCustomContent": [{ type: core.Input },],
            "isOverlayPanelBg": [{ type: core.Input },],
            "links": [{ type: core.Input },],
            "isShowHome": [{ type: core.Input },],
            "homeUrl": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isIconLarge": [{ type: core.Input },],
            "itemClass": [{ type: core.Input },],
            "contentClass": [{ type: core.Input },],
            "tagCount": [{ type: core.Input },],
            "isShowTagAsBullet": [{ type: core.Input },],
            "userInfos": [{ type: core.Input },],
            "userInfosIconClass": [{ type: core.Input },],
            "isHiddenMobile": [{ type: core.Input },],
            "isMobileOnly": [{ type: core.Input },],
            "isHiddenDesktop": [{ type: core.Input },],
            "isUseSidebarTemplateAsLinks": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "isContentFixedHeight": [{ type: core.Input },],
            "headerUserProfileLinks": [{ type: core.Input },],
            "languageCodes": [{ type: core.Input },],
            "additionalLanguages": [{ type: core.Input },],
            "selectedLanguage": [{ type: core.Input },],
            "isShowLanguageSelector": [{ type: core.Input },],
            "isShowBadge": [{ type: core.Input },],
            "hideBagdeOnClick": [{ type: core.Input },],
            "languageChanged": [{ type: core.Output },],
            "clicked": [{ type: core.Output },],
            "toggled": [{ type: core.Output },],
            "userProfileLinkSelected": [{ type: core.Output },],
            "customItemContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutNavBarItemContentTagDirective;
                        }),] },],
            "unToggleAll": [{ type: core.HostListener, args: ['body:click',] },],
        };
        return UxLayoutNavBarActionItemComponent;
    }());
    var UxLayoutNavBarOverlayPanelContentTagDirective = (function () {
        function UxLayoutNavBarOverlayPanelContentTagDirective() {
        }
        UxLayoutNavBarOverlayPanelContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutNavBarOverlayPanelContent' },] },
        ];
        return UxLayoutNavBarOverlayPanelContentTagDirective;
    }());
    var UxLayoutNavBarOverlayHeaderPanelContentTagDirective = (function () {
        function UxLayoutNavBarOverlayHeaderPanelContentTagDirective() {
        }
        UxLayoutNavBarOverlayHeaderPanelContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutNavBarOverlayPanelHeaderContent' },] },
        ];
        return UxLayoutNavBarOverlayHeaderPanelContentTagDirective;
    }());
    var UxLayoutNavBarItemContentTagDirective = (function () {
        function UxLayoutNavBarItemContentTagDirective() {
        }
        UxLayoutNavBarItemContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutNavBarItemContent' },] },
        ];
        return UxLayoutNavBarItemContentTagDirective;
    }());
    var UxLayoutNavBarActionItemComponentModule = (function () {
        function UxLayoutNavBarActionItemComponentModule() {
        }
        UxLayoutNavBarActionItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            UxLanguageSelectorComponentModule,
                            UxLayoutSidebarItemsComponentModule,
                            UxLayoutOverlayPanelComponentModule,
                            UxDropdownButtonComponentModule,
                            UxDropdownButtonItemComponentModule,
                            UxIconComponentModule,
                        ],
                        exports: [
                            UxLayoutNavBarActionItemComponent,
                            UxLayoutNavBarOverlayPanelContentTagDirective,
                            UxLayoutNavBarItemContentTagDirective,
                            UxLayoutNavBarOverlayHeaderPanelContentTagDirective,
                        ],
                        declarations: [
                            UxLayoutNavBarActionItemComponent,
                            UxLayoutNavBarOverlayPanelContentTagDirective,
                            UxLayoutNavBarItemContentTagDirective,
                            UxLayoutNavBarOverlayHeaderPanelContentTagDirective,
                        ]
                    },] },
        ];
        return UxLayoutNavBarActionItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarActionsComponent = (function () {
        function UxLayoutNavBarActionsComponent(uxService) {
            this.uxService = uxService;
        }
        /**
         * @return {?}
         */
        UxLayoutNavBarActionsComponent.prototype.unToggleAll = /**
         * @return {?}
         */
        function () {
            this.items.toArray().forEach(function (i) {
                i.isActive = false;
            });
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxLayoutNavBarActionsComponent.prototype.hideAll = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.items.toArray().forEach(function (i) {
                if (i !== item) {
                    i.isActive = false;
                }
            });
        };
        UxLayoutNavBarActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-actions',
                        template: "\n        <div class=\"ux-layout-nav-bar__right-actions\">\n            <ng-content></ng-content>\n        </div>\n    ",
                        // IE11 icons overlapping issue (cfr. EUI-1115)
                        // styles: [`
                        //     :host {
                        //         display: flex;
                        //         margin-left: auto;
                        //     }
                        // `],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarActionsComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxLayoutNavBarActionsComponent.propDecorators = {
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxLayoutNavBarActionItemComponent; }), { descendants: true },] },],
            "unToggleAll": [{ type: core.HostListener, args: ['body:click',] },],
        };
        return UxLayoutNavBarActionsComponent;
    }());
    var UxLayoutNavBarActionsComponentModule = (function () {
        function UxLayoutNavBarActionsComponentModule() {
        }
        UxLayoutNavBarActionsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutNavBarActionsComponent],
                        declarations: [UxLayoutNavBarActionsComponent]
                    },] },
        ];
        return UxLayoutNavBarActionsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxListItemsComponent = (function () {
        function UxListItemsComponent(elementRef, uxService) {
            this.elementRef = elementRef;
            this.uxService = uxService;
            this.expanded = false;
            this.isSmall = false;
            this.isLarge = false;
            this.hasBorder = false;
            this.isLeftPositioned = false;
            this.isAccessible = false;
            this.tabindex = '0';
            this.listItemClick = new core.EventEmitter();
        }
        /**
         * @param {?} item
         * @return {?}
         */
        UxListItemsComponent.prototype.onListItemClick = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.listItemClick.emit(item);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxListItemsComponent.prototype.onFocus = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isAccessible) {
                var /** @type {?} */ focusableElements = this.getFocusableElements();
                if (focusableElements.length > 0) {
                    for (var /** @type {?} */ i = 0; i < focusableElements.length; i++) {
                        focusableElements[i].setAttribute('tabindex', '-1');
                    }
                    this.focusElement(focusableElements[0]);
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxListItemsComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            if (this.isAccessible) {
                var /** @type {?} */ next = false;
                switch (event.keyCode) {
                    case 38:
                        // ARROW UP
                        break;
                    case 40:
                        // ARROW DOWN
                        next = true;
                        break;
                    case 9:
                        // TAB
                        if (event.shiftKey) {
                            var /** @type {?} */ oldTabindex_1 = this.tabindex;
                            this.tabindex = '-1';
                            setTimeout(function () {
                                _this.tabindex = oldTabindex_1;
                            }, 0);
                        }
                        return;
                    default:
                        return;
                }
                // Focus on the next/previous list item label, making sure only that item is focusable:
                var /** @type {?} */ focusableElements = this.getFocusableElements();
                if (focusableElements.length > 0) {
                    for (var /** @type {?} */ i = 0; i < focusableElements.length; i++) {
                        if (focusableElements[i] === document.activeElement) {
                            focusableElements[i].setAttribute('tabindex', '-1');
                            if (next) {
                                if (i + 1 < focusableElements.length) {
                                    this.focusElement(focusableElements[i + 1]);
                                }
                                else {
                                    this.focusElement(focusableElements[0]);
                                }
                            }
                            else {
                                if (i - 1 >= 0) {
                                    this.focusElement(focusableElements[i - 1]);
                                }
                                else {
                                    this.focusElement(focusableElements[focusableElements.length - 1]);
                                }
                            }
                            break;
                        }
                    }
                }
                this.uxService.consumeEvent(event);
            }
        };
        /**
         * @param {?} element
         * @return {?}
         */
        UxListItemsComponent.prototype.focusElement = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            element.setAttribute('tabindex', '0');
            element.focus();
        };
        /**
         * @return {?}
         */
        UxListItemsComponent.prototype.getFocusableElements = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement.querySelectorAll('.ux-a-label,.ux-a-tag');
        };
        UxListItemsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-list-items',
                        template: "\n    <div *ngIf=\"titleLabel\" class=\"ux-list-items-title {{titleLabelClass}}\">{{titleLabel}}</div>\n    <ul class=\"ux-list-items\" [tabindex]=\"tabindex\" aria-orientation=\"vertical\" (focus)=\"onFocus($event)\" (keydown)=\"onKeyDown($event)\">\n        <ng-template [ngIf]=\"links\">\n            <ux-list-item *ngFor=\"let link of links\"\n                           [item]=\"link\"\n                           (listItemClick)=\"onListItemClick($event)\"\n                           [isExpanded]=\"expanded\"\n                           [isSmall]=\"isSmall\"\n                           [hasBorder]=\"hasBorder\"\n                           [isLarge]=\"isLarge\"\n                           [isLeftPositioned]=\"isLeftPositioned\"\n                           [isScreenReaderClickable]=\"link.isScreenReaderClickable\">\n            </ux-list-item>\n        </ng-template>\n        <ng-template [ngIf]=\"!links\">\n            <ng-content></ng-content>\n        </ng-template>\n    </ul>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxListItemsComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: UxService, },
        ]; };
        UxListItemsComponent.propDecorators = {
            "titleLabel": [{ type: core.Input },],
            "titleLabelClass": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "links": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "hasBorder": [{ type: core.Input },],
            "isLeftPositioned": [{ type: core.Input },],
            "isAccessible": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "listItemClick": [{ type: core.Output },],
        };
        return UxListItemsComponent;
    }());
    var UxListItemsComponentModule = (function () {
        function UxListItemsComponentModule() {
        }
        UxListItemsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxListItemComponentModule],
                        exports: [UxListItemsComponent],
                        declarations: [
                            UxListItemsComponent
                        ]
                    },] },
        ];
        return UxListItemsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDateTagComponent = (function () {
        function UxDateTagComponent(uxService) {
            this.uxService = uxService;
            this.dateFormat = 'DD/MM/YYYY';
            this.isVerticalLayout = true;
            this.isHandleOverdue = false;
            this.isDisplayDaysLeft = false;
            this.isMuted = false;
            this.tabindex = 0;
            this.stateClass = '';
            this.languageCode = uxService.activeLanguage.code;
        }
        /**
         * @return {?}
         */
        UxDateTagComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ prefix = 'ux-a-date-tag';
            if (this.isMuted) {
                this.isVerticalLayout = false;
            }
            if (this.isVerticalLayout) {
                this.stateClass += prefix + '--vertical ';
                if (this.typeClass) {
                    this.stateClass += prefix + '--vertical--' + this.typeClass + ' ';
                }
                else {
                    if (this.isHandleOverdue) {
                        this.stateClass += prefix + '--vertical--' + this.getOverdueState();
                    }
                }
            }
            else {
                if (this.typeClass) {
                    this.stateClass += prefix + '--' + this.typeClass;
                }
                else {
                    if (this.isHandleOverdue) {
                        this.stateClass += prefix + '--' + this.getOverdueState();
                    }
                }
                if (this.isMuted) {
                    this.stateClass += ' ' + prefix + '--muted';
                }
            }
        };
        Object.defineProperty(UxDateTagComponent.prototype, "daysLeftValue", {
            get: /**
             * @return {?}
             */
            function () {
                if (typeof this.date !== 'string') {
                    var /** @type {?} */ diffDays = this.uxService.diffDaysFromToday(this.date);
                    var /** @type {?} */ label = '';
                    switch (true) {
                        case (diffDays < -1):
                            label = this.uxService.translate('xDaysAgo', this.languageCode).replace('%PARAM%', Math.abs(diffDays).toString());
                            break;
                        case (diffDays === -1):
                            label = this.uxService.translate('oneDayAgo', this.languageCode);
                            break;
                        case (diffDays === 0):
                            label = this.uxService.translate('today', this.languageCode);
                            break;
                        case (diffDays === 1):
                            label = this.uxService.translate('inOneDay', this.languageCode);
                            break;
                        case (diffDays > 1):
                            label = this.uxService.translate('inXDays', this.languageCode).replace('%PARAM%', diffDays.toString());
                            break;
                    }
                    return label;
                }
                else {
                    return '';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxDateTagComponent.prototype.getOverdueState = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ now = new Date();
            if (this.date.toDateString() === now.toDateString()) {
                return 'warning';
            }
            else if (now > this.date) {
                return 'danger';
            }
            return 'primary';
        };
        UxDateTagComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-date-tag',
                        template: "<span *ngIf=\"isVerticalLayout\" class=\"ux-a-date-tag-container\" [tabindex]=\"tabindex\" attr.aria-label=\"{{ date | amLocal | amDateFormat: 'DD' }} {{ date | amLocal | amDateFormat: 'MMM' }} {{ date | amLocal | amDateFormat: 'YYYY' }} {{ daysLeftValue }}\"> <div class=\"ux-a-date-tag {{ stateClass }} {{ styleClass }}\"> <div class=\"ux-a-date-tag__d\">{{ date | amLocal | amDateFormat: 'DD' }}</div> <div class=\"ux-a-date-tag__m\">{{ date | amLocal | amDateFormat: 'MMM' }}</div> <div class=\"ux-a-date-tag__y\">{{ date | amLocal | amDateFormat: 'YYYY' }}</div> </div> <div *ngIf=\"isDisplayDaysLeft\" class=\"ux-a-date-tag__sub-label\"> {{ daysLeftValue }} </div> </span> <span *ngIf=\"!isVerticalLayout\" class=\"ux-a-date-tag-container\" [tabindex]=\"tabindex\" attr.aria-label=\"{{ date | amLocal | amDateFormat: dateFormat }} {{ daysLeftValue }}\"> <div class=\"ux-a-date-tag {{ stateClass }} {{ styleClass }}\"> {{ date | amLocal | amDateFormat: dateFormat }} </div> <div *ngIf=\"isDisplayDaysLeft\" class=\"ux-a-date-tag__sub-label\"> {{ daysLeftValue }} </div> </span> ",
                        styles: [".ux-a-date-tag-container .ux-a-date-tag{background-color:white;padding:.66rem;text-align:center;width:100px;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag__sub-label{font-size:.71429rem;font-style:italic;margin-top:.33rem;text-align:center}.ux-a-date-tag-container .ux-a-date-tag--vertical{background:#d2d2d2;border-bottom:4px solid #ffd114}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__d{font-size:1.14286rem;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__m{font-size:1rem;text-transform:uppercase;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__y{font-size:.85714rem}.ux-a-date-tag-container .ux-a-date-tag--tiny{padding:.33rem}.ux-a-date-tag-container .ux-a-date-tag--big{padding:1.25rem}.ux-a-date-tag-container .ux-a-date-tag--primary{color:#003e8c}.ux-a-date-tag-container .ux-a-date-tag--info{color:#0067ad}.ux-a-date-tag-container .ux-a-date-tag--success{color:#3f7233}.ux-a-date-tag-container .ux-a-date-tag--warning{color:#ee821d}.ux-a-date-tag-container .ux-a-date-tag--danger{color:#d61d2b}.ux-a-date-tag-container .ux-a-date-tag--vertical--primary{background:#003e8c;border-bottom-color:#001f65;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--info{background:#0067ad;border-bottom-color:#00408c;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--success{background:#3f7233;border-bottom-color:#204a17;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--warning{background:#f08d23;border-bottom-color:#e8670e;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--danger{background:#d61d2b;border-bottom-color:#c20b13;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--muted{margin-bottom:0;box-shadow:none;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal} /*# sourceMappingURL=ux-a-date-tag.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxDateTagComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxDateTagComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "date": [{ type: core.Input },],
            "dateFormat": [{ type: core.Input },],
            "isVerticalLayout": [{ type: core.Input },],
            "isHandleOverdue": [{ type: core.Input },],
            "isDisplayDaysLeft": [{ type: core.Input },],
            "languageCode": [{ type: core.Input },],
            "isMuted": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
        };
        return UxDateTagComponent;
    }());
    var UxDateTagComponentModule = (function () {
        function UxDateTagComponentModule() {
        }
        UxDateTagComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, angular2Moment.MomentModule],
                        exports: [UxDateTagComponent],
                        declarations: [UxDateTagComponent]
                    },] },
        ];
        return UxDateTagComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxNotificationItemComponent = (function () {
        function UxNotificationItemComponent(uxService) {
            this.uxService = uxService;
            this.dateFormat = 'DD/MM/YYYY';
            this.isRenderHTML = false;
            this.isShowPriority = false;
            this.itemClick = new core.EventEmitter();
            this.itemMarkAsRead = new core.EventEmitter();
            this.itemMarkAsUnRead = new core.EventEmitter();
            this.tooltipSize = 'auto';
            if (!this.markAsReadLabel) {
                this.markAsReadLabel = uxService.translate('notificationMarkAsRead');
            }
            if (!this.markAsUnReadLabel) {
                this.markAsUnReadLabel = uxService.translate('notificationMarkAsUnRead');
            }
        }
        /**
         * @param {?} event
         * @return {?}
         */
        UxNotificationItemComponent.prototype.onItemClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.itemClick.emit(this.notificationLink);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxNotificationItemComponent.prototype.onItemMarkAsRead = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.notificationLink.metadata) {
                this.notificationLink.metadata.read = true;
            }
            this.itemMarkAsRead.emit(this.notificationLink);
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxNotificationItemComponent.prototype.onItemMarkAsUnRead = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.notificationLink.metadata) {
                this.notificationLink.metadata.read = false;
            }
            this.itemMarkAsUnRead.emit(this.notificationLink);
            this.uxService.consumeEvent(event);
        };
        Object.defineProperty(UxNotificationItemComponent.prototype, "notificationTypeClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (!this.notificationLink.typeClass) {
                    return 'primary';
                }
                else {
                    return this.notificationLink.typeClass;
                }
            },
            enumerable: true,
            configurable: true
        });
        UxNotificationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notification-item',
                        template: "<div class=\"ux-notification__item\"> <div class=\"ux-notification__item-content\" [ngClass]=\"isShowPriority && notificationLink.metadata.typeClass ? 'ux-notification__item-content--' + notificationLink.metadata.typeClass : 'ux-notification__item-content--secondary'\" (click)=\"onItemClick($event)\" [class.ux-notification__item-content--type]=\"notificationLink.metadata && ( notificationLink.metadata.type || notificationLink.metadata.date )\"> <div *ngIf=\"notificationLink.metadata && ( notificationLink.metadata.type || notificationLink.metadata.date )\" class=\"ux-notification__item-content-col--left\"> <ux-badge *ngIf=\"notificationLink.metadata && notificationLink.metadata.type\" [isPill]=\"false\" [isSmall]=\"true\" [typeClass]=\"isShowPriority && notificationLink.metadata.typeClass ? notificationLink.metadata.typeClass : 'primary'\"> {{ notificationLink.metadata.type }} </ux-badge> <ux-badge *ngIf=\"notificationLink.metadata && !notificationLink.metadata.type\" [isPill]=\"false\" [isSmall]=\"true\" [typeClass]=\"isShowPriority && notificationLink.metadata.typeClass ? notificationLink.metadata.typeClass : 'primary'\"> <span class=\"ux-icon ux-icon-envelope-o\"></span> </ux-badge> <ux-a-date-tag *ngIf=\"notificationLink.metadata && notificationLink.metadata.date\" [date]=\"notificationLink.metadata.date\" [isMuted]=\"true\" [isDisplayDaysLeft]=\"true\" dateFormat=\"{{dateFormat}}\"> </ux-a-date-tag> </div> <div class=\"ux-notification__item-content-col--center\"> <ng-template [ngIf]=\"notificationLink.metadata?.url\"> <a href=\"{{ notificationLink.metadata.url }}\" target=\"_blank\">{{ notificationLink.label | uxTruncate : 200 }}</a> </ng-template> <ng-template [ngIf]=\"!notificationLink.metadata?.url\"> {{ notificationLink.label | uxTruncate : 200 }} </ng-template> </div> <div class=\"ux-notification__item-content-col--right\"> <button class=\"ux-notification__item-close\" type=\"button\" [attr.aria-label]=\"markAsReadLabel\" title=\"{{ markAsReadLabel }}\" (click)=\"onItemMarkAsRead($event)\"> <span class=\"ion ion-ios-close-empty\"></span> </button> </div> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxNotificationItemComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxNotificationItemComponent.propDecorators = {
            "notificationLink": [{ type: core.Input },],
            "dateFormat": [{ type: core.Input },],
            "isRenderHTML": [{ type: core.Input },],
            "markAsReadLabel": [{ type: core.Input },],
            "markAsUnReadLabel": [{ type: core.Input },],
            "isShowPriority": [{ type: core.Input },],
            "itemClick": [{ type: core.Output },],
            "itemMarkAsRead": [{ type: core.Output },],
            "itemMarkAsUnRead": [{ type: core.Output },],
        };
        return UxNotificationItemComponent;
    }());
    var UxNotificationItemComponentModule = (function () {
        function UxNotificationItemComponentModule() {
        }
        UxNotificationItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxIconComponentModule,
                            UxLabelComponentModule,
                            UxBadgeComponentModule,
                            UxDateTagComponentModule,
                            UxTooltipModule,
                            UxTruncatePipeModule,
                        ],
                        exports: [UxNotificationItemComponent],
                        declarations: [UxNotificationItemComponent]
                    },] },
        ];
        return UxNotificationItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxButtonComponent = (function () {
        function UxButtonComponent(cd) {
            this.cd = cd;
            this.type = 'button';
            this.isOutline = false;
            this.isSecondary = false;
            this.isSmall = false;
            this.isLarge = false;
            this.isBlock = false;
            this.isFlat = false;
            this.isLineWrap = false;
            this.tabindex = '0';
            this.isDisabled = false;
            this.stateClass = 'ux-button--with-label';
        }
        /**
         * @return {?}
         */
        UxButtonComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.setClasses();
        };
        /**
         * @return {?}
         */
        UxButtonComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ innerText = this.uxContentPlaceholder.nativeElement.innerText;
            if (!innerText.trim()) {
                this.stateClass = 'ux-button--icon-only';
                this.cd.detectChanges();
            }
        };
        /**
         * @return {?}
         */
        UxButtonComponent.prototype.setClasses = /**
         * @return {?}
         */
        function () {
            this.btnTypeClass = '';
            var /** @type {?} */ prefix = 'btn-';
            if (!this.isFlat && !this.typeClass) {
                this.typeClass = 'primary';
            }
            if (this.isFlat && !this.typeClass) {
                this.typeClass = 'default';
            }
            if (this.isSecondary) {
                this.typeClass = 'secondary';
            }
            if (this.isOutline) {
                prefix += 'outline-';
            }
            if (this.isFlat) {
                prefix = 'btn-flat btn-flat-';
            }
            this.btnTypeClass = prefix + this.typeClass;
            this.btnSizeClass = '';
            if (this.isSmall) {
                this.btnSizeClass = 'btn-sm';
            }
            if (this.isLarge) {
                this.btnSizeClass = 'btn-lg';
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxButtonComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            this.setClasses();
        };
        UxButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-button',
                        template: "<button type=\"{{type}}\" class=\"btn ux-button {{btnTypeClass}} {{btnSizeClass}} {{styleClass}} {{stateClass}}\" [class.btn-block]=\"isBlock\" [class.ux-button--line-wrap]=\"isLineWrap\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-disabled]=\"isDisabled\"> <span *ngIf=\"iconClass\" class=\"ux-button__icon {{iconClass}}\"></span> <span class=\"ux-button__content\" #uxContentPlaceholder> <ng-content></ng-content> </span> </button> ",
                        styles: ["﻿:host(.ux-button—host-disabled){pointer-events:none} /*# sourceMappingURL=ux-button.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxButtonComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef, },
        ]; };
        UxButtonComponent.propDecorators = {
            "type": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isOutline": [{ type: core.Input },],
            "isSecondary": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isBlock": [{ type: core.Input },],
            "isFlat": [{ type: core.Input },],
            "isLineWrap": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input }, { type: core.HostBinding, args: ['class.ux-button—host-disabled',] },],
            "uxContentPlaceholder": [{ type: core.ViewChild, args: ['uxContentPlaceholder',] },],
        };
        return UxButtonComponent;
    }());
    var UxButtonComponentModule = (function () {
        function UxButtonComponentModule() {
        }
        UxButtonComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxButtonComponent],
                        declarations: [UxButtonComponent]
                    },] },
        ];
        return UxButtonComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxNotificationsPanelComponent = (function () {
        function UxNotificationsPanelComponent(uxLayoutNavBarActionsComponent, uxLayoutOverlayPanelComponent, uxService) {
            this.uxService = uxService;
            this.notificationLinks = [];
            this.viewAllNotificationsLabel = null;
            this.headerTitleLabel = null;
            this.noNotificationFoundLabel = null;
            this.todaysSeparatorLabel = null;
            this.oldestSeparatorLabel = null;
            this.unreadLabel = null;
            this.totalLabel = null;
            this.markAsReadLabel = null;
            this.markAsUnReadLabel = null;
            this.markAllAsReadLabel = null;
            this.settingsLabel = null;
            this.isShowViewAllAction = true;
            this.isSeparateCurrentDayNotifications = false;
            this.isHidePanelOnViewAllAction = true;
            this.isRenderHTML = false;
            this.isShowTotalNotifications = true;
            this.isShowRefreshButton = true;
            this.customUnreadCount = false;
            this.nbUnreadCount = null;
            this.isShowPriority = false;
            this.refreshClick = new core.EventEmitter();
            this.viewAllClick = new core.EventEmitter();
            this.itemClick = new core.EventEmitter();
            this.itemMarkAsRead = new core.EventEmitter();
            this.itemMarkAsUnRead = new core.EventEmitter();
            this.markAllAsRead = new core.EventEmitter();
            this.notificationSettings = new core.EventEmitter();
            this.currentDayNotifications = [];
            this.oldestNotifications = [];
            this.unreadNotifications = [];
            this.today = new Date();
            this.uxLayoutNavBarActionsComponent = uxLayoutNavBarActionsComponent;
            this.uxLayoutOverlayPanelComponent = uxLayoutOverlayPanelComponent;
            if (!this.viewAllNotificationsLabel) {
                this.viewAllNotificationsLabel = uxService.translate('viewAllNotifications');
            }
            if (!this.headerTitleLabel) {
                this.headerTitleLabel = uxService.translate('myNotifications');
            }
            if (!this.noNotificationFoundLabel) {
                this.noNotificationFoundLabel = uxService.translate('noNotificationFound');
            }
            if (!this.todaysSeparatorLabel) {
                this.todaysSeparatorLabel = uxService.translate('notificationsToday');
            }
            if (!this.oldestSeparatorLabel) {
                this.oldestSeparatorLabel = uxService.translate('notificationsOldest');
            }
            if (!this.unreadLabel) {
                this.unreadLabel = uxService.translate('notificationsUnread');
            }
            if (!this.totalLabel) {
                this.totalLabel = uxService.translate('notificationsTotal');
            }
            if (!this.markAsReadLabel) {
                this.markAsReadLabel = uxService.translate('notificationMarkAsRead');
            }
            if (!this.markAsUnReadLabel) {
                this.markAsUnReadLabel = uxService.translate('notificationMarkAsUnRead');
            }
        }
        Object.defineProperty(UxNotificationsPanelComponent.prototype, "unreadCount", {
            get: /**
             * @return {?}
             */
            function () {
                var /** @type {?} */ unreadNotifications = this.notificationLinks.filter(function (link) {
                    if (link.metadata) {
                        return link.metadata.read === false;
                    }
                    return false;
                });
                return unreadNotifications.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (this.isSeparateCurrentDayNotifications) {
                this.currentDayNotifications = this.notificationLinks.filter(function (link) {
                    if (link.metadata) {
                        return new Date(link.metadata.date).toDateString() === new Date().toDateString();
                    }
                    return false;
                });
                this.oldestNotifications = this.notificationLinks.filter(function (link) {
                    if (link.metadata) {
                        return new Date(link.metadata.date).toDateString() !== new Date().toDateString();
                    }
                    return false;
                });
            }
            if (!this.customUnreadCount) {
                this.nbUnreadCount = this.unreadCount;
            }
        };
        /**
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this.customUnreadCount) {
                this.nbUnreadCount = this.unreadCount;
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onRefresh = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.refreshClick.emit();
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onItemClick = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            this.itemClick.emit(link);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onViewAllClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.viewAllClick.emit();
            if (!this.isHidePanelOnViewAllAction) {
                this.uxService.consumeEvent(event);
            }
            else {
                if (this.uxLayoutNavBarActionsComponent && !this.uxLayoutOverlayPanelComponent) {
                    this.uxLayoutNavBarActionsComponent.hideAll(null);
                }
            }
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onItemMarkAsRead = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            this.itemMarkAsRead.emit(link);
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onItemMarkAsUnRead = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            this.itemMarkAsUnRead.emit(link);
        };
        /**
         * @param {?} e
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onMarkAllAsRead = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            this.markAllAsRead.emit(e);
        };
        /**
         * @param {?} e
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.onNotificationSettings = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            this.notificationSettings.emit(e);
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxNotificationsPanelComponent.prototype.getNotificationStateClass = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            if (link.metadata) {
                if (link.metadata.read) {
                    return 'ux-list-item--muted';
                }
            }
            return '';
        };
        UxNotificationsPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notifications-panel',
                        template: "<div class=\"ux-notifications-panel\"> <div class=\"ux-notifications-panel__header\"> <div class=\"ux-notifications-panel__header-title\"> <div class=\"ux-notifications-panel__header-title-label\"> {{ headerTitleLabel }} <span *ngIf=\"notificationLinks\" class=\"ux-u-cursor-help ml-2\" [attr.aria-label]=\"unreadLabel\" title=\"{{ unreadLabel }}\"> <ux-badge [isPill]=\"true\" [isSmall]=\"true\" typeClass=\"primary\">{{ notificationLinks.length }}</ux-badge> </span> </div> </div> <div *ngIf=\"notificationLinks\" class=\"ux-notifications-panel__header-actions\"> <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-checkbox-outline\" [attr.aria-label]=\"markAllAsReadLabel\" title=\"{{ markAllAsReadLabel }}\" (click)=\"onMarkAllAsRead($event)\"></ux-button> <!-- <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-settings\" [attr.aria-label]=\"settingsLabel\" title=\"{{ settingsLabel }}\" (click)=\"onNotificationSettings($event)\"></ux-button> --> <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-refresh\" (click)=\"onRefresh($event)\" *ngIf=\"isShowRefreshButton\"></ux-button> </div> </div> <div class=\"ux-notifications-panel__content\"> <ux-notification-item *ngFor=\"let notificationLink of notificationLinks\" [notificationLink]=\"notificationLink\" [isShowPriority]=\"isShowPriority\" [isRenderHTML]=\"isRenderHTML\" dateFormat=\"hh:mm\" (itemClick)=\"onItemClick($event)\" (itemMarkAsRead)=\"onItemMarkAsRead($event)\" (itemMarkAsUnRead)=\"onItemMarkAsUnRead($event)\"></ux-notification-item> </div> <div class=\"ux-notifications-panel__footer\"> <ng-template [ngIf]=\"notificationLinks?.length > 0\"> <strong><a (click)=\"onViewAllClick($event)\">{{ viewAllNotificationsLabel }}</a></strong> </ng-template> <ng-template [ngIf]=\"notificationLinks?.length === 0\"> <div class=\"ux-notification__item-content\">{{ noNotificationFoundLabel }}</div> </ng-template> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxNotificationsPanelComponent.ctorParameters = function () { return [
            { type: UxLayoutNavBarActionsComponent, decorators: [{ type: core.Host }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return UxLayoutNavBarActionsComponent; }),] },] },
            { type: UxLayoutOverlayPanelComponent, decorators: [{ type: core.Host }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return UxLayoutOverlayPanelComponent; }),] },] },
            { type: UxService, },
        ]; };
        UxNotificationsPanelComponent.propDecorators = {
            "notificationLinks": [{ type: core.Input },],
            "viewAllNotificationsLabel": [{ type: core.Input },],
            "headerTitleLabel": [{ type: core.Input },],
            "noNotificationFoundLabel": [{ type: core.Input },],
            "todaysSeparatorLabel": [{ type: core.Input },],
            "oldestSeparatorLabel": [{ type: core.Input },],
            "unreadLabel": [{ type: core.Input },],
            "totalLabel": [{ type: core.Input },],
            "markAsReadLabel": [{ type: core.Input },],
            "markAsUnReadLabel": [{ type: core.Input },],
            "markAllAsReadLabel": [{ type: core.Input },],
            "settingsLabel": [{ type: core.Input },],
            "isShowViewAllAction": [{ type: core.Input },],
            "isSeparateCurrentDayNotifications": [{ type: core.Input },],
            "isHidePanelOnViewAllAction": [{ type: core.Input },],
            "isRenderHTML": [{ type: core.Input },],
            "isShowTotalNotifications": [{ type: core.Input },],
            "isShowRefreshButton": [{ type: core.Input },],
            "customUnreadCount": [{ type: core.Input },],
            "nbUnreadCount": [{ type: core.Input },],
            "isShowPriority": [{ type: core.Input },],
            "refreshClick": [{ type: core.Output },],
            "viewAllClick": [{ type: core.Output },],
            "itemClick": [{ type: core.Output },],
            "itemMarkAsRead": [{ type: core.Output },],
            "itemMarkAsUnRead": [{ type: core.Output },],
            "markAllAsRead": [{ type: core.Output },],
            "notificationSettings": [{ type: core.Output },],
        };
        return UxNotificationsPanelComponent;
    }());
    var UxNotificationsPanelComponentModule = (function () {
        function UxNotificationsPanelComponentModule() {
        }
        UxNotificationsPanelComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxListItemComponentModule,
                            UxListItemsComponentModule,
                            UxNotificationItemComponentModule,
                            UxBadgeComponentModule,
                            angular2Moment.MomentModule,
                            UxDateTagComponentModule,
                            UxTruncatePipeModule,
                            UxButtonComponentModule,
                        ],
                        exports: [UxNotificationsPanelComponent],
                        declarations: [UxNotificationsPanelComponent]
                    },] },
        ];
        return UxNotificationsPanelComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarActionItemNotificationsComponent = (function () {
        function UxLayoutNavBarActionItemNotificationsComponent(uxService) {
            this.uxService = uxService;
            this.notificationLinks = [];
            this.isRenderHTML = false;
            this.isShowViewAllAction = true;
            this.isShowUnreadNotificationsCountAsBullet = false;
            this.isShowTotalNotifications = true;
            this.isShowRefreshButton = true;
            this.isHidePanelOnViewAllAction = false;
            this.isShowBadge = true;
            this.hideBagdeOnClick = false;
            this.customUnreadCount = false;
            this.nbUnreadCount = null;
            this.viewAllNotificationsLabel = null;
            this.headerTitleLabel = null;
            this.noNotificationFoundLabel = null;
            this.todaysSeparatorLabel = null;
            this.oldestSeparatorLabel = null;
            this.unreadLabel = null;
            this.totalLabel = null;
            this.markAsReadLabel = null;
            this.markAsUnReadLabel = null;
            this.markAllAsReadLabel = null;
            this.settingsLabel = null;
            this.isShowPriority = false;
            this.notificationsRefreshClick = new core.EventEmitter();
            this.notificationsViewAllClick = new core.EventEmitter();
            this.notificationsItemClick = new core.EventEmitter();
            this.notificationsItemMarkAsRead = new core.EventEmitter();
            this.notificationsItemMarkAsUnRead = new core.EventEmitter();
            this.iconClick = new core.EventEmitter();
            this.notificationsMarkAllAsRead = new core.EventEmitter();
            this.notificationsSettings = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemNotificationsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this.viewAllNotificationsLabel) {
                this.viewAllNotificationsLabel = this.uxService.translate('viewAllNotifications');
            }
            if (!this.headerTitleLabel) {
                this.headerTitleLabel = this.uxService.translate('myNotifications');
            }
            if (!this.noNotificationFoundLabel) {
                this.noNotificationFoundLabel = this.uxService.translate('noNotificationFound');
            }
            if (!this.todaysSeparatorLabel) {
                this.todaysSeparatorLabel = this.uxService.translate('notificationsToday');
            }
            if (!this.oldestSeparatorLabel) {
                this.oldestSeparatorLabel = this.uxService.translate('notificationsOldest');
            }
            if (!this.unreadLabel) {
                this.unreadLabel = this.uxService.translate('notificationsUnread');
            }
            if (!this.totalLabel) {
                this.totalLabel = this.uxService.translate('notificationsTotal');
            }
            if (!this.markAsReadLabel) {
                this.markAsReadLabel = this.uxService.translate('notificationMarkAsRead');
            }
            if (!this.markAsUnReadLabel) {
                this.markAsUnReadLabel = this.uxService.translate('notificationMarkAsUnRead');
            }
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemNotificationsComponent.prototype.showBadge = /**
         * @return {?}
         */
        function () {
            this.uxLayoutNavBarActionItemComponent.showBadge();
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarActionItemNotificationsComponent.prototype.hideBadge = /**
         * @return {?}
         */
        function () {
            this.uxLayoutNavBarActionItemComponent.hideBadge();
        };
        /**
         * @param {?} e
         * @return {?}
         */
        UxLayoutNavBarActionItemNotificationsComponent.prototype.onIconClick = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            this.iconClick.emit(e);
        };
        Object.defineProperty(UxLayoutNavBarActionItemNotificationsComponent.prototype, "unreadNotificationsCountGenerated", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.unreadNotificationsCount) {
                    return this.unreadNotificationsCount;
                }
                else {
                    return this.notificationLinks.length;
                }
            },
            enumerable: true,
            configurable: true
        });
        UxLayoutNavBarActionItemNotificationsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-action-item-notifications',
                        template: "\n        <!-- WITHIN OVERLAY -->\n        <ux-layout-nav-bar-action-item  iconClass=\"ux-icon ux-icon-bell\"\n                                        tagCount=\"{{unreadNotificationsCountGenerated}}\"\n                                        [isShowTagAsBullet]=\"isShowUnreadNotificationsCountAsBullet\"\n                                        [isOverlayPanel]=\"true\"\n                                        [isOverlayPanelCustomContent]=\"true\"\n                                        [isShowBadge]=\"isShowBadge\"\n                                        [hideBagdeOnClick]=\"hideBagdeOnClick\"\n                                        (clicked)=\"onIconClick($event)\">\n            <uxLayoutNavBarOverlayPanelContent>\n                <ux-notifications-panel [notificationLinks]=\"notificationLinks\"\n                                        [isSeparateCurrentDayNotifications]=\"false\"\n                                        [isHidePanelOnViewAllAction]=\"isHidePanelOnViewAllAction\"\n                                        (refreshClick)=\"notificationsRefreshClick.emit($event)\"\n                                        (viewAllClick)=\"notificationsViewAllClick.emit($event)\"\n                                        (itemMarkAsRead)=\"notificationsItemMarkAsRead.emit($event)\"\n                                        (itemMarkAsUnRead)=\"notificationsItemMarkAsUnRead.emit($event)\"\n                                        (itemClick)=\"notificationsItemClick.emit($event)\"\n                                        (markAllAsRead)=\"notificationsMarkAllAsRead.emit($event)\"\n                                        (notificationSettings)=\"notificationsSettings.emit($event)\"\n                                        [isRenderHTML]=\"isRenderHTML\"\n                                        [isShowViewAllAction]=\"isShowViewAllAction\"\n                                        [isShowTotalNotifications]=\"isShowTotalNotifications\"\n                                        [isShowRefreshButton]=\"isShowRefreshButton\"\n                                        [customUnreadCount]=\"customUnreadCount\"\n                                        [nbUnreadCount]=\"nbUnreadCount\"\n                                        [viewAllNotificationsLabel]=\"viewAllNotificationsLabel\"\n                                        [headerTitleLabel]=\"headerTitleLabel\"\n                                        [noNotificationFoundLabel]=\"noNotificationFoundLabel\"\n                                        [todaysSeparatorLabel]=\"todaysSeparatorLabel\"\n                                        [oldestSeparatorLabel]=\"oldestSeparatorLabel\"\n                                        [unreadLabel]=\"unreadLabel\"\n                                        [totalLabel]=\"totalLabel\"\n                                        [markAsReadLabel]=\"markAsReadLabel\"\n                                        [markAsUnReadLabel]=\"markAsUnReadLabel\"\n                                        [markAllAsReadLabel]=\"markAllAsReadLabel\"\n                                        [settingsLabel]=\"settingsLabel\"\n                                        [isShowPriority]=\"isShowPriority\">\n                </ux-notifications-panel>\n            </uxLayoutNavBarOverlayPanelContent>\n        </ux-layout-nav-bar-action-item>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarActionItemNotificationsComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxLayoutNavBarActionItemNotificationsComponent.propDecorators = {
            "notificationLinks": [{ type: core.Input },],
            "unreadNotificationsCount": [{ type: core.Input },],
            "isRenderHTML": [{ type: core.Input },],
            "isShowViewAllAction": [{ type: core.Input },],
            "isShowUnreadNotificationsCountAsBullet": [{ type: core.Input },],
            "isShowTotalNotifications": [{ type: core.Input },],
            "isShowRefreshButton": [{ type: core.Input },],
            "isHidePanelOnViewAllAction": [{ type: core.Input },],
            "isShowBadge": [{ type: core.Input },],
            "hideBagdeOnClick": [{ type: core.Input },],
            "customUnreadCount": [{ type: core.Input },],
            "nbUnreadCount": [{ type: core.Input },],
            "viewAllNotificationsLabel": [{ type: core.Input },],
            "headerTitleLabel": [{ type: core.Input },],
            "noNotificationFoundLabel": [{ type: core.Input },],
            "todaysSeparatorLabel": [{ type: core.Input },],
            "oldestSeparatorLabel": [{ type: core.Input },],
            "unreadLabel": [{ type: core.Input },],
            "totalLabel": [{ type: core.Input },],
            "markAsReadLabel": [{ type: core.Input },],
            "markAsUnReadLabel": [{ type: core.Input },],
            "markAllAsReadLabel": [{ type: core.Input },],
            "settingsLabel": [{ type: core.Input },],
            "isShowPriority": [{ type: core.Input },],
            "notificationsRefreshClick": [{ type: core.Output },],
            "notificationsViewAllClick": [{ type: core.Output },],
            "notificationsItemClick": [{ type: core.Output },],
            "notificationsItemMarkAsRead": [{ type: core.Output },],
            "notificationsItemMarkAsUnRead": [{ type: core.Output },],
            "iconClick": [{ type: core.Output },],
            "notificationsMarkAllAsRead": [{ type: core.Output },],
            "notificationsSettings": [{ type: core.Output },],
            "uxLayoutNavBarActionItemComponent": [{ type: core.ViewChild, args: [UxLayoutNavBarActionItemComponent,] },],
        };
        return UxLayoutNavBarActionItemNotificationsComponent;
    }());
    var UxLayoutNavBarActionItemNotificationsComponentModule = (function () {
        function UxLayoutNavBarActionItemNotificationsComponentModule() {
        }
        UxLayoutNavBarActionItemNotificationsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxLayoutNavBarActionItemComponentModule, UxNotificationsPanelComponentModule],
                        exports: [UxLayoutNavBarActionItemNotificationsComponent],
                        declarations: [UxLayoutNavBarActionItemNotificationsComponent]
                    },] },
        ];
        return UxLayoutNavBarActionItemNotificationsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarTopMenuComponent = (function () {
        function UxLayoutNavBarTopMenuComponent(asService) {
            var _this = this;
            this.asService = asService;
            this.homeUrl = '/screen/home';
            this.isShowHome = true;
            this.menuItemClicked = new core.EventEmitter();
            this.links = [];
            this.linksSubscription = asService.state$.subscribe(function (state) {
                _this.links = state.menuLinks;
            });
        }
        /**
         * @return {?}
         */
        UxLayoutNavBarTopMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.linksSubscription) {
                this.linksSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        UxLayoutNavBarTopMenuComponent.prototype.onHomeClick = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ link = new UxLink({ id: 'home', url: this.homeUrl });
            this.onLinkClick(link);
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxLayoutNavBarTopMenuComponent.prototype.onLinkClick = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            if (link.url) {
                window.scrollTo(0, 0);
            }
            if (!link.disabled) {
                this.menuItemClicked.emit(link);
            }
            if (link.urlExternal) {
                window.open(link.urlExternal, '_blank');
            }
            if (link.command) {
                link.command();
            }
        };
        UxLayoutNavBarTopMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-top-menu',
                        template: "\n        <nav id=\"top-menu\" *ngIf=\"links && links.length !== 0\">\n            <ul>\n                <li *ngIf=\"isShowHome\" class=\"icon-menu-item\"\n                    routerLinkActive=\"selected\" [routerLinkActiveOptions]=\"{exact:true}\">\n                    <a [routerLink]=\"homeUrl\" (click)=\"onHomeClick()\" class=\"icon-home-link\">\n                        <span class=\"ux-icon ux-icon-2x ux-icon-home\"></span>\n                    </a>\n                </li>\n\n                <li *ngFor=\"let link of links\" [class.has-sub]=\"link.hasChildren\" routerLinkActive=\"selected\">\n                    <ng-template [ngIf]=\"link.visible && !link.isHome\">\n                        <a *ngIf=\"!link.url\" (click)=\"onLinkClick(link)\">\n                            <i *ngIf=\"link.iconClass\" class=\"{{ link.iconClass }} ux-icon-fw\"></i> {{link.label}}\n                        </a>\n                        <a *ngIf=\"link.url\" [routerLink]=\"link.url\" (click)=\"onLinkClick(link)\">\n                            <i *ngIf=\"link.iconClass\" class=\"{{ link.iconClass }} ux-icon-fw\"></i> {{link.label}}\n                        </a>\n                        <ul *ngIf=\"link.hasChildren\">\n                            <li class=\"child\" *ngFor=\"let childLink of link.children\"\n                                [class.has-sub]=\"childLink.hasChildren\" [class.hidden]=\"!childLink.visible\">\n                                <ng-template [ngIf]=\"childLink.visible\">\n                                    <a *ngIf=\"!childLink.url\"\n                                        [class.disabled]=\"childLink.disabled\"\n                                        (click)=\"onLinkClick(childLink)\">\n                                        <i *ngIf=\"childLink.iconClass\" class=\"{{ childLink.iconClass }} ux-icon-fw\"></i>\n                                        {{childLink.label}}\n                                    </a>\n                                    <a *ngIf=\"childLink.url\"\n                                        [class.disabled]=\"childLink.disabled\"\n                                        [routerLink]=\"childLink.url\"\n                                        (click)=\"onLinkClick(childLink)\">\n                                        <i *ngIf=\"childLink.iconClass\" class=\"{{ childLink.iconClass }} ux-icon-fw\"></i>\n                                        {{childLink.label}}\n                                    </a>\n                                    <ul *ngIf=\"childLink.hasChildren\">\n                                        <li class=\"child\" *ngFor=\"let childSubLink of childLink.children\">\n                                            <ng-template [ngIf]=\"childSubLink.visible\">\n                                                <a *ngIf=\"childSubLink.url\"\n                                                    [class.disabled]=\"childSubLink.disabled\"\n                                                    [routerLink]=\"childSubLink.url\"\n                                                    (click)=\"onLinkClick(childSubLink)\">\n                                                    <i *ngIf=\"childSubLink.iconClass\"\n                                                        class=\"{{ childSubLink.iconClass }} ux-icon-fw\"></i>\n                                                    {{childSubLink.label}}\n                                                    </a>\n                                                <a *ngIf=\"!childSubLink.url\"\n                                                    [class.disabled]=\"childSubLink.disabled\"\n                                                    (click)=\"onLinkClick(childSubLink)\">\n                                                    <i *ngIf=\"childSubLink.iconClass\"\n                                                        class=\"{{ childSubLink.iconClass }} ux-icon-fw\"></i>\n                                                    {{childSubLink.label}}\n                                                    </a>\n                                            </ng-template>\n                                        </li>\n                                    </ul>\n                                </ng-template>\n                            </li>\n                        </ul>\n                    </ng-template>\n                </li>\n            </ul>\n        </nav>\n    ",
                        styles: ["\n        :host {\n            display: block;\n            width: 100%;\n        }\n    "],
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarTopMenuComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxLayoutNavBarTopMenuComponent.propDecorators = {
            "homeUrl": [{ type: core.Input },],
            "isShowHome": [{ type: core.Input },],
            "menuItemClicked": [{ type: core.Output },],
        };
        return UxLayoutNavBarTopMenuComponent;
    }());
    var UxLayoutNavBarTopMenuComponentModule = (function () {
        function UxLayoutNavBarTopMenuComponentModule() {
        }
        UxLayoutNavBarTopMenuComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule],
                        exports: [UxLayoutNavBarTopMenuComponent],
                        declarations: [UxLayoutNavBarTopMenuComponent]
                    },] },
        ];
        return UxLayoutNavBarTopMenuComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarLeftActionItemComponent = (function () {
        function UxLayoutNavBarLeftActionItemComponent() {
            this.itemClass = '';
            this.isStatic = false;
        }
        UxLayoutNavBarLeftActionItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-left-action-item',
                        template: "\n        <div class=\"ux-layout-nav-bar__action-item {{itemClass}}\"\n            [class.d-none.d-lg-block]=\"isHiddenMobile\" [class.not-hoverable]=\"isStatic\">\n            <ng-content></ng-content>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarLeftActionItemComponent.propDecorators = {
            "itemClass": [{ type: core.Input },],
            "isHiddenMobile": [{ type: core.Input },],
            "isStatic": [{ type: core.Input },],
        };
        return UxLayoutNavBarLeftActionItemComponent;
    }());
    var UxLayoutNavBarLeftActionItemComponentModule = (function () {
        function UxLayoutNavBarLeftActionItemComponentModule() {
        }
        UxLayoutNavBarLeftActionItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutNavBarLeftActionItemComponent],
                        declarations: [UxLayoutNavBarLeftActionItemComponent]
                    },] },
        ];
        return UxLayoutNavBarLeftActionItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutNavBarLeftActionsComponent = (function () {
        function UxLayoutNavBarLeftActionsComponent() {
        }
        UxLayoutNavBarLeftActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-left-actions',
                        template: "\n        <div class=\"ux-layout-nav-bar__left-actions\">\n            <ng-content></ng-content>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        return UxLayoutNavBarLeftActionsComponent;
    }());
    var UxLayoutNavBarLeftActionsComponentModule = (function () {
        function UxLayoutNavBarLeftActionsComponentModule() {
        }
        UxLayoutNavBarLeftActionsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutNavBarLeftActionsComponent],
                        declarations: [UxLayoutNavBarLeftActionsComponent]
                    },] },
        ];
        return UxLayoutNavBarLeftActionsComponentModule;
    }());

    var __assign$3 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var UxLayoutNavBarLeftActionItemSidebarToggleComponent = (function () {
        function UxLayoutNavBarLeftActionItemSidebarToggleComponent(uxAppShellService) {
            this.uxAppShellService = uxAppShellService;
        }
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutNavBarLeftActionItemSidebarToggleComponent.prototype.onToggleSidebar = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.uxAppShellService.setState(__assign$3({}, this.uxAppShellService.state, { isSidebarOpen: !this.uxAppShellService.state.isSidebarOpen }));
        };
        UxLayoutNavBarLeftActionItemSidebarToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-nav-bar-left-action-item-sidebar-toggle',
                        template: "\n        <div class=\"ux-layout-nav-bar__action-item d-none d-lg-block\" (click)=\"onToggleSidebar($event)\">\n            <a href=\"javascript:void(0);\" class=\"ux-layout-nav-bar__action-item-icon-toggle\">\n                <span class=\"ux-layout-nav-bar__action-item-icon-toggle-icon ux-icon ux-icon-bars\"></span>\n            </a>\n        </div>\n        <div *ngIf=\"label\"\n             class=\"ux-layout-nav-bar__action-item ux-layout-nav-bar__action-item-label d-none d-lg-block\"\n             (click)=\"onToggleSidebar($event)\">\n                {{label}}\n        </div>\n    ",
                        styles: ["\n        :host {\n            display: flex;\n        }\n    "],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutNavBarLeftActionItemSidebarToggleComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxLayoutNavBarLeftActionItemSidebarToggleComponent.propDecorators = {
            "label": [{ type: core.Input },],
        };
        return UxLayoutNavBarLeftActionItemSidebarToggleComponent;
    }());
    var UxLayoutNavBarLeftActionItemSidebarToggleComponentModule = (function () {
        function UxLayoutNavBarLeftActionItemSidebarToggleComponentModule() {
        }
        UxLayoutNavBarLeftActionItemSidebarToggleComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutNavBarLeftActionItemSidebarToggleComponent],
                        declarations: [UxLayoutNavBarLeftActionItemSidebarToggleComponent]
                    },] },
        ];
        return UxLayoutNavBarLeftActionItemSidebarToggleComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutSidebarComponent = (function () {
        function UxLayoutSidebarComponent(uxService, asService, document) {
            var _this = this;
            this.uxService = uxService;
            this.asService = asService;
            this.document = document;
            this.homeUrl = '/screen/home';
            this.isShowLogo = false;
            this.isLargeItems = false;
            this.hasFilter = false;
            this.filterPlaceholderLabel = 'Filter';
            this.isInnerSidebar = false;
            // as sub-transclusion contentChildren does not work : https://github.com/angular/angular/issues/16299
            // @Input() items: QueryList<UxLayoutSidebarItemComponent>;
            this.toggled = new core.EventEmitter();
            this.clicked = new core.EventEmitter();
            this.topPosition = 0;
            this.subscription = this.uxService.windowWidth$.subscribe(function (width) {
                _this.calculatePosition();
            });
        }
        /**
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.onWindowScroll = /**
         * @return {?}
         */
        function () {
            this.calculatePosition();
        };
        /**
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.theme) {
                this.themeClass = 'sidebar--t-' + this.theme;
            }
            if (this.isInnerSidebar) {
                this.isLargeItems = true;
            }
            this.calculatePosition();
        };
        /**
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscription.unsubscribe();
        };
        /**
         * @param {?} id
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.onClick = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            if (id) {
                this.clicked.emit(id);
            }
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.onSidebarItemToggle = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            if (!this.uxService.isSidebarStateOpen) {
                this.uxService.isSidebarStateOpen = true;
            }
            this.toggled.next(item);
        };
        /**
         * @return {?}
         */
        UxLayoutSidebarComponent.prototype.calculatePosition = /**
         * @return {?}
         */
        function () {
            if (!this.isInnerSidebar) {
                this.topPosition = 0;
            }
            else {
                var /** @type {?} */ position = 0;
                var /** @type {?} */ navBar = this.document.getElementById('nav-bar');
                if (navBar) {
                    position = navBar.getBoundingClientRect().bottom;
                }
                if (position >= 0) {
                    this.topPosition = position;
                }
                else {
                    this.topPosition = 0;
                }
            }
        };
        UxLayoutSidebarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-sidebar',
                        template: "\n        <div class=\"sidebar {{themeClass}}\"\n            [class.inner-sidebar]=\"isInnerSidebar\"\n            [class.sidebar--large-items]=\"isLargeItems\"\n            [style.top.px]=\"topPosition\">\n\n            <div class=\"logo-wrapper\" *ngIf=\"isShowLogo\">\n                <a [routerLink]=\"homeUrl\">\n                    <div class=\"logo\"></div>\n                </a>\n            </div>\n\n            <div class=\"sidebar-inner\">\n\n                <ng-template [ngIf]=\"customContent\">\n                    <ng-content select=\"uxLayoutSidebarContent\"></ng-content>\n                </ng-template>\n\n                <ng-template [ngIf]=\"!customContent\">\n\n                    <div *ngIf=\"titleLabel\" class=\"title\">{{titleLabel}}</div>\n\n                    <div class=\"header\" *ngIf=\"customHeaderContent\">\n                        <ng-content select=\"uxLayoutSidebarHeader\"></ng-content>\n                    </div>\n\n                    <div class=\"filter\" *ngIf=\"hasFilter\">\n                        <input type=\"text\" #sidebarFilter placeholder=\"{{filterPlaceholderLabel}}\"/>\n                        <span class=\"ux-icon ux-icon-search\"></span>\n                    </div>\n\n                    <ux-layout-sidebar-items [links]=\"(asService.state$ | async).sidebarLinks\"\n                                             [isLargeItems]=\"isLargeItems\"\n                                             [isInnerSidebar]=\"isInnerSidebar\"\n                                             (toggled)=\"onSidebarItemToggle($event)\">\n                    </ux-layout-sidebar-items>\n\n                </ng-template>\n            </div>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutSidebarComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxAppShellService, },
            { type: undefined, decorators: [{ type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
        ]; };
        UxLayoutSidebarComponent.propDecorators = {
            "homeUrl": [{ type: core.Input },],
            "titleLabel": [{ type: core.Input },],
            "isShowLogo": [{ type: core.Input },],
            "isLargeItems": [{ type: core.Input },],
            "hasFilter": [{ type: core.Input },],
            "filterPlaceholderLabel": [{ type: core.Input },],
            "isInnerSidebar": [{ type: core.Input },],
            "theme": [{ type: core.Input },],
            "toggled": [{ type: core.Output },],
            "clicked": [{ type: core.Output },],
            "customHeaderContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxLayoutSidebarHeaderTagDirective; }),] },],
            "customContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxLayoutSidebarContentTagDirective; }),] },],
            "onWindowScroll": [{ type: core.HostListener, args: ['window:scroll', [],] },],
        };
        return UxLayoutSidebarComponent;
    }());
    var UxLayoutSidebarHeaderTagDirective = (function () {
        function UxLayoutSidebarHeaderTagDirective() {
        }
        UxLayoutSidebarHeaderTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutSidebarHeader' },] },
        ];
        return UxLayoutSidebarHeaderTagDirective;
    }());
    var UxLayoutSidebarContentTagDirective = (function () {
        function UxLayoutSidebarContentTagDirective() {
        }
        UxLayoutSidebarContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutSidebarContent' },] },
        ];
        return UxLayoutSidebarContentTagDirective;
    }());
    var UxLayoutSidebarComponentModule = (function () {
        function UxLayoutSidebarComponentModule() {
        }
        UxLayoutSidebarComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, router.RouterModule,
                            UxLayoutSidebarItemComponentModule, UxLayoutSidebarItemsComponentModule,
                        ],
                        exports: [
                            UxLayoutSidebarComponent,
                            UxLayoutSidebarHeaderTagDirective,
                            UxLayoutSidebarContentTagDirective,
                        ],
                        declarations: [
                            UxLayoutSidebarComponent,
                            UxLayoutSidebarHeaderTagDirective,
                            UxLayoutSidebarContentTagDirective,
                        ]
                    },] },
        ];
        return UxLayoutSidebarComponentModule;
    }());

    var __assign$4 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var UxLayoutAppShellComponent = (function () {
        function UxLayoutAppShellComponent(uxService, uxAppShellService) {
            var _this = this;
            this.uxService = uxService;
            this.uxAppShellService = uxAppShellService;
            // GLOBAL
            this.appHomeUrl = '/screen/home';
            this.isContract = false;
            this.isContractMedium = false;
            this.isContractSmall = false;
            this.isScrollHandlerActive = true;
            this.isErrorState = false;
            // HEADER
            this.hasHeader = true;
            this.hasHeaderUserProfile = false;
            this.hasHeaderProfileAvatar = false;
            this.isHeaderHideLogo = false;
            this.isHeaderShowLanguageSelector = true;
            this.isHeaderHomeUrlActive = true;
            this.headerLanguageChanged = new core.EventEmitter();
            this.headerUserProfileLinkSelected = new core.EventEmitter();
            // NAV BAR
            this.hasNavBar = true;
            this.navBarTopMenuLinks = [];
            this.navBarTopMenuHomeUrl = '/screen/home';
            this.isNavBarTopMenuShowHome = true;
            this.isNavBarMuted = false;
            this.navBarNotificationLinks = [];
            this.isNavBarMobileSidebarTemplateLinks = false;
            this.navBarTopMenuItemClicked = new core.EventEmitter();
            this.navBarNotificationsRefreshClick = new core.EventEmitter();
            this.navBarNotificationsViewAllClick = new core.EventEmitter();
            this.navBarNotificationsItemClick = new core.EventEmitter();
            this.navBarNotificationsItemMarkAsRead = new core.EventEmitter();
            this.navBarNotificationsItemMarkAsUnRead = new core.EventEmitter();
            // FOOTER
            this.isFooterCompact = true;
            this.footerAppVersion = '@app.version@';
            this.footerAppReleaseDate = '@app.release.date@';
            this.isFooterStyleInverse = false;
            this.hasFooter = true;
            // SIDEBAR
            this.hasSidebar = false;
            this.isSidebarInner = false;
            this.sidebarLinks = [];
            this.isSidebarShowLogo = false;
            this.isSidebarLargeItems = false;
            this.isSidebarStateCloseWithIcons = true;
            this.isSidebarMobileVisible = false;
            this.hasSidebarFilter = false;
            this.isSidebarOpen = true;
            this.isDebugState = false;
            this.sidebarItemToggle = new core.EventEmitter();
            this.isMobile = false;
            this.isTablet = false;
            this.mobileMenuLinks = [];
            this.appShellStateSubscription = uxAppShellService.state$.subscribe(function (state) {
                if (_this.isDebugState) {
                    console.log('ux-layout-app-shell : state subscription : ', state);
                }
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ cSidebarLinks = changes['sidebarLinks'];
            var /** @type {?} */ cMenuLinks = changes['navBarTopMenuLinks'];
            var /** @type {?} */ hasChanged = false;
            if (cSidebarLinks) {
                if (cSidebarLinks.previousValue && cSidebarLinks.currentValue) {
                    if (cSidebarLinks.previousValue.join() !== cSidebarLinks.currentValue.join()) {
                        hasChanged = true;
                    }
                }
            }
            if (cMenuLinks) {
                if (cMenuLinks.previousValue && cMenuLinks.currentValue) {
                    if (cMenuLinks.previousValue.join() !== cMenuLinks.currentValue.join()) {
                        hasChanged = true;
                    }
                }
            }
            if (hasChanged) {
                this.uxAppShellService.setState(__assign$4({}, this.uxAppShellService.state, { sidebarLinks: this.sidebarLinks, menuLinks: this.navBarTopMenuLinks }));
            }
        };
        /**
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            console.log('ux-layout-app-shell : init application state');
            this.uxAppShellService.setState(__assign$4({}, this.uxAppShellService.state, { isSidebarOpen: this.isSidebarOpen, isSidebarActive: this.hasSidebar && !this.isSidebarInner, isSidebarInnerActive: this.isSidebarInner, isSidebarStateCloseWithIcons: this.isSidebarStateCloseWithIcons, windowHeight: window.innerHeight, windowWidth: window.innerWidth, menuLinks: this.navBarTopMenuLinks, sidebarLinks: this.sidebarLinks }));
            // DEPRECATED start
            this.uxService.setActiveBreakpoint(window.innerWidth);
            this.uxService.setWindowHeight(window.innerHeight);
            // DEPRECATED end
            this.windowResizedSubscription = fromEvent.fromEvent(window, 'resize')
                .debounceTime(300)
                .subscribe(function (event) {
                _this.uxAppShellService.setState(__assign$4({}, _this.uxAppShellService.state, { windowHeight: window.innerHeight, windowWidth: window.innerWidth }));
                // DEPRECATED start
                // DEPRECATED start
                _this.uxService.setActiveBreakpoint(window.innerWidth);
                _this.uxService.setWindowHeight(window.innerHeight);
                // DEPRECATED end
            });
        };
        /**
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.appClasses = '';
            if (this.styleClass) {
                this.appClasses += ' ' + this.styleClass;
            }
            if (this.themeClass) {
                this.appClasses += ' ' + this.themeClass;
            }
            if (this.isContract) {
                this.appClasses += ' contract';
            }
            if (this.isContractMedium) {
                this.appClasses += ' contract-half';
            }
            if (this.isContractSmall) {
                this.appClasses += ' contract-quarter';
            }
            if (this.isSidebarShowLogo) {
                this.isHeaderHideLogo = true;
            }
        };
        /**
         * @param {?} uxLanguage
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.onHeaderLanguageChanged = /**
         * @param {?} uxLanguage
         * @return {?}
         */
        function (uxLanguage) {
            this.headerSelectedLanguage = uxLanguage;
            this.headerLanguageChanged.emit(uxLanguage);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.onHeaderUserProfileLinkSelected = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.headerUserProfileLinkSelected.emit(uxLink);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.onTopMenuItemClicked = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.navBarTopMenuItemClicked.emit(uxLink);
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.onSidebarItemToggle = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.sidebarItemToggle.next(item);
        };
        /**
         * @return {?}
         */
        UxLayoutAppShellComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.windowResizedSubscription) {
                this.windowResizedSubscription.unsubscribe();
            }
            if (this.appShellStateSubscription) {
                this.appShellStateSubscription.unsubscribe();
            }
        };
        UxLayoutAppShellComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-app-shell',
                        template: "<div id=\"app-wrapper\" [uxScrollHandler]=\"isScrollHandlerActive\" class=\"{{appClasses}} {{(uxAppShellService.state$ | async).wrapperClasses}}\"> <ux-layout-sidebar *ngIf=\"hasSidebar && !isSidebarInner\" titleLabel=\"{{sidebarTitle}}\" [isShowLogo]=\"isSidebarShowLogo\" [isLargeItems]=\"isSidebarLargeItems\" [isInnerSidebar]=\"isSidebarInner\" [hasFilter]=\"hasSidebarFilter\" theme=\"{{sidebarTheme}}\" (toggled)=\"onSidebarItemToggle($event)\"> <uxLayoutSidebarHeader *ngIf=\"customSidebarHeaderContent.length !== 0\"> <ng-content select=\"uxAppShellSidebarHeaderContent\"></ng-content> </uxLayoutSidebarHeader> </ux-layout-sidebar> <div id=\"main\" role=\"main\"> <ng-template [ngIf]=\"customTopMessage.length !== 0\"> <uxLayoutSidebarHeader> <ng-content select=\"uxAppShellTopMessageContent\"></ng-content> </uxLayoutSidebarHeader> </ng-template> <ux-layout-header *ngIf=\"hasHeader\" appFullName=\"{{headerAppFullName}}\" appShortName=\"{{headerAppShortName}}\" appSubtitle=\"{{headerAppSubtitle}}\" [userInfos]=\"headerUserInfos\" [userInfosIcon]=\"headerUserInfosIcon\" homeUrl=\"{{appHomeUrl}}\" [userProfileLinks]=\"headerUserProfileLinks\" [isHideLogo]=\"isHeaderHideLogo\" [isShowLanguageSelector]=\"isHeaderShowLanguageSelector\" [isCustomTitleContent]=\"customHeaderTitleContent.length !== 0\" [isCustomRightContent]=\"customHeaderRightContent.length !== 0\" envLabel=\"{{headerEnvLabel}}\" [languageCodes]=\"headerLanguageCodes\" [additionalLanguages]=\"headerAdditionalLanguages\" [selectedLanguage]=\"headerSelectedLanguage\" (languageChanged)=\"onHeaderLanguageChanged($event)\" [isHomeUrlActive]=\"isHeaderHomeUrlActive\" (userProfileLinkSelected)=\"onHeaderUserProfileLinkSelected($event)\" [isErrorState]=\"isErrorState\"> <uxLayoutHeaderTitleContent *ngIf=\"customHeaderTitleContent.length !== 0\"> <ng-content select=\"uxAppShellHeaderTitleContent\"></ng-content> </uxLayoutHeaderTitleContent> <uxLayoutHeaderRightContent *ngIf=\"customHeaderRightContent.length !== 0\"> <ng-content select=\"uxAppShellHeaderRightContent\"></ng-content> </uxLayoutHeaderRightContent> </ux-layout-header> <ng-template [ngIf]=\"hasNavBar\"> <ng-template [ngIf]=\"isNavBarMuted || isErrorState\"> <ux-layout-nav-bar [isMuted]=\"true\"></ux-layout-nav-bar> </ng-template> <ng-template [ngIf]=\"!isNavBarMuted && !isErrorState\"> <ux-layout-nav-bar styleClass=\"navBarStyleClass\"> <uxLayoutNavBarLeftActionsContent> <ux-layout-nav-bar-left-actions> <ux-layout-nav-bar-left-action-item-sidebar-toggle *ngIf=\"isSidebarInner && hasSidebar\" label=\"{{navBarSidebarToggleLabel}}\"> </ux-layout-nav-bar-left-action-item-sidebar-toggle> <ng-template [ngIf]=\"customNavBarLeftItemsContent.length !== 0\"> <ng-content select=\"uxAppShellNavBarLeftItemsContent\"></ng-content> </ng-template> </ux-layout-nav-bar-left-actions> </uxLayoutNavBarLeftActionsContent> <ux-layout-nav-bar-top-menu homeUrl=\"{{navBarTopMenuHomeUrl}}\" [isShowHome]=\"isNavBarTopMenuShowHome\" (menuItemClicked)=\"onTopMenuItemClicked($event)\"> </ux-layout-nav-bar-top-menu> <ux-layout-nav-bar-actions> <ng-template [ngIf]=\"customNavBarItemsContent.length !== 0\"> <ng-content select=\"uxAppShellNavBarItemsContent\"></ng-content> </ng-template> <ux-layout-nav-bar-action-item-notifications *ngIf=\"navBarNotificationLinks.length !== 0\" [notificationLinks]=\"navBarNotificationLinks\" (notificationsRefreshClick)=\"navBarNotificationsRefreshClick.emit($event)\" (notificationsViewAllClick)=\"navBarNotificationsViewAllClick.emit($event)\" (notificationsItemClick)=\"navBarNotificationsItemClick.emit($event)\" (notificationsItemMarkAsRead)=\"navBarNotificationsItemMarkAsRead.emit($event)\" (notificationsItemMarkAsUnRead)=\"navBarNotificationsItemMarkAsUnRead.emit($event)\"> </ux-layout-nav-bar-action-item-notifications> <ux-layout-nav-bar-action-item iconClass=\"ux-icon ux-icon-bars\" [isHiddenDesktop]=\"true\" [isOverlayPanel]=\"true\" [isUseSidebarTemplateAsLinks]=\"isNavBarMobileSidebarTemplateLinks\" [userInfos]=\"headerUserInfos\" [headerUserProfileLinks]=\"headerUserProfileLinks\" [languageCodes]=\"headerLanguageCodes\" [additionalLanguages]=\"headerAdditionalLanguages\" [selectedLanguage]=\"headerSelectedLanguage\" (languageChanged)=\"onHeaderLanguageChanged($event)\" [isShowLanguageSelector]=\"isHeaderShowLanguageSelector\" (userProfileLinkSelected)=\"onHeaderUserProfileLinkSelected($event)\"> <uxLayoutNavBarOverlayPanelHeaderContent> <ng-content select=\"uxAppShellOverlayPanelHeaderContent\"></ng-content> </uxLayoutNavBarOverlayPanelHeaderContent> </ux-layout-nav-bar-action-item> </ux-layout-nav-bar-actions> </ux-layout-nav-bar> </ng-template> </ng-template> <div id=\"main-content\"> <ux-layout-sidebar *ngIf=\"hasSidebar && isSidebarInner\" titleLabel=\"{{sidebarTitle}}\" [isInnerSidebar]=\"isSidebarInner\" [isShowLogo]=\"isSidebarShowLogo\" [isLargeItems]=\"isSidebarLargeItems\" theme=\"{{sidebarTheme}}\" (toggled)=\"onSidebarItemToggle($event)\"> </ux-layout-sidebar> <ng-template [ngIf]=\"customMainContent.length === 0 && !isErrorState\"> <router-outlet></router-outlet> </ng-template> <ng-template [ngIf]=\"customMainContent.length !== 0\"> <ng-content select=\"uxAppShellMainContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"isErrorState && customErrorStateContent.length !== 0\"> <ng-content select=\"uxAppShellErrorStateContent\"></ng-content> </ng-template> </div> <!-- #main-content end --> <ux-layout-footer *ngIf=\"hasFooter\" [isCompact]=\"isFooterCompact\" [isStyleInverse]=\"isFooterStyleInverse\"> <ng-template [ngIf]=\"customFooterContent.length === 0\"> version <strong [ngClass]=\"isFooterStyleInverse ? 'ux-u-color-accent' : 'ux-u-color-primary'\"> {{footerAppVersion}}</strong> - {{footerAppReleaseDate}} </ng-template> <ng-template [ngIf]=\"customFooterContent.length !== 0\"> <ng-content select=\"uxAppShellFooterContent\"></ng-content> </ng-template> </ux-layout-footer> </div> <!-- #main end --> <ux-growl [value]=\"uxService.growlMessages\" [sticky]=\"uxService.isGrowlSticky\" [life]=\"uxService.growlLife\" [position]=\"uxService.growlPosition\"></ux-growl> <ux-block-document [isBlocked]=\"(uxAppShellService.state$ | async).isBlockDocumentActive\"></ux-block-document> </div> ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutAppShellComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxAppShellService, },
        ]; };
        UxLayoutAppShellComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "appHomeUrl": [{ type: core.Input },],
            "themeClass": [{ type: core.Input },],
            "isContract": [{ type: core.Input },],
            "isContractMedium": [{ type: core.Input },],
            "isContractSmall": [{ type: core.Input },],
            "isScrollHandlerActive": [{ type: core.Input },],
            "isErrorState": [{ type: core.Input },],
            "hasHeader": [{ type: core.Input },],
            "headerAppFullName": [{ type: core.Input },],
            "headerAppShortName": [{ type: core.Input },],
            "headerAppSubtitle": [{ type: core.Input },],
            "headerUserInfos": [{ type: core.Input },],
            "headerUserInfosIcon": [{ type: core.Input },],
            "hasHeaderUserProfile": [{ type: core.Input },],
            "hasHeaderProfileAvatar": [{ type: core.Input },],
            "headerUserProfileLinks": [{ type: core.Input },],
            "isHeaderHideLogo": [{ type: core.Input },],
            "isHeaderShowLanguageSelector": [{ type: core.Input },],
            "languageCodes": [{ type: core.Input },],
            "headerEnvLabel": [{ type: core.Input },],
            "headerLanguageCodes": [{ type: core.Input },],
            "headerAdditionalLanguages": [{ type: core.Input },],
            "headerSelectedLanguage": [{ type: core.Input },],
            "isHeaderHomeUrlActive": [{ type: core.Input },],
            "headerLanguageChanged": [{ type: core.Output },],
            "headerUserProfileLinkSelected": [{ type: core.Output },],
            "hasNavBar": [{ type: core.Input },],
            "navBarTopMenuLinks": [{ type: core.Input },],
            "navBarTopMenuHomeUrl": [{ type: core.Input },],
            "isNavBarTopMenuShowHome": [{ type: core.Input },],
            "isNavBarMuted": [{ type: core.Input },],
            "navBarStyleClass": [{ type: core.Input },],
            "navBarSidebarToggleLabel": [{ type: core.Input },],
            "navBarNotificationLinks": [{ type: core.Input },],
            "isNavBarMobileSidebarTemplateLinks": [{ type: core.Input },],
            "navBarTopMenuItemClicked": [{ type: core.Output },],
            "navBarNotificationsRefreshClick": [{ type: core.Output },],
            "navBarNotificationsViewAllClick": [{ type: core.Output },],
            "navBarNotificationsItemClick": [{ type: core.Output },],
            "navBarNotificationsItemMarkAsRead": [{ type: core.Output },],
            "navBarNotificationsItemMarkAsUnRead": [{ type: core.Output },],
            "isFooterCompact": [{ type: core.Input },],
            "footerAppVersion": [{ type: core.Input },],
            "footerAppReleaseDate": [{ type: core.Input },],
            "isFooterStyleInverse": [{ type: core.Input },],
            "hasFooter": [{ type: core.Input },],
            "hasSidebar": [{ type: core.Input },],
            "isSidebarInner": [{ type: core.Input },],
            "sidebarLinks": [{ type: core.Input },],
            "sidebarTitle": [{ type: core.Input },],
            "isSidebarShowLogo": [{ type: core.Input },],
            "isSidebarLargeItems": [{ type: core.Input },],
            "isSidebarStateCloseWithIcons": [{ type: core.Input },],
            "isSidebarMobileVisible": [{ type: core.Input },],
            "hasSidebarFilter": [{ type: core.Input },],
            "sidebarTheme": [{ type: core.Input },],
            "isSidebarOpen": [{ type: core.Input },],
            "isDebugState": [{ type: core.Input },],
            "sidebarItemToggle": [{ type: core.Output },],
            "customSidebarContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellSidebarContentTagDirective;
                        }),] },],
            "customSidebarHeaderContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellSidebarHeaderContentTagDirective;
                        }),] },],
            "customHeaderRightContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellHeaderRightContentTagDirective;
                        }),] },],
            "customHeaderTitleContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellHeaderTitleContentTagDirective;
                        }),] },],
            "customMainContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellMainContentTagDirective;
                        }),] },],
            "customNavBarItemsContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellNavBarItemsContentTagDirective;
                        }),] },],
            "customNavBarLeftItemsContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellNavBarLeftItemsContentTagDirective;
                        }),] },],
            "customFooterContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellFooterContentTagDirective;
                        }),] },],
            "sidebarItems": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxLayoutSidebarItemComponent;
                        }), { descendants: true },] },],
            "customTopMessage": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellTopMessageContentTagDirective;
                        }),] },],
            "customErrorStateContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxAppShellErrorStateContentTagDirective;
                        }),] },],
        };
        return UxLayoutAppShellComponent;
    }());
    var UxAppShellSidebarContentTagDirective = (function () {
        function UxAppShellSidebarContentTagDirective() {
        }
        UxAppShellSidebarContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellSidebarContent' },] },
        ];
        return UxAppShellSidebarContentTagDirective;
    }());
    var UxAppShellSidebarHeaderContentTagDirective = (function () {
        function UxAppShellSidebarHeaderContentTagDirective() {
        }
        UxAppShellSidebarHeaderContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellSidebarHeaderContent' },] },
        ];
        return UxAppShellSidebarHeaderContentTagDirective;
    }());
    var UxAppShellHeaderRightContentTagDirective = (function () {
        function UxAppShellHeaderRightContentTagDirective() {
        }
        UxAppShellHeaderRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellHeaderRightContent' },] },
        ];
        return UxAppShellHeaderRightContentTagDirective;
    }());
    var UxAppShellHeaderTitleContentTagDirective = (function () {
        function UxAppShellHeaderTitleContentTagDirective() {
        }
        UxAppShellHeaderTitleContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellHeaderTitleContent' },] },
        ];
        return UxAppShellHeaderTitleContentTagDirective;
    }());
    var UxAppShellMainContentTagDirective = (function () {
        function UxAppShellMainContentTagDirective() {
        }
        UxAppShellMainContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellMainContent' },] },
        ];
        return UxAppShellMainContentTagDirective;
    }());
    var UxAppShellNavBarItemsContentTagDirective = (function () {
        function UxAppShellNavBarItemsContentTagDirective() {
        }
        UxAppShellNavBarItemsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellNavBarItemsContent' },] },
        ];
        return UxAppShellNavBarItemsContentTagDirective;
    }());
    var UxAppShellNavBarLeftItemsContentTagDirective = (function () {
        function UxAppShellNavBarLeftItemsContentTagDirective() {
        }
        UxAppShellNavBarLeftItemsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellNavBarLeftItemsContent' },] },
        ];
        return UxAppShellNavBarLeftItemsContentTagDirective;
    }());
    var UxAppShellFooterContentTagDirective = (function () {
        function UxAppShellFooterContentTagDirective() {
        }
        UxAppShellFooterContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellFooterContent' },] },
        ];
        return UxAppShellFooterContentTagDirective;
    }());
    var UxAppShellOverlayPanelHeaderTagDirective = (function () {
        function UxAppShellOverlayPanelHeaderTagDirective() {
        }
        UxAppShellOverlayPanelHeaderTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellOverlayPanelHeaderContent' },] },
        ];
        return UxAppShellOverlayPanelHeaderTagDirective;
    }());
    var UxAppShellTopMessageContentTagDirective = (function () {
        function UxAppShellTopMessageContentTagDirective() {
        }
        UxAppShellTopMessageContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellTopMessageContent' },] },
        ];
        return UxAppShellTopMessageContentTagDirective;
    }());
    var UxAppShellErrorStateContentTagDirective = (function () {
        function UxAppShellErrorStateContentTagDirective() {
        }
        UxAppShellErrorStateContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxAppShellErrorStateContent' },] },
        ];
        return UxAppShellErrorStateContentTagDirective;
    }());
    var UxLayoutAppShellComponentModule = (function () {
        function UxLayoutAppShellComponentModule() {
        }
        UxLayoutAppShellComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            UxGrowlComponentModule,
                            UxBlockDocumentComponentModule,
                            UxScrollHandlerDirectiveModule,
                            UxLayoutHeaderComponentModule,
                            UxLayoutFooterComponentModule,
                            UxLayoutNavBarComponentModule,
                            UxLayoutNavBarActionsComponentModule,
                            UxLayoutNavBarActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemSidebarToggleComponentModule,
                            UxLayoutNavBarLeftActionsComponentModule,
                            UxLayoutNavBarActionItemNotificationsComponentModule,
                            UxLayoutNavBarTopMenuComponentModule,
                            UxLayoutSidebarComponentModule,
                        ],
                        exports: [
                            UxLayoutAppShellComponent,
                            UxAppShellSidebarContentTagDirective,
                            UxAppShellSidebarHeaderContentTagDirective,
                            UxAppShellHeaderRightContentTagDirective,
                            UxAppShellHeaderTitleContentTagDirective,
                            UxAppShellMainContentTagDirective,
                            UxAppShellNavBarItemsContentTagDirective,
                            UxAppShellNavBarLeftItemsContentTagDirective,
                            UxAppShellFooterContentTagDirective,
                            UxAppShellOverlayPanelHeaderTagDirective,
                            UxAppShellTopMessageContentTagDirective,
                            UxAppShellErrorStateContentTagDirective,
                        ],
                        declarations: [
                            UxLayoutAppShellComponent,
                            UxAppShellSidebarContentTagDirective,
                            UxAppShellSidebarHeaderContentTagDirective,
                            UxAppShellHeaderRightContentTagDirective,
                            UxAppShellHeaderTitleContentTagDirective,
                            UxAppShellMainContentTagDirective,
                            UxAppShellNavBarItemsContentTagDirective,
                            UxAppShellNavBarLeftItemsContentTagDirective,
                            UxAppShellFooterContentTagDirective,
                            UxAppShellOverlayPanelHeaderTagDirective,
                            UxAppShellTopMessageContentTagDirective,
                            UxAppShellErrorStateContentTagDirective,
                        ],
                    },] },
        ];
        return UxLayoutAppShellComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimezones = (function () {
        function UxTimezones() {
            this.primary = 'Europe/Brussels';
            this.secondary = 'Europe/Brussels';
        }
        return UxTimezones;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutHeaderProfileComponent = (function () {
        function UxLayoutHeaderProfileComponent(uxService, tzService) {
            this.uxService = uxService;
            this.tzService = tzService;
            this.languageCodes = '';
            this.isConnected = false;
            this.isOnline = false;
            this.isShowTimeWrapper = false;
            this.isUserLoggedIn = true;
            this.welcomeLabel = 'Welcome';
            this.isAvailableUserStateBullet = true;
            // deprecated start
            this.utcLocalCityName = 'Brussels';
            this.utcLocalCityTooltip = 'My local time';
            this.utcLocalOffset = +1;
            this.utcForeignCityName = 'Addis-Abeba';
            this.utcForeignCityTooltip = 'Foreign time';
            this.utcForeignOffset = +2;
            // deprecated end
            this.timezones = new UxTimezones();
            this.languageChanged = new core.EventEmitter();
            this.formattedDateTimeSeparatorPattern = /\s\W\s/g;
            this.isProfileDropdownVisible = false;
            this.localTime = new Date();
        }
        /**
         * @return {?}
         */
        UxLayoutHeaderProfileComponent.prototype.closeProfileDropdown = /**
         * @return {?}
         */
        function () {
            this.isProfileDropdownVisible = false;
        };
        /**
         * @return {?}
         */
        UxLayoutHeaderProfileComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ ttimer = timer$1.timer(0, 60000);
            ttimer.subscribe(function (t) {
                _this.localTime = new Date();
            });
        };
        /**
         * @param {?} language
         * @return {?}
         */
        UxLayoutHeaderProfileComponent.prototype.onLanguageChanged = /**
         * @param {?} language
         * @return {?}
         */
        function (language) {
            this.languageChanged.emit(language);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutHeaderProfileComponent.prototype.onToggleProfileDropdown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isProfileDropdownVisible = !this.isProfileDropdownVisible;
            this.uxService.consumeEvent(event);
        };
        UxLayoutHeaderProfileComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-header-profile',
                        template: "<div class=\"profile-wrapper\"> <div class=\"left-panel\"> <div class=\"user-infos\"> <ng-template [ngIf]=\"isUserLoggedIn\"> {{welcomeLabel}} <strong class=\"ux-u-color-primary\">{{userInfos}}</strong> </ng-template> </div> <div *ngIf=\"isShowTimeWrapper\" class=\"time-wrapper\"> <div class=\"current-time\"> <span class=\"ux-icon ion-ios-clock-outline\"></span> <span> {{localTime | uxMomentTz: timezones?.primary | amDateFormat: 'HH:mm'}} </span> <span class=\"utc-time\"> <span class=\"ux-icon ion-location mr-1\"></span> {{tzService.getTimezone(timezones?.primary)?.desc}} </span> </div> <div class=\"utc-time\"> <span class=\"ux-icon ion-location mr-1\"></span> {{tzService.getTimezone(timezones?.secondary)?.desc}} <span> {{localTime | uxMomentTz: timezones?.secondary | amDateFormat: 'HH:mm'}} </span> </div> </div> <div *ngIf=\"!isShowTimeWrapper\" class=\"sub-content-wrapper\"> <ng-content select=\"uxLayoutHeaderProfileSubContent\"></ng-content> </div> </div> <div *ngIf=\"isUserLoggedIn\" class=\"right-panel\" (click)=\"onToggleProfileDropdown($event)\"> <div class=\"picture\"> <div class=\"connected-state\"> <span class=\"pulse-ring connect red\"></span> <span *ngIf=\"isConnected\" class=\"icon ion ion-social-rss ux-u-color-success\" title=\"Sucessfully connected to remote Opsys Server\"> </span> <span *ngIf=\"!isConnected\" class=\"icon ion ion-social-rss ux-u-color-danger\" title=\"Connection to remote Opsys Server failed!\"> </span> </div> <div class=\"available-state\" *ngIf=\"isAvailableUserStateBullet\"> <span *ngIf=\"isOnline\" class=\"icon ux-icon ux-icon-circle ux-u-color-success-light\" title=\"Online - Available for chat discussion\"> </span> <span *ngIf=\"!isOnline\" class=\"icon ux-icon ux-icon-circle ux-u-color-danger-light\" title=\"Offline - Unavailable for chat discussion\"> </span> </div> </div> <div class=\"profile-toggle\"> <span class=\"ux-icon\" [ngClass]=\"isProfileDropdownVisible ? 'ux-icon-angle-up' : 'ux-icon-angle-down'\"></span> </div> </div> <div class=\"language-selector-panel\"> <ux-language-selector *ngIf=\"languageCodes\" (languageChanged)=\"onLanguageChanged($event)\" languageCodes=\"{{languageCodes}}\" [isShowLabel]=\"!isUserLoggedIn\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes\" (languageChanged)=\"onLanguageChanged($event)\" [isShowLabel]=\"!isUserLoggedIn\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> </div> <div *ngIf=\"isProfileDropdownVisible && customProfileMenuContent\" class=\"profile-dropdown fx flipInY\"> <ng-content select=\"uxLayoutHeaderProfileMenuContent\"></ng-content> </div> </div> <ng-template [ngIf]=\"!isUserLoggedIn\"> <div> <ng-content select=\"uxLayoutHeaderProfileNotLoggedInContent\"></ng-content> </div> </ng-template> ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutHeaderProfileComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxTimezoneService, },
        ]; };
        UxLayoutHeaderProfileComponent.propDecorators = {
            "userInfos": [{ type: core.Input },],
            "languageCodes": [{ type: core.Input },],
            "isConnected": [{ type: core.Input },],
            "isOnline": [{ type: core.Input },],
            "isShowTimeWrapper": [{ type: core.Input },],
            "isUserLoggedIn": [{ type: core.Input },],
            "selectedLanguage": [{ type: core.Input },],
            "welcomeLabel": [{ type: core.Input },],
            "isAvailableUserStateBullet": [{ type: core.Input },],
            "utcLocalCityName": [{ type: core.Input },],
            "utcLocalCityTooltip": [{ type: core.Input },],
            "utcLocalOffset": [{ type: core.Input },],
            "utcForeignCityName": [{ type: core.Input },],
            "utcForeignCityTooltip": [{ type: core.Input },],
            "utcForeignOffset": [{ type: core.Input },],
            "timezones": [{ type: core.Input },],
            "languageChanged": [{ type: core.Output },],
            "customProfileMenuContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutHeaderProfileMenuContentTagDirective;
                        }),] },],
            "customProfileSubContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutHeaderProfileSubContentTagDirective;
                        }),] },],
            "closeProfileDropdown": [{ type: core.HostListener, args: ['body:click',] },],
        };
        return UxLayoutHeaderProfileComponent;
    }());
    var UxLayoutHeaderProfileMenuContentTagDirective = (function () {
        function UxLayoutHeaderProfileMenuContentTagDirective() {
        }
        UxLayoutHeaderProfileMenuContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderProfileMenuContent' },] },
        ];
        return UxLayoutHeaderProfileMenuContentTagDirective;
    }());
    var UxLayoutHeaderProfileNotLoggedInContentTagDirective = (function () {
        function UxLayoutHeaderProfileNotLoggedInContentTagDirective() {
        }
        UxLayoutHeaderProfileNotLoggedInContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderProfileNotLoggedInContent' },] },
        ];
        return UxLayoutHeaderProfileNotLoggedInContentTagDirective;
    }());
    var UxLayoutHeaderProfileSubContentTagDirective = (function () {
        function UxLayoutHeaderProfileSubContentTagDirective() {
        }
        UxLayoutHeaderProfileSubContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHeaderProfileSubContent' },] },
        ];
        return UxLayoutHeaderProfileSubContentTagDirective;
    }());
    var UxLayoutHeaderProfileComponentModule = (function () {
        function UxLayoutHeaderProfileComponentModule() {
        }
        UxLayoutHeaderProfileComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            angular2Moment.MomentModule,
                            UxLanguageSelectorComponentModule,
                            UxDropdownButtonComponentModule,
                            UxDropdownButtonItemComponentModule,
                            UxMomentTzPipeModule,
                        ],
                        exports: [
                            UxLayoutHeaderProfileComponent,
                            UxLayoutHeaderProfileMenuContentTagDirective,
                            UxLayoutHeaderProfileNotLoggedInContentTagDirective,
                            UxLayoutHeaderProfileSubContentTagDirective,
                        ],
                        declarations: [
                            UxLayoutHeaderProfileComponent,
                            UxLayoutHeaderProfileMenuContentTagDirective,
                            UxLayoutHeaderProfileNotLoggedInContentTagDirective,
                            UxLayoutHeaderProfileSubContentTagDirective,
                        ]
                    },] },
        ];
        return UxLayoutHeaderProfileComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAppComponent = (function () {
        function UxAppComponent() {
            this.homeUrl = '/screen/home';
            this.notificationLinks = [];
            this.activeLanguageCode = 'en';
        }
        UxAppComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-app',
                        template: "<div class=\"ux-app {{styleClass}}\"> <div class=\"ux-app__main\" role=\"main\"> <div class=\"ux-app__header\"> <a class=\"ux-app__header-logo\" [routerLink]=\"homeUrl\"></a> <h1 class=\"ux-app__header-title\">{{appTitle}}</h1> <span class=\"ux-app__header-actions\"> <ng-content></ng-content> </span> </div> <div class=\"ux-app__main-content\"> <router-outlet></router-outlet> </div> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxAppComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "appTitle": [{ type: core.Input },],
            "homeUrl": [{ type: core.Input },],
            "notificationLinks": [{ type: core.Input },],
        };
        return UxAppComponent;
    }());
    var UxAppModule = (function () {
        function UxAppModule() {
        }
        UxAppModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, router.RouterModule,
                        ],
                        exports: [UxAppComponent],
                        declarations: [UxAppComponent]
                    },] },
        ];
        return UxAppModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBreadcrumbsService = (function () {
        function UxBreadcrumbsService(translateService) {
            this.translateService = translateService;
            this.labels = new Map();
        }
        /**
         * @param {?} route
         * @return {?}
         */
        UxBreadcrumbsService.prototype.buildUrl = /**
         * @param {?} route
         * @return {?}
         */
        function (route) {
            var /** @type {?} */ url = '';
            route.pathFromRoot.forEach(function (parentRoute) {
                if (parentRoute.snapshot.url.length > 0) {
                    url += '/' + parentRoute.snapshot.url.map(function (segment) { return segment.path; }).join('/');
                }
            });
            return url;
        };
        /**
         * @param {?} route
         * @param {?} label
         * @return {?}
         */
        UxBreadcrumbsService.prototype.setLabel = /**
         * @param {?} route
         * @param {?} label
         * @return {?}
         */
        function (route, label) {
            this.labels.set(this.buildUrl(route), label);
        };
        /**
         * @param {?} route
         * @return {?}
         */
        UxBreadcrumbsService.prototype.getLabel = /**
         * @param {?} route
         * @return {?}
         */
        function (route) {
            var /** @type {?} */ label = this.labels.get(this.buildUrl(route));
            if (!label) {
                label = route.snapshot.data['breadcrumb'].label ?
                    this.translateService.instant(route.snapshot.data['breadcrumb'].label) :
                    'unknown';
            }
            return label;
        };
        UxBreadcrumbsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxBreadcrumbsService.ctorParameters = function () { return [
            { type: core$1.TranslateService, },
        ]; };
        return UxBreadcrumbsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutBreadcrumbsComponent = (function () {
        function UxLayoutBreadcrumbsComponent(router$$1, activatedRoute, breadcrumbsService) {
            this.router = router$$1;
            this.activatedRoute = activatedRoute;
            this.breadcrumbsService = breadcrumbsService;
            this.homeUrl = '';
            this.homeUrlLabel = 'Home';
            this.truncateSize = 20;
            this.isECL = false;
            this.segments = [];
            this.isShowMore = false;
            this.isShowBreadcrumbsMenu = false;
            this.previousSegments = [];
        }
        /**
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.closeBreadcrumbsMenu = /**
         * @return {?}
         */
        function () {
            this.isShowBreadcrumbsMenu = false;
        };
        /**
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.routeChange(this.activatedRoute);
            this.router.events
                .subscribe(function (event) {
                if (event instanceof router.NavigationEnd) {
                    _this.routeChange(_this.activatedRoute);
                    _this.buildBreadcrumb();
                }
            });
            this.buildBreadcrumb();
        };
        /**
         * @param {?} route
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.routeChange = /**
         * @param {?} route
         * @return {?}
         */
        function (route) {
            this.previousSegments = this.segments.slice();
            this.segments = [];
            addBreadcrumb.call(this);
            while (route.firstChild) {
                route = route.firstChild;
                addBreadcrumb.call(this);
            }
            this.segments = concatToPreviousRoute.call(this);
            /**
             * @return {?}
             */
            function addBreadcrumb() {
                var /** @type {?} */ breadcrumb = route.snapshot.data['breadcrumb'];
                if (typeof breadcrumb !== 'undefined' && breadcrumb !== null) {
                    this.segments.push(route);
                }
            }
            /**
             * @return {?}
             */
            function concatToPreviousRoute() {
                var /** @type {?} */ currentRoute = this.segments.slice(-1)[0];
                var /** @type {?} */ previousAllowed = currentRoute &&
                    currentRoute.snapshot.data.breadcrumb &&
                    currentRoute.snapshot.data.breadcrumb.previousAllowed;
                if (!previousAllowed) {
                    return this.segments;
                }
                var /** @type {?} */ concatFromLastRoute = false;
                var /** @type {?} */ index = -1;
                var /** @type {?} */ goingBack = false;
                this.previousSegments.forEach(function (lastRoute, i) {
                    if (!concatFromLastRoute && lastRoute && lastRoute.snapshot.data.pageId) {
                        concatFromLastRoute = previousAllowed.indexOf(lastRoute.snapshot.data.pageId) >= 0;
                    }
                    if (currentRoute.snapshot.data.pageId && currentRoute.snapshot.data.pageId === lastRoute.snapshot.data.pageId) {
                        goingBack = true;
                        index = i;
                    }
                });
                if (goingBack) {
                    return this.previousSegments.slice(0, index + 1);
                }
                else if (concatFromLastRoute) {
                    return this.previousSegments.concat([currentRoute]);
                }
                return this.segments;
            }
        };
        /**
         * @param {?} segment
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.buildUrl = /**
         * @param {?} segment
         * @return {?}
         */
        function (segment) {
            return this.breadcrumbsService.buildUrl(segment);
        };
        /**
         * @param {?} segment
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.getLabel = /**
         * @param {?} segment
         * @return {?}
         */
        function (segment) {
            return this.breadcrumbsService.getLabel(segment);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.toggleIsShowMore = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isShowBreadcrumbsMenu = !this.isShowBreadcrumbsMenu;
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.cancelBubble = true;
            }
        };
        /**
         * @return {?}
         */
        UxLayoutBreadcrumbsComponent.prototype.buildBreadcrumb = /**
         * @return {?}
         */
        function () {
            /*  2DO
                        Calculate the total width of ux-breadcrumbs__item.
                        If max-width > ux-layout-nav-bar width then show the more (...) element.
                        Use this.isShowMore variable for this.
                    */
        };
        UxLayoutBreadcrumbsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-breadcrumbs',
                        template: "<ng-container *ngIf=\"!isECL\"> <div class=\"ux-layout-breadcrumbs\"> <!-- Home --> <span class=\"ux-layout-breadcrumbs__item\"> <a *ngIf=\"segments.length > 0\" [routerLink]=\"homeUrl\" title=\"{{ homeUrlLabel }}\"><span>{{ homeUrlLabel }}</span></a> <span *ngIf=\"segments.length === 0\">{{ homeUrlLabel }}</span> </span> <!-- Items --> <span class=\"ux-layout-breadcrumbs__item\" *ngFor=\"let segment of segments; let last = last; let index = i;\"> <ng-template [ngIf]=\"!last\"> <a [routerLink]=\"buildUrl(segment)\" title=\"{{ getLabel(segment) }}\">{{ getLabel(segment) | uxTruncate : truncateSize }}</a> </ng-template> <!-- Last item --> <ng-template [ngIf]=\"last\"> <!-- More... (for future release) --> <!-- <a *ngIf=\"isShowMore\" href=\"javascript:void(0);\" (click)=\"toggleIsShowMore($event);\">...</a> --> <span title=\"{{ getLabel(segment) }}\">{{ getLabel(segment) }}</span> </ng-template> </span> </div> <!-- Called by More...: populated with \"hidden\" breadcrumbs items (for future release) <div class=\"ux-layout-breadcrumbs__menu dropdown-menu\" *ngIf=\"isShowBreadcrumbsMenu\"> <span class=\"ux-layout-breadcrumbs__item\" *ngFor=\"let number of [0,1,2,3,4,5,6,7,8,9]\"> <a href=\"javascript:void(0);\" title=\"Segment link n-{{number}}\">Segment link with long label n-{{number}}</a> </span> </div> --> </ng-container> <ng-container *ngIf=\"isECL\"> <nav class=\"ecl-breadcrumb\" aria-label=\"breadcrumb\"> <span class=\"ecl-u-sr-only\">You are here:</span> <ol class=\"ecl-breadcrumb__segments-wrapper\"> <li class=\"ecl-breadcrumb__segment ecl-breadcrumb__segment--first\"> <a *ngIf=\"segments.length > 0\" class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\" [routerLink]=\"homeUrl\" title=\"{{ homeUrlLabel }}\"> {{ homeUrlLabel }} </a> <span *ngIf=\"segments.length === 0\">{{ homeUrlLabel }}</span> </li> <ng-container *ngFor=\"let segment of segments; let last = last; let index = i;\"> <li *ngIf=\"!last\" class=\"ecl-breadcrumb__segment\"> <a class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\" [routerLink]=\"buildUrl(segment)\" title=\"{{ getLabel(segment) }}\"> {{ getLabel(segment) | uxTruncate : truncateSize }} </a> </li> <li *ngIf=\"last\" class=\"ecl-breadcrumb__segment ecl-breadcrumb__segment--last\"> <span class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\"> {{ getLabel(segment) | uxTruncate : truncateSize }} </span> </li> </ng-container> </ol> </nav> </ng-container> ",
                        changeDetection: core.ChangeDetectionStrategy.Default,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutBreadcrumbsComponent.ctorParameters = function () { return [
            { type: router.Router, },
            { type: router.ActivatedRoute, },
            { type: UxBreadcrumbsService, },
        ]; };
        UxLayoutBreadcrumbsComponent.propDecorators = {
            "homeUrl": [{ type: core.Input },],
            "homeUrlLabel": [{ type: core.Input },],
            "truncateSize": [{ type: core.Input },],
            "isECL": [{ type: core.Input },],
            "closeBreadcrumbsMenu": [{ type: core.HostListener, args: ['body:click',] },],
        };
        return UxLayoutBreadcrumbsComponent;
    }());
    var UxLayoutBreadcrumbsComponentModule = (function () {
        function UxLayoutBreadcrumbsComponentModule() {
        }
        UxLayoutBreadcrumbsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule, UxTruncatePipeModule],
                        exports: [UxLayoutBreadcrumbsComponent],
                        declarations: [UxLayoutBreadcrumbsComponent],
                        providers: [core$1.TranslateService],
                    },] },
        ];
        return UxLayoutBreadcrumbsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutTopMessageComponent = (function () {
        function UxLayoutTopMessageComponent() {
        }
        UxLayoutTopMessageComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-top-message',
                        template: "\n        <div class=\"ux-top-message {{styleClass}} ux-top-message--{{typeClass}}\">\n            <ng-content></ng-content>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutTopMessageComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
        };
        return UxLayoutTopMessageComponent;
    }());
    var UxLayoutTopMessageComponentModule = (function () {
        function UxLayoutTopMessageComponentModule() {
        }
        UxLayoutTopMessageComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutTopMessageComponent],
                        declarations: [UxLayoutTopMessageComponent]
                    },] },
        ];
        return UxLayoutTopMessageComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutBannerComponent = (function () {
        function UxLayoutBannerComponent() {
        }
        UxLayoutBannerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-banner',
                        template: "\n        <div class=\"ux-layout-banner {{styleClass}}\">\n            <div class=\"ux-layout-banner__content\">\n                <ng-content></ng-content>\n             </div>\n        </div>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutBannerComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
        };
        return UxLayoutBannerComponent;
    }());
    var UxLayoutBannerComponentModule = (function () {
        function UxLayoutBannerComponentModule() {
        }
        UxLayoutBannerComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutBannerComponent],
                        declarations: [UxLayoutBannerComponent]
                    },] },
        ];
        return UxLayoutBannerComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutHorizontalComponent = (function () {
        function UxLayoutHorizontalComponent() {
        }
        UxLayoutHorizontalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-horizontal',
                        template: "<div class=\"ux-o-layout-horizontal {{styleClass}}\"> <div class=\"ux-o-layout-horizontal__left\"><ng-content select=\"uxLayoutHorizontalLeft\"></ng-content></div> <div class=\"ux-o-layout-horizontal__center\"><ng-content select=\"uxLayoutHorizontalCenter\"></ng-content></div> <div class=\"ux-o-layout-horizontal__right\"><ng-content select=\"uxLayoutHorizontalRight\"></ng-content></div> </div> ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutHorizontalComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
        };
        return UxLayoutHorizontalComponent;
    }());
    var UxLayoutHorizontalLeftTagDirective = (function () {
        function UxLayoutHorizontalLeftTagDirective() {
        }
        UxLayoutHorizontalLeftTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHorizontalLeft' },] },
        ];
        return UxLayoutHorizontalLeftTagDirective;
    }());
    var UxLayoutHorizontalRightTagDirective = (function () {
        function UxLayoutHorizontalRightTagDirective() {
        }
        UxLayoutHorizontalRightTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHorizontalRight' },] },
        ];
        return UxLayoutHorizontalRightTagDirective;
    }());
    var UxLayoutHorizontalCenterTagDirective = (function () {
        function UxLayoutHorizontalCenterTagDirective() {
        }
        UxLayoutHorizontalCenterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutHorizontalCenter' },] },
        ];
        return UxLayoutHorizontalCenterTagDirective;
    }());
    var UxLayoutHorizontalModule = (function () {
        function UxLayoutHorizontalModule() {
        }
        UxLayoutHorizontalModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            UxLayoutHorizontalComponent,
                            UxLayoutHorizontalLeftTagDirective,
                            UxLayoutHorizontalRightTagDirective,
                            UxLayoutHorizontalCenterTagDirective
                        ],
                        declarations: [
                            UxLayoutHorizontalComponent,
                            UxLayoutHorizontalLeftTagDirective,
                            UxLayoutHorizontalRightTagDirective,
                            UxLayoutHorizontalCenterTagDirective
                        ]
                    },] },
        ];
        return UxLayoutHorizontalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutPageHeaderComponent = (function () {
        function UxLayoutPageHeaderComponent(asService) {
            this.asService = asService;
            this.isLarge = false;
            this.isHighlighted = false;
            this.isECL = false;
            this.hasECLBreadcrumb = false;
            this.highlightedClasses = 'ux-u-z-highlighted ux-u-p-relative ux-u-color-white';
            this.pageTitleStateClass = '';
        }
        /**
         * @return {?}
         */
        UxLayoutPageHeaderComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this.pageSubtitle) {
                this.pageTitleStateClass = 'ux-layout-page-header__title--no-subtitle ';
            }
            if (this.isLarge) {
                this.pageTitleStateClass += 'page-title--large';
            }
        };
        UxLayoutPageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-page-header',
                        template: "<ng-container *ngIf=\"!isECL\"> <div *ngIf=\"!(asService.breakpoints$ | async).isMobile\"> <div class=\"ux-layout-page-header-wrapper\"> <div class=\"ux-layout-page-header\"> <div class=\"ux-layout-page-header__title page-title {{pageTitleStateClass}}\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageTitle}} </div> <ng-container *ngTemplateOutlet=\"actions\"></ng-container> </div> <div *ngIf=\"pageSubtitle\" class=\"ux-layout-page-header__sub-title\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\" title=\"{{pageSubtitle}}\"> <span class=\"page-sub-title\">{{pageSubtitle}}</span> </div> </div> </div> <div *ngIf=\"(asService.breakpoints$ | async).isMobile\"> <div class=\"ux-layout-page-header-wrapper ux-layout-page-header-wrapper--mobile\"> <ng-container *ngTemplateOutlet=\"actions\"></ng-container> <div class=\"ux-layout-page-header mt-2\"> <div class=\"ux-layout-page-header__title page-title {{pageTitleStateClass}}\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageTitle}} </div> </div> <div *ngIf=\"pageSubtitle\" class=\"ux-layout-page-header__sub-title page-sub-title\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageSubtitle}} </div> </div> </div> <ng-template #actions> <div class=\"ux-layout-page-header__actions\" [class.ml-auto]=\"!(asService.breakpoints$ | async).isMobile\"> <div *ngIf=\"customActionsContent\" class=\"ux-layout-page-header__actions-content\"> <ng-content select=\"uxLayoutPageHeaderActionsContent\"></ng-content> </div> <ul *ngIf=\"customActionIconsContent\" class=\"ux-layout-page-header__actions-icons\"> <ng-content select=\"uxLayoutPageHeaderActionIconsContent\"></ng-content> </ul> </div> </ng-template> </ng-container> <ng-container *ngIf=\"isECL\"> <div class=\"ecl-page-header\"> <div class=\"ecl-container\"> <ux-layout-breadcrumbs [isECL]=\"true\" *ngIf=\"hasECLBreadcrumb\"></ux-layout-breadcrumbs> <div class=\"ecl-page-header__body\"> <div class=\"ecl-page-header__identity\"> {{pageTitle}} </div> </div> </div> </div> </ng-container> ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutPageHeaderComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxLayoutPageHeaderComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "pageTitle": [{ type: core.Input },],
            "pageSubtitle": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isHighlighted": [{ type: core.Input },],
            "isECL": [{ type: core.Input },],
            "hasECLBreadcrumb": [{ type: core.Input },],
            "customActionsContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutPageHeaderActionsContentTagDirective;
                        }),] },],
            "customActionIconsContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutPageHeaderActionIconsContentTagDirective;
                        }),] },],
        };
        return UxLayoutPageHeaderComponent;
    }());
    var UxLayoutPageHeaderActionsContentTagDirective = (function () {
        function UxLayoutPageHeaderActionsContentTagDirective() {
        }
        UxLayoutPageHeaderActionsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutPageHeaderActionsContent' },] },
        ];
        return UxLayoutPageHeaderActionsContentTagDirective;
    }());
    var UxLayoutPageHeaderActionIconsContentTagDirective = (function () {
        function UxLayoutPageHeaderActionIconsContentTagDirective() {
        }
        UxLayoutPageHeaderActionIconsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutPageHeaderActionIconsContent' },] },
        ];
        return UxLayoutPageHeaderActionIconsContentTagDirective;
    }());
    var UxLayoutPageHeaderComponentModule = (function () {
        function UxLayoutPageHeaderComponentModule() {
        }
        UxLayoutPageHeaderComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxLayoutBreadcrumbsComponentModule,
                        ],
                        exports: [
                            UxLayoutPageHeaderComponent,
                            UxLayoutPageHeaderActionsContentTagDirective,
                            UxLayoutPageHeaderActionIconsContentTagDirective,
                        ],
                        declarations: [
                            UxLayoutPageHeaderComponent,
                            UxLayoutPageHeaderActionsContentTagDirective,
                            UxLayoutPageHeaderActionIconsContentTagDirective,
                        ]
                    },] },
        ];
        return UxLayoutPageHeaderComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutPageHeaderActionIconItemComponent = (function () {
        function UxLayoutPageHeaderActionIconItemComponent() {
        }
        UxLayoutPageHeaderActionIconItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-page-header-action-icon-item',
                        template: "\n        <li class=\"ux-layout-page-header__actions-icons__item\">\n            <span class=\"{{iconClass}}\"></span>\n        </li>\n    ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutPageHeaderActionIconItemComponent.propDecorators = {
            "iconClass": [{ type: core.Input },],
        };
        return UxLayoutPageHeaderActionIconItemComponent;
    }());
    var UxLayoutPageHeaderActionIconItemComponentModule = (function () {
        function UxLayoutPageHeaderActionIconItemComponentModule() {
        }
        UxLayoutPageHeaderActionIconItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            UxLayoutPageHeaderActionIconItemComponent,
                        ],
                        declarations: [
                            UxLayoutPageHeaderActionIconItemComponent,
                        ]
                    },] },
        ];
        return UxLayoutPageHeaderActionIconItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutFooterActionBarComponent = (function () {
        function UxLayoutFooterActionBarComponent() {
            this.dismissActionLabel = 'Cancel';
            this.dismissActionDisabled = false;
            this.acceptActionLabel = 'OK';
            this.acceptActionDisabled = false;
            this.onDismiss = new core.EventEmitter();
            this.onAccept = new core.EventEmitter();
        }
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutFooterActionBarComponent.prototype.onDismissClicked = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.onDismiss.emit(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutFooterActionBarComponent.prototype.onAcceptClicked = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.onAccept.emit(event);
        };
        UxLayoutFooterActionBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-layout-footer-action-bar',
                        template: "<div class=\"ux-layout-footer-action-bar-wrapper\"> <div class=\"ux-layout-footer-action-bar {{styleClass}}\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxLayoutFooterActionBarContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <div class=\"row\"> <div class=\"col\"> <button class=\"btn btn-secondary btn-block\" [disabled]=\"dismissActionDisabled\" (click)=\"onDismissClicked($event)\"> {{dismissActionLabel}} </button> </div> <div class=\"col\"> <button class=\"btn btn-primary btn-block\" [disabled]=\"acceptActionDisabled\" (click)=\"onAcceptClicked($event)\"> {{acceptActionLabel}} </button> </div> </div> </ng-template> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxLayoutFooterActionBarComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "dismissActionLabel": [{ type: core.Input },],
            "dismissActionDisabled": [{ type: core.Input },],
            "acceptActionLabel": [{ type: core.Input },],
            "acceptActionDisabled": [{ type: core.Input },],
            "onDismiss": [{ type: core.Output },],
            "onAccept": [{ type: core.Output },],
            "customContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxLayoutFooterActionBarContentTagDirective;
                        }),] },],
        };
        return UxLayoutFooterActionBarComponent;
    }());
    var UxLayoutFooterActionBarContentTagDirective = (function () {
        function UxLayoutFooterActionBarContentTagDirective() {
        }
        UxLayoutFooterActionBarContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxLayoutFooterActionBarContent' },] },
        ];
        return UxLayoutFooterActionBarContentTagDirective;
    }());
    var UxLayoutFooterActionBarComponentModule = (function () {
        function UxLayoutFooterActionBarComponentModule() {
        }
        UxLayoutFooterActionBarComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLayoutFooterActionBarComponent, UxLayoutFooterActionBarContentTagDirective],
                        declarations: [UxLayoutFooterActionBarComponent, UxLayoutFooterActionBarContentTagDirective]
                    },] },
        ];
        return UxLayoutFooterActionBarComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxToolbarFilterComponent = (function () {
        function UxToolbarFilterComponent(uxService) {
            this.uxService = uxService;
            this.isVisible = false;
            this.isFilterVisible = true;
            this.isToggleVisible = true;
            this.isToggleExpanded = false;
            this.filter = new core.EventEmitter();
            this.expandAll = new core.EventEmitter();
            this.collapseAll = new core.EventEmitter();
            this.filterValue = '';
        }
        /**
         * @return {?}
         */
        UxToolbarFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this.filterLabel) {
                this.translatedFilterLabel = this.uxService.translate('filter');
            }
            else {
                this.translatedFilterLabel = this.filterLabel;
            }
            if (!this.expandAllLabel) {
                this.translatedExpandAllLabel = this.uxService.translate('expandAll');
            }
            else {
                this.translatedExpandAllLabel = this.expandAllLabel;
            }
            if (!this.collapseAllLabel) {
                this.translatedCollapseAllLabel = this.uxService.translate('collapseAll');
            }
            else {
                this.translatedCollapseAllLabel = this.collapseAllLabel;
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxToolbarFilterComponent.prototype.onFilter = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.filterValue === '') {
                if (!this.isToggleExpanded) {
                    this.collapseAll.emit(null);
                }
            }
            this.filter.emit(this.filterValue);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxToolbarFilterComponent.prototype.onExpandAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isToggleExpanded = !this.isToggleExpanded;
            this.expandAll.emit(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxToolbarFilterComponent.prototype.onCollapseAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isToggleExpanded = !this.isToggleExpanded;
            this.collapseAll.emit(event);
        };
        UxToolbarFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-toolbar-filter',
                        template: "<div *ngIf=\"isVisible\" class=\"ux-a-toolbar-filter\"> <div class=\"ux-a-toolbar-filter-content\"> <div *ngIf=\"isFilterVisible\" class=\"ux-a-toolbar-filter-filter\"> <div class=\"input-group\"> <span class=\"input-group-prepend\"> <span class=\"input-group-text\"> <span class=\"ux-icon ux-icon-search\"></span> </span> </span> <input type=\"text\" class=\"form-control ux-a-toolbar-filter-filter-input\" placeholder=\"{{translatedFilterLabel}}\" [(ngModel)]=\"filterValue\" (keyup)=\"onFilter($event)\"/> </div> </div> <div *ngIf=\"isToggleVisible\" class=\"ux-a-toolbar-filter-trigger-wrapper\"> <button type=\"button\" *ngIf=\"!isToggleExpanded\" class=\"ux-a-toolbar-filter-trigger btn btn-secondary\" (click)=\"onExpandAll($event)\"> <span class=\"ux-icon ux-icon-level-down ux-a-toolbar-filter-trigger-icon\"></span> {{translatedExpandAllLabel}} </button> <button type=\"button\" *ngIf=\"isToggleExpanded\" class=\"ux-a-toolbar-filter-trigger btn btn-secondary\" (click)=\"onCollapseAll($event)\"> <span class=\"ux-icon ux-icon-level-up ux-a-toolbar-filter-trigger-icon\"></span> {{translatedCollapseAllLabel}} </button> <ng-content select=\"uxToolbarFilterButtons\"></ng-content> </div> <div class=\"ml-auto d-flex-none\"> <ng-content></ng-content> </div> </div> </div> ",
                        styles: [".ux-a-toolbar-filter{padding:.66rem}.ux-a-toolbar-filter-content{align-items:center;display:flex;flex-shrink:0}.ux-a-toolbar-filter-trigger-wrapper{display:flex;flex-shrink:0}.ux-a-toolbar-filter-trigger{margin-right:.33rem}.ux-a-toolbar-filter-filter{margin-right:.33rem;position:relative;width:100%}.ux-a-toolbar-filter-filter-input{width:100%}.ux-a-toolbar-filter-filter-input-search-icon{position:absolute;right:.66rem;top:.66rem} /*# sourceMappingURL=ux-a-toolbar-filter.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxToolbarFilterComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxToolbarFilterComponent.propDecorators = {
            "isVisible": [{ type: core.Input },],
            "filterLabel": [{ type: core.Input },],
            "expandAllLabel": [{ type: core.Input },],
            "collapseAllLabel": [{ type: core.Input },],
            "isFilterVisible": [{ type: core.Input },],
            "isToggleVisible": [{ type: core.Input },],
            "isToggleExpanded": [{ type: core.Input },],
            "filter": [{ type: core.Output },],
            "expandAll": [{ type: core.Output },],
            "collapseAll": [{ type: core.Output },],
        };
        return UxToolbarFilterComponent;
    }());
    var UxToolbarFilterButtonsTagDirective = (function () {
        function UxToolbarFilterButtonsTagDirective() {
        }
        UxToolbarFilterButtonsTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxToolbarFilterButtons' },] },
        ];
        return UxToolbarFilterButtonsTagDirective;
    }());
    var UxToolbarFilterComponentModule = (function () {
        function UxToolbarFilterComponentModule() {
        }
        UxToolbarFilterComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule],
                        exports: [UxToolbarFilterComponent, UxToolbarFilterButtonsTagDirective],
                        declarations: [UxToolbarFilterComponent, UxToolbarFilterButtonsTagDirective]
                    },] },
        ];
        return UxToolbarFilterComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPanelsComponent = (function () {
        function UxPanelsComponent(uxService) {
            this.uxService = uxService;
            this.isShowToolbar = false;
            this.isShowToolbarExtendedPanelsToggle = false;
            this.openAllPanelsLabel = 'Open all panels';
            this.closeAllPanelsLabel = 'Close all panels';
            this.filterLabel = 'Filter panels';
            this.goToPanelsLabel = 'Go to panel';
            this.isMultipleExpanded = true;
            this.isAllPanelsExpandable = false;
            this.isDebug = false;
            this.isFilterVisible = true;
            this.isShowInvalidPanelsOnly = false;
            this.isAccordionPanels = false;
            this.isAllPanelsExpanded = false;
            this.panelExpanded = new core.EventEmitter();
            this.panelsFilter = '';
            this.extendedPanelsLinks = [];
        }
        /**
         * @return {?}
         */
        UxPanelsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ isAccordionPanels = this.isAccordionPanels;
            if (isAccordionPanels) {
                this.isMultipleExpanded = false;
                this.isAllPanelsExpandable = true;
            }
            setTimeout(function () {
                if (_this.isAllPanelsExpandable) {
                    _this.panels.forEach(function (i) {
                        i.isExpandable = true;
                        if (!i.isExpandedInitialState) {
                            i.isExpanded = false;
                        }
                        if (isAccordionPanels) {
                            i.isAccordionPanel = true;
                        }
                    });
                }
                if (_this.isAllPanelsExpanded) {
                    _this.openAllPanels(null);
                }
            });
            this.panels.forEach(function (panel, i) {
                _this.extendedPanelsLinks.push(new UxLink({
                    label: panel.label, iconClass: panel.iconClass,
                    command: function () { return _this.selectPanel(i); }
                }));
            });
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxPanelsComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ isShowInvalidPanelsOnly = this.isShowInvalidPanelsOnly;
            var /** @type {?} */ customStateFilterValue = this.customStateFilterValue;
            if (this.panelsChildren) {
                if (changes['isShowInvalidPanelsOnly']) {
                    this.panelsChildren.forEach(function (i) {
                        if (!i.hasStatusIndicator && i.statusIndicatorTypeClass !== 'info') {
                            // i.isVisible = !isShowInvalidPanelsOnly;
                            i.showOnlyInvalid = isShowInvalidPanelsOnly;
                        }
                        else {
                            i.isExpanded = true;
                        }
                    });
                }
                if (changes['customStateFilterValue']) {
                    this.panels.forEach(function (i) {
                        if (customStateFilterValue && customStateFilterValue !== '') {
                            i.isVisible = (i.customState === customStateFilterValue);
                        }
                        else {
                            i.isVisible = true;
                        }
                    });
                }
            }
        };
        /**
         * @param {?} filterValue
         * @return {?}
         */
        UxPanelsComponent.prototype.onFilter = /**
         * @param {?} filterValue
         * @return {?}
         */
        function (filterValue) {
            this.panelsFilter = filterValue;
            this.filterPanels();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        UxPanelsComponent.prototype.selectPanel = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            var /** @type {?} */ selectedPanel = this.panels.toArray()[index];
            this.closeAllPanels(null);
            selectedPanel.isExpanded = true;
            window.scrollTo(0, selectedPanel.HTMLElement.getBoundingClientRect().top - 150);
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxPanelsComponent.prototype.collapseAll = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.panels.forEach(function (i) {
                if (i !== item) {
                    i.isExpanded = false;
                }
            });
            this.panelExpanded.emit(item.id);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelsComponent.prototype.openAllPanels = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.panels.forEach(function (i) {
                i.isExpanded = true;
            });
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelsComponent.prototype.closeAllPanels = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.panels.forEach(function (i) {
                i.isExpanded = false;
            });
            this.uxService.consumeEvent(event);
        };
        /**
         * @return {?}
         */
        UxPanelsComponent.prototype.filterPanels = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.customPanelsFilter) {
                if (this.panelsFilter !== '') {
                    this.panels.forEach(function (i) {
                        i.isVisible = false;
                    });
                    this.panels.forEach(function (i) {
                        if (i.filterInput) {
                            if (i.filterInput.toUpperCase().indexOf(_this.panelsFilter.toUpperCase()) !== -1) {
                                i.isVisible = true;
                            }
                        }
                        else {
                            if (i.label.toUpperCase().indexOf(_this.panelsFilter.toUpperCase()) !== -1) {
                                i.isVisible = true;
                            }
                        }
                    });
                }
                else {
                    this.panels.forEach(function (i) {
                        i.isVisible = true;
                    });
                }
            }
            else {
                this.customPanelsFilter.filter(this.panels, this.panelsFilter);
            }
        };
        UxPanelsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-panels',
                        template: "\n\n        <div *ngIf=\"isShowToolbar\" class=\"ux-panel-toolbar\">\n            <ux-a-toolbar-filter [isVisible]=\"true\"\n                                [filterLabel]=\"filterLabel\"\n                                [expandAllLabel]=\"openAllPanelsLabel\"\n                                [collapseAllLabel]=\"closeAllPanelsLabel\"\n                                [isFilterVisible]=\"isFilterVisible\"\n                                [isToggleExpanded]=\"isAllPanelsExpanded\"\n                                (filter)=\"onFilter($event)\"\n                                (expandAll)=\"openAllPanels($event)\"\n                                (collapseAll)=\"closeAllPanels($event)\">\n                <uxToolbarFilterButtons>\n                    <ux-dropdown-button *ngIf=\"isShowToolbarExtendedPanelsToggle\"\n                        label=\"{{goToPanelsLabel}}\" iconClass=\"ux-icon ux-icon-bars\"\n                        [links]=\"extendedPanelsLinks\">\n                    </ux-dropdown-button>\n                </uxToolbarFilterButtons>\n            </ux-a-toolbar-filter>\n        </div>\n\n        <ul class=\"panels\">\n            <ng-content></ng-content>\n        </ul>"
                    },] },
        ];
        /** @nocollapse */
        UxPanelsComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxPanelsComponent.propDecorators = {
            "isShowToolbar": [{ type: core.Input },],
            "isShowToolbarExtendedPanelsToggle": [{ type: core.Input },],
            "openAllPanelsLabel": [{ type: core.Input },],
            "closeAllPanelsLabel": [{ type: core.Input },],
            "filterLabel": [{ type: core.Input },],
            "goToPanelsLabel": [{ type: core.Input },],
            "isMultipleExpanded": [{ type: core.Input },],
            "isAllPanelsExpandable": [{ type: core.Input },],
            "isDebug": [{ type: core.Input },],
            "isFilterVisible": [{ type: core.Input },],
            "isShowInvalidPanelsOnly": [{ type: core.Input },],
            "isAccordionPanels": [{ type: core.Input },],
            "customStateFilterValue": [{ type: core.Input },],
            "customPanelsFilter": [{ type: core.Input },],
            "isAllPanelsExpanded": [{ type: core.Input },],
            "panelExpanded": [{ type: core.Output },],
            "panels": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxPanelComponent; }), { descendants: true },] },],
            "panelsChildren": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxPanelComponent; }), { descendants: false },] },],
        };
        return UxPanelsComponent;
    }());
    var UxPanelsComponentModule = (function () {
        function UxPanelsComponentModule() {
        }
        UxPanelsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, UxDropdownButtonComponentModule, UxToolbarFilterComponentModule],
                        exports: [UxPanelsComponent],
                        declarations: [UxPanelsComponent]
                    },] },
        ];
        return UxPanelsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPanelComponent = (function () {
        function UxPanelComponent(uxPanelsComponent, el, render, uxService, uxDomService) {
            this.render = render;
            this.uxService = uxService;
            this.uxDomService = uxDomService;
            this.isIconRounded = false;
            this.isExpandable = false;
            this.isExpanded = false;
            this.isVisible = true;
            this.isSelected = false;
            this.isCollapsible = false;
            this.isCollapsed = false;
            this.badgeTypeClass = 'primary';
            this.hasTabs = false;
            this.hasNoHeader = false;
            this.hasNoContentPadding = false;
            this.isBlocked = false;
            this.isBlockedAriaLabel = 'loading';
            this.maxHeight = 'none';
            this.contentHeight = 'none';
            this.isFlat = false;
            this.isLargeHeader = false;
            this.isLargeFooter = false;
            this.isSmallHeader = false;
            this.hasStatusIndicator = false;
            this.statusIndicatorTypeClass = 'warning';
            this.statusIndicatorMessageLabel = 'Status indicator default message';
            this.isTogglableStatusIndicatorContent = true;
            this.isStatusIndicatorContentExpanded = false;
            this.hasStatusIndicatorHeaderBg = false;
            this.hasStatusIndicatorHeaderIcon = false;
            this.isEditModeActive = false;
            this.isContainerOnly = false;
            this.isClickable = false;
            this.isHighlighted = false;
            this.isAccordionPanel = false;
            this.tabindex = '0';
            this.isSticky = false;
            this.panelExpanded = new core.EventEmitter();
            this.panelCollapsed = new core.EventEmitter();
            this.showOnlyInvalid = false;
            this.statusIndicatorIconClass = '';
            this.labelThemeClass = '';
            this.isExpandedInitialState = false;
            // panel states
            this.hasMaxHeight = false;
            this.hasContentHeight = false;
            this.stateExpandableClass = '';
            this.stateTabsClass = '';
            this.statePanelItemClasses = '';
            this.statePanelHeaderClasses = '';
            this.statePanelContentClasses = '';
            this.stickyContentYOffset = 14;
            this.onScrollBind = this.onScroll.bind(this);
            this.onResizeBind = this.onResize.bind(this);
            this.sticked = true;
            this.selectedOffset = 0;
            this.windowOffsetTop = 0;
            this.offSet = 0;
            this.addClass = 'fixed';
            this.uxPanelsComponent = uxPanelsComponent;
            this.HTMLElement = el.nativeElement;
            this.selectedOffset = this.HTMLElement.offsetTop;
        }
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.isSticky) {
                window.addEventListener('scroll', this.onScrollBind);
                window.addEventListener('resize', this.onResizeBind);
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.onScroll = /**
         * @return {?}
         */
        function () {
            this.onWindowScroll();
            this.handleStickyPanel();
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.onResize = /**
         * @return {?}
         */
        function () {
            this.handleStickyPanel();
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.onWindowScroll = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ offset = this.HTMLElement.offsetTop;
            this.windowOffsetTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
            if (this.selectedOffset === 0) {
                this.selectedOffset = offset;
            }
            if (this.sticked === false) {
                this.selectedOffset = offset;
            }
            if ((this.windowOffsetTop + this.offSet) > this.selectedOffset) {
                this.addSticky();
            }
            else {
                this.removeSticky();
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.handleStickyPanel = /**
         * @return {?}
         */
        function () {
            if (this.stickyContentElementRef) {
                var /** @type {?} */ effectiveTopOffset = '';
                var /** @type {?} */ stickyContentTopOffset = this.stickyContainerElementRef.nativeElement.getBoundingClientRect().top;
                if (stickyContentTopOffset < 0) {
                    effectiveTopOffset = -stickyContentTopOffset + this.stickyContentYOffset + 'px';
                }
                this.stickyContentElementRef.nativeElement.style.top = effectiveTopOffset;
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            // Bugfix: prevent "flashing" of content being visible, then suddenly being invisible again.
            // This side-effect is caused by the parent <ux-panels> tag that sets the panels as accordion with a setTimeout().
            // That means: panels are visible by default, are rendered, then hidden again after becoming an accordion...
            if (this.uxPanelsComponent && this.uxPanelsComponent.isAccordionPanels) {
                this.isExpandable = true;
            }
            // end bugfix
            if (!this.contentId) {
                this.contentId = this.uxService.uniqueId();
            }
            this.isExpandedInitialState = this.isExpanded;
            if (!this.isExpandable) {
                this.isExpanded = true;
            }
            this.actualMaxHeight = this.maxHeight;
            // setting panel states
            if (this.maxHeight !== 'none') {
                this.hasMaxHeight = true;
            }
            if (this.contentHeight !== 'none') {
                this.hasContentHeight = true;
                this.actualMaxHeight = this.contentHeight;
            }
            if (this.hasTabs) {
                this.stateTabsClass = 'ux-panel-item--has-tabs';
            }
            if (this.isContainerOnly) {
                this.hasNoHeader = true;
                this.hasNoContentPadding = true;
            }
            if (this.hasNoHeader) {
                this.statePanelItemClasses += 'ux-panel-item--no-header ';
            }
            if (this.hasTabs) {
                this.statePanelItemClasses += 'ux-panel-item--has-tabs ';
            }
            if (this.isFlat) {
                this.statePanelItemClasses += 'ux-panel-item--flat ';
            }
            if (this.isClickable) {
                this.statePanelItemClasses += 'ux-panel-item--clickable ';
            }
            if (this.isLargeHeader) {
                this.statePanelHeaderClasses += 'ux-panel-header--large ';
            }
            if (this.isSmallHeader) {
                this.statePanelHeaderClasses += 'ux-panel-header--small ';
            }
            if (this.hasStatusIndicator && this.hasStatusIndicatorHeaderBg && !this.hasStatusIndicatorHeaderIcon) {
                this.statePanelItemClasses += 'ux-panel-item--' + this.statusIndicatorTypeClass;
                this.labelThemeClass = 'white';
            }
            // Cfr. EUI-1097
            // if (this.hasStatusIndicator && !this.hasStatusIndicatorHeaderBg && !this.hasStatusIndicatorHeaderIcon) {
            //     this.statePanelHeaderClasses += 'ux-u-border-l-' + this.statusIndicatorTypeClass;
            // }
            if (!this.isTogglableStatusIndicatorContent) {
                this.isStatusIndicatorContentExpanded = true;
            }
            if (this.hasNoContentPadding) {
                this.statePanelContentClasses += 'ux-panel-content--no-padding ';
            }
            if (this.isBlocked) {
                this.statePanelContentClasses += 'ux-panel-content--blocked';
            }
            // status indicator icon class
            if (this.statusIndicatorTypeClass === 'warning') {
                this.statusIndicatorIconClass = 'exclamation';
            }
            else if (this.statusIndicatorTypeClass === 'danger') {
                this.statusIndicatorIconClass = 'times';
            }
            else if (this.statusIndicatorTypeClass === 'info') {
                this.statusIndicatorIconClass = 'info';
            }
            else if (this.statusIndicatorTypeClass === 'success') {
                this.statusIndicatorIconClass = 'check';
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            window.removeEventListener('scroll', this.onScrollBind);
            window.removeEventListener('resize', this.onResizeBind);
        };
        Object.defineProperty(UxPanelComponent.prototype, "statePanelItemClassesDynamic", {
            get: /**
             * @return {?}
             */
            function () {
                var /** @type {?} */ panelItemClasses = '';
                if (this.isSelected) {
                    panelItemClasses += 'ux-panel-item--selected ';
                }
                if (this.isHighlighted) {
                    panelItemClasses += 'ux-panel-item--highlighted ';
                }
                return panelItemClasses;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "statePanelContentClassesDynamic", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isEditModeActive) {
                    return 'ux-panel-content--edit-mode-active';
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelHeader", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelHeader.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelFooter", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelFooter.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelHeaderRightContent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelHeaderRightContent.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelHeaderWithDescendants", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelHeaderWithDescendants.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelFooterWithDescendants", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelFooterWithDescendants.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxPanelComponent.prototype, "hasCustomPanelHeaderRightContentWithDescendants", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customPanelHeaderRightContentWithDescendants.length !== 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelComponent.prototype.toggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ el;
            if (event) {
                el = /** @type {?} */ (event.target);
            }
            if (!event ||
                el.classList.contains('ux-panel-header') ||
                el.classList.contains('ux-a-label__label') ||
                el.classList.contains('ux-panel-header__expand-toggle') ||
                el.parentElement && el.parentElement.classList.contains('ux-a-label__label')) {
                if (this.isExpandable) {
                    if (this.uxPanelsComponent) {
                        if (!this.uxPanelsComponent.isMultipleExpanded) {
                            this.uxPanelsComponent.collapseAll(this);
                        }
                    }
                    this.isExpanded = !this.isExpanded;
                    this.panelExpanded.emit(this.id);
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelComponent.prototype.toggleMaxHeight = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.maxHeight !== this.actualMaxHeight) {
                this.actualMaxHeight = this.maxHeight;
            }
            else {
                this.actualMaxHeight = 'none';
            }
        };
        Object.defineProperty(UxPanelComponent.prototype, "isMaxHeightExpanded", {
            get: /**
             * @return {?}
             */
            function () {
                return this.actualMaxHeight === 'none';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.onToggleStatusIndicatorContent = /**
         * @return {?}
         */
        function () {
            this.isStatusIndicatorContentExpanded = !this.isStatusIndicatorContentExpanded;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelComponent.prototype.onCollapsibleButtonClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isCollapsed = !this.isCollapsed;
            this.panelCollapsed.emit(this.isCollapsed);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPanelComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case 13: // ENTER
                case 32:
                    // SPACE
                    var /** @type {?} */ target = /** @type {?} */ (event.target);
                    if (!this.uxDomService.closestMatchingParent(target, 'ux-panel-header__right-content')) {
                        this.toggle(null);
                        this.uxService.consumeEvent(event);
                    }
                    break;
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.addSticky = /**
         * @return {?}
         */
        function () {
            this.sticked = true;
            this.HTMLElement.style.position = 'fixed';
            this.HTMLElement.style.top = this.offSet + 'px';
            this.render.addClass(this.HTMLElement, this.addClass);
            if (this.isHighlighted) {
                this.render.addClass(this.HTMLElement, 'ux-panel-item--highlighted');
            }
        };
        /**
         * @return {?}
         */
        UxPanelComponent.prototype.removeSticky = /**
         * @return {?}
         */
        function () {
            this.sticked = false;
            this.HTMLElement.style.position = '';
            this.render.removeClass(this.HTMLElement, this.addClass);
            if (this.isHighlighted) {
                this.render.removeClass(this.HTMLElement, 'ux-panel-item--highlighted');
            }
        };
        UxPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-panel',
                        template: "<div #stickyContainer></div> <div class=\"ux-panel\" [class.ux-panel--is-collapsible]=\"isCollapsible\"> <ng-template [ngIf]=\"isCollapsible\"> <div class=\"ux-panel__collapsible-button\" [class.ux-panel__collapsible-button--collapsed]=\"isCollapsed\" (click)=\"onCollapsibleButtonClick($event)\"> <i class=\"ux-icon\" [ngClass]=\"isCollapsed ? 'ux-icon-caret-right' : 'ux-icon-caret-left'\"></i> </div> </ng-template> <div *ngIf=\"isVisible && !showOnlyInvalid && !isCollapsed\" class=\"ux-panel-item {{styleClass}} {{statePanelItemClasses}} {{statePanelItemClassesDynamic}}\" #stickyContent> <span *ngIf=\"hasStatusIndicator && hasStatusIndicatorHeaderIcon\" class=\"ux-panel-item__status-indicator-icon-wrapper ux-u-bg-color-{{statusIndicatorTypeClass}}-dark\"> <span class=\"ux-panel-item__status-indicator-icon-wrapper-icon ux-icon ux-icon-{{statusIndicatorIconClass}}\"></span> </span> <ng-template [ngIf]=\"hasCustomPanelHeader\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ng-content select=\"uxPanelHeader\"></ng-content> <span *ngIf=\"isExpandable\" class=\"ux-panel-header__expand-toggle ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span> </div> </ng-template> <ng-template [ngIf]=\"hasCustomPanelHeaderWithDescendants\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ng-content select=\"uxPanelHeaderWithDescendants\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"!hasCustomPanelHeader && !hasCustomPanelHeaderWithDescendants\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" badgeLabel=\"{{badgeLabel}}\" badgeTypeClass=\"{{badgeTypeClass}}\" infos=\"{{labelInfos}}\" iconClass=\"{{iconClass}}\" iconTypeClass=\"{{iconTypeClass}}\" themeClass=\"{{labelThemeClass}}\" [isIconRounded]=\"isIconRounded\" subLabelSizeLimit=\"{{subLabelSizeLimit}}\" [isBoldLabel]=\"true\" tabindex=\"-1\"> </ux-a-label> <div [id]=\"contentId\" class=\"ux-panel-header__right-content\"> <ng-template [ngIf]=\"hasCustomPanelHeaderRightContent\"> <ng-content select=\"uxPanelHeaderRightContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"hasCustomPanelHeaderRightContentWithDescendants\"> <ng-content select=\"uxPanelHeaderRightContentWithDescendants\"></ng-content> </ng-template> <ng-template [ngIf]=\"!hasCustomPanelHeaderRightContent && !hasCustomPanelHeaderRightContentWithDescendants\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\"></ux-a-tag> </ng-template> <span *ngIf=\"isExpandable\" class=\"ux-panel-header__expand-toggle ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span> </div> </div> </ng-template> <ng-template [ngIf]=\"customSubHeaderContent\"> <div class=\"ux-panel-header__sub-header\"> <ng-content select=\"uxPanelSubHeaderContent\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"hasStatusIndicator && customStatusIndicatorContent\"> <div class=\"ux-panel-header__status-indicator-wrapper\"> <span class=\"ux-panel-header__status-indicator-wrapper-label ux-u-color-{{statusIndicatorTypeClass}}-darkest\"> {{statusIndicatorMessageLabel}} </span> <a *ngIf=\"isTogglableStatusIndicatorContent\" (click)=\"onToggleStatusIndicatorContent()\" class=\"ux-panel-header__status-indicator-wrapper-toggle\" tabindex=\"1\"> <span class=\"ux-icon\" [class.ux-icon-angle-down]=\"isStatusIndicatorContentExpanded\" [class.ux-icon-angle-right]=\"!isStatusIndicatorContentExpanded\"> </span> </a> </div> <div *ngIf=\"isStatusIndicatorContentExpanded\" class=\"ux-panel-header__status-indicator-content\"> <ng-content select=\"uxPanelHeaderStatusIndicatorContent\"></ng-content> </div> </ng-template> <div class=\"ux-panel-content {{statePanelContentClasses}} {{contentStyleClass}} {{statePanelContentClassesDynamic}}\" [class.ux-panel-content--fixed-height]=\"hasMaxHeight\" [style.max-height]=\"actualMaxHeight\" [hidden]=\"!isExpanded\" [style.height]=\"contentHeight\" [class.ux-panel-content--fixed-height-scrollable]=\"hasContentHeight\" aria-live=\"polite\"> <ng-content></ng-content> <div *ngIf=\"isBlocked\" class=\"ux-panel-content__blocked-overlay\" role=\"status\" [attr.aria-busy]=\"isBlocked\" [attr.aria-label]=\"isBlockedAriaLabel\"></div> </div> <div *ngIf=\"hasCustomPanelFooter\" class=\"ux-panel-footer\" [class.ux-panel-footer--large]=\"isLargeFooter\"> <ng-content select=\"uxPanelFooter\"></ng-content> </div> <div *ngIf=\"hasCustomPanelFooterWithDescendants\" class=\"ux-panel-footer\" [class.ux-panel-footer--large]=\"isLargeFooter\"> <ng-content select=\"uxPanelFooterWithDescendants\"></ng-content> </div> <div *ngIf=\"hasMaxHeight\" class=\"ux-panel-footer text-center\"> <button type=\"button\" class=\"btn btn-sm btn-secondary\" (click)=\"toggleMaxHeight($event)\"> <span *ngIf=\"isMaxHeightExpanded\">show less...</span> <span *ngIf=\"!isMaxHeightExpanded\">show more...</span> </button> </div> </div> </div> "
                    },] },
        ];
        /** @nocollapse */
        UxPanelComponent.ctorParameters = function () { return [
            { type: UxPanelsComponent, decorators: [{ type: core.Optional }, { type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxPanelsComponent; }),] },] },
            { type: core.ElementRef, },
            { type: core.Renderer2, },
            { type: UxService, },
            { type: UxDomService, },
        ]; };
        UxPanelComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "contentId": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "contentStyleClass": [{ type: core.Input },],
            "headerStyleClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "labelInfos": [{ type: core.Input },],
            "filterInput": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "isIconRounded": [{ type: core.Input },],
            "isExpandable": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "isVisible": [{ type: core.Input },],
            "isSelected": [{ type: core.Input },],
            "isCollapsible": [{ type: core.Input },],
            "isCollapsed": [{ type: core.Input },],
            "tagLabel": [{ type: core.Input },],
            "tagTypeClass": [{ type: core.Input },],
            "tagCount": [{ type: core.Input },],
            "badgeLabel": [{ type: core.Input },],
            "badgeTypeClass": [{ type: core.Input },],
            "hasTabs": [{ type: core.Input },],
            "hasNoHeader": [{ type: core.Input },],
            "hasNoContentPadding": [{ type: core.Input },],
            "isBlocked": [{ type: core.Input },],
            "isBlockedAriaLabel": [{ type: core.Input },],
            "maxHeight": [{ type: core.Input },],
            "contentHeight": [{ type: core.Input },],
            "isFlat": [{ type: core.Input },],
            "isLargeHeader": [{ type: core.Input },],
            "isLargeFooter": [{ type: core.Input },],
            "isSmallHeader": [{ type: core.Input },],
            "hasStatusIndicator": [{ type: core.Input },],
            "statusIndicatorTypeClass": [{ type: core.Input },],
            "statusIndicatorMessageLabel": [{ type: core.Input },],
            "isTogglableStatusIndicatorContent": [{ type: core.Input },],
            "isStatusIndicatorContentExpanded": [{ type: core.Input },],
            "hasStatusIndicatorHeaderBg": [{ type: core.Input },],
            "hasStatusIndicatorHeaderIcon": [{ type: core.Input },],
            "isEditModeActive": [{ type: core.Input },],
            "isContainerOnly": [{ type: core.Input },],
            "isClickable": [{ type: core.Input },],
            "isHighlighted": [{ type: core.Input },],
            "isAccordionPanel": [{ type: core.Input },],
            "customState": [{ type: core.Input },],
            "subLabelSizeLimit": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "isSticky": [{ type: core.Input },],
            "panelExpanded": [{ type: core.Output },],
            "panelCollapsed": [{ type: core.Output },],
            "customPanelHeader": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelHeaderTagDirective;
                        }), { descendants: false },] },],
            "customPanelFooter": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelFooterTagDirective;
                        }), { descendants: false },] },],
            "customPanelHeaderRightContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelHeaderRightContentTagDirective;
                        }), { descendants: false },] },],
            "customPanelHeaderWithDescendants": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelHeaderWithDescendantsTagDirective;
                        }), { descendants: true },] },],
            "customPanelFooterWithDescendants": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelFooterWithDescendantsTagDirective;
                        }), { descendants: true },] },],
            "customPanelHeaderRightContentWithDescendants": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxPanelHeaderRightContentWithDescendantsTagDirective;
                        }), { descendants: true },] },],
            "customStatusIndicatorContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxPanelHeaderStatusIndicatorContentTagDirective;
                        }),] },],
            "customSubHeaderContent": [{ type: core.ContentChild, args: [core.forwardRef(function () {
                            return UxPanelSubHeaderContentTagDirective;
                        }),] },],
            "stickyContainerElementRef": [{ type: core.ViewChild, args: ['stickyContainer',] },],
            "stickyContentElementRef": [{ type: core.ViewChild, args: ['stickyContent',] },],
        };
        return UxPanelComponent;
    }());
    var UxPanelHeaderTagDirective = (function () {
        function UxPanelHeaderTagDirective() {
        }
        UxPanelHeaderTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelHeader' },] },
        ];
        return UxPanelHeaderTagDirective;
    }());
    var UxPanelFooterTagDirective = (function () {
        function UxPanelFooterTagDirective() {
        }
        UxPanelFooterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelFooter' },] },
        ];
        return UxPanelFooterTagDirective;
    }());
    var UxPanelHeaderRightContentTagDirective = (function () {
        function UxPanelHeaderRightContentTagDirective() {
        }
        UxPanelHeaderRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelHeaderRightContent' },] },
        ];
        return UxPanelHeaderRightContentTagDirective;
    }());
    var UxPanelHeaderWithDescendantsTagDirective = (function () {
        function UxPanelHeaderWithDescendantsTagDirective() {
        }
        UxPanelHeaderWithDescendantsTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelHeaderWithDescendants' },] },
        ];
        return UxPanelHeaderWithDescendantsTagDirective;
    }());
    var UxPanelFooterWithDescendantsTagDirective = (function () {
        function UxPanelFooterWithDescendantsTagDirective() {
        }
        UxPanelFooterWithDescendantsTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelFooterWithDescendants' },] },
        ];
        return UxPanelFooterWithDescendantsTagDirective;
    }());
    var UxPanelHeaderRightContentWithDescendantsTagDirective = (function () {
        function UxPanelHeaderRightContentWithDescendantsTagDirective() {
        }
        UxPanelHeaderRightContentWithDescendantsTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelHeaderRightContentWithDescendants' },] },
        ];
        return UxPanelHeaderRightContentWithDescendantsTagDirective;
    }());
    var UxPanelHeaderStatusIndicatorContentTagDirective = (function () {
        function UxPanelHeaderStatusIndicatorContentTagDirective() {
        }
        UxPanelHeaderStatusIndicatorContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelHeaderStatusIndicatorContent' },] },
        ];
        return UxPanelHeaderStatusIndicatorContentTagDirective;
    }());
    var UxPanelSubHeaderContentTagDirective = (function () {
        function UxPanelSubHeaderContentTagDirective() {
        }
        UxPanelSubHeaderContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPanelSubHeaderContent' },] },
        ];
        return UxPanelSubHeaderContentTagDirective;
    }());
    var UxPanelComponentModule = (function () {
        function UxPanelComponentModule() {
        }
        UxPanelComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxTagComponentModule, UxIconComponentModule, UxLabelComponentModule],
                        exports: [
                            UxPanelComponent, UxPanelHeaderTagDirective, UxPanelFooterTagDirective,
                            UxPanelHeaderRightContentTagDirective, UxPanelHeaderStatusIndicatorContentTagDirective,
                            UxPanelHeaderWithDescendantsTagDirective,
                            UxPanelFooterWithDescendantsTagDirective,
                            UxPanelHeaderRightContentWithDescendantsTagDirective,
                            UxPanelSubHeaderContentTagDirective
                        ],
                        declarations: [
                            UxPanelComponent, UxPanelHeaderTagDirective, UxPanelFooterTagDirective,
                            UxPanelHeaderRightContentTagDirective, UxPanelHeaderStatusIndicatorContentTagDirective,
                            UxPanelHeaderWithDescendantsTagDirective,
                            UxPanelFooterWithDescendantsTagDirective,
                            UxPanelHeaderRightContentWithDescendantsTagDirective,
                            UxPanelSubHeaderContentTagDirective
                        ]
                    },] },
        ];
        return UxPanelComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLayoutFlexContentComponent = (function () {
        function UxLayoutFlexContentComponent() {
            this.isCollapsible = true;
            this.isCollapsed = false;
            this.isFlat = false;
            this.leftPanelSize = '20';
            // 2DO: Option feature to review: only applies for mobile & tablet modes when content is driven by router outlet
            // @Input() isAutoCollapsedOnClick: boolean = false;
            this.panelCollapsed = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxLayoutFlexContentComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.templates.forEach(function (item) {
                if (item.getType() === 'left') {
                    _this.leftTemplate = item.template;
                }
                if (item.getType() === 'right') {
                    _this.rightTemplate = item.template;
                }
            });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxLayoutFlexContentComponent.prototype.onCollapsibleButtonClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isCollapsed = !this.isCollapsed;
            this.panelCollapsed.emit(this.isCollapsed);
        };
        UxLayoutFlexContentComponent.decorators = [
            { type: core.Component, args: [{
                        /* tslint:disable-next-line */
                        selector: 'ux-layout-flex-content',
                        template: "<div class=\"ux-layout-flex-content {{styleClass}}\" [class.ux-layout-flex-content--not-collapsible]=\"!isCollapsible\"> <div class=\"ux-layout-flex-content__left\" [ngClass]=\"!isCollapsed ? 'ux-layout-flex-content__left--size-' + leftPanelSize : ''\" [class.ux-layout-flex-content__left--collapsed]=\"isCollapsed\" [class.ux-layout-flex-content__left--not-collapsible]=\"!isCollapsible\"> <div class=\"ux-layout-flex-content__left-container\" [class.ux-layout-flex-content__left-container--no-borders]=\"isFlat\"> <ng-template [ngIf]=\"leftTemplate\" [ngTemplateOutlet]=\"leftTemplate\"> </ng-template> </div> </div> <ng-template [ngIf]=\"isCollapsible\"> <div class=\"ux-layout-flex-content__collapsible-button\" [class.ux-layout-flex-content__collapsible-button--collapsed]=\"isCollapsed\" (click)=\"onCollapsibleButtonClick($event)\"> <i class=\"ux-icon\" [ngClass]=\"isCollapsed ? 'ux-icon-caret-right' : 'ux-icon-caret-left'\"></i> </div> </ng-template> <div class=\"ux-layout-flex-content__right\" [class.ux-layout-flex-content__right--overlay]=\"isCollapsible && !isCollapsed\"> <ng-template [ngIf]=\"rightTemplate\" [ngTemplateOutlet]=\"rightTemplate\"> </ng-template> </div> </div> ",
                        styles: ["ux-layout-flex-content{flex-basis:0;flex-grow:1;max-width:100%}.ux-layout-flex-content{align-items:flex-start;-webkit-box-flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex !important;-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto;-ms-flex-align:start;width:100%}.ux-layout-flex-content__left{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto}.ux-layout-flex-content__left--size-20{max-width:20%;width:20%}.ux-layout-flex-content__left--size-25{max-width:25%;width:25%}.ux-layout-flex-content__left--size-30{max-width:30%;width:30%}.ux-layout-flex-content__left--size-40{max-width:40%;width:40%}.ux-layout-flex-content__left--size-50{max-width:50%;width:50%}.ux-layout-flex-content__left--size-60{max-width:60%;width:60%}.ux-layout-flex-content__left--size-70{max-width:70%;width:70%}.ux-layout-flex-content__left--size-75{max-width:75%;width:75%}.ux-layout-flex-content__left--size-80{max-width:80%;width:80%}.ux-layout-flex-content__left--size-90{max-width:90%;width:90%}.ux-layout-flex-content__left--size-auto{max-width:100%;width:100%}.ux-layout-flex-content__left--collapsed{display:none}.ux-layout-flex-content__left--not-collapsible{margin-right:.89rem}.ux-layout-flex-content__left-container{background-color:white;border-radius:3px;border-top:1px solid #ddd;margin-bottom:1.25rem;position:relative;width:100%;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-layout-flex-content__left-container::after{clear:both;content:\"\";display:table}.ux-layout-flex-content__left-container--no-borders{background-color:transparent;border:none;box-shadow:none}.ux-layout-flex-content__left-container .ux-panel{margin-bottom:0}.ux-layout-flex-content__collapsible-button{align-items:center;background-color:white;border:1px solid #ddd;color:#004494;cursor:pointer;display:flex;font-size:1.5rem;height:3.5rem;margin-right:.89rem;padding:.89rem;position:relative;text-align:center}.ux-layout-flex-content__collapsible-button--collapsed{align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center}.ux-layout-flex-content__collapsible-button:hover{background-color:#4d7cb4;color:white}.ux-layout-flex-content__right{-webkit-flex:1 1 0%;-ms-flex:1 0 auto;overflow:visible}.ux-layout-flex-content__right-container{background-color:white;border-radius:3px;margin-bottom:1.25rem;padding:1.25rem;width:100%;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-layout-flex-content__right-container--clickable{cursor:pointer}.ux-layout-flex-content__right-container--clickable:focus,.ux-layout-flex-content__right-container--clickable:hover{background:#eee;outline:0;cursor:pointer;box-shadow:0 3px 6px rgba(0,0,0,0.16),0 3px 6px rgba(0,0,0,0.23)}.ux-layout-flex-content__right-container .col:not(:first-child),.ux-layout-flex-content__right-container .ux-col:not(:first-child){padding-top:2rem}@media screen and (max-width: 991px){.ux-layout-flex-content__left{min-width:60%;position:absolute;z-index:2}.ux-layout-flex-content__left--not-collapsible{display:flex;margin-right:1.25rem;position:relative !important}.ux-layout-flex-content__collapsible-button{left:60%;margin-left:1.25rem;padding:.66rem;position:absolute;text-align:center;z-index:1}.ux-layout-flex-content__collapsible-button:hover{background-color:#4d7cb4;color:white}.ux-layout-flex-content__collapsible-button--collapsed{align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center;left:0;margin-left:0;position:relative}.ux-layout-flex-content__right--overlay{opacity:0.4}.ux-layout-flex-content__right--overlay>*{cursor:not-allowed}.ux-layout-flex-content__right .content{align-items:center;display:flex;flex-direction:row;text-align:center;width:100% !important}}@media screen and (min-width: 0) and (max-width: 575px){.ux-layout-flex-content{display:block !important;max-width:100%;position:relative;width:100%}.ux-layout-flex-content__left{display:block;position:relative}.ux-layout-flex-content__left--not-collapsible{display:block;max-width:100%;position:relative !important;width:100%}.ux-layout-flex-content__collapsible-button{display:none}.ux-layout-flex-content__right{display:block;position:relative}.ux-layout-flex-content__right--overlay{opacity:1}.ux-layout-flex-content__right--overlay>*{cursor:pointer}} /*# sourceMappingURL=ux-layout-flex-content.component.css.map */"],
                        encapsulation: core.ViewEncapsulation.None,
                    },] },
        ];
        /** @nocollapse */
        UxLayoutFlexContentComponent.ctorParameters = function () { return []; };
        UxLayoutFlexContentComponent.propDecorators = {
            "isCollapsible": [{ type: core.Input },],
            "isCollapsed": [{ type: core.Input },],
            "isFlat": [{ type: core.Input },],
            "leftPanelSize": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "panelCollapsed": [{ type: core.Output },],
            "templates": [{ type: core.ContentChildren, args: [UxTemplateDirective,] },],
        };
        return UxLayoutFlexContentComponent;
    }());
    var UxLayoutFlexContentModule = (function () {
        function UxLayoutFlexContentModule() {
        }
        UxLayoutFlexContentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxPanelComponentModule],
                        exports: [
                            UxLayoutFlexContentComponent
                        ],
                        declarations: [
                            UxLayoutFlexContentComponent
                        ]
                    },] },
        ];
        return UxLayoutFlexContentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxSearchInputComponent = (function () {
        function UxSearchInputComponent(shadowDomRoot, uxService) {
            var _this = this;
            this.shadowDomRoot = shadowDomRoot;
            this.uxService = uxService;
            this.minCharacters = 3;
            this.maxHistoryEntries = 3;
            this.keyboardDebounceTime = 200;
            this.historicalSearches = [];
            this.suggestionsService = {
                getSuggestions: /**
                 * @param {?} query
                 * @return {?}
                 */
                function (query) {
                    return new Observable.Observable(function (observer) {
                        observer.next([]);
                        observer.complete();
                    });
                }
            };
            this.search = new core.EventEmitter();
            this.query = '';
            this.autocompleteLoading = false;
            this.historicalSearchesVisible = true;
            this.suggestionsVisible = false;
            this.noSuggestionsFound = false;
            this.ignoreInputBlur = false;
            this.control = new forms.FormControl();
            this.control.valueChanges.debounceTime(this.keyboardDebounceTime).subscribe(function (query) {
                _this.query = query;
                _this.getSuggestions();
            });
        }
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.searchInput = /** @type {?} */ (this.shadowDomQuery('input'));
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.getQuery = /**
         * @return {?}
         */
        function () {
            return this.query;
        };
        /**
         * @param {?} query
         * @return {?}
         */
        UxSearchInputComponent.prototype.setQuery = /**
         * @param {?} query
         * @return {?}
         */
        function (query) {
            this.query = query;
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            this.searchInput.focus();
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.focusAndSelect = /**
         * @return {?}
         */
        function () {
            this.focus();
            this.searchInput.select();
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.hideSuggestions = /**
         * @return {?}
         */
        function () {
            this.suggestionsVisible = false;
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.showSuggestions = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ show = true;
            // The suggestions should not be shown when:
            // 1. There are no visible suggestions.
            var /** @type {?} */ firstVisibleSuggestion = this.shadowDomQuery('.dropdown-item:not([hidden])');
            show = show && (firstVisibleSuggestion != null);
            // 2. The focus is no longer on the input field.
            show = show && (this.searchInput === this.shadowDomQuery(':focus'));
            if (show) {
                this.suggestionsVisible = true;
            }
            this.inactivateActiveSuggestion();
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.startSearch = /**
         * @return {?}
         */
        function () {
            this.storeHistoricalSearch();
            this.search.emit(this.query);
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.showHistoricalSearches = /**
         * @return {?}
         */
        function () {
            this.suggestions = [];
            this.historicalSearchesVisible = true;
            this.noSuggestionsFound = this.historicalSearches.length <= 0;
            this.showSuggestions();
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.searchInputBlur = /**
         * @return {?}
         */
        function () {
            if (!this.ignoreInputBlur) {
                this.hideSuggestions();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.searchInputKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            var /** @type {?} */ keyCode = event.keyCode;
            if (keyCode === 40 || keyCode === 38) {
                // 40 = arrow down, 38 = arrow up
                this.focusNextSuggestion(event);
            }
            else if (keyCode === 13) {
                // 13 = enter
                // Wait for field value to update:
                setTimeout(function () {
                    _this.startSearch();
                }, this.keyboardDebounceTime);
            }
            else {
                this.hideSuggestionOnEscape(event);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.searchInputClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.suggestionKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ keyCode = event.keyCode;
            if (keyCode === 40) {
                // 40 = arrow down
                this.focusNextSuggestion(event);
            }
            else if (keyCode === 38) {
                // 38 = arrow up
                this.focusPreviousSuggestion(event);
            }
            else if (keyCode === 13) {
                // 13 = enter
                this.selectActiveSuggestion();
            }
            else if (keyCode === 8) {
                // 8 = backspace
                this.consumeEvent(event);
            }
            this.hideSuggestionOnEscape(event);
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.suggestionBlur = /**
         * @return {?}
         */
        function () {
            if (!this.ignoreInputBlur) {
                this.hideSuggestions();
            }
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.selectActiveSuggestion = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
            if (activeSuggestion != null) {
                var /** @type {?} */ suggestion_1 = activeSuggestion.textContent;
                // Wait for input event to finish:
                setTimeout(function () {
                    _this.hideSuggestions();
                    _this.focus();
                    _this.query = /** @type {?} */ (suggestion_1);
                    _this.startSearch();
                }, 0);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.suggestionClicked = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            var /** @type {?} */ clickedSuggestion = /** @type {?} */ (event.currentTarget);
            if (clickedSuggestion != null) {
                this.inactivateActiveSuggestion();
                clickedSuggestion.classList.add('active');
                // Wait for input event to finish:
                setTimeout(function () {
                    _this.hideSuggestions();
                    _this.focus();
                    _this.query = /** @type {?} */ (clickedSuggestion.textContent);
                    _this.startSearch();
                }, 0);
            }
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.getActiveSuggestion = /**
         * @return {?}
         */
        function () {
            return this.shadowDomQuery('.dropdown-item.active');
        };
        // *****************************************************************************
        /**
         * @param {?} querySelector
         * @return {?}
         */
        UxSearchInputComponent.prototype.shadowDomQuery = /**
         * @param {?} querySelector
         * @return {?}
         */
        function (querySelector) {
            return this.shadowDomRoot.nativeElement.querySelector(querySelector);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.consumeEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            event.cancelBubble = true;
            return false;
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.ignoreBlur = /**
         * @return {?}
         */
        function () {
            this.ignoreInputBlur = true;
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.allowBlur = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // IE issue: let the focus() on an element first be completed before the blur() can be triggered.
            setTimeout(function () {
                _this.ignoreInputBlur = false;
            }, 0);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.hideSuggestionOnEscape = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ keyCode = event.keyCode;
            if (keyCode === 27) {
                // 27 = escape
                this.hideSuggestions();
                this.focus();
                this.consumeEvent(event);
            }
        };
        /**
         * @param {?} menuItem
         * @return {?}
         */
        UxSearchInputComponent.prototype.focusOnMenuItem = /**
         * @param {?} menuItem
         * @return {?}
         */
        function (menuItem) {
            this.ignoreBlur();
            menuItem.focus();
            this.allowBlur();
        };
        /**
         * @param {?} activeSuggestion
         * @return {?}
         */
        UxSearchInputComponent.prototype.focusFirstSuggestion = /**
         * @param {?} activeSuggestion
         * @return {?}
         */
        function (activeSuggestion) {
            var _this = this;
            if (!this.noSuggestionsFound) {
                if (activeSuggestion == null) {
                    var /** @type {?} */ firstSuggestion = this.shadowDomQuery('.dropdown-item:not([hidden])');
                    if (firstSuggestion != null && !firstSuggestion.classList.contains('empty')) {
                        firstSuggestion.classList.add('active');
                        this.focusOnMenuItem(firstSuggestion);
                    }
                }
                else {
                    setTimeout(function () {
                        _this.focusOnMenuItem(activeSuggestion);
                    }, 0);
                }
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.focusNextSuggestion = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
            if (!this.suggestionsVisible) {
                this.showSuggestions();
                this.focusFirstSuggestion(activeSuggestion);
            }
            else {
                if (activeSuggestion != null) {
                    // focus next suggestion:
                    var /** @type {?} */ nextSuggestion = /** @type {?} */ (activeSuggestion.nextElementSibling);
                    if (nextSuggestion != null && !nextSuggestion.classList.contains('empty')) {
                        activeSuggestion.classList.remove('active');
                        nextSuggestion.classList.add('active');
                        this.ignoreBlur();
                        nextSuggestion.focus();
                        this.allowBlur();
                    }
                }
                else {
                    this.focusFirstSuggestion(activeSuggestion);
                }
            }
            this.consumeEvent(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSearchInputComponent.prototype.focusPreviousSuggestion = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
            if (!this.suggestionsVisible) {
                this.showSuggestions();
                this.focusFirstSuggestion(activeSuggestion);
            }
            else {
                if (activeSuggestion != null) {
                    // focus next suggestion:
                    var /** @type {?} */ previousSuggestion = /** @type {?} */ (activeSuggestion.previousElementSibling);
                    if (previousSuggestion != null && !previousSuggestion.classList.contains('empty')) {
                        activeSuggestion.classList.remove('active');
                        previousSuggestion.classList.add('active');
                        this.ignoreBlur();
                        previousSuggestion.focus();
                        this.allowBlur();
                    }
                }
                else {
                    this.focusFirstSuggestion(activeSuggestion);
                }
            }
            this.consumeEvent(event);
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.inactivateActiveSuggestion = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
            if (activeSuggestion != null) {
                activeSuggestion.classList.remove('active');
            }
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.storeHistoricalSearch = /**
         * @return {?}
         */
        function () {
            // Remove existing entry:
            var /** @type {?} */ search = this.query;
            if (search !== null && search.trim().length > 0) {
                var /** @type {?} */ index = this.historicalSearches.indexOf(search, 0);
                if (index > -1) {
                    this.historicalSearches.splice(index, 1);
                }
                this.historicalSearches.unshift(search);
                if (this.historicalSearches.length > this.maxHistoryEntries) {
                    this.historicalSearches.splice(this.maxHistoryEntries);
                }
            }
        };
        /**
         * @return {?}
         */
        UxSearchInputComponent.prototype.getSuggestions = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.query.length >= this.minCharacters) {
                this.hideSuggestions();
                this.noSuggestionsFound = false;
                this.autocompleteLoading = true;
                this.suggestions = [];
                this.suggestionsService.getSuggestions(this.query).subscribe(function (suggestions) {
                    _this.suggestions = suggestions;
                    _this.noSuggestionsFound = (_this.suggestions == null || _this.suggestions.length <= 0);
                    _this.autocompleteLoading = false;
                    _this.historicalSearchesVisible = false;
                    setTimeout(function () {
                        _this.showSuggestions();
                    }, 0);
                });
            }
            else if (this.query.trim().length <= 0) {
                this.showHistoricalSearches();
            }
        };
        UxSearchInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-input',
                        template: "\n\n        <div class=\"ux-search-input-container\">\n            <input #input type=\"search\" class=\"form-control\" [value]=\"query\"\n                   [formControl]=\"control\" (blur)=\"searchInputBlur()\"\n                   (keydown)=\"searchInputKeydown($event)\"\n                   (click)=\"searchInputClick($event)\"/>\n            <div class=\"dropdown-menu-container\">\n                <div class=\"dropdown-menu\" [hidden]=\"! suggestionsVisible\">\n                    <div *ngFor=\"let historicalSearch of historicalSearches\"\n                         class=\"dropdown-item historical\" tabindex=\"0\"\n                         [hidden]=\"! historicalSearchesVisible\"\n                         (keydown)=\"suggestionKeydown($event)\"\n                         (mousedown)=\"suggestionClicked($event)\"\n                         (blur)=\"suggestionBlur()\">\n                         {{historicalSearch}}\n                   </div>\n                    <div *ngFor=\"let suggestion of suggestions\" class=\"dropdown-item\" tabindex=\"0\"\n                         (keydown)=\"suggestionKeydown($event)\"\n                         (mousedown)=\"suggestionClicked($event)\"\n                         (blur)=\"suggestionBlur()\">\n                         {{suggestion}}\n                    </div>\n                    <div class=\"dropdown-item empty\" [hidden]=\"! noSuggestionsFound\">\n                        No suggestions found.\n                    </div>\n                </div>\n            </div>\n            <div class=\"spinner\" [hidden]=\"! autocompleteLoading\">\n                <div class=\"spinner-item1\"></div>\n                <div class=\"spinner-item2\"></div>\n                <div class=\"spinner-item3\"></div>\n            </div>\n        </div>\n\n\n    "
                    },] },
        ];
        /** @nocollapse */
        UxSearchInputComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: UxService, },
        ]; };
        UxSearchInputComponent.propDecorators = {
            "minCharacters": [{ type: core.Input },],
            "maxHistoryEntries": [{ type: core.Input },],
            "keyboardDebounceTime": [{ type: core.Input },],
            "historicalSearches": [{ type: core.Input },],
            "suggestionsService": [{ type: core.Input },],
            "search": [{ type: core.Output },],
        };
        return UxSearchInputComponent;
    }());
    var UxSearchInputComponentModule = (function () {
        function UxSearchInputComponentModule() {
        }
        UxSearchInputComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.ReactiveFormsModule],
                        exports: [UxSearchInputComponent],
                        declarations: [UxSearchInputComponent]
                    },] },
        ];
        return UxSearchInputComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxIconToggleComponent = (function () {
        function UxIconToggleComponent(uxService) {
            this.uxService = uxService;
            this.styleClassOn = 'ux-u-color-accent-dark';
            this.styleClassOff = 'ux-u-color-grey-dark';
            this.isChecked = false;
            this.isReadOnly = false;
            this.tabindex = 0;
            this.toggle = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxIconToggleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.setIconClass();
            if (!this.ariaLabel || this.ariaLabel === '') {
                this.ariaLabel = (this.iconClass ? this.iconClass : '');
            }
        };
        /**
         * @return {?}
         */
        UxIconToggleComponent.prototype.onToggle = /**
         * @return {?}
         */
        function () {
            if (!this.isReadOnly) {
                this.isChecked = !this.isChecked;
                this.setIconClass();
                this.toggle.emit(this.isChecked);
            }
            this.focusElement.nativeElement.focus();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxIconToggleComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case 13: // ENTER
                case 32:
                    // SPACE
                    this.uxService.consumeEvent(event);
                    this.onToggle();
                    break;
            }
        };
        /**
         * @return {?}
         */
        UxIconToggleComponent.prototype.setIconClass = /**
         * @return {?}
         */
        function () {
            if (this.isChecked) {
                this.iconClass = this.iconClassOn;
                this.stateClass = this.styleClassOn;
            }
            else {
                this.iconClass = this.iconClassOff;
                this.stateClass = this.styleClassOff;
            }
        };
        UxIconToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-icon-toggle',
                        template: "<span #focusElement class=\"ux-a-icon-toggle {{stateClass}} {{styleClass}}\" tabindex=\"{{!isReadOnly ? tabindex: '-1'}}\" role=\"switch\" [attr.aria-label]=\"ariaLabel\" [attr.aria-checked]=\"isChecked\" [attr.accesskey]=\"keyboardAccessKey\" (click)=\"onToggle()\" (keydown)=\"onKeyDown($event)\"> <span class=\"{{iconClass}} ux-a-icon__icon\" [class.ux-u-cursor-pointer]=\"!isReadOnly\"></span> </span> ",
                        styles: [".ux-a-icon-toggle .ux-a-icon__icon{font-size:1.42857rem} /*# sourceMappingURL=ux-a-icon-toggle.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxIconToggleComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxIconToggleComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "styleClassOn": [{ type: core.Input },],
            "styleClassOff": [{ type: core.Input },],
            "iconClassOff": [{ type: core.Input },],
            "iconClassOn": [{ type: core.Input },],
            "isChecked": [{ type: core.Input },],
            "isReadOnly": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input },],
            "keyboardAccessKey": [{ type: core.Input },],
            "toggle": [{ type: core.Output },],
            "focusElement": [{ type: core.ViewChild, args: ['focusElement',] },],
        };
        return UxIconToggleComponent;
    }());
    var UxIconToggleComponentModule = (function () {
        function UxIconToggleComponentModule() {
        }
        UxIconToggleComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxIconToggleComponent],
                        declarations: [UxIconToggleComponent]
                    },] },
        ];
        return UxIconToggleComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxIconBoxComponent = (function () {
        function UxIconBoxComponent() {
            this.tabindex = 0;
        }
        UxIconBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-a-icon-box',
                        template: "<div class=\"ux-a-icon-box {{styleClass}}\" [tabindex]=\"tabindex\" [attr.aria-label]=\"label\"> <div class=\"ux-a-icon-box__icon\"> <span class=\"ux-a-icon-box__icon-element {{iconClass}}\"></span> </div> <div class=\"ux-a-icon-box__label\"> {{label}} </div> </div> ",
                        styles: [".ux-a-icon-box{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#004494;color:white;flex:0 0 8rem;height:9rem;margin-right:1.25rem;padding:.66rem;text-align:center}.ux-a-icon-box__icon{font-size:4rem}.ux-a-icon-box__label{font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal;text-transform:uppercase} /*# sourceMappingURL=ux-a-icon-box.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxIconBoxComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
        };
        return UxIconBoxComponent;
    }());
    var UxIconBoxComponentModule = (function () {
        function UxIconBoxComponentModule() {
        }
        UxIconBoxComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxIconBoxComponent],
                        declarations: [UxIconBoxComponent]
                    },] },
        ];
        return UxIconBoxComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBlockContentComponent = (function () {
        function UxBlockContentComponent(elRef, renderer) {
            this.elRef = elRef;
            this.renderer = renderer;
            this.lastActiveElement = null;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        UxBlockContentComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ activeElement = this.getActiveElement();
            var /** @type {?} */ isBlocking = this.isAboutToBlock(changes);
            if (isBlocking) {
                this.desactivateElement(activeElement);
            }
            else {
                this.reactivateElement(activeElement);
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxBlockContentComponent.prototype.isAboutToBlock = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ isBlockedChange = changes['isBlocked'];
            return isBlockedChange &&
                isBlockedChange.currentValue &&
                !isBlockedChange.previousValue;
        };
        /**
         * @param {?} activeElement
         * @return {?}
         */
        UxBlockContentComponent.prototype.desactivateElement = /**
         * @param {?} activeElement
         * @return {?}
         */
        function (activeElement) {
            if (activeElement) {
                this.renderer.invokeElementMethod(activeElement, 'blur');
                this.lastActiveElement = activeElement;
            }
            else {
                this.lastActiveElement = null;
            }
        };
        /**
         * @param {?} activeElement
         * @return {?}
         */
        UxBlockContentComponent.prototype.reactivateElement = /**
         * @param {?} activeElement
         * @return {?}
         */
        function (activeElement) {
            if (this.lastActiveElement) {
                this.renderer.invokeElementMethod(this.lastActiveElement, 'focus');
            }
        };
        /**
         * @return {?}
         */
        UxBlockContentComponent.prototype.getActiveElement = /**
         * @return {?}
         */
        function () {
            return this.elRef.nativeElement.querySelector(':focus');
        };
        UxBlockContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-block-content',
                        template: "<div class=\"ux-c-block-content\" [class.ux-is-active]=\"isBlocked\"> <ng-content></ng-content> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxBlockContentComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.Renderer, },
        ]; };
        UxBlockContentComponent.propDecorators = {
            "isBlocked": [{ type: core.Input },],
        };
        return UxBlockContentComponent;
    }());
    var UxBlockContentComponentModule = (function () {
        function UxBlockContentComponentModule() {
        }
        UxBlockContentComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxBlockContentComponent],
                        declarations: [UxBlockContentComponent]
                    },] },
        ];
        return UxBlockContentComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDisableContentComponent = (function () {
        function UxDisableContentComponent(elRef, renderer, uxService) {
            this.elRef = elRef;
            this.renderer = renderer;
            this.uxService = uxService;
            this.disabledText = '';
            this.lastActiveElement = null;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        UxDisableContentComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ activeElement = this.getActiveElement();
            var /** @type {?} */ isBlocking = this.isAboutToBlock(changes);
            if (isBlocking) {
                this.desactivateElement(activeElement);
            }
            else {
                this.reactivateElement(activeElement);
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxDisableContentComponent.prototype.isAboutToBlock = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ isBlockedChange = changes['isDisabled'];
            return isBlockedChange &&
                isBlockedChange.currentValue &&
                !isBlockedChange.previousValue;
        };
        /**
         * @param {?} activeElement
         * @return {?}
         */
        UxDisableContentComponent.prototype.desactivateElement = /**
         * @param {?} activeElement
         * @return {?}
         */
        function (activeElement) {
            if (activeElement) {
                this.renderer.invokeElementMethod(activeElement, 'blur');
                this.lastActiveElement = activeElement;
            }
            else {
                this.lastActiveElement = null;
            }
        };
        /**
         * @param {?} activeElement
         * @return {?}
         */
        UxDisableContentComponent.prototype.reactivateElement = /**
         * @param {?} activeElement
         * @return {?}
         */
        function (activeElement) {
            if (this.lastActiveElement) {
                this.renderer.invokeElementMethod(this.lastActiveElement, 'focus');
            }
        };
        /**
         * @return {?}
         */
        UxDisableContentComponent.prototype.getActiveElement = /**
         * @return {?}
         */
        function () {
            return this.elRef.nativeElement.querySelector(':focus');
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxDisableContentComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isDisabled && this.disabledText) {
                this.uxService.growlInfo(this.disabledText);
            }
        };
        UxDisableContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-disable-content',
                        template: "<div class=\"ux-c-disable-content\" [class.ux-is-active]=\"isDisabled\" (click)=\"onClick($event)\"> <ng-content></ng-content> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxDisableContentComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.Renderer, },
            { type: UxService, },
        ]; };
        UxDisableContentComponent.propDecorators = {
            "isDisabled": [{ type: core.Input },],
            "disabledText": [{ type: core.Input },],
        };
        return UxDisableContentComponent;
    }());
    var UxDisableContentComponentModule = (function () {
        function UxDisableContentComponentModule() {
        }
        UxDisableContentComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxDisableContentComponent],
                        declarations: [UxDisableContentComponent]
                    },] },
        ];
        return UxDisableContentComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxProgressCircleComponent = (function () {
        function UxProgressCircleComponent() {
            this.emptyLabel = 'N/A';
            this.isDefaultColorSteps = true;
            this.isSmall = false;
            this.isLarge = false;
            this.tabindex = '0';
            this.ariaLabel = '';
            this.stateColorNumberClass = '';
            this.labelValue = '';
            this.percentValue = '';
            this.isLongLabel = false;
            this.offsetWidth = 0;
        }
        /**
         * @return {?}
         */
        UxProgressCircleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ prefix = 'ux-progress-circle--';
            var /** @type {?} */ colorStepsArray = [];
            this.roundedValue = Math.round(this.value);
            if (this.colorSteps) {
                colorStepsArray = this.colorSteps.split(/[ ,]+/g);
            }
            else {
                colorStepsArray = ['33', '66'];
            }
            if (this.colorType) {
                this.stateColorNumberClass = prefix + this.colorType;
            }
            else {
                if (this.isDefaultColorSteps) {
                    if (this.value <= Number.parseInt(colorStepsArray[0], 10)) {
                        this.stateColorNumberClass = prefix + 'success';
                    }
                    if (this.value > Number.parseInt(colorStepsArray[0], 10) && this.value <= Number.parseInt(colorStepsArray[1], 10)) {
                        this.stateColorNumberClass = prefix + 'warning';
                    }
                    if (this.value > Number.parseInt(colorStepsArray[1], 10)) {
                        this.stateColorNumberClass = prefix + 'danger';
                    }
                }
            }
            if (this.value === 0) {
                this.labelValue = this.emptyLabel;
            }
            else {
                if (this.valueLabel) {
                    this.labelValue = this.valueLabel;
                }
                else {
                    this.labelValue = this.value + '%';
                }
            }
        };
        /**
         * @return {?}
         */
        UxProgressCircleComponent.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
        function () {
            if (this.labelValueEl) {
                this.offsetWidth = this.labelValueEl.nativeElement.offsetWidth;
                if (this.offsetWidth > 60) {
                    this.isLongLabel = true;
                }
            }
        };
        UxProgressCircleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-progress-circle',
                        template: "\n        <div class=\"ux-progress-circle-wrapper\" [tabindex]=\"tabindex\" [attr.aria-label]=\"ariaLabel\">\n            <div class=\"ux-progress-circle p{{roundedValue}} {{stateColorNumberClass}}\"\n                [class.ux-progress-circle--over50]=\"roundedValue > 50\"\n                [class.ux-progress-circle--small]=\"isSmall\"\n                [class.ux-progress-circle--large]=\"isLarge\">\n\n                <span class=\"ux-progress-circle__label\" *ngIf=\"!isLongLabel\">\n                    <span #labelValueEl>{{labelValue}}</span>\n                </span>\n                <div class=\"ux-progress-circle__left-half-clipper\">\n                    <div class=\"ux-progress-circle__first50-bar\"></div>\n                    <div class=\"ux-progress-circle__value-bar\"></div>\n                </div>\n\n                <div class=\"ux-progress-circle__bottom-label\" *ngIf=\"isLongLabel\"\n                    [class.ux-progress-circle--small]=\"isSmall\"\n                    [class.ux-progress-circle--large]=\"isLarge\">\n                    <span class=\"label\">{{labelValue}}</span>\n                </div>\n            </div>\n            <div *ngIf=\"iconLabelClass\"\n                 [class.ux-progress-circle__icon-label]=\"!isLarge && !isSmall\"\n                 [class.ux-progress-circle__icon-label--small]=\"isSmall\"\n                 [class.ux-progress-circle__icon-label--large]=\"isLarge\">\n                <span class=\"{{iconLabelClass}} {{iconLabelStyleClass}}\"></span>\n            </div>\n        </div>\n        "
                    },] },
        ];
        /** @nocollapse */
        UxProgressCircleComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "value": [{ type: core.Input },],
            "emptyLabel": [{ type: core.Input },],
            "valueLabel": [{ type: core.Input },],
            "isDefaultColorSteps": [{ type: core.Input },],
            "colorSteps": [{ type: core.Input },],
            "colorType": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "iconLabelClass": [{ type: core.Input },],
            "iconLabelStyleClass": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input },],
            "labelValueEl": [{ type: core.ViewChild, args: ['labelValueEl',] },],
        };
        return UxProgressCircleComponent;
    }());
    var UxProgressCircleComponentModule = (function () {
        function UxProgressCircleComponentModule() {
        }
        UxProgressCircleComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxProgressCircleComponent],
                        declarations: [UxProgressCircleComponent]
                    },] },
        ];
        return UxProgressCircleComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxActionBoxComponent = (function () {
        function UxActionBoxComponent(uxService) {
            this.uxService = uxService;
            this.items = [];
            this.isCollapsible = true;
            this.isExpanded = true;
            this.isLeftPositioned = false;
            this.isSticky = false;
            this.tabindex = '0';
            this.actionsYOffset = 14;
            this.onScrollBind = this.onScroll.bind(this);
            this.onResizeBind = this.onResize.bind(this);
        }
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.isSticky) {
                window.addEventListener('scroll', this.onScrollBind);
                window.addEventListener('resize', this.onResizeBind);
            }
            this.generatedId = this.uxService.uniqueId();
        };
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.onScroll = /**
         * @return {?}
         */
        function () {
            this.handleStickyActionsBox();
        };
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.onResize = /**
         * @return {?}
         */
        function () {
            this.handleStickyActionsBox();
        };
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.handleStickyActionsBox = /**
         * @return {?}
         */
        function () {
            if (this.actionsElementRef) {
                var /** @type {?} */ effectiveTopOffset = '';
                var /** @type {?} */ actionsTopOffset = this.containerElementRef.nativeElement.getBoundingClientRect().top;
                if (actionsTopOffset < 0) {
                    effectiveTopOffset = -actionsTopOffset + this.actionsYOffset + 'px';
                }
                this.actionsElementRef.nativeElement.style.top = effectiveTopOffset;
            }
        };
        Object.defineProperty(UxActionBoxComponent.prototype, "stateCollapsedClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (!this.isExpanded) {
                    return 'ux-action-box--collapsed';
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} link
         * @return {?}
         */
        UxActionBoxComponent.prototype.onItemClick = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            if (link && link.command) {
                link.command();
            }
        };
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.onToggle = /**
         * @return {?}
         */
        function () {
            if (this.isCollapsible) {
                this.isExpanded = !this.isExpanded;
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxActionBoxComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case 13: // ENTER
                case 32:
                    // SPACE
                    this.uxService.consumeEvent(event);
                    this.onToggle();
                    break;
            }
        };
        /**
         * @return {?}
         */
        UxActionBoxComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            window.removeEventListener('scroll', this.onScrollBind);
            window.removeEventListener('resize', this.onResizeBind);
        };
        UxActionBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-action-box',
                        template: "<div *ngIf=\"isLeftPositioned\" #container class=\"flex-container flex-container--align-top\"> <div #actions class=\"ux-action-box__actions\" [class.ux-action-box__actions--collapsed]=\"!isExpanded\" [class.ux-action-box__actions--left-positioned]=\"true\"> <ux-panel [id]=\"generatedId\" styleClass=\"{{stateCollapsedClass}}\" [tabindex]=\"tabindex\"> <uxPanelHeader> <ux-a-label *ngIf=\"isExpanded\" label=\"{{titleLabel}}\" styleClass=\"ux-action-box__label\" tabindex=\"-1\"></ux-a-label> <div class=\"ux-panel-header__right-content\"> <span *ngIf=\"isCollapsible\" class=\"ux-icon ux-action-box__icon-toggle\" [class.ux-icon-indent]=\"isExpanded\" [class.ux-icon-dedent]=\"!isExpanded\" role=\"button\" [attr.aria-controls]=\"generatedId\" [attr.aria-expanded]=\"isExpanded\" [tabindex]=\"tabindex\" (keydown)=\"onKeyDown($event)\" (click)=\"onToggle()\"></span> </div> </uxPanelHeader> <ng-template ngFor let-item [ngForOf]=\"items\"> <ux-list-items *ngIf=\"item.actions\" titleLabel=\"{{item.label}}\" [links]=\"item.actions\" [expanded]=\"isExpanded\" [isSmall]=\"true\" (listItemClick)=\"onItemClick($event)\" [isLeftPositioned]=\"true\" [isAccessible]=\"true\"> </ux-list-items> </ng-template> </ux-panel> </div> <ng-container *ngTemplateOutlet=\"content\"></ng-container> </div> <div *ngIf=\"!isLeftPositioned\" #container class=\"flex-container flex-container--align-top\"> <ng-container *ngTemplateOutlet=\"content\"></ng-container> <div #actions  class=\"ux-action-box__actions\" [class.ux-action-box__actions--collapsed]=\"!isExpanded\" [class.ux-action-box__actions--left-positioned]=\"false\"> <ux-panel [id]=\"generatedId\" styleClass=\"{{stateCollapsedClass}}\" [tabindex]=\"tabindex\"> <uxPanelHeader> <ux-a-label *ngIf=\"isExpanded\" label=\"{{titleLabel}}\" styleClass=\"ux-action-box__label\" tabindex=\"-1\"></ux-a-label> <div class=\"ux-panel-header__right-content\"> <span *ngIf=\"isCollapsible\" class=\"ux-icon ux-action-box__icon-toggle\" [class.ux-icon-indent]=\"isExpanded\" [class.ux-icon-dedent]=\"!isExpanded\" role=\"button\" [tabindex]=\"tabindex\" [attr.aria-controls]=\"generatedId\" [attr.aria-expanded]=\"isExpanded\" (keydown)=\"onKeyDown($event)\" (click)=\"onToggle()\"></span> </div> </uxPanelHeader> <ng-template ngFor let-item [ngForOf]=\"items\"> <ux-list-items *ngIf=\"item.actions\" titleLabel=\"{{item.label}}\" [links]=\"item.actions\" [expanded]=\"isExpanded\" [isSmall]=\"true\" (listItemClick)=\"onItemClick($event)\" [isLeftPositioned]=\"false\" [isAccessible]=\"true\"> </ux-list-items> </ng-template> </ux-panel> </div> </div> <ng-template #content> <div class=\"ux-action-box__content\"> <ng-content></ng-content> </div> <ng-template> ",
                    },] },
        ];
        /** @nocollapse */
        UxActionBoxComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxActionBoxComponent.propDecorators = {
            "titleLabel": [{ type: core.Input },],
            "items": [{ type: core.Input },],
            "isCollapsible": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "isLeftPositioned": [{ type: core.Input },],
            "isSticky": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "containerElementRef": [{ type: core.ViewChild, args: ['container',] },],
            "actionsElementRef": [{ type: core.ViewChild, args: ['actions',] },],
        };
        return UxActionBoxComponent;
    }());
    var UxActionBoxComponentModule = (function () {
        function UxActionBoxComponentModule() {
        }
        UxActionBoxComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxListItemsComponentModule, UxPanelComponentModule, UxLabelComponentModule],
                        exports: [UxActionBoxComponent],
                        declarations: [UxActionBoxComponent]
                    },] },
        ];
        return UxActionBoxComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxActionBoxItem = (function () {
        function UxActionBoxItem(values) {
            if (values === void 0) { values = {}; }
            Object.assign(this, values);
        }
        return UxActionBoxItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAlertComponent = (function () {
        function UxAlertComponent() {
            this.typeClass = 'info';
            this.isMuted = false;
            this.isCloseable = false;
            this.close = new core.EventEmitter();
            this.isVisible = true;
            this.contentClass = '';
        }
        /**
         * @return {?}
         */
        UxAlertComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.iconClass) {
                this.isMuted = true;
                this.contentClass = 'text with-icon';
            }
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        UxAlertComponent.prototype.onCloseClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this.isVisible = false;
            this.close.next();
        };
        UxAlertComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-alert',
                        template: "<div *ngIf=\"isVisible\" class=\"alert alert-{{typeClass}} ux-alert {{styleClass}}\" [class.muted]=\"isMuted\"> <div class=\"ux-alert__content-container {{contentClass}}\"> <div *ngIf=\"iconClass\" class=\"{{iconClass}} icon\"></div> <div> <ng-content></ng-content> </div> <div *ngIf=\"isCloseable\" (click)=\"onCloseClick($event)\" class=\"ux-alert__close\">×</div> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxAlertComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isMuted": [{ type: core.Input },],
            "isCloseable": [{ type: core.Input },],
            "close": [{ type: core.Output },],
        };
        return UxAlertComponent;
    }());
    var UxAlertComponentModule = (function () {
        function UxAlertComponentModule() {
        }
        UxAlertComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxAlertComponent],
                        declarations: [UxAlertComponent]
                    },] },
        ];
        return UxAlertComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDashboardCardComponent = (function () {
        function UxDashboardCardComponent(uxService) {
            this.uxService = uxService;
            this.imageWidth = '64';
            this.imageHeight = '64';
            this.isIconCompact = true;
            this.buttonStyleClass = 'btn-info';
            this.isClickable = false;
            this.isHorizontalLayout = false;
        }
        /**
         * @return {?}
         */
        UxDashboardCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        Object.defineProperty(UxDashboardCardComponent.prototype, "stateTypeClass", {
            get: /**
             * @return {?}
             */
            function () {
                var /** @type {?} */ classes = '';
                if (this.typeClass) {
                    classes = 'ux-dashboard-card--' + this.typeClass;
                }
                return classes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxDashboardCardComponent.prototype.onKeyDown = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (this.isClickable && keyCode === 13) {
                this.openLink();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxDashboardCardComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isClickable) {
                this.openLink();
            }
        };
        /**
         * @return {?}
         */
        UxDashboardCardComponent.prototype.openLink = /**
         * @return {?}
         */
        function () {
            if (this.url) {
                this.uxService.appRouter.navigate([this.url]);
            }
            if (this.urlExternal) {
                window.open(this.urlExternal, '_blank');
            }
        };
        UxDashboardCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-card',
                        template: "\n      <div class=\"ux-dashboard-card {{styleClass}} {{stateTypeClass}}\" tabindex=\"1\" [class.row]=\"isHorizontalLayout\"\n                 [class.ux-dashboard-card--clickable]=\"isClickable\"\n                 [class.ux-dashboard-card--icon-compact]=\"isIconCompact\"\n                 [class.ux-dashboard-card--horizontal]=\"isHorizontalLayout\"\n                 [class.ux-dashboard-card--horizontal--icon-compact]=\"isIconCompact && isHorizontalLayout\"\n                 (click)=\"onClick($event)\"\n                 (keydown)=\"onKeyDown($event.keyCode)\">\n\n          <div *ngIf=\"iconClass\" [class.col-4]=\"isHorizontalLayout\" class=\"ux-dashboard-card__icon-container\">\n              <div class=\"ux-dashboard-card__icon-wrapper ux-dashboard-card__icon-wrapper--{{iconTypeClass}}\">\n                  <span class=\"{{iconClass}} ux-icon-fw ux-dashboard-card__icon-wrapper-icon\"></span>\n              </div>\n          </div>\n\n          <div *ngIf=\"imageUrl\" [class.col-4]=\"isHorizontalLayout\" class=\"ux-dashboard-card__image-container\">\n              <div class=\"ux-dashboard-card__image-wrapper\">\n                  <img [style.height.px]=\"imageHeight\" [style.width.px]=\"imageWidth\"\n                       src=\"{{imageUrl}}\" alt=\"{{imageUrl}}\"/>\n              </div>\n          </div>\n\n          <div class=\"ux-dashboard-card__content-wrapper\" [class.col-8]=\"isHorizontalLayout\">\n              <div class=\"ux-dashboard-card__content\">\n                  <div class=\"ux-dashboard-card__content-label\">{{label}}</div>\n                  <div class=\"ux-dashboard-card__content-sub-label\">{{subLabel}}</div>\n                  <div *ngIf=\"!isClickable\" class=\"ux-dashboard-card__content-link\">\n                    <a *ngIf=\"urlExternal\" href=\"{{urlExternal}}\" target=\"_blank\"\n                       class=\"btn {{buttonStyleClass}}\" tabindex=\"1\">{{buttonLinkLabel}}</a>\n                    <a *ngIf=\"url\" [routerLink]=\"[url]\" class=\"btn {{buttonStyleClass}}\" tabindex=\"1\">{{buttonLinkLabel}}</a>\n                  </div>\n              </div>\n          </div>\n      </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxDashboardCardComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxDashboardCardComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "imageUrl": [{ type: core.Input },],
            "imageWidth": [{ type: core.Input },],
            "imageHeight": [{ type: core.Input },],
            "isIconCompact": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "urlExternal": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "buttonLinkLabel": [{ type: core.Input },],
            "buttonStyleClass": [{ type: core.Input },],
            "isClickable": [{ type: core.Input },],
            "isHorizontalLayout": [{ type: core.Input },],
        };
        return UxDashboardCardComponent;
    }());
    var UxDashboardCardComponentModule = (function () {
        function UxDashboardCardComponentModule() {
        }
        UxDashboardCardComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule],
                        exports: [UxDashboardCardComponent],
                        declarations: [UxDashboardCardComponent]
                    },] },
        ];
        return UxDashboardCardComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxControlFeedbackComponent = (function () {
        function UxControlFeedbackComponent() {
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        UxControlFeedbackComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ typeClassChanges = changes['typeClass'];
            if (typeClassChanges) {
                this.stateClass = typeClassChanges.currentValue ? "ux-u-color-" + typeClassChanges.currentValue : void 0;
            }
        };
        UxControlFeedbackComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-control-feedback',
                        template: "<div role=\"alert\" class=\"ux-c-control-feedback form-control-feedback {{stateClass}} {{styleClass}}\"> <small class=\"ux-c-control-feedback__message\"><ng-content></ng-content></small> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxControlFeedbackComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
        };
        return UxControlFeedbackComponent;
    }());
    var UxControlFeedbackComponentModule = (function () {
        function UxControlFeedbackComponentModule() {
        }
        UxControlFeedbackComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxControlFeedbackComponent],
                        declarations: [UxControlFeedbackComponent]
                    },] },
        ];
        return UxControlFeedbackComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDropdownComponent = (function () {
        function UxDropdownComponent(uxService) {
            this.uxService = uxService;
            this.isActive = false;
            this.isRightAligned = true;
            this.width = '10rem';
            this.height = 'auto';
            this.clickedOutside = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        /**
         * @param {?} keyCode
         * @return {?}
         */
        UxDropdownComponent.prototype.closeDropDownOnEscape = /**
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            if (keyCode === 27) {
                // 27 = escape
                this.isActive = false;
            }
        };
        UxDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dropdown',
                        template: "\n        <div class=\"ux-dropdown dropdown-menu\" [style.min-width]=\"width\" [style.max-height]=\"height\"\n                [class.d-block]=\"isActive\"\n                [class.dropdown-menu-right]=\"isRightAligned\"\n                (keydown)=\"closeDropDownOnEscape($event.keyCode)\">\n                <ng-content></ng-content>\n        </div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxDropdownComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxDropdownComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "isRightAligned": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "height": [{ type: core.Input },],
            "clickedOutside": [{ type: core.Output },],
        };
        return UxDropdownComponent;
    }());
    var UxDropdownComponentModule = (function () {
        function UxDropdownComponentModule() {
        }
        UxDropdownComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxDropdownComponent],
                        declarations: [UxDropdownComponent]
                    },] },
        ];
        return UxDropdownComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFieldSearchComponent = (function () {
        function UxFieldSearchComponent(uxService) {
            this.uxService = uxService;
            this.inputPlaceholderLabel = 'Search...';
            this.searchButtonAsIcon = false;
            this.isFilterButtonTrigger = false;
            this.isDropdownFilter = false;
            this.isAutofocus = false;
            this.suggestions = false;
            this.suggestionsData = [];
            this.dropdownFilterLabel = 'Advanced search';
            this.dropdownFilterTypeClass = 'secondary';
            this.dropdownFilterIsSplitButtonToggle = false;
            this.dropdownFilterIsDropDownRightAligned = false;
            this.dropdownFilterIsUpdateLabelFromSelectedItem = false;
            this.dropdownFilterIsOutline = false;
            this.dropdownFilterIsDisabled = false;
            this.dropdownFilterWidth = 'auto';
            this.dropdownFilterMaxHeight = '200px';
            this.dropdownFilterLinks = [];
            this.search = new core.EventEmitter();
            this.isFilterActive = false;
            this.data = '';
            this.dropdownFilterHasItems = true;
            this.translatedSearchButtonLabel = '';
            this.searchField = new forms.FormControl();
            this.propagateChange = function (_) { };
            this.propagateTouched = function () { };
        }
        /**
         * @return {?}
         */
        UxFieldSearchComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.dropdownFilterLinks && this.dropdownFilterLinks.length > 0) {
                this.dropdownFilterHasItems = false;
            }
            if (!this.searchButtonLabel) {
                this.translatedSearchButtonLabel = this.uxService.translate('search');
            }
            else {
                this.translatedSearchButtonLabel = this.searchButtonLabel;
            }
            this.filteredOptions = this.searchField.valueChanges.pipe(operators.startWith(''), operators.map(function (value) {
                _this.data = value;
                return _this._filter(value);
            }));
            if (this.defaultValue) {
                this.searchField.patchValue(this.defaultValue);
            }
        };
        /**
         * @return {?}
         */
        UxFieldSearchComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.isAutofocus) {
                this.focus();
            }
        };
        /**
         * @param {?} name
         * @return {?}
         */
        UxFieldSearchComponent.prototype._filter = /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            return this.suggestionsData.filter(function (option) { return option.toLowerCase().indexOf(name.toLowerCase()) > -1; });
        };
        /**
         * @return {?}
         */
        UxFieldSearchComponent.prototype.onClearClick = /**
         * @return {?}
         */
        function () {
            this.searchField.patchValue('');
            this.propagateChange('');
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxFieldSearchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== undefined) {
                this.data = value;
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxFieldSearchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxFieldSearchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateTouched = fn;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFieldSearchComponent.prototype.onChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ newValue = event.target.value;
            this.data = newValue;
            this.propagateChange(this.data);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFieldSearchComponent.prototype.onKeyup = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.onChange(event);
            if (event.keyCode === 13) {
                this.search.emit(event.target.value);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFieldSearchComponent.prototype.onSearch = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.search.emit(this.data);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFieldSearchComponent.prototype.onTouched = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.propagateTouched();
        };
        /**
         * @return {?}
         */
        UxFieldSearchComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (this.inputElementRef) {
                this.inputElementRef.nativeElement.focus();
            }
        };
        UxFieldSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-field-search',
                        template: "<div class=\"ux-field-search {{styleClass}}\"> <div class=\"input-group\"> <span class=\"input-group-prepend\"> <span class=\"input-group-text\"> <span class=\"ux-icon ux-icon-search\"></span> </span> </span> <div class=\"ux-clearable-input-wrapper\"> <input type=\"text\" matInput [matAutocomplete]=\"auto\" [formControl]=\"searchField\" class=\"form-control\" placeholder=\"{{inputPlaceholderLabel}}\" [value]=\"defaultValue\" (change)=\"onChange($event)\" (keyup)=\"onKeyup($event)\" (blur)=\"onTouched($event)\"/> <i class=\"ux-clearable-input-wrapper__clear\" *ngIf=\"data\" (click)=\"onClearClick()\">&times;</i> <mat-autocomplete #auto=\"matAutocomplete\"> <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option\"> {{ option }} </mat-option> </mat-autocomplete> </div> <span class=\"input-group-append\"> <ng-template [ngIf]=\"isDropdownFilter\"> <ux-dropdown-button [hasItems]=\"dropdownFilterHasItems\" [links]=\"dropdownFilterLinks\" [styleClass]=\"'ux-dropdown-button-search ' + dropdownFilterStyleClass\" [label]=\"dropdownFilterLabel\" [typeClass]=\"dropdownFilterTypeClass\" [iconClass]=\"dropdownFilterIconClass\" [isSplitButtonToggle]=\"dropdownFilterIsSplitButtonToggle\" [isDropDownRightAligned]=\"dropdownFilterIsDropDownRightAligned\" [isUpdateLabelFromSelectedItem]=\"dropdownFilterIsUpdateLabelFromSelectedItem\" [isOutline]=\"dropdownFilterIsOutline\" [isDisabled]=\"dropdownFilterIsDisabled\" [width]=\"dropdownFilterWidth\" [dropdownMaxHeight]=\"dropdownFilterMaxHeight\"> <div class=\"p-2\"> <ng-container *ngTemplateOutlet=\"filterContent\"></ng-container> </div> </ux-dropdown-button> </ng-template> </span> <span class=\"input-group-append\"> <button class=\"btn btn-primary\" type=\"button\" (click)=\"onSearch($event)\"> <span *ngIf=\"!searchButtonAsIcon\">{{translatedSearchButtonLabel}}</span> <span *ngIf=\"searchButtonAsIcon\"><i class=\"ux-icon ux-icon-search\"></i></span> </button> </span> <span *ngIf=\"customFilterContent && isFilterButtonTrigger\" class=\"input-group-append\"> <button class=\"btn btn-secondary\" type=\"button\" (click)=\"isFilterActive = !isFilterActive\"> <span class=\"ux-icon\" [ngClass]=\"!isFilterActive ? 'ux-icon-filter' : 'ux-icon-times'\"></span> </button> </span> </div> <ng-template [ngIf]=\"!isDropdownFilter && isFilterActive\"> <ng-container *ngTemplateOutlet=\"filterContent\"></ng-container> </ng-template> </div> <ng-template #filterContent> <div class=\"mt-2\"> <ng-content select=\"uxFieldSearchFilterContent\"></ng-content> </div> <ng-template> ",
                        providers: [{
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef(function () { return UxFieldSearchComponent; }),
                                multi: true,
                            }]
                    },] },
        ];
        /** @nocollapse */
        UxFieldSearchComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxFieldSearchComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "inputPlaceholderLabel": [{ type: core.Input },],
            "searchButtonLabel": [{ type: core.Input },],
            "searchButtonAsIcon": [{ type: core.Input },],
            "filterContentWidth": [{ type: core.Input },],
            "filterContentHeight": [{ type: core.Input },],
            "isFilterButtonTrigger": [{ type: core.Input },],
            "isDropdownFilter": [{ type: core.Input },],
            "isAutofocus": [{ type: core.Input },],
            "suggestions": [{ type: core.Input },],
            "suggestionsData": [{ type: core.Input },],
            "defaultValue": [{ type: core.Input },],
            "dropdownFilterStyleClass": [{ type: core.Input },],
            "dropdownFilterLabel": [{ type: core.Input },],
            "dropdownFilterIconClass": [{ type: core.Input },],
            "dropdownFilterTypeClass": [{ type: core.Input },],
            "dropdownFilterIsSplitButtonToggle": [{ type: core.Input },],
            "dropdownFilterIsDropDownRightAligned": [{ type: core.Input },],
            "dropdownFilterIsUpdateLabelFromSelectedItem": [{ type: core.Input },],
            "dropdownFilterIsOutline": [{ type: core.Input },],
            "dropdownFilterIsDisabled": [{ type: core.Input },],
            "dropdownFilterWidth": [{ type: core.Input },],
            "dropdownFilterMaxHeight": [{ type: core.Input },],
            "dropdownFilterLinks": [{ type: core.Input },],
            "search": [{ type: core.Output },],
            "inputElementRef": [{ type: core.ViewChild, args: ['input',] },],
            "customFilterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxFieldSearchFilterContentTagDirective; }),] },],
        };
        return UxFieldSearchComponent;
    }());
    var UxFieldSearchFilterContentTagDirective = (function () {
        function UxFieldSearchFilterContentTagDirective() {
        }
        UxFieldSearchFilterContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFieldSearchFilterContent' },] },
        ];
        return UxFieldSearchFilterContentTagDirective;
    }());
    var UxFieldSearchComponentModule = (function () {
        function UxFieldSearchComponentModule() {
        }
        UxFieldSearchComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxDropdownComponentModule,
                            UxDropdownButtonComponentModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            autocomplete.MatAutocompleteModule,
                        ],
                        exports: [
                            UxFieldSearchComponent,
                            UxFieldSearchFilterContentTagDirective,
                        ],
                        declarations: [
                            UxFieldSearchComponent,
                            UxFieldSearchFilterContentTagDirective,
                        ]
                    },] },
        ];
        return UxFieldSearchComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxOverlayComponent = (function () {
        function UxOverlayComponent() {
            this.isActive = false;
        }
        UxOverlayComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-overlay',
                        template: "\n      <div class=\"ux-overlay {{styleClass}}\" [class.ux-overlay--is-active]=\"isActive\"></div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxOverlayComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
        };
        return UxOverlayComponent;
    }());
    var UxOverlayComponentModule = (function () {
        function UxOverlayComponentModule() {
        }
        UxOverlayComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxOverlayComponent],
                        declarations: [UxOverlayComponent]
                    },] },
        ];
        return UxOverlayComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFieldsetComponent = (function () {
        function UxFieldsetComponent() {
            this.typeClass = 'default';
            this.isFirst = false;
            this.isLarge = false;
            this.isCompactFields = false;
            this.isVerticalFields = false;
            this.isHighlighted = false;
            this.isExpandable = false;
            this.isExpanded = true;
            this.expanded = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxFieldsetComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ stateClass = '';
            var /** @type {?} */ headerStateClass = '';
            if (this.isFirst) {
                stateClass += 'ux-fieldset--first ';
            }
            if (this.isLarge) {
                stateClass += 'ux-fieldset--large ';
            }
            if (this.isExpandable) {
                headerStateClass += 'ux-fieldset__header--expandable';
            }
            this.stateClass = stateClass;
            this.headerStateClass = headerStateClass;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFieldsetComponent.prototype.onToggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isExpandable) {
                this.isExpanded = !this.isExpanded;
                this.expanded.emit(this.id);
            }
        };
        UxFieldsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-fieldset',
                        template: "\n   <div id=\"{{id}}\" class=\"ux-fieldset {{styleClass}} {{stateClass}}\" [class.ux-fieldset--highlighted]=\"isHighlighted\">\n       <div *ngIf=\"label\" class=\"ux-fieldset__header {{headerStateClass}}\" (click)=\"onToggle($event)\">\n           <div class=\"ux-fieldset__header-label ux-u-color-{{ typeClass }}\">\n               <i *ngIf=\"iconClass\" class=\"{{ iconClass }} mr-1\"></i>\n               {{ label }}\n           </div>\n           <div class=\"ux-fieldset__header-right-content\">\n               <ng-template [ngIf]=\"customLabelRightContent\">\n                   <ng-content select=\"uxFieldsetLabelRightContent\"></ng-content>\n               </ng-template>\n               <span *ngIf=\"isExpandable\" class=\"ux-fieldset__header-expand-toggle ux-icon\"\n                     [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\">\n               </span>\n           </div>\n       </div>\n       <div *ngIf=\"isExpanded\" class=\"ux-fieldset__content\">\n           <ng-content></ng-content>\n       </div>\n   </div>\n   <ux-overlay [isActive]=\"isHighlighted\"></ux-overlay>\n"
                    },] },
        ];
        /** @nocollapse */
        UxFieldsetComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "labelWidthClass": [{ type: core.Input },],
            "inputWidthClass": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "isFirst": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isCompactFields": [{ type: core.Input },],
            "isVerticalFields": [{ type: core.Input },],
            "isHighlighted": [{ type: core.Input },],
            "isExpandable": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "expanded": [{ type: core.Output },],
            "customLabelRightContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxFieldsetLabelRightContentTagDirective; }),] },],
        };
        return UxFieldsetComponent;
    }());
    var UxFieldsetLabelRightContentTagDirective = (function () {
        function UxFieldsetLabelRightContentTagDirective() {
        }
        UxFieldsetLabelRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFieldsetLabelRightContent' },] },
        ];
        return UxFieldsetLabelRightContentTagDirective;
    }());
    var UxFieldsetComponentModule = (function () {
        function UxFieldsetComponentModule() {
        }
        UxFieldsetComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxOverlayComponentModule],
                        exports: [UxFieldsetComponent, UxFieldsetLabelRightContentTagDirective],
                        declarations: [UxFieldsetComponent, UxFieldsetLabelRightContentTagDirective]
                    },] },
        ];
        return UxFieldsetComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ noop = function () { };
    var /** @type {?} */ UX_SWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return UxSwitchComponent; }),
        multi: true,
    };
    var UxSwitchComponent = (function () {
        function UxSwitchComponent() {
            this.isChecked = false;
            this.isDisabled = false;
            this.isSmall = false;
            this.isLarge = false;
            this.tabindex = '0';
            this.toggle = new core.EventEmitter();
            this.onChange = noop;
            this.onTouched = noop;
        }
        /**
         * @param {?} evt
         * @return {?}
         */
        UxSwitchComponent.prototype.handleKey = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            if (evt.which === KeyCodes.SPACE) {
                this.handleClicked();
            }
        };
        /**
         * @return {?}
         */
        UxSwitchComponent.prototype.handleClicked = /**
         * @return {?}
         */
        function () {
            if (this.isDisabled) {
                return;
            }
            this.isChecked = !this.isChecked;
            this.onChange(this.isChecked);
            this.onTouched(this.isChecked);
            this.toggle.emit(this.isChecked);
        };
        /**
         * @param {?} obj
         * @return {?}
         */
        UxSwitchComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
        function (obj) {
            this.isChecked = obj;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxSwitchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxSwitchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        UxSwitchComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.isDisabled = isDisabled;
        };
        UxSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-switch',
                        template: "\n        <span\n          class=\"ux-c-switch {{styleClass}}\"\n          [class.ux-c-switch--small]=\"isSmall\"\n          [class.ux-c-switch--large]=\"isLarge\"\n          [class.ux-c-switch--checked]=\"isChecked\"\n          [class.ux-c-switch--disabled]=\"isDisabled\"\n          role=\"switch\"\n          [tabindex]=\"tabindex\"\n          [attr.aria-label]=\"label\"\n          [attr.aria-checked]=\"isChecked\"\n          [attr.aria-disabled]=\"isDisabled\">\n          <small class=\"ux-c-switch__handle\"></small>\n        </span>\n  ",
                        providers: [UX_SWITCH_VALUE_ACCESSOR],
                    },] },
        ];
        /** @nocollapse */
        UxSwitchComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "isChecked": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "toggle": [{ type: core.Output },],
            "handleKey": [{ type: core.HostListener, args: ['keyup', ['$event'],] },],
            "handleClicked": [{ type: core.HostListener, args: ['click',] },],
        };
        return UxSwitchComponent;
    }());
    var UxSwitchComponentModule = (function () {
        function UxSwitchComponentModule() {
        }
        UxSwitchComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxSwitchComponent],
                        declarations: [UxSwitchComponent]
                    },] },
        ];
        return UxSwitchComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxBadgeGroupComponent = (function () {
        function UxBadgeGroupComponent() {
            this.typeClass = 'default';
            this.isSmall = false;
            this.isLarge = false;
            this.isPill = false;
        }
        UxBadgeGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-badge-group',
                        template: "<span class=\"ux-badge-group ux-badge-group-{{typeClass}} {{styleClass}}\"> <span class=\"badge badge-{{typeClass}} ux-badge-group__badge-left\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\"> {{label}} </span> <span class=\"badge badge-secondary ux-badge-group__badge-right ux-badge-group__badge-right--{{typeClass}}\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\"> {{subLabel}} </span> </span> ",
                    },] },
        ];
        /** @nocollapse */
        UxBadgeGroupComponent.ctorParameters = function () { return []; };
        UxBadgeGroupComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isPill": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
        };
        return UxBadgeGroupComponent;
    }());
    var UxBadgeGroupComponentModule = (function () {
        function UxBadgeGroupComponentModule() {
        }
        UxBadgeGroupComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxBadgeGroupComponent],
                        declarations: [UxBadgeGroupComponent]
                    },] },
        ];
        return UxBadgeGroupComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDashboardButtonComponent = (function () {
        function UxDashboardButtonComponent() {
            this.isRounded = true;
            this.isLarge = false;
            this.isFullWidth = false;
            this.cmpPrefix = 'ux-dashboard-button';
        }
        Object.defineProperty(UxDashboardButtonComponent.prototype, "stateRoundedClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isRounded) {
                    return this.cmpPrefix + '--rounded';
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxDashboardButtonComponent.prototype, "stateTypeClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.typeClass) {
                    return this.cmpPrefix + '--' + this.typeClass;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxDashboardButtonComponent.prototype, "stateLargeClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isLarge) {
                    return this.cmpPrefix + '--large';
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxDashboardButtonComponent.prototype, "stateFullWidthClass", {
            get: /**
             * @return {?}
             */
            function () {
                if (this.isFullWidth) {
                    return this.cmpPrefix + '--full-width';
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        UxDashboardButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-button',
                        template: "\n        <div class=\"ux-dashboard-button {{stateRoundedClass}} {{stateTypeClass}} {{stateLargeClass}} {{stateFullWidthClass}}\" tabindex=\"1\">\n            <div class=\"ux-dashboard-button__content\">\n                <div *ngIf=\"iconClass\" class=\"ux-dashboard-button__content-main-icon\">\n                    <span class=\"ux-dashboard-button__icon-element {{iconClass}}\"></span>\n                </div>\n                <div *ngIf=\"!iconClass\" class=\"ux-dashboard-button__content-main-label\">\n                    {{mainLabel}}\n                </div>\n                <div class=\"ux-dashboard-button__content-title\">\n                    {{label}}\n                </div>\n                <div class=\"ux-dashboard-button__content-sub-title\">\n                    {{subLabel}}\n                </div>\n            </div>\n        </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxDashboardButtonComponent.propDecorators = {
            "mainLabel": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "isRounded": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "isFullWidth": [{ type: core.Input },],
        };
        return UxDashboardButtonComponent;
    }());
    var UxDashboardButtonComponentModule = (function () {
        function UxDashboardButtonComponentModule() {
        }
        UxDashboardButtonComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule],
                        exports: [UxDashboardButtonComponent],
                        declarations: [UxDashboardButtonComponent]
                    },] },
        ];
        return UxDashboardButtonComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDashboardButtonsComponent = (function () {
        function UxDashboardButtonsComponent() {
            this.isRounded = true;
            this.isLarge = false;
            this.isExtendedPanelsViewActive = false;
        }
        /**
         * @return {?}
         */
        UxDashboardButtonsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            // console.log(this.buttons)
            if (this.isRounded) {
                this.buttons.forEach(function (i) {
                    i.isRounded = true;
                });
            }
            else {
                this.buttons.forEach(function (i) {
                    i.isRounded = false;
                });
            }
            if (this.isLarge) {
                this.buttons.forEach(function (i) {
                    i.isLarge = true;
                });
            }
            else {
                this.buttons.forEach(function (i) {
                    i.isLarge = false;
                });
            }
        };
        UxDashboardButtonsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-buttons',
                        template: "\n    <ul class=\"ux-dashboard-buttons {{styleClass}}\">\n        <ng-content></ng-content>\n    </ul>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxDashboardButtonsComponent.propDecorators = {
            "isRounded": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "buttons": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxDashboardButtonComponent; }),] },],
        };
        return UxDashboardButtonsComponent;
    }());
    var UxDashboardButtonsComponentModule = (function () {
        function UxDashboardButtonsComponentModule() {
        }
        UxDashboardButtonsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxDashboardButtonsComponent],
                        declarations: [UxDashboardButtonsComponent]
                    },] },
        ];
        return UxDashboardButtonsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTabComponent = (function () {
        function UxTabComponent() {
            this.isClosable = false;
            this.isDisabled = false;
            this.isActive = false;
            this.isVisible = true;
            this.hasValidationErrors = false;
            this.isVisibleOnScreen = true;
        }
        UxTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tab',
                        template: "\n    <div [hidden]=\"!isActive || !isVisible\">\n        <ng-content></ng-content>\n    </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTabComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "index": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "isClosable": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "tag": [{ type: core.Input },],
            "tagTypeClass": [{ type: core.Input },],
            "hasMarker": [{ type: core.Input },],
            "markerTypeClass": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "isVisible": [{ type: core.Input },],
            "hasValidationErrors": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "labelStyleClass": [{ type: core.Input },],
        };
        return UxTabComponent;
    }());
    var UxTabComponentModule = (function () {
        function UxTabComponentModule() {
        }
        UxTabComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTabComponent],
                        declarations: [UxTabComponent]
                    },] },
        ];
        return UxTabComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTabService = (function () {
        function UxTabService(uxService) {
            this.uxService = uxService;
            this.activeTabIndex = 1;
            this.tabs = [];
            console.log('UxTabService initiated');
        }
        /**
         * @param {?} tabs
         * @param {?} route
         * @return {?}
         */
        UxTabService.prototype.init = /**
         * @param {?} tabs
         * @param {?} route
         * @return {?}
         */
        function (tabs, route) {
            this.tabs = tabs;
            this.route = route;
            var /** @type {?} */ currentRoute = this.uxService.appRouter.url;
            var /** @type {?} */ currentTabUrl = currentRoute.substr(currentRoute.lastIndexOf('/') + 1);
            for (var /** @type {?} */ i = 0; i < this.tabs.length; i++) {
                if (this.tabs[i].url === currentTabUrl) {
                    this.activeTabIndex = i + 1;
                }
            }
        };
        /**
         * @param {?} increment
         * @return {?}
         */
        UxTabService.prototype.navigationIncrement = /**
         * @param {?} increment
         * @return {?}
         */
        function (increment) {
            var /** @type {?} */ newIndex = this.activeTabIndex + increment;
            if (newIndex >= 1 && newIndex <= this.tabs.length) {
                this.activeTabIndex = newIndex;
            }
        };
        /**
         * @param {?} tab
         * @return {?}
         */
        UxTabService.prototype.selectTab = /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            this.activeTabIndex = tab.index;
            if (tab.url) {
                this._navigateToTab(tab.url);
            }
        };
        /**
         * @param {?} url
         * @return {?}
         */
        UxTabService.prototype._navigateToTab = /**
         * @param {?} url
         * @return {?}
         */
        function (url) {
            this.uxService.appRouter.navigate([url], { relativeTo: this.route });
        };
        UxTabService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxTabService.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        return UxTabService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTabsComponent = (function () {
        function UxTabsComponent(uxService, el) {
            var _this = this;
            this.uxService = uxService;
            this.el = el;
            this.tabs = [];
            this.isMainNavigation = false;
            this.isSubTabs = false;
            this.tabSelected = new core.EventEmitter();
            this.tabClosed = new core.EventEmitter();
            this.activeTabIndexChange = new core.EventEmitter();
            this.subscription = this.uxService.activeBreakpoint.subscribe(function (bkp) {
                _this.checkTabsWidthHandler();
            });
        }
        /**
         * @return {?}
         */
        UxTabsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.childrenTabs.forEach(function (tab) {
                _this.tabs.push(tab);
            });
            var /** @type {?} */ activeTabs = this.tabs.filter(function (tab) { return tab.isActive; });
            if (activeTabs.length === 0 && !this.activeTabIndex) {
                this._selectTab(this.tabs[0], 1);
            }
            else {
                if (this.activeTabIndex) {
                    this._selectTab(this._getTab(this.activeTabIndex - 1), this.activeTabIndex);
                }
            }
        };
        /**
         * @return {?}
         */
        UxTabsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscription.unsubscribe();
        };
        /**
         * @return {?}
         */
        UxTabsComponent.prototype.checkTabsWidthHandler = /**
         * @return {?}
         */
        function () {
            if (this.el.nativeElement.children[0]) {
                var /** @type {?} */ lastVisibleOnScreenTab = this.el.nativeElement.children[0].lastElementChild;
                if (lastVisibleOnScreenTab) {
                    var /** @type {?} */ right = lastVisibleOnScreenTab.offsetLeft + lastVisibleOnScreenTab.clientWidth;
                    var /** @type {?} */ triggerOffset = 30;
                    var /** @type {?} */ position = this.uxService.position(lastVisibleOnScreenTab);
                    if (right + triggerOffset > this.uxService.windowWidth) {
                        this.tabs[this.tabs.length - 1].isVisibleOnScreen = false;
                    }
                    else {
                        this.tabs[this.tabs.length - 1].isVisibleOnScreen = true;
                    }
                }
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxTabsComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (this.activeTabIndex && this.tabs) {
                this._selectTab(this._getTab(this.activeTabIndex - 1), this.activeTabIndex);
            }
        };
        /**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        UxTabsComponent.prototype.onSelectTab = /**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        function (tab, index) {
            if (!tab.isDisabled) {
                this._selectTab(tab, index);
            }
        };
        /**
         * @param {?} event
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        UxTabsComponent.prototype.onCloseTab = /**
         * @param {?} event
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        function (event, tab, index) {
            event.stopPropagation();
            tab.isVisible = false;
            if (index > 0) {
                this._selectTab(this.tabs[index - 1], index - 1);
            }
            this.tabClosed.emit(tab);
        };
        /**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        UxTabsComponent.prototype._selectTab = /**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        function (tab, index) {
            if (tab) {
                this.tabs.forEach(function (currentStep) { return currentStep.isActive = false; });
                tab.isActive = true;
                tab.index = index;
                this.activeTabIndex = index;
                this.activeTabIndexChange.emit(index);
                this.tabSelected.emit(tab);
            }
        };
        /**
         * @param {?} index
         * @return {?}
         */
        UxTabsComponent.prototype._getTab = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (index >= 0 && index <= this.tabs.length) {
                return this.tabs[index];
            }
            return null;
        };
        UxTabsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabs',
                        template: "\n    <div class=\"ux-tabs {{styleClass}}\" [class.ux-tabs--main-navigation]=\"isMainNavigation\">\n        <div class=\"ux-tabs__items\">\n            <ng-template *ngFor=\"let tab of tabs; let i = index\" [ngIf]=\"tab.isVisible\">\n                <div class=\"ux-tab-item {{tab.styleClass}}\" id=\"{{tab.id}}\" (click)=\"onSelectTab(tab, i+1)\"\n                        [class.ux-tab-item--active]=\"tab.isActive\"\n                        [class.ux-tab-item--disabled]=\"tab.isDisabled\"\n                        [class.ux-tab-item--sub-tabs]=\"isSubTabs\"\n                        [class.ux-tab-item--invalid]=\"tab.hasValidationErrors\"\n                        [class.ux-tab-item--hidden]=\"!tab.isVisible\">\n                    <ux-a-icon styleClass=\"ux-tab-item__icon\"\n                            iconClass=\"{{tab.iconClass}}\" typeClass=\"{{tab.iconTypeClass}}\"\n                            [isRounded]=\"false\">\n                    </ux-a-icon>\n                    <ux-a-label styleClass=\"ux-tab-item__label\" labelStyleClass=\"{{tab.labelStyleClass}}\"\n                                [isDisabled]=\"tab.isDisabled\"\n                                label=\"{{tab.label}}\"\n                                subLabel=\"{{tab.subLabel}}\"\n                                [isBoldLabel]=\"true\">\n                    </ux-a-label>\n                    <ux-a-tag *ngIf=\"tab.tag\" styleClass=\"ux-tab-item__tag\"\n                            label=\"{{tab.tag}}\"\n                            [isSmall]=\"true\"\n                            typeClass=\"{{tab.tagTypeClass}}\">\n                    </ux-a-tag>\n                    <ux-a-marker *ngIf=\"tab.hasMarker\"\n                                styleClass=\"ux-tab-item__marker\"\n                                typeClass=\"{{tab.markerTypeClass}}\">\n                    </ux-a-marker>\n                    <span\n                        *ngIf=\"tab.isClosable\"\n                        class=\"ux-tab-item__close-toggle ux-icon ux-icon-times\"\n                        (click)=\"onCloseTab($event,tab,i)\"></span>\n                </div>\n            </ng-template>\n        </div>\n        <div class=\"ux-tabs__right-content\">\n            <ng-content select=\"uxTabsRightContent\"></ng-content>\n        </div>\n    </div>\n    <div class=\"ux-tab-content\">\n        <ng-content></ng-content>\n    </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTabsComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: core.ElementRef, },
        ]; };
        UxTabsComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "tabs": [{ type: core.Input },],
            "isMainNavigation": [{ type: core.Input },],
            "isSubTabs": [{ type: core.Input },],
            "activeTabIndex": [{ type: core.Input },],
            "tabSelected": [{ type: core.Output },],
            "tabClosed": [{ type: core.Output },],
            "activeTabIndexChange": [{ type: core.Output },],
            "childrenTabs": [{ type: core.ContentChildren, args: [UxTabComponent,] },],
        };
        return UxTabsComponent;
    }());
    var UxTabsRightContentTagDirective = (function () {
        function UxTabsRightContentTagDirective() {
        }
        UxTabsRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTabsRightContent' },] },
        ];
        return UxTabsRightContentTagDirective;
    }());
    var UxTabsComponentModule = (function () {
        function UxTabsComponentModule() {
        }
        UxTabsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxLabelComponentModule, UxIconComponentModule, UxMarkerComponentModule, UxTagComponentModule],
                        exports: [UxTabsComponent, UxTabsRightContentTagDirective],
                        declarations: [UxTabsComponent, UxTabsRightContentTagDirective],
                        providers: [
                            UxTabService
                        ]
                    },] },
        ];
        return UxTabsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTab = (function () {
        function UxTab(values) {
            if (values === void 0) { values = {}; }
            this.isClosable = false;
            this.isDisabled = false;
            this.isActive = false;
            this.isVisible = true;
            this.isVisibleOnScreen = true;
            this.hasValidationErrors = false;
            Object.assign(this, values);
        }
        return UxTab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTabsBarComponent = (function () {
        function UxTabsBarComponent() {
            this.tabs = [];
            this.isMainNavigation = false;
            this.isSubTabs = false;
            this.tabSelected = new core.EventEmitter();
            this.tabClosed = new core.EventEmitter();
            this.calculatedWidth = 'auto';
        }
        /**
         * @return {?}
         */
        UxTabsBarComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.templates.forEach(function (item) {
                if (item.getType() === 'tabContent') {
                    _this.tabContent = item.template;
                }
                if (item.getType() === 'rightTabContent') {
                    _this.rightTabContent = item.template;
                }
            });
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxTabsBarComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes["tabs"] || changes["isMainNavigation"]) {
                if (this.isMainNavigation) {
                    this.calculatedWidth = (100 / (this.tabs ? this.tabs.length : 1)) + '%';
                }
                else {
                    this.calculatedWidth = 'auto';
                }
            }
        };
        /**
         * @return {?}
         */
        UxTabsBarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        /**
         * @return {?}
         */
        UxTabsBarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () { };
        /**
         * @param {?} tab
         * @return {?}
         */
        UxTabsBarComponent.prototype.onSelectTab = /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            if (!tab.isDisabled) {
                this.tabSelected.emit(tab);
            }
        };
        /**
         * @param {?} event
         * @param {?} tab
         * @return {?}
         */
        UxTabsBarComponent.prototype.onCloseTab = /**
         * @param {?} event
         * @param {?} tab
         * @return {?}
         */
        function (event, tab) {
            event.stopPropagation();
            this.tabClosed.emit(tab);
        };
        UxTabsBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabs-bar',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        template: "\n    <div *ngIf=\"tabs\">\n        <div class=\"ux-tabs {{styleClass}}\" [class.ux-tabs--main-navigation]=\"isMainNavigation\">\n            <div class=\"ux-tabs__items\">\n                <div *ngFor=\"let tab of tabs\" class=\"ux-tab-item {{tab.styleClass}}\" (click)=\"onSelectTab(tab)\"\n                        [class.ux-tab-item--active]=\"tab.isActive\"\n                        [class.ux-tab-item--disabled]=\"tab.isDisabled\"\n                        [class.ux-tab-item--sub-tabs]=\"isSubTabs\"\n                        [style.width]=\"calculatedWidth\">\n                    <ng-template\n                        [ngIf]=\"tabContent\"\n                        [ngTemplateOutlet]=\"tabContent\"\n                        [ngTemplateOutletContext]=\"{ $implicit: tab }\">\n                    </ng-template>\n                    <ng-template [ngIf]=\"!tabContent\">\n                        <ux-a-icon styleClass=\"ux-tab-item__icon\"\n                                iconClass=\"{{tab.iconClass}}\" typeClass=\"{{tab.iconTypeClass}}\"\n                                [isRounded]=\"false\">\n                        </ux-a-icon>\n                        <ux-a-label styleClass=\"ux-tab-item__label {{tab.labelStyleClass}}\"\n                                    [isDisabled]=\"tab.isDisabled\"\n                                    label=\"{{tab.label}}\"\n                                    subLabel=\"{{tab.subLabel}}\"\n                                    [isBoldLabel]=\"true\">\n                        </ux-a-label>\n                        <ux-a-tag *ngIf=\"tab.tag\" styleClass=\"ux-tab-item__tag\"\n                                label=\"{{tab.tag}}\"\n                                [isSmall]=\"true\"\n                                typeClass=\"{{tab.tagTypeClass}}\">\n                        </ux-a-tag>\n                        <ux-a-marker *ngIf=\"tab.hasMarker\"\n                                    styleClass=\"ux-tab-item__marker\"\n                                    typeClass=\"{{tab.markerTypeClass}}\">\n                        </ux-a-marker>\n                        <ng-template\n                            [ngIf]=\"rightTabContent\"\n                            [ngTemplateOutlet]=\"rightTabContent\"\n                            [ngTemplateOutletContext]=\"{ $implicit: tab }\">\n                        </ng-template>\n                    </ng-template>\n\n                    <span *ngIf=\"tab.isClosable\"\n                        class=\"ux-tab-item__close-toggle ux-icon ux-icon-times\"\n                        (click)=\"onCloseTab($event, tab)\"></span>\n                </div>\n            </div>\n            <div class=\"ux-tabs__right-content\">\n                <ng-content select=\"uxTabsBarRightContent\"></ng-content>\n            </div>\n        </div>\n        <div class=\"ux-tab-content\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTabsBarComponent.ctorParameters = function () { return []; };
        UxTabsBarComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "tabs": [{ type: core.Input },],
            "isMainNavigation": [{ type: core.Input },],
            "isSubTabs": [{ type: core.Input },],
            "templates": [{ type: core.ContentChildren, args: [UxTemplateDirective,] },],
            "tabSelected": [{ type: core.Output },],
            "tabClosed": [{ type: core.Output },],
        };
        return UxTabsBarComponent;
    }());
    var UxTabsBarRightContentTagDirective = (function () {
        function UxTabsBarRightContentTagDirective() {
        }
        UxTabsBarRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTabsBarRightContent' },] },
        ];
        return UxTabsBarRightContentTagDirective;
    }());
    var UxTabsBarComponentModule = (function () {
        function UxTabsBarComponentModule() {
        }
        UxTabsBarComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxLabelComponentModule, UxIconComponentModule, UxMarkerComponentModule, UxTagComponentModule],
                        exports: [UxTabsBarComponent, UxTabsBarRightContentTagDirective],
                        declarations: [UxTabsBarComponent, UxTabsBarRightContentTagDirective],
                    },] },
        ];
        return UxTabsBarComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxStaticTabsComponent = (function () {
        function UxStaticTabsComponent() {
            this.isMainNavigation = false;
            this.isSubTabs = false;
            // @Input() activeTabIndex: number; // tom: i'm not sure if this makes sense. If you want to
            // activate a tab you should use the [isActive] attribute on the <ux-tab> element
            this.tabSelected = new core.EventEmitter();
            this.tabClosed = new core.EventEmitter();
            this.tabs = [];
        }
        /**
         * @return {?}
         */
        UxStaticTabsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.tabs = this._filterChildren();
            // this._autoSelect();
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxStaticTabsComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            // if (changes.activeTabIndex) {
            //     this._autoSelect();
            // }
        };
        /**
         * @param {?} tab
         * @return {?}
         */
        UxStaticTabsComponent.prototype.onSelectTab = /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            if (!tab.isDisabled) {
                this._selectTab(tab);
            }
        };
        /**
         * @param {?} closedTab
         * @return {?}
         */
        UxStaticTabsComponent.prototype.onCloseTab = /**
         * @param {?} closedTab
         * @return {?}
         */
        function (closedTab) {
            var /** @type {?} */ nextTab;
            if (closedTab.isActive) {
                var /** @type {?} */ closedTabIndex = this.tabs.indexOf(closedTab);
                var /** @type {?} */ isSelectableTab = function (tab) { return !tab.isDisabled; };
                nextTab = this.tabs
                    .slice(closedTabIndex + 1)
                    .find(isSelectableTab)
                    || this.tabs
                        .slice(0, closedTabIndex)
                        .reverse()
                        .find(isSelectableTab);
                closedTab.isActive = false;
            }
            closedTab.isVisible = false;
            this.tabs = this._filterChildren(); // removes closedTab from tabs
            this.tabClosed.emit(closedTab);
            // select alternative tab
            if (nextTab) {
                this._selectTab(nextTab);
            }
        };
        /**
         * @param {?} tab
         * @return {?}
         */
        UxStaticTabsComponent.prototype._selectTab = /**
         * @param {?} tab
         * @return {?}
         */
        function (tab) {
            if (tab) {
                this.tabs = this.tabs
                    .filter(function (_tab) { return _tab.isVisible; })
                    .map(function (_tab) {
                    _tab.isActive = (_tab === tab);
                    return _tab;
                });
                this.tabSelected.emit(tab);
            }
        };
        /**
         * @return {?}
         */
        UxStaticTabsComponent.prototype._filterChildren = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ _tabs = this.childrenTabs
                .filter(function (childTab) { return childTab.isVisible; });
            // tom: if you want to change the order of the tabs based on the index attribute of the child-elements you
            // could sort them here.
            // you could perform a check/set isActive before returning the new array
            return _tabs;
        };
        UxStaticTabsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-static-tabs',
                        template: "\n        <ux-tabs-bar [tabs]=\"tabs\"\n                         [styleClass]=\"styleClass\"\n                         [isMainNavigation]=\"isMainNavigation\"\n                         [isSubTabs]=\"isSubTabs\"\n                         (tabSelected)=\"onSelectTab($event)\"\n                         (tabClosed)=\"onCloseTab($event)\">\n            <ng-content></ng-content>\n        </ux-tabs-bar>\n  "
                    },] },
        ];
        // private _autoSelect(): void {
        //     const hasTabs = this.tabs.length > 0;
        //     const hasActiveTab = this.tabs.some((tab) => tab.isActive);
        //
        //     if (hasTabs && !hasActiveTab) {
        //         this._selectTab(this._getTab(!!this.activeTabIndex ? this.activeTabIndex : 0));
        //     }
        // }
        /** @nocollapse */
        UxStaticTabsComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "isMainNavigation": [{ type: core.Input },],
            "isSubTabs": [{ type: core.Input },],
            "tabSelected": [{ type: core.Output },],
            "tabClosed": [{ type: core.Output },],
            "childrenTabs": [{ type: core.ContentChildren, args: [UxTabComponent,] },],
        };
        return UxStaticTabsComponent;
    }());
    var UxStaticTabsComponentModule = (function () {
        function UxStaticTabsComponentModule() {
        }
        UxStaticTabsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxTabsBarComponentModule],
                        exports: [UxStaticTabsComponent],
                        declarations: [UxStaticTabsComponent],
                    },] },
        ];
        return UxStaticTabsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimelineItemsComponent = (function () {
        function UxTimelineItemsComponent() {
            this.isLeftAligned = false;
        }
        // @ContentChildren(forwardRef(() => UxTimelineItemComponent)) items: QueryList<UxTimelineItemComponent>;
        /**
         * @return {?}
         */
        UxTimelineItemsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () { };
        UxTimelineItemsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-items',
                        template: "\n     <ul class=\"timeline\" [class.left-aligned]=\"isLeftAligned\">\n        <ng-content></ng-content>\n     </ul>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTimelineItemsComponent.propDecorators = {
            "isLeftAligned": [{ type: core.Input },],
        };
        return UxTimelineItemsComponent;
    }());
    var UxTimelineItemsComponentModule = (function () {
        function UxTimelineItemsComponentModule() {
        }
        UxTimelineItemsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTimelineItemsComponent],
                        declarations: [UxTimelineItemsComponent]
                    },] },
        ];
        return UxTimelineItemsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimelineItemComponent = (function () {
        function UxTimelineItemComponent(uxTimelineItemsComponent) {
            this.isGroup = false;
            this.isLeftAligned = false;
            this.uxTimelineItemsComponent = uxTimelineItemsComponent;
        }
        /**
         * @return {?}
         */
        UxTimelineItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.isLeftAligned = this.uxTimelineItemsComponent.isLeftAligned;
        };
        UxTimelineItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-item',
                        template: "\n        <li [ngClass]=\"styleClass\" [class.ux-timeline-item--more]=\"isGroup\">\n                <div *ngIf=\"!isLeftAligned\" class=\"date\">{{date}}</div>\n                <span *ngIf=\"!isGroup\" class=\"icon ux-icon ux-icon-circle-o\"></span>\n                <div class=\"content\">\n                    <div #customContent><ng-content></ng-content></div>\n                    <ng-container *ngIf=\"customContent.childNodes.length === 0\">\n                        <div class=\"title\">{{label}}</div>\n                        <div class=\"sub\">{{subLabel}}</div>\n                        <div *ngIf=\"isLeftAligned && date\" class=\"date\">{{date}}</div>\n                    </ng-container>\n                </div>\n        </li>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTimelineItemComponent.ctorParameters = function () { return [
            { type: UxTimelineItemsComponent, decorators: [{ type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxTimelineItemsComponent; }),] },] },
        ]; };
        UxTimelineItemComponent.propDecorators = {
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "date": [{ type: core.Input },],
            "isGroup": [{ type: core.Input },],
        };
        return UxTimelineItemComponent;
    }());
    var UxTimelineItemComponentModule = (function () {
        function UxTimelineItemComponentModule() {
        }
        UxTimelineItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxTimelineItemComponent],
                        declarations: [UxTimelineItemComponent]
                    },] },
        ];
        return UxTimelineItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxWizardStepComponent = (function () {
        function UxWizardStepComponent(elementRef) {
            this.elementRef = elementRef;
            this.isCompleted = false;
            this.isActive = false;
            this.isShowStepTitle = false;
            this.isInvalid = false;
            this.isDisabled = false;
        }
        UxWizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "\n    <div [hidden]=\"!isActive\">\n        <ng-template [ngIf]=\"!customContent\">\n            <ux-panel label=\"{{label}}\">\n                <ng-content></ng-content>\n            </ux-panel>\n        </ng-template>\n        <ng-template [ngIf]=\"customContent\">\n            <h5 *ngIf=\"isShowStepTitle\" class=\"section-title first\">\n               {{label}}\n            </h5>\n            <div class=\"content\">\n                <ng-content select=\"uxWizardStepContent\"></ng-content>\n            </div>\n        </ng-template>\n    </div>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxWizardStepComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxWizardStepComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "indexLabel": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "isCompleted": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "isShowStepTitle": [{ type: core.Input },],
            "isInvalid": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "index": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "customContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxWizardStepContentTagDirective; }),] },],
        };
        return UxWizardStepComponent;
    }());
    var UxWizardStepContentTagDirective = (function () {
        function UxWizardStepContentTagDirective() {
        }
        UxWizardStepContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxWizardStepContent' },] },
        ];
        return UxWizardStepContentTagDirective;
    }());
    var UxWizardStepComponentModule = (function () {
        function UxWizardStepComponentModule() {
        }
        UxWizardStepComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxPanelComponentModule],
                        exports: [UxWizardStepComponent, UxWizardStepContentTagDirective],
                        declarations: [UxWizardStepComponent, UxWizardStepContentTagDirective]
                    },] },
        ];
        return UxWizardStepComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxWizardStepService = (function () {
        function UxWizardStepService(uxService) {
            this.uxService = uxService;
            this.activeStepIndex = 1;
            this.steps = [];
            console.log('UxWizardService initiated');
        }
        /**
         * @param {?} steps
         * @param {?} route
         * @return {?}
         */
        UxWizardStepService.prototype.init = /**
         * @param {?} steps
         * @param {?} route
         * @return {?}
         */
        function (steps, route) {
            this.steps = steps;
            this.route = route;
            var /** @type {?} */ currentRoute = this.uxService.appRouter.url;
            var /** @type {?} */ currentStepUrl = currentRoute.substr(currentRoute.lastIndexOf('/') + 1);
            for (var /** @type {?} */ i = 0; i < this.steps.length; i++) {
                if (this.steps[i].url === currentStepUrl) {
                    this.activeStepIndex = i + 1;
                }
            }
        };
        /**
         * @param {?} increment
         * @return {?}
         */
        UxWizardStepService.prototype.navigationIncrement = /**
         * @param {?} increment
         * @return {?}
         */
        function (increment) {
            var /** @type {?} */ newIndex = this.activeStepIndex + increment;
            if (newIndex >= 1 && newIndex <= this.steps.length) {
                this.activeStepIndex = newIndex;
            }
        };
        /**
         * @param {?} step
         * @return {?}
         */
        UxWizardStepService.prototype.selectStep = /**
         * @param {?} step
         * @return {?}
         */
        function (step) {
            this.activeStepIndex = step.index;
            if (step.url) {
                this._navigateToStep(step.url);
            }
        };
        /**
         * @param {?} url
         * @return {?}
         */
        UxWizardStepService.prototype._navigateToStep = /**
         * @param {?} url
         * @return {?}
         */
        function (url) {
            this.uxService.appRouter.navigate([url], { relativeTo: this.route });
        };
        UxWizardStepService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxWizardStepService.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        return UxWizardStepService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxWizardStepsComponent = (function () {
        function UxWizardStepsComponent(uxService) {
            this.uxService = uxService;
            this.isCustomContent = false;
            this.isShowStepTitle = false;
            this.isNavigationAllowed = true;
            this.steps = [];
            this.tabindex = 0;
            this.selectStep = new core.EventEmitter();
            this.stepContentId = this.uxService.uniqueId();
        }
        /**
         * @return {?}
         */
        UxWizardStepsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ stepIdsBuffer = [];
            this.childrenSteps.forEach(function (step) {
                _this.steps.push(step);
                if (!step.id) {
                    step.id = _this.uxService.uniqueId();
                }
                stepIdsBuffer.push(step.id);
            });
            this.stepIds = stepIdsBuffer.join(' ');
            var /** @type {?} */ activeSteps = this.steps.filter(function (step) { return step.isActive; });
            if (activeSteps.length === 0 && !this.activeStepIndex) {
                this._selectStep(this.steps[0], 1);
            }
            else {
                if (this.activeStepIndex) {
                    this._selectStep(this._getStep(this.activeStepIndex - 1), this.activeStepIndex);
                }
            }
            this.steps.forEach(function (step) {
                step.isShowStepTitle = _this.isShowStepTitle;
            });
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxWizardStepsComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var _this = this;
            if (this.activeStepIndex && this.steps) {
                this._selectStep(this._getStep(this.activeStepIndex - 1), this.activeStepIndex);
                var /** @type {?} */ stepIdsBuffer_1 = [];
                this.steps.forEach(function (step) {
                    if (!step.id) {
                        step.id = _this.uxService.uniqueId();
                    }
                    stepIdsBuffer_1.push(step.id);
                });
                this.stepIds = stepIdsBuffer_1.join(' ');
            }
        };
        /**
         * @param {?} step
         * @param {?} index
         * @return {?}
         */
        UxWizardStepsComponent.prototype.onSelectStep = /**
         * @param {?} step
         * @param {?} index
         * @return {?}
         */
        function (step, index) {
            if (!step.isDisabled && this.isNavigationAllowed) {
                this._selectStep(step, index);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxWizardStepsComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.isNavigationAllowed) {
                switch (event.keyCode) {
                    case 37:
                        // ARROW LEFT
                        this.uxService.consumeEvent(event);
                        this.selectPreviousStep();
                        break;
                    case 39:
                        // ARROW RIGHT
                        this.uxService.consumeEvent(event);
                        this.selectNextStep();
                        break;
                }
            }
        };
        /**
         * @return {?}
         */
        UxWizardStepsComponent.prototype.selectPreviousStep = /**
         * @return {?}
         */
        function () {
            if (this.isNavigationAllowed && this.steps) {
                var /** @type {?} */ i = 0;
                for (; i < this.steps.length; i++) {
                    var /** @type {?} */ step = this.steps[i];
                    if (step.isActive) {
                        break;
                    }
                }
                var /** @type {?} */ previousIndex = i;
                do {
                    previousIndex--;
                    if (previousIndex < 0) {
                        previousIndex = this.steps.length - 1;
                    }
                } while (this.steps[previousIndex].isDisabled);
                this._selectStep(this.steps[previousIndex], previousIndex + 1);
                this.focusables.toArray()[previousIndex].nativeElement.focus();
            }
        };
        /**
         * @return {?}
         */
        UxWizardStepsComponent.prototype.selectNextStep = /**
         * @return {?}
         */
        function () {
            if (this.isNavigationAllowed && this.steps) {
                var /** @type {?} */ i = 0;
                for (; i < this.steps.length; i++) {
                    var /** @type {?} */ step = this.steps[i];
                    if (step.isActive) {
                        break;
                    }
                }
                var /** @type {?} */ nextIndex = i;
                do {
                    nextIndex++;
                    if (nextIndex >= this.steps.length) {
                        nextIndex = 0;
                    }
                } while (this.steps[nextIndex].isDisabled);
                this._selectStep(this.steps[nextIndex], nextIndex + 1);
                this.focusables.toArray()[nextIndex].nativeElement.focus();
            }
        };
        /**
         * @param {?} step
         * @param {?} index
         * @return {?}
         */
        UxWizardStepsComponent.prototype._selectStep = /**
         * @param {?} step
         * @param {?} index
         * @return {?}
         */
        function (step, index) {
            if (step) {
                this.steps.forEach(function (currentStep) { return currentStep.isActive = false; });
                step.isActive = true;
                step.index = index;
                this.selectStep.emit(step);
            }
        };
        /**
         * @param {?} index
         * @return {?}
         */
        UxWizardStepsComponent.prototype._getStep = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (index >= 0 && index <= this.steps.length) {
                return this.steps[index];
            }
            return null;
        };
        UxWizardStepsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-steps',
                        template: "\n    <div class=\"ux-wizard-steps\" role=\"tablist\" aria-orientation=\"horizontal\" aria-label=\"\">\n        <div #focusable *ngFor=\"let step of steps; let idx = index\" class=\"ux-wizard-step\" role=\"tab\"\n            [id]=\"step.id\"\n            attr.aria-label=\"{{step.label}} {{step.subLabel}}\"\n            [attr.aria-disabled]=\"step.isDisabled\"\n            [attr.aria-controls]=\"stepContentId\"\n            [tabindex]=\"(step.isActive ? tabindex : -1)\"\n            [class.ux-wizard-step--completed]=\"step.isCompleted\"\n            [class.ux-wizard-step--active]=\"step.isActive\"\n            [class.ux-wizard-step--disabled]=\"step.isDisabled\"\n            [class.ux-wizard-step--error]=\"step.isInvalid\"\n            (click)=\"onSelectStep(step, idx+1)\"\n            (keydown)=\"onKeyDown($event)\">\n            <div *ngIf=\"step.isActive\" class=\"ux-wizard-step__current-marker\" role=\"presentation\">\n                <span class=\"ux-wizard-step__current-marker-icon ux-icon ux-icon-map-marker\"></span>\n            </div>\n            <div class=\"ux-wizard-step__indicator-wrapper\" role=\"presentation\"></div>\n            <div class=\"ux-wizard-step__bullet-item\">\n                <span class=\"ux-wizard-step__bullet-item-icon ux-icon\" role=\"presentation\"\n                    [class.ux-icon-check]=\"step.isCompleted\"\n                    [class.ux-icon-exclamation]=\"step.isInvalid && !step.isActive\"\n                    [class.ux-icon-pencil]=\"step.isActive\">\n                    <span *ngIf=\"!step.isActive && !step.isCompleted && !step.isInvalid\" role=\"presentation\">\n                        {{step.indexLabel !== undefined ? step.indexLabel : idx + 1}}\n                    </span>\n                </span>\n            </div>\n            <div class=\"ux-wizard-step__label-wrapper\" role=\"presentation\">\n                <div class=\"ux-wizard-step__label-wrapper-label\" role=\"presentation\">\n                    {{step.label}}\n                </div>\n                <div class=\"ux-wizard-step__label-wrapper-sub-label\" role=\"presentation\">\n                    {{step.subLabel}}\n                </div>\n            </div>\n        </div>\n    </div>\n    <div [id]=\"stepContentId\" class=\"step-content\" role=\"tabpanel\" [attr.aria-labelledby]=\"stepIds\">\n        <ng-content></ng-content>\n    </div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxWizardStepsComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxWizardStepsComponent.propDecorators = {
            "isCustomContent": [{ type: core.Input },],
            "isShowStepTitle": [{ type: core.Input },],
            "isNavigationAllowed": [{ type: core.Input },],
            "activeStepIndex": [{ type: core.Input },],
            "steps": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "selectStep": [{ type: core.Output },],
            "childrenSteps": [{ type: core.ContentChildren, args: [UxWizardStepComponent,] },],
            "focusables": [{ type: core.ViewChildren, args: ['focusable',] },],
        };
        return UxWizardStepsComponent;
    }());
    var UxWizardStepsComponentModule = (function () {
        function UxWizardStepsComponentModule() {
        }
        UxWizardStepsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxWizardStepsComponent],
                        declarations: [UxWizardStepsComponent],
                        providers: [
                            UxWizardStepService
                        ]
                    },] },
        ];
        return UxWizardStepsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxWizardStep = (function () {
        function UxWizardStep(values) {
            if (values === void 0) { values = {}; }
            this.isCompleted = false;
            this.isActive = false;
            this.isShowStepTitle = false;
            this.isInvalid = false;
            this.isDisabled = false;
            Object.assign(this, values);
        }
        return UxWizardStep;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTreeListItemComponent = (function () {
        function UxTreeListItemComponent(treeListComponent, uxService, elementRef) {
            this.uxService = uxService;
            this.elementRef = elementRef;
            this.active = false;
            this.expanded = false;
            this.alwaysExpanded = false;
            this.isDisplaySubLinksOnHover = false;
            this.subLinks = [];
            this.hasMarker = false;
            this.isNavigateOnlyOnLabelClick = false;
            this.isIconRounded = false;
            this.toggled = new core.EventEmitter();
            this.isVisible = true;
            this.isHovered = false;
            // tree states
            this.hasSub = false;
            // custom content
            this.hasCustomContent = false;
            this.treeListComponent = treeListComponent;
        }
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            // make sure that the tree item can be aria-owned by a parent tree for WAI-ARIA attributes:
            if (!this.id) {
                this.id = this.uxService.uniqueId();
            }
            // setting tree states
            if (this.subTreeList.length !== 0) {
                this.hasSub = true;
            }
            // checking if customContent set
            if (this.customContent.length !== 0) {
                this.hasCustomContent = true;
            }
            if (this.markerTypeClass && !this.hasMarker) {
                this.hasMarker = true;
            }
            // make sure that any child tree-list is non-focusable and that it has the role of a WAI-ARIA group:
            if (this.subTreeList) {
                this.subTreeList.forEach(function (subtree) {
                    subtree.disableFocus();
                    subtree.ariaRole = 'group';
                });
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListItemComponent.prototype.toggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.expanded = !this.expanded;
            this.toggled.next(this);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListItemComponent.prototype.navigateToLink = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.linkUrl && !this.isNavigateOnlyOnLabelClick) {
                this.uxService.appRouter.navigate([this.linkUrl]);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListItemComponent.prototype.onLabelClicked = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.linkUrl && this.isNavigateOnlyOnLabelClick) {
                this.uxService.appRouter.navigate([this.linkUrl]);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListItemComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.keyCode) {
                case 13: // ENTER
                case 32:
                    // SPACE
                    this.expanded = !this.expanded;
                    this.uxService.consumeEvent(event);
                    break;
                case 37:
                    // ARROW LEFT
                    this.expanded = false;
                    this.uxService.consumeEvent(event);
                    break;
                case 38:
                    // ARROW UP
                    if (this.treeListComponent) {
                        if (this.treeListComponent.focusOnPreviousTreeItem(this)) {
                            this.disableFocus();
                        }
                    }
                    this.uxService.consumeEvent(event);
                    break;
                case 39:
                    // ARROW RIGHT
                    this.expanded = true;
                    this.uxService.consumeEvent(event);
                    break;
                case 40:
                    // ARROW DOWN
                    if (this.focusOnNextTreeItem()) {
                        this.disableFocus();
                    }
                    this.uxService.consumeEvent(event);
                    break;
            }
        };
        /**
         * @param {?} state
         * @return {?}
         */
        UxTreeListItemComponent.prototype.setVisibleState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.isVisible = state;
            if (this.subTreeList && this.subTreeList.length !== 0) {
                this.subTreeList.toArray().forEach(function (item) {
                    item.setVisibleState(state);
                });
            }
        };
        /**
         * @param {?} state
         * @return {?}
         */
        UxTreeListItemComponent.prototype.setExpandedState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.expanded = state;
            if (this.subTreeList.length !== 0) {
                this.subTreeList.toArray().forEach(function (item) {
                    item.setExpandedState(state);
                });
            }
        };
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (this.focusable) {
                this.enableFocus();
                this.focusable.nativeElement.focus();
            }
            if (this.treeListComponent) {
                this.treeListComponent.disableFocus();
            }
        };
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.focusOnLastExpandedTreeItem = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ lastExpanded = this.elementRef.nativeElement.querySelectorAll('.ux-tree-list-item-header__content');
            if (lastExpanded && lastExpanded.length > 0) {
                var /** @type {?} */ element = lastExpanded[lastExpanded.length - 1];
                element.setAttribute('tabindex', '0');
                element.focus();
            }
            else {
                this.focus();
            }
        };
        Object.defineProperty(UxTreeListItemComponent.prototype, "hasCustomDetailContent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customDetailContent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxTreeListItemComponent.prototype, "hasCustomSubContainerContent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.customSubContainerContent;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.focusOnNextTreeItem = /**
         * @return {?}
         */
        function () {
            if (this.expanded && this.subTreeList && this.subTreeList.length > 0) {
                this.subTreeList.first.focus();
                return true;
            }
            else if (this.treeListComponent) {
                return this.treeListComponent.focusOnNextTreeItem(this);
            }
            return false;
        };
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.disableFocus = /**
         * @return {?}
         */
        function () {
            if (this.focusable) {
                this.focusable.nativeElement.setAttribute('tabindex', '-1');
            }
        };
        /**
         * @return {?}
         */
        UxTreeListItemComponent.prototype.enableFocus = /**
         * @return {?}
         */
        function () {
            if (this.focusable) {
                this.focusable.nativeElement.setAttribute('tabindex', '0');
            }
        };
        UxTreeListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tree-list-item',
                        template: "<div class=\"ux-tree-list-item {{styleClass}}\" [class.ux-tree-list-item--active]=\"active\" [hidden]=\"!isVisible\"> <div class=\"ux-tree-list-item-header ux-tree-list-item-header--{{typeClass}} {{headerStyleClass}}\" (click)=\"navigateToLink($event)\"> <div #focusable class=\"ux-tree-list-item-header__content\" role=\"treeitem\" [id]=\"id\" (keydown)=\"onKeyDown($event)\" attr.aria-label=\"{{label}} {{subLabel}}\" [attr.aria-expanded]=\"expanded\"> <ng-template [ngIf]=\"hasCustomContent\"> <ng-content select=\"uxTreeListItemCustomContent\"></ng-content> <div class=\"ux-tree-list-item-header__content-right-content\"> <div class=\"ux-tree-list-item-header__content-right-content-sub\"> <ng-container *ngTemplateOutlet=\"rightContent\"></ng-container> </div> <span class=\"ux-tree-list-item-header__content-expand-toggle-wrapper\"> <span *ngIf=\"hasSub && !alwaysExpanded\" class=\"ux-tree-list-item-header__content-expand-toggle\" (click)=\"toggle($event)\"> <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !expanded, 'ux-icon-angle-down': expanded}\"></span> </span> </span> </div> </ng-template> <ng-template [ngIf]=\"!hasCustomContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isClickable]=\"linkUrl && isNavigateOnlyOnLabelClick\" (click)=\"navigateToLink($event)\" (labelClicked)=\"onLabelClicked($event)\" [isBoldLabel]=\"true\" tabindex=\"-1\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxTreeListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-tree-list-item-header__content-right-content\"> <div class=\"ux-tree-list-item-header__content-right-content-sub\"> <ng-container *ngTemplateOutlet=\"rightContent\"></ng-container> </div> <span class=\"ux-tree-list-item-header__content-expand-toggle-wrapper\"> <span *ngIf=\"hasSub && !alwaysExpanded\" class=\"ux-tree-list-item-header__content-expand-toggle\" (click)=\"toggle($event)\"> <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !expanded, 'ux-icon-angle-down': expanded}\"></span> </span> </span> </div> </ng-template> </div> <ng-template [ngIf]=\"hasCustomDetailContent\"> <div class=\"ux-tree-list-item-header__details-content\"> <ng-content select=\"uxTreeListItemDetailsContent\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"hasCustomSubContainerContent\"> <ng-content select=\"uxTreeListItemSubContainerContent\"></ng-content> </ng-template> </div> <ng-template [ngIf]=\"expanded || alwaysExpanded\"> <ng-content></ng-content> </ng-template> </div> <ng-template #rightContent><ng-content select=\"uxTreeListItemRightContent\"></ng-content></ng-template> ",
                    },] },
        ];
        /** @nocollapse */
        UxTreeListItemComponent.ctorParameters = function () { return [
            { type: UxTreeListComponent, decorators: [{ type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxTreeListComponent; }),] },] },
            { type: UxService, },
            { type: core.ElementRef, },
        ]; };
        UxTreeListItemComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "headerStyleClass": [{ type: core.Input },],
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "linkUrl": [{ type: core.Input },],
            "subLabel": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "active": [{ type: core.Input },],
            "expanded": [{ type: core.Input },],
            "alwaysExpanded": [{ type: core.Input },],
            "url": [{ type: core.Input },],
            "isDisplaySubLinksOnHover": [{ type: core.Input },],
            "subLinks": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "hasMarker": [{ type: core.Input },],
            "markerTypeClass": [{ type: core.Input },],
            "isNavigateOnlyOnLabelClick": [{ type: core.Input },],
            "isIconRounded": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "toggled": [{ type: core.Output },],
            "focusable": [{ type: core.ViewChild, args: ['focusable',] },],
            "subTreeList": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxTreeListComponent; }), { descendants: true },] },],
            "customSubLabel": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxTreeListItemSubLabelTagDirective; }),] },],
            "customContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxTreeListItemCustomContentTagDirective; }), { descendants: false },] },],
            "customDetailContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxTreeListItemDetailsContentTagDirective; }),] },],
            "customSubContainerContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxTreeListItemSubContainerContentTagDirective; }),] },],
        };
        return UxTreeListItemComponent;
    }());
    var UxTreeListItemCustomContentTagDirective = (function () {
        function UxTreeListItemCustomContentTagDirective() {
        }
        UxTreeListItemCustomContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListItemCustomContent' },] },
        ];
        return UxTreeListItemCustomContentTagDirective;
    }());
    var UxTreeListItemRightContentTagDirective = (function () {
        function UxTreeListItemRightContentTagDirective() {
        }
        UxTreeListItemRightContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListItemRightContent' },] },
        ];
        return UxTreeListItemRightContentTagDirective;
    }());
    var UxTreeListItemSubLabelTagDirective = (function () {
        function UxTreeListItemSubLabelTagDirective() {
        }
        UxTreeListItemSubLabelTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListItemSubLabel' },] },
        ];
        return UxTreeListItemSubLabelTagDirective;
    }());
    var UxTreeListItemDetailsContentTagDirective = (function () {
        function UxTreeListItemDetailsContentTagDirective() {
        }
        UxTreeListItemDetailsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListItemDetailsContent' },] },
        ];
        return UxTreeListItemDetailsContentTagDirective;
    }());
    var UxTreeListItemSubContainerContentTagDirective = (function () {
        function UxTreeListItemSubContainerContentTagDirective() {
        }
        UxTreeListItemSubContainerContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListItemSubContainerContent' },] },
        ];
        return UxTreeListItemSubContainerContentTagDirective;
    }());
    var UxTreeListItemComponentModule = (function () {
        function UxTreeListItemComponentModule() {
        }
        UxTreeListItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, router.RouterModule, UxLabelComponentModule],
                        exports: [UxTreeListItemComponent, UxTreeListItemSubLabelTagDirective, UxTreeListItemCustomContentTagDirective,
                            UxTreeListItemRightContentTagDirective, UxTreeListItemDetailsContentTagDirective, UxTreeListItemSubContainerContentTagDirective],
                        declarations: [UxTreeListItemComponent, UxTreeListItemSubLabelTagDirective, UxTreeListItemCustomContentTagDirective,
                            UxTreeListItemRightContentTagDirective, UxTreeListItemDetailsContentTagDirective, UxTreeListItemSubContainerContentTagDirective]
                    },] },
        ];
        return UxTreeListItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTreeListComponent = (function () {
        function UxTreeListComponent(elementRef) {
            this.elementRef = elementRef;
            this.isShowToolbar = false;
            this.isShowToolbarToggle = true;
            this.isExpanded = false;
            this.hasItemsUrl = false;
            this.hasItemsBullet = true;
            this.hasLeftIndent = true;
            this.tabindex = '0';
            this.ariaRole = 'tree';
            this.ariaLabel = '';
            this.itemSelected = new core.EventEmitter();
            this.ariaOwns = '';
            this.originalTabindex = '0';
            this.classes = '';
        }
        /**
         * @return {?}
         */
        UxTreeListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.classes = '';
            if (!this.hasItemsBullet) {
                this.classes += ' ux-tree-list--no-bullets';
            }
            if (this.hasLeftIndent) {
                this.classes += ' ux-tree-list--with-left-indent';
            }
            if (this.hasItemsUrl) {
                this.classes += ' ux-tree-list--with-items-url';
            }
            if (this.isExpanded) {
                this.setExpandedState(true);
            }
        };
        /**
         * @return {?}
         */
        UxTreeListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ treeItemIds = [];
            if (this.items) {
                this.items.forEach(function (treeItem) {
                    treeItemIds.push(treeItem.id);
                });
            }
            setTimeout(function () {
                _this.ariaOwns = treeItemIds.join(' ');
                _this.originalTabindex = _this.tabindex;
            }, 0);
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxTreeListComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes && changes['tabindex']) {
                this.originalTabindex = this.tabindex;
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListComponent.prototype.onExpandAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setExpandedState(true);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeListComponent.prototype.onCollapseAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setExpandedState(false);
        };
        /**
         * @param {?} filterValue
         * @return {?}
         */
        UxTreeListComponent.prototype.onFilter = /**
         * @param {?} filterValue
         * @return {?}
         */
        function (filterValue) {
            var _this = this;
            // TODO find a recursive way of doing the filtering throughout the tree structure
            if (filterValue !== '' && filterValue !== undefined) {
                this.setVisibleState(false);
                this.items.toArray().forEach(function (item1) {
                    item1.isVisible = _this.filterMatched(item1.label, filterValue);
                    if (item1.subTreeList.length !== 0) {
                        item1.subTreeList.toArray().forEach(function (item1SubTreeList) {
                            item1SubTreeList.items.toArray().forEach(function (item2) {
                                if (_this.filterMatched(item2.label, filterValue)) {
                                    item2.isVisible = true;
                                    item1.isVisible = true;
                                    item1.expanded = true;
                                    if (item2.subTreeList.length !== 0) {
                                        item2.subTreeList.toArray().forEach(function (item2SubTreeList) {
                                            item2SubTreeList.items.toArray().forEach(function (item3) {
                                                item3.isVisible = true;
                                            });
                                        });
                                    }
                                }
                                if (item2.subTreeList.length !== 0) {
                                    item2.subTreeList.toArray().forEach(function (item2SubTreeList) {
                                        item2SubTreeList.items.toArray().forEach(function (item4) {
                                            if (_this.filterMatched(item4.label, filterValue)) {
                                                item4.isVisible = true;
                                                item2.isVisible = true;
                                                item2.expanded = true;
                                                item1.isVisible = true;
                                                item1.expanded = true;
                                            }
                                        });
                                    });
                                }
                            });
                        });
                    }
                });
            }
            else {
                this.setVisibleState(true);
            }
        };
        /**
         * @return {?}
         */
        UxTreeListComponent.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            this.focus();
        };
        /**
         * @param {?} state
         * @return {?}
         */
        UxTreeListComponent.prototype.setVisibleState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.items.toArray().forEach(function (item) {
                item.setVisibleState(state);
            });
        };
        /**
         * @param {?} state
         * @return {?}
         */
        UxTreeListComponent.prototype.setExpandedState = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.items.toArray().forEach(function (item) {
                item.setExpandedState(state);
            });
        };
        /**
         * @return {?}
         */
        UxTreeListComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            // Focus on the first child tree item:
            if (this.items && this.items.length > 0) {
                this.items.first.focus();
            }
        };
        /**
         * @return {?}
         */
        UxTreeListComponent.prototype.disableFocus = /**
         * @return {?}
         */
        function () {
            this.tabindex = '-1';
        };
        /**
         * @param {?} currentTreeListItem
         * @return {?}
         */
        UxTreeListComponent.prototype.focusOnPreviousTreeItem = /**
         * @param {?} currentTreeListItem
         * @return {?}
         */
        function (currentTreeListItem) {
            if (this.items && this.items.length > 0) {
                var /** @type {?} */ previousTreeListItem = null;
                for (var _i = 0, _a = this.items.toArray(); _i < _a.length; _i++) {
                    var treeListItem = _a[_i];
                    if (treeListItem !== currentTreeListItem) {
                        previousTreeListItem = treeListItem;
                    }
                    else if (previousTreeListItem) {
                        previousTreeListItem.focusOnLastExpandedTreeItem();
                        return true;
                    }
                }
                // Focus on the last item of the previous parent:
                // First find the parent list item:
                if (this.elementRef) {
                    var /** @type {?} */ parent_1 = this.elementRef.nativeElement.parentElement;
                    while (parent_1 && !parent_1.classList.contains('ux-tree-list-item')) {
                        parent_1 = parent_1.parentElement;
                    }
                    if (parent_1) {
                        // parent tree-item is found
                        var /** @type {?} */ content = parent_1.querySelector('.ux-tree-list-item-header__content');
                        if (content) {
                            content.setAttribute('tabindex', '0');
                            content.focus();
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * @param {?} currentTreeListItem
         * @return {?}
         */
        UxTreeListComponent.prototype.focusOnNextTreeItem = /**
         * @param {?} currentTreeListItem
         * @return {?}
         */
        function (currentTreeListItem) {
            if (this.items && this.items.length > 0) {
                if (currentTreeListItem !== this.items.last) {
                    var /** @type {?} */ previousTreeListItem = null;
                    for (var _i = 0, _a = this.items.toArray(); _i < _a.length; _i++) {
                        var treeListItem = _a[_i];
                        if (previousTreeListItem !== currentTreeListItem) {
                            previousTreeListItem = treeListItem;
                        }
                        else {
                            treeListItem.focus();
                            return true;
                        }
                    }
                }
                else {
                    // The current focused tree item is the last one; find the first next tree item:
                    if (this.elementRef) {
                        // First find the parent tree list item:
                        var /** @type {?} */ parent_2 = this.elementRef.nativeElement.parentElement;
                        // Find the parent that is not a last child itself:
                        while (parent_2 && (parent_2.tagName.toLowerCase() !== 'ux-tree-list-item' || parent_2.nextElementSibling === null)) {
                            parent_2 = parent_2.parentElement;
                        }
                        if (parent_2) {
                            // parent tree list item is found; focus on the first child of the next list item
                            var /** @type {?} */ nextTreeListItem = parent_2.nextElementSibling;
                            if (nextTreeListItem) {
                                var /** @type {?} */ next = nextTreeListItem.querySelector('.ux-tree-list-item-header__content');
                                next.setAttribute('tabindex', '0');
                                next.focus();
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        /**
         * @param {?} label
         * @param {?} filterValue
         * @return {?}
         */
        UxTreeListComponent.prototype.filterMatched = /**
         * @param {?} label
         * @param {?} filterValue
         * @return {?}
         */
        function (label, filterValue) {
            if (!label) {
                return false;
            }
            if (label.toUpperCase().indexOf(filterValue.toUpperCase()) !== -1) {
                return true;
            }
            return false;
        };
        UxTreeListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tree-list',
                        template: "\n        <ux-a-toolbar-filter [isVisible]=\"isShowToolbar\" [isToggleVisible]=\"isShowToolbarToggle\"\n                             (filter)=\"onFilter($event)\" (expandAll)=\"onExpandAll($event)\"\n                             (collapseAll)=\"onCollapseAll($event)\"\n                             filterLabel=\"{{filterLabel}}\" expandAllLabel=\"{{expandAllLabel}}\"\n                             collapseAllLabel=\"{{collapseAllLabel}}\">\n            <ng-content select=\"uxTreeListToolbarContent\"></ng-content>\n        </ux-a-toolbar-filter>\n\n        <div class=\"ux-tree-list {{styleClass}} {{classes}}\"\n             [attr.role]=\"ariaRole\"\n             [tabindex]=\"tabindex\" [attr.data-tabindex]=\"originalTabindex\" [attr.aria-label]=\"ariaLabel\" [attr.aria-owns]=\"ariaOwns\"\n             (focus)=\"onFocus()\">\n            <ng-content></ng-content>\n        </div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxTreeListComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxTreeListComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "isShowToolbar": [{ type: core.Input },],
            "isShowToolbarToggle": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "filterLabel": [{ type: core.Input },],
            "expandAllLabel": [{ type: core.Input },],
            "collapseAllLabel": [{ type: core.Input },],
            "hasItemsUrl": [{ type: core.Input },],
            "hasItemsBullet": [{ type: core.Input },],
            "hasLeftIndent": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "ariaRole": [{ type: core.Input },],
            "ariaLabel": [{ type: core.Input },],
            "itemSelected": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxTreeListItemComponent; }),] },],
        };
        return UxTreeListComponent;
    }());
    var UxTreeListToolbarContentTagDirective = (function () {
        function UxTreeListToolbarContentTagDirective() {
        }
        UxTreeListToolbarContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxTreeListToolbarContent' },] },
        ];
        return UxTreeListToolbarContentTagDirective;
    }());
    var UxTreeListComponentModule = (function () {
        function UxTreeListComponentModule() {
        }
        UxTreeListComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, UxToolbarFilterComponentModule],
                        exports: [UxTreeListComponent, UxTreeListToolbarContentTagDirective],
                        declarations: [UxTreeListComponent, UxTreeListToolbarContentTagDirective]
                    },] },
        ];
        return UxTreeListComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCarouselItemComponent = (function () {
        function UxCarouselItemComponent() {
            this.isActive = false;
        }
        UxCarouselItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-carousel-item',
                        template: "<div [hidden]=\"!isActive\" class=\"{{styleClass}}\"> <ng-content></ng-content> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxCarouselItemComponent.ctorParameters = function () { return []; };
        UxCarouselItemComponent.propDecorators = {
            "isActive": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
        };
        return UxCarouselItemComponent;
    }());
    var UxCarouselItemComponentModule = (function () {
        function UxCarouselItemComponentModule() {
        }
        UxCarouselItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxCarouselItemComponent],
                        declarations: [UxCarouselItemComponent]
                    },] },
        ];
        return UxCarouselItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCarouselItemsComponent = (function () {
        function UxCarouselItemsComponent() {
            this.isShowSummaryIndicators = true;
            this.itemsArray = [];
            this.itemsLength = 0;
            this.currentItem = 0;
            this.animStyleClass = 'fx fadeIn';
        }
        /**
         * @return {?}
         */
        UxCarouselItemsComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.items.length > 0) {
                var /** @type {?} */ activeItems = this.items.filter(function (item) { return item.isActive; });
                if (activeItems.length === 0) {
                    this.selectItem(this.items.first);
                }
                this.itemsArray = this.items.toArray();
                this.itemsLength = this.itemsArray.length;
            }
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxCarouselItemsComponent.prototype.selectItem = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.itemsArray.forEach(function (currentItem) { return currentItem.isActive = false; });
            // Changing child already initialized normally produces ExpressionChangedAfterItHasBeenCheckedError
            // thus child change is made in microtask
            Promise.resolve().then(function () { return item.isActive = true; });
        };
        /**
         * @param {?} itemIndex
         * @return {?}
         */
        UxCarouselItemsComponent.prototype.gotoItem = /**
         * @param {?} itemIndex
         * @return {?}
         */
        function (itemIndex) {
            if (this.currentItem <= itemIndex) {
                this.animStyleClass = 'fx slideInRight';
            }
            else {
                this.animStyleClass = 'fx slideInLeft';
            }
            this.currentItem = itemIndex;
            this.selectItem(this.itemsArray[itemIndex]);
        };
        Object.defineProperty(UxCarouselItemsComponent.prototype, "isFirstItemActive", {
            get: /**
             * @return {?}
             */
            function () {
                return this.currentItem === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UxCarouselItemsComponent.prototype, "isLastItemActive", {
            get: /**
             * @return {?}
             */
            function () {
                return this.currentItem === this.itemsArray.length - 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        UxCarouselItemsComponent.prototype.goPrevious = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.animStyleClass = 'fx slideInLeft';
            if (!this.isFirstItemActive) {
                this.currentItem--;
                this.selectItem(this.itemsArray[this.currentItem]);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxCarouselItemsComponent.prototype.goNext = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.animStyleClass = 'fx slideInRight';
            if (!this.isLastItemActive) {
                this.currentItem++;
                this.selectItem(this.itemsArray[this.currentItem]);
            }
        };
        UxCarouselItemsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-carousel-items',
                        template: "<div class=\"ux-carousel-items\"> <div class=\"row flex-container\"> <div class=\"col-1 text-center\"> <span class=\"ux-icon ux-icon-caret-left ux-icon-3x ux-carousel-items__arrow\" [class.ux-carousel-items__arrow--inactive]=\"isFirstItemActive\" (click)=\"goPrevious($event)\"></span> </div> <div class=\"col-10 text-center\" [ngClass]=\"animStyleClass\"> <ng-content></ng-content> </div> <div class=\"col-1 text-center\"> <span class=\"ux-icon ux-icon-caret-right ux-icon-3x ux-carousel-items__arrow\" [class.ux-carousel-items__arrow--inactive]=\"isLastItemActive\" (click)=\"goNext($event)\"></span> </div> </div> <div *ngIf=\"isShowSummaryIndicators\" class=\"row flex-container ux-carousel-items__summary-indicators\"> <div class=\"col-12 text-center\"> <span *ngFor=\"let item of itemsArray; let i = index\" class=\"ux-icon ux-carousel-items__summary-indicators-item\" (click)=\"gotoItem(i)\" [ngClass]=\"i === currentItem ? 'ux-icon-circle ux-u-color-primary' : 'ux-icon-circle-o ux-u-color-grey-light'\"></span> </div> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxCarouselItemsComponent.propDecorators = {
            "isShowSummaryIndicators": [{ type: core.Input },],
            "items": [{ type: core.ContentChildren, args: [UxCarouselItemComponent,] },],
        };
        return UxCarouselItemsComponent;
    }());
    var UxCarouselItemsComponentModule = (function () {
        function UxCarouselItemsComponentModule() {
        }
        UxCarouselItemsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxCarouselItemComponentModule],
                        exports: [UxCarouselItemsComponent],
                        declarations: [UxCarouselItemsComponent]
                    },] },
        ];
        return UxCarouselItemsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTreeNodeComponent = (function () {
        function UxTreeNodeComponent(router$$1, uxService) {
            this.router = router$$1;
            this.uxService = uxService;
            this.isFirst = false;
            this.isLast = false;
            this.isRootNode = false;
            this.isClickTogglingNode = false;
            this.isMultiselect = false;
            this.isRecursiveSelection = false;
            this.isShowActiveNode = false;
            this.nodeClick = new core.EventEmitter();
            this.nodeToggle = new core.EventEmitter();
            this.selectionChange = new core.EventEmitter();
            this.nodeId = "ux-tree-node-" + uxService.uniqueId();
        }
        /**
         * @param {?} node
         * @return {?}
         */
        UxTreeNodeComponent.prototype.hasNodeChildren = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node && node.children && node.children.length > 0;
        };
        /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onNodeKeydown = /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        function (event, uxLink) {
            if (event.keyCode === 13) {
                this.onNodeClick(event, uxLink);
            }
        };
        /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onNodeToggle = /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        function (event, uxLink) {
            this.node.expanded = !this.node.expanded;
            this.nodeToggle.emit(uxLink);
        };
        /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onNodeClick = /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        function (event, uxLink) {
            if (!this.node.metadata) {
                if (!this.node.children || this.node.children.length === 0) {
                    this.node.expanded = !this.node.expanded;
                    if (this.node.url) {
                        this.router.navigate([this.node.url]);
                    }
                    if (this.node.urlExternal) {
                        window.open(this.node.urlExternal, '_blank');
                    }
                }
                else {
                    var /** @type {?} */ clickedEl = event.target['nodeName'];
                    if (this.isClickTogglingNode) {
                        this.onNodeToggle(event, uxLink);
                    }
                    if (clickedEl === 'SPAN' && (this.node.url || this.node.urlExternal)) {
                        if (this.node.url) {
                            this.router.navigate([this.node.url]);
                        }
                        if (this.node.urlExternal) {
                            window.open(this.node.urlExternal, '_blank');
                        }
                    }
                }
            }
            else {
                if (this.node.url) {
                    this.router.navigate([this.node.url]);
                }
                if (this.node.urlExternal) {
                    window.open(this.node.urlExternal, '_blank');
                }
            }
            if (uxLink.command) {
                uxLink.command();
            }
            this.nodeClick.emit(uxLink);
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} uxLink
         * @param {?} evt
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onCheckboxChange = /**
         * @param {?} uxLink
         * @param {?} evt
         * @return {?}
         */
        function (uxLink, evt) {
            if (this.isRecursiveSelection) {
                this.changeSelectionRecursively(uxLink, evt.target.checked);
            }
            this.selectionChange.next(uxLink);
        };
        /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onMetadataNodeToggle = /**
         * @param {?} event
         * @param {?} uxLink
         * @return {?}
         */
        function (event, uxLink) {
            this.node.expanded = !this.node.expanded;
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onSubNodeClick = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.nodeClick.emit(uxLink);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onSubNodeToggle = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.nodeToggle.emit(uxLink);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeNodeComponent.prototype.onSelectionChange = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.selectionChange.next(uxLink);
        };
        /**
         * @param {?} uxLink
         * @param {?} value
         * @return {?}
         */
        UxTreeNodeComponent.prototype.changeSelectionRecursively = /**
         * @param {?} uxLink
         * @param {?} value
         * @return {?}
         */
        function (uxLink, value) {
            var _this = this;
            if (uxLink.hasChildren) {
                uxLink.children.forEach(function (link) {
                    link.selected = value;
                    _this.changeSelectionRecursively(link, value);
                });
            }
        };
        UxTreeNodeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tree-node',
                        template: "<li *ngIf=\"node.visible\" class=\"ux-tree__node\" tabindex=\"1\" title=\"{{node.label}}\" [class.first-child]=\"isFirst\" [class.last-child]=\"isLast\"> <div class=\"ux-tree__node-wrapper px-1\" [class.ux-tree__node--selected]=\"node.selected\"> <ux-button (click)=\"onNodeToggle($event, node)\" (keydown)=\"onNodeKeydown($event, node)\" styleClass=\"ux-tree__node-toggle-icon\" *ngIf=\"hasNodeChildren(node)\" [isSmall]=\"true\" [isFlat]=\"true\" [iconClass]=\"node.expanded ? expandedIconClass : collapsedIconClass\"></ux-button> <span *ngIf=\"isMultiselect\" class=\"ml-2\"> <input type=\"checkbox\" [id]=\"nodeId\" [value]=\"node.label\" [(ngModel)]=\"node.selected\" (change)=\"onCheckboxChange(node, $event)\"> <label class=\"ux-tree__node-checkbox-label\" [for]=\"nodeId\"> </label> </span> <div *ngIf=\"nodeContentTemplate\" class=\"ml-2\"> <ng-template [ngTemplateOutlet]=\"nodeContentTemplate\" [ngTemplateOutletContext]=\"{ $implicit: node }\"> </ng-template> </div> <ng-container *ngIf=\"!nodeContentTemplate\"> <ng-container *ngIf=\"node.typeLabel || node.iconClass\"> <span *ngIf=\"node.typeLabel\" class=\"ux-tree__node-type ux-tree__node-type--{{node.typeClass}}\" (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\"> {{node.typeLabel}} </span> <span *ngIf=\"node.iconClass\" class=\"ux-tree__node-icon ux-tree__node-type--{{node.iconTypeClass}}\"> <span class=\"{{node.iconClass}}\"></span> </span> <div class=\"ux-tree__node-label-wrapped\"> <span (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\">{{node.label}}</span> </div> </ng-container> <ng-container *ngIf=\"!(node.typeLabel || node.iconClass)\"> <span class=\"ux-tree__node-label\" (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\"> {{node.label}} </span> </ng-container> <div *ngIf=\"node.badges\" class=\"ml-auto\"> <span *ngFor=\"let badge of node.badges\" class=\"badge badge--small ux-c-badge--outline badge-pill ux-c-badge badge-{{badge.typeClass}} ux-c-badge--{{badge.typeClass}} ux-tree__node-badge\"> {{badge.label}} </span> </div> <span *ngIf=\"node.metadata && node.metadata.title && node.metadata.title.length > 0\" class=\"ux-tree__node-metacontent-toggle ux-tree__node-clickable\" (click)=\"onMetadataNodeToggle($event, node)\"> <span class=\"ux-icon\" [ngClass]=\"node.expanded ? 'ux-icon ux-icon-angle-down' : 'ux-icon ux-icon-angle-right'\"> </span> </span> </ng-container> </div> <ng-container *ngIf=\"node.expanded\"> <ul *ngIf=\"hasNodeChildren(node)\" class=\"ux-tree__nodes\"> <ux-tree-node *ngFor=\"let subNode of node.children; let isFirst = first; let isLast = last\" [node]=\"subNode\" [isMultiselect]=\"isMultiselect\" [isRecursiveSelection]=\"isRecursiveSelection\" (nodeClick)=\"onSubNodeClick($event)\" (nodeToggle)=\"onSubNodeToggle($event)\" (selectionChange)=\"onSelectionChange($event)\" [isFirst]=\"isFirst\" [isLast]=\"isLast\" [isClickTogglingNode]=\"isClickTogglingNode\" expandedIconClass=\"{{expandedIconClass}}\" collapsedIconClass=\"{{collapsedIconClass}}\" [templateVariable]=\"templateVariable\" [nodeContentTemplate]=\"nodeContentTemplate\" [isShowActiveNode]=\"isShowActiveNode\"> </ux-tree-node> </ul> <div *ngIf=\"node.metadata && node.metadata.title && node.metadata.title.length > 0\" class=\"ux-tree__node-metacontent\"> <ng-template [ngTemplateOutlet]=\"templateVariable\" [ngTemplateOutletContext]=\"{metadata: node.metadata}\"></ng-template> </div> </ng-container> </li> ",
                    },] },
        ];
        /** @nocollapse */
        UxTreeNodeComponent.ctorParameters = function () { return [
            { type: router.Router, },
            { type: UxService, },
        ]; };
        UxTreeNodeComponent.propDecorators = {
            "node": [{ type: core.Input },],
            "isFirst": [{ type: core.Input },],
            "isLast": [{ type: core.Input },],
            "isRootNode": [{ type: core.Input },],
            "isClickTogglingNode": [{ type: core.Input },],
            "isMultiselect": [{ type: core.Input },],
            "isRecursiveSelection": [{ type: core.Input },],
            "expandedIconClass": [{ type: core.Input },],
            "collapsedIconClass": [{ type: core.Input },],
            "templateVariable": [{ type: core.Input },],
            "isShowActiveNode": [{ type: core.Input },],
            "nodeContentTemplate": [{ type: core.Input },],
            "nodeClick": [{ type: core.Output },],
            "nodeToggle": [{ type: core.Output },],
            "selectionChange": [{ type: core.Output },],
        };
        return UxTreeNodeComponent;
    }());
    var UxTreeComponent = (function () {
        function UxTreeComponent() {
            this.isShowToolbar = false;
            this.isExpanded = false;
            this.isMultiselect = false;
            this.isRecursiveSelection = false;
            this.isClickTogglingNode = false;
            this.collapsedIconClass = 'ux-icon ux-icon-ios-plus';
            this.expandedIconClass = 'ux-icon ux-icon-ios-minus';
            this.isShowActiveNode = false;
            this.nodeClick = new core.EventEmitter();
            this.nodeToggle = new core.EventEmitter();
            this.selectionChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxTreeComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isExpanded) {
                this.setNodesExpandedState(this.nodes, true);
            }
            this.templates.forEach(function (item) {
                if (item.getType() === 'nodeContent') {
                    _this.nodeContentTemplate = item.template;
                }
            });
        };
        /**
         * @return {?}
         */
        UxTreeComponent.prototype.getSelectedNodes = /**
         * @return {?}
         */
        function () {
            return this.getSelectedNodesRecursive(this.nodes);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeComponent.prototype.onNodeToggle = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.nodeToggle.emit(uxLink);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeComponent.prototype.onNodeClick = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.nodeClick.emit(uxLink);
            if (this.isClickTogglingNode && uxLink.hasChildren) {
                this.onNodeToggle(uxLink);
            }
            if (!this.isMultiselect && this.isShowActiveNode) {
                this.setNodesSelectedState(this.nodes, false);
                uxLink.selected = true;
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeComponent.prototype.onExpandAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setNodesExpandedState(this.nodes, true);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxTreeComponent.prototype.onCollapseAll = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setNodesExpandedState(this.nodes, false);
        };
        /**
         * @param {?} uxLink
         * @return {?}
         */
        UxTreeComponent.prototype.onSelectionChange = /**
         * @param {?} uxLink
         * @return {?}
         */
        function (uxLink) {
            this.selectionChange.next(uxLink);
        };
        /**
         * @param {?} filterValue
         * @return {?}
         */
        UxTreeComponent.prototype.onFilter = /**
         * @param {?} filterValue
         * @return {?}
         */
        function (filterValue) {
            var _this = this;
            if (filterValue !== '') {
                this.setNodesVisibleState(this.nodes, false);
                this.nodes.forEach(function (node) {
                    _this.isFilterMatched(node, filterValue);
                });
                this.setNodesExpandedState(this.nodes, true);
            }
            else {
                this.setNodesVisibleState(this.nodes, true);
            }
        };
        /**
         * @param {?} nodes
         * @return {?}
         */
        UxTreeComponent.prototype.getSelectedNodesRecursive = /**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) {
            var _this = this;
            return (nodes || []).reduce(function (acc, node) {
                if (node.hasChildren) {
                    return node.selected ? acc.concat([node], _this.getSelectedNodesRecursive(node.children)) : acc.concat(_this.getSelectedNodesRecursive(node.children));
                }
                else {
                    return node.selected ? acc.concat([node]) : acc.slice();
                }
            }, []);
        };
        /**
         * @param {?} node
         * @param {?} filterValue
         * @return {?}
         */
        UxTreeComponent.prototype.isFilterMatched = /**
         * @param {?} node
         * @param {?} filterValue
         * @return {?}
         */
        function (node, filterValue) {
            var _this = this;
            node.label.toUpperCase().indexOf(filterValue.toUpperCase()) !== -1 ? node.visible = true : node.visible = false;
            if (node.children) {
                node.children.forEach(function (childrenNode) {
                    _this.isFilterMatched(childrenNode, filterValue);
                    if (childrenNode.visible) {
                        node.visible = true;
                    }
                });
            }
        };
        /**
         * @param {?} nodes
         * @param {?} expanded
         * @return {?}
         */
        UxTreeComponent.prototype.setNodesExpandedState = /**
         * @param {?} nodes
         * @param {?} expanded
         * @return {?}
         */
        function (nodes, expanded) {
            var _this = this;
            nodes.forEach(function (node) {
                node.expanded = expanded;
                if (node.children) {
                    _this.setNodesExpandedState(node.children, expanded);
                }
            });
        };
        /**
         * @param {?} nodes
         * @param {?} visible
         * @return {?}
         */
        UxTreeComponent.prototype.setNodesVisibleState = /**
         * @param {?} nodes
         * @param {?} visible
         * @return {?}
         */
        function (nodes, visible) {
            var _this = this;
            nodes.forEach(function (node) {
                node.visible = visible;
                if (node.children) {
                    _this.setNodesVisibleState(node.children, visible);
                }
            });
        };
        /**
         * @param {?} nodes
         * @param {?} selected
         * @return {?}
         */
        UxTreeComponent.prototype.setNodesSelectedState = /**
         * @param {?} nodes
         * @param {?} selected
         * @return {?}
         */
        function (nodes, selected) {
            var _this = this;
            nodes.forEach(function (node) {
                node.selected = selected;
                if (node.children) {
                    _this.setNodesSelectedState(node.children, selected);
                }
            });
        };
        UxTreeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tree',
                        template: "\n    <ux-a-toolbar-filter [isVisible]=\"isShowToolbar\"\n                         (filter)=\"onFilter($event)\"\n                         (expandAll)=\"onExpandAll($event)\"\n                         (collapseAll)=\"onCollapseAll($event)\"\n                         filterLabel=\"{{filterLabel}}\"\n                         expandAllLabel=\"{{expandAllLabel}}\"\n                         collapseAllLabel=\"{{collapseAllLabel}}\"\n                         [isToggleExpanded]=\"isExpanded\">\n    </ux-a-toolbar-filter>\n\n    <ul class=\"ux-tree\" [class.ux-tree--multiselect]=\"isMultiselect\">\n        <ux-tree-node *ngFor=\"let node of nodes\"\n                        [node]=\"node\"\n                        (nodeClick)=\"onNodeClick($event)\"\n                        (nodeToggle)=\"onNodeToggle($event)\"\n                        (selectionChange)=\"onSelectionChange($event)\"\n                        [isRootNode]=\"true\"\n                        [isMultiselect]=\"isMultiselect\"\n                        [isRecursiveSelection]=\"isRecursiveSelection\"\n                        [isClickTogglingNode]=\"isClickTogglingNode\"\n                        expandedIconClass=\"{{expandedIconClass}}\"\n                        collapsedIconClass=\"{{collapsedIconClass}}\"\n                        [templateVariable]=\"templateVariable\"\n                        [nodeContentTemplate]=\"nodeContentTemplate\"\n                        [isShowActiveNode]=\"isShowActiveNode\">\n        </ux-tree-node>\n    </ul>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxTreeComponent.propDecorators = {
            "nodes": [{ type: core.Input },],
            "isShowToolbar": [{ type: core.Input },],
            "collapseAllLabel": [{ type: core.Input },],
            "expandAllLabel": [{ type: core.Input },],
            "filterLabel": [{ type: core.Input },],
            "isExpanded": [{ type: core.Input },],
            "isMultiselect": [{ type: core.Input },],
            "isRecursiveSelection": [{ type: core.Input },],
            "isClickTogglingNode": [{ type: core.Input },],
            "collapsedIconClass": [{ type: core.Input },],
            "expandedIconClass": [{ type: core.Input },],
            "isShowActiveNode": [{ type: core.Input },],
            "nodeClick": [{ type: core.Output },],
            "nodeToggle": [{ type: core.Output },],
            "selectionChange": [{ type: core.Output },],
            "templateVariable": [{ type: core.ContentChild, args: [core.TemplateRef,] },],
            "templates": [{ type: core.ContentChildren, args: [UxTemplateDirective,] },],
        };
        return UxTreeComponent;
    }());
    var UxTreeComponentModule = (function () {
        function UxTreeComponentModule() {
        }
        UxTreeComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, forms.FormsModule, UxToolbarFilterComponentModule,
                            UxButtonComponentModule,
                            UxBadgeComponentModule
                        ],
                        exports: [UxTreeComponent, UxTreeNodeComponent],
                        declarations: [UxTreeComponent, UxTreeNodeComponent]
                    },] },
        ];
        return UxTreeComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimebarItemUI = (function () {
        function UxTimebarItemUI() {
        }
        return UxTimebarItemUI;
    }());
    var UxTimebarComponent = (function () {
        function UxTimebarComponent(uxService, asService, renderer2) {
            this.uxService = uxService;
            this.asService = asService;
            this.renderer2 = renderer2;
            this.dateFormat = 'YYYY-MM-DD';
            this.isShowLegend = false;
            this.isShowLegendAsIndex = true;
            this.isShowCurrentDateMarker = false;
            this.isCurrentDateMarkerAlwaysInRange = false;
            this.isGroupOverlappingLabels = false;
            this.itemsUI = [];
            this.currentDate = new Date();
            this.timebarColumnClass = 'col-12';
            this.isMobile = false;
            this.isSomeStepsAreGrouped = false;
            this.extraTimelineLabelSpace = 21;
            this.maxStepWidth = 112;
        }
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.subscription = this.asService.breakpoints$.subscribe(function (bkps) {
                _this.onBreakpointChange(bkps);
            });
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.removeNullItems();
            this.sortItems();
            var /** @type {?} */ startDate = this.items[0].date;
            var /** @type {?} */ endDate = this.items[this.items.length - 1].date;
            this.items.forEach(function (item) {
                var /** @type {?} */ stepTypeClass = '';
                var /** @type {?} */ tooltipColor = 'none';
                if (item.stepType) {
                    stepTypeClass = 'ux-timebar__step--' + item.stepType;
                    tooltipColor = item.stepType;
                }
                var /** @type {?} */ isNumber = /^\d+\.\d+$/.test(item.label) || /^\d+$/.test(item.label);
                if (isNumber) {
                    item.label = _this.uxService.formatNumber(item.label, 2);
                }
                _this.itemsUI.push({
                    perc: _this.calculatePercentage(item.date, startDate, endDate),
                    item: item,
                    stepTypeClass: stepTypeClass,
                    tooltipColor: tooltipColor,
                });
            });
            this.currentPerc = this.calculatePercentage(this.currentDate, startDate, endDate, true);
            this.markedPerc = this.calculatePercentage(this.markedDate, startDate, endDate, true);
            if (this.startLabel && this.endLabel) {
                this.timebarColumnClass = 'col-8';
            }
            else {
                if (this.startLabel || this.endLabel) {
                    this.timebarColumnClass = 'col-10';
                }
            }
            // initialize attributes
            this.isShowLegendGenerated = this.isShowLegend;
            this.isShowLegendAsIndexGenerated = this.isShowLegendAsIndex;
            this.isGroupOverlappingLabelsGenerated = this.isGroupOverlappingLabels;
            this.isMobile = false;
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.groupOverlappingLabels();
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxTimebarComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes) {
                var /** @type {?} */ change = changes['markedDate'];
                if (change) {
                    var /** @type {?} */ startDate = this.items[0].date;
                    var /** @type {?} */ endDate = this.items[this.items.length - 1].date;
                    this.markedPerc = this.calculatePercentage(/** @type {?} */ (change.currentValue), startDate, endDate);
                }
            }
        };
        /**
         * @param {?} bkps
         * @return {?}
         */
        UxTimebarComponent.prototype.onBreakpointChange = /**
         * @param {?} bkps
         * @return {?}
         */
        function (bkps) {
            if (bkps.isMobile) {
                this.isShowLegendGenerated = true;
                this.isShowLegendAsIndexGenerated = true;
                this.isMobile = true;
            }
            else {
                this.isShowLegendGenerated = this.isShowLegend;
                this.isShowLegendAsIndexGenerated = this.isShowLegendAsIndex;
                this.isMobile = false;
            }
            this.groupOverlappingLabels();
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.removeNullItems = /**
         * @return {?}
         */
        function () {
            if (this.items) {
                for (var /** @type {?} */ i = 0; i < this.items.length; i++) {
                    if (!this.items[i]) {
                        this.items.splice(i, 1);
                        i--;
                    }
                }
            }
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.sortItems = /**
         * @return {?}
         */
        function () {
            if (this.items) {
                // Sort by ascending date:
                this.items = this.items.sort(function (a, b) {
                    if (a && b) {
                        return /** @type {?} */ (a.date) - /** @type {?} */ (b.date);
                    }
                    else {
                        return 0;
                    }
                });
            }
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.groupOverlappingLabels = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isGroupOverlappingLabelsGenerated) {
                this.clearGrouping();
                if (this.container && this.itemsUI && this.isShowLegendAsIndexGenerated) {
                    var /** @type {?} */ containerElement_1 = this.container.nativeElement;
                    setTimeout(function () {
                        var /** @type {?} */ containerWidth = containerElement_1.clientWidth;
                        // const groupingThreshold = this.maxStepWidth / 2;
                        var /** @type {?} */ groupingThreshold = (_this.maxStepWidth * 100) / containerWidth;
                        var /** @type {?} */ groupingCounter = 0;
                        var /** @type {?} */ mobileIndexDisplacement = 0;
                        var /** @type {?} */ previousUiItem = null;
                        for (var /** @type {?} */ i = 0; i < _this.itemsUI.length; i++) {
                            var /** @type {?} */ uiItem = _this.itemsUI[i];
                            if (previousUiItem) {
                                var /** @type {?} */ distance = Math.abs(uiItem.perc - previousUiItem.perc);
                                if (distance <= groupingThreshold) {
                                    // Group the 2 items:
                                    groupingCounter++;
                                    if (_this.isShowLegendGenerated && mobileIndexDisplacement <= 0) {
                                        mobileIndexDisplacement = i - 1;
                                    }
                                    if (!previousUiItem.groupLabel) {
                                        previousUiItem.groupIndex = groupingCounter;
                                        if (!_this.isShowLegendGenerated) {
                                            previousUiItem.groupLabel = '' + groupingCounter;
                                        }
                                        else {
                                            previousUiItem.groupLabel = '' + (mobileIndexDisplacement + groupingCounter);
                                        }
                                        previousUiItem.groupLabelMobile = '' + (mobileIndexDisplacement + groupingCounter);
                                        groupingCounter++;
                                    }
                                    if (!_this.isShowLegendGenerated) {
                                        previousUiItem.groupLabel += ', ' + groupingCounter;
                                    }
                                    else {
                                        previousUiItem.groupLabel += ', ' + (mobileIndexDisplacement + groupingCounter);
                                    }
                                    previousUiItem.groupLabelMobile += ', ' + (mobileIndexDisplacement + groupingCounter);
                                    previousUiItem.groupEndDate = uiItem.item.date;
                                    previousUiItem.stepTypeClass = uiItem.item.stepType;
                                    uiItem.isGrouped = true;
                                    uiItem.groupIndex = groupingCounter;
                                    _this.isSomeStepsAreGrouped = true;
                                }
                                else {
                                    previousUiItem = uiItem;
                                }
                            }
                            else {
                                previousUiItem = uiItem;
                            }
                        }
                        // TODO: for what this code is really needed ?
                        // https://webgate.ec.europa.eu/CITnet/jira/browse/OPSYS-3958
                        // this.calculateExtraTimelineLabelSpace();
                    }, 0);
                }
            }
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.clearGrouping = /**
         * @return {?}
         */
        function () {
            this.isSomeStepsAreGrouped = false;
            if (this.itemsUI) {
                for (var _i = 0, _a = this.itemsUI; _i < _a.length; _i++) {
                    var item = _a[_i];
                    delete item.isGrouped;
                    delete item.groupIndex;
                    delete item.groupLabel;
                    delete item.groupLabelMobile;
                    delete item.groupEndDate;
                }
            }
            this.extraTimelineLabelSpace = 21;
        };
        /**
         * @return {?}
         */
        UxTimebarComponent.prototype.calculateExtraTimelineLabelSpace = /**
         * @return {?}
         */
        function () {
            if (this.itemsUI) {
                var /** @type {?} */ maxLabelLength = 0;
                for (var _i = 0, _a = this.itemsUI; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.item && item.item.label) {
                        maxLabelLength = Math.max(maxLabelLength, item.item.label.length);
                    }
                }
                if (maxLabelLength > 56) {
                    // 56px = 4rem margin of the timeline itself.
                    this.extraTimelineLabelSpace = maxLabelLength + 28; // 28px = 2rem = 1 line of text in height + margins
                }
            }
        };
        /**
         * @param {?} date
         * @param {?} startDate
         * @param {?} endDate
         * @param {?=} compensateForRange
         * @return {?}
         */
        UxTimebarComponent.prototype.calculatePercentage = /**
         * @param {?} date
         * @param {?} startDate
         * @param {?} endDate
         * @param {?=} compensateForRange
         * @return {?}
         */
        function (date, startDate, endDate, compensateForRange) {
            if (compensateForRange === void 0) { compensateForRange = false; }
            if (date && startDate && endDate) {
                var /** @type {?} */ percentage = ((date.getTime() - startDate.getTime()) / (endDate.getTime() - startDate.getTime())) * 100;
                if (compensateForRange) {
                    // if the date is over the end date, or below the start date
                    // simulate its positioning to not mess up the timebar global width
                    if (percentage > 100) {
                        if (this.isCurrentDateMarkerAlwaysInRange) {
                            percentage = 100;
                        }
                        else {
                            percentage = 103;
                        }
                    }
                    else if (percentage <= 0) {
                        if (this.isCurrentDateMarkerAlwaysInRange) {
                            percentage = 0;
                        }
                        else {
                            percentage = -3;
                        }
                    }
                }
                return percentage;
            }
            else {
                return 0;
            }
        };
        UxTimebarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timebar',
                        template: "<div class=\"row flex-container\" #container> <div *ngIf=\"startLabel\" class=\"col-2 ux-timebar__start-label\"> {{startLabel}} </div> <div class=\"{{timebarColumnClass}}\"> <div class=\"ux-timebar\" [style.marginBottom.px]=\"extraTimelineLabelSpace\"> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-progress\" [style.width.%]=\"currentPerc >= 100 ? 100 : currentPerc\"></div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-progress\" [style.width.%]=\"markedPerc >= 100 ? 100 : markedPerc\"></div> <ng-template [ngIf]=\"!isMobile\"> <ng-container *ngFor=\"let item of itemsUI; let i = index;\"> <ng-container *ngIf=\"! item.isGrouped\"> <div class=\"ux-timebar__step\" [ngClass]=\"item.stepTypeClass\" [style.left.%]=\"item.perc\" [class.ux-timebar__step--with-current-date-marker]=\"isShowCurrentDateMarker || markedDate\"> <div class=\"ux-timebar__step-date-item\" [class.ux-timebar__step-date-item--with-end-date]=\"item.groupEndDate\"> <span class=\"{{ item.tooltipColor ? 'ux-timebar__step--' + item.tooltipColor : '' }}\" [class.timebar__grouped__step]=\"item.groupEndDate\"> {{ item.item.date | amLocal | amDateFormat: dateFormat }} </span> <span *ngIf=\"item.groupEndDate\" class=\"timebar__grouped__step {{ item.stepTypeClass ? 'ux-timebar__step--' + item.stepTypeClass : '' }}\"> {{ item.groupEndDate | amLocal | amDateFormat: dateFormat }} </span> </div> <div *ngIf=\"!isShowLegendGenerated\" [style.left.%]=\"item.perc\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabel\"> <span title=\"{{item.item.label}}\">{{item.item.label}}</span> </ng-container> <ng-container *ngIf=\"item.groupLabel\"> <span title=\"{{item.groupLabel}}\">{{item.groupLabel}}</span> </ng-container> </div> <div *ngIf=\"isShowLegendGenerated && isShowLegendAsIndexGenerated\" [style.left.%]=\"item.perc\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> {{i+1}} </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> </div> </ng-container> </ng-container> </ng-template> <ng-template [ngIf]=\"isMobile\"> <ng-container *ngFor=\"let item of itemsUI; let i = index;\"> <ng-container *ngIf=\"! item.isGrouped\"> <div class=\"ux-timebar__step\" [ngClass]=\"item.stepTypeClass\" [style.left.%]=\"item.perc\" [class.ux-timebar__step--with-current-date-marker]=\"isShowCurrentDateMarker || markedDate\"> <div *ngIf=\"!isShowLegendGenerated\" class=\"ux-timebar__step-label\" title=\"{{item.item.label}}\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> <span title=\"{{item.item.label}}\">{{item.item.label}}</span> </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> <div *ngIf=\"isShowLegendGenerated && isShowLegendAsIndexGenerated\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> {{i+1}} </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> </div> </ng-container> </ng-container> </ng-template> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-date-marker\" [style.left.%]=\"currentPerc\" uxTooltip=\"{{currentDate | amLocal | amDateFormat: dateFormat }}\"> <span class=\"ux-icon ux-icon-map-marker\"></span> </div> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-date-marker-step\" [style.left.%]=\"currentPerc\"> <span class=\"ux-icon ux-icon-circle\"></span> </div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-date-marker\" [style.left.%]=\"markedPerc\" uxTooltip=\"{{markedDate | amLocal | amDateFormat: dateFormat }}\"> <span class=\"ux-icon ux-icon-map-marker\"></span> </div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-date-marker-step\" [style.left.%]=\"markedPerc\"> <span class=\"ux-icon ux-icon-circle\"></span> </div> </div> </div> <div *ngIf=\"endLabel\" class=\"col-2 ux-timebar__end-label\"> {{endLabel}} </div> </div> <div class=\"row flex-container\"> <div *ngIf=\"startLabel\" class=\"col-2\"></div> <div class=\"{{timebarColumnClass}}\"> <div *ngIf=\"isShowLegendGenerated || isSomeStepsAreGrouped\" class=\"ux-timebar__legend\"> <ng-container *ngIf=\"isShowLegendGenerated\"> <div class=\"ux-timebar__legend-item\" *ngFor=\"let item of itemsUI; let i = index\"> <div *ngIf=\"!isShowLegendAsIndexGenerated\" class=\"ux-timebar__legend-item-icon\"> <span class=\"ux-icon ux-icon-fw ux-icon-circle ux-timebar__legend-item-icon--{{item.item.stepType}}\"></span> </div> <div *ngIf=\"isShowLegendAsIndexGenerated\" class=\"ux-timebar__legend-item-index-wrapper\"> {{i+1}} </div> <div class=\"ux-timebar__legend-item-label\"> <ng-template [ngIf]=\"isMobile\"> <strong>{{item.item.date | amLocal | amDateFormat: dateFormat }}</strong> - {{item.item.label}} </ng-template> <ng-template [ngIf]=\"!isMobile\"> {{item.item.label}} </ng-template> </div> </div> </ng-container> <ng-container *ngIf=\"! isShowLegendGenerated\"> <ng-container *ngFor=\"let item of itemsUI\"> <div *ngIf=\"item.groupLabel || item.isGrouped\" class=\"ux-timebar__legend-item\"> <div class=\"ux-timebar__legend-item-index-wrapper\"> {{item.groupIndex}} </div> <div class=\"ux-timebar__legend-item-label\"> <strong>{{item.item.date | amLocal | amDateFormat: dateFormat }}</strong> - {{item.item.label}} </div> </div> </ng-container> </ng-container> </div> </div> <div *ngIf=\"endLabel\" class=\"col-2\"></div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxTimebarComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxAppShellService, },
            { type: core.Renderer2, },
        ]; };
        UxTimebarComponent.propDecorators = {
            "items": [{ type: core.Input },],
            "startLabel": [{ type: core.Input },],
            "endLabel": [{ type: core.Input },],
            "dateFormat": [{ type: core.Input },],
            "isShowLegend": [{ type: core.Input },],
            "isShowLegendAsIndex": [{ type: core.Input },],
            "isShowCurrentDateMarker": [{ type: core.Input },],
            "isCurrentDateMarkerAlwaysInRange": [{ type: core.Input },],
            "isGroupOverlappingLabels": [{ type: core.Input },],
            "markedDate": [{ type: core.Input },],
            "container": [{ type: core.ViewChild, args: ['container',] },],
        };
        return UxTimebarComponent;
    }());
    var UxTimebarComponentModule = (function () {
        function UxTimebarComponentModule() {
        }
        UxTimebarComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxTooltipModule, angular2Moment.MomentModule],
                        exports: [UxTimebarComponent],
                        declarations: [UxTimebarComponent]
                    },] },
        ];
        return UxTimebarComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxTimebarItem = (function () {
        function UxTimebarItem(values) {
            if (values === void 0) { values = {}; }
            Object.assign(this, values);
        }
        return UxTimebarItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAutocompleteTagItem = (function () {
        function UxAutocompleteTagItem(values) {
            if (values === void 0) { values = {}; }
            this.isDeletable = true;
            Object.assign(this, values);
        }
        return UxAutocompleteTagItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        Point.create = /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x, y) {
            return new Point(x, y);
        };
        /**
         * @return {?}
         */
        Point.prototype.clone = /**
         * @return {?}
         */
        function () {
            return Point.create(this.x, this.y);
        };
        /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        Point.prototype.set = /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        /**
         * @param {?} offsetX
         * @param {?} offsetY
         * @return {?}
         */
        Point.prototype.translate = /**
         * @param {?} offsetX
         * @param {?} offsetY
         * @return {?}
         */
        function (offsetX, offsetY) {
            this.x += offsetX;
            this.y += offsetY;
            return this;
        };
        /**
         * @param {?} offsetX
         * @return {?}
         */
        Point.prototype.translateX = /**
         * @param {?} offsetX
         * @return {?}
         */
        function (offsetX) {
            return this.translate(offsetX, 0);
        };
        /**
         * @param {?} offsetY
         * @return {?}
         */
        Point.prototype.translateY = /**
         * @param {?} offsetY
         * @return {?}
         */
        function (offsetY) {
            return this.translate(0, offsetY);
        };
        /**
         * @param {?} factor
         * @return {?}
         */
        Point.prototype.scale = /**
         * @param {?} factor
         * @return {?}
         */
        function (factor) {
            this.x *= factor;
            this.y *= factor;
            return this;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        Point.prototype.map = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.x = fn.call(this, this.x);
            this.y = fn.call(this, this.y);
            return this;
        };
        /**
         * @return {?}
         */
        Point.prototype.isZero = /**
         * @return {?}
         */
        function () {
            return this.equals(Point.create(0, 0));
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Point.prototype.equals = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.x === other.x && this.y === other.y;
        };
        /**
         * @return {?}
         */
        Point.prototype.toString = /**
         * @return {?}
         */
        function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Point;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Overflow = (function () {
        function Overflow(left, top, right, bottom) {
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        Overflow.create = /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        function (left, top, right, bottom) {
            return new Overflow(left, top, right, bottom);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Overflow.prototype.equals = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.left === other.left &&
                this.top === other.top &&
                this.bottom === other.bottom &&
                this.right === other.right;
        };
        /**
         * @return {?}
         */
        Overflow.prototype.toString = /**
         * @return {?}
         */
        function () {
            return "(" + this.left + ", " + this.top + ", " + this.right + ", " + this.bottom + ")";
        };
        return Overflow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Rectangle = (function () {
        function Rectangle(left, top, right, bottom) {
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        Rectangle.create = /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        function (x, y, width, height) {
            return new Rectangle(x, y, x + width, y + height);
        };
        /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        Rectangle.fromBounds = /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        function (left, top, right, bottom) {
            return Rectangle.create(left, top, right - left, bottom - top);
        };
        /**
         * @param {?} rect
         * @return {?}
         */
        Rectangle.fromRect = /**
         * @param {?} rect
         * @return {?}
         */
        function (rect) {
            return Rectangle.create(rect.x, rect.y, rect.width, rect.height);
        };
        /**
         * @return {?}
         */
        Rectangle.empty = /**
         * @return {?}
         */
        function () {
            return Rectangle.create(0, 0, 0, 0);
        };
        Object.defineProperty(Rectangle.prototype, "x", {
            get: /**
             * @return {?}
             */
            function () {
                return this.left;
            },
            set: /**
             * @param {?} newX
             * @return {?}
             */
            function (newX) {
                var /** @type {?} */ offsetX = newX - this.x;
                this.left = newX;
                this.right += offsetX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "y", {
            get: /**
             * @return {?}
             */
            function () {
                return this.top;
            },
            set: /**
             * @param {?} newY
             * @return {?}
             */
            function (newY) {
                var /** @type {?} */ offsetY = newY - this.y;
                this.top = newY;
                this.bottom += offsetY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "width", {
            get: /**
             * @return {?}
             */
            function () {
                return this.right - this.left;
            },
            set: /**
             * @param {?} newWidth
             * @return {?}
             */
            function (newWidth) {
                this.right = this.left + newWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "height", {
            get: /**
             * @return {?}
             */
            function () {
                return this.bottom - this.top;
            },
            set: /**
             * @param {?} newWidth
             * @return {?}
             */
            function (newWidth) {
                this.bottom = this.top + newWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Rectangle.prototype.clone = /**
         * @return {?}
         */
        function () {
            return Rectangle.create(this.x, this.y, this.width, this.height);
        };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        Rectangle.prototype.setRectangle = /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        function (x, y, width, height) {
            this.left = x;
            this.top = y;
            this.right = x + width;
            this.bottom = y + height;
            return this;
        };
        /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        Rectangle.prototype.setBounds = /**
         * @param {?} left
         * @param {?} top
         * @param {?} right
         * @param {?} bottom
         * @return {?}
         */
        function (left, top, right, bottom) {
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            return this;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.copyFrom = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            this.left = other.left;
            this.top = other.top;
            this.right = other.right;
            this.bottom = other.bottom;
            return this;
        };
        /**
         * @param {?} p
         * @param {?=} anchor
         * @return {?}
         */
        Rectangle.prototype.moveTo = /**
         * @param {?} p
         * @param {?=} anchor
         * @return {?}
         */
        function (p, anchor) {
            if (anchor === void 0) { anchor = this.leftTop(); }
            this.x = p.x + (this.x - anchor.x);
            this.y = p.y + (this.y - anchor.y);
            return this;
        };
        /**
         * @param {?} x
         * @param {?=} anchor
         * @return {?}
         */
        Rectangle.prototype.moveXTo = /**
         * @param {?} x
         * @param {?=} anchor
         * @return {?}
         */
        function (x, anchor) {
            if (anchor === void 0) { anchor = this.leftTop(); }
            this.x = x + (this.x - anchor.x);
            return this;
        };
        /**
         * @param {?} y
         * @param {?=} anchor
         * @return {?}
         */
        Rectangle.prototype.moveYTo = /**
         * @param {?} y
         * @param {?=} anchor
         * @return {?}
         */
        function (y, anchor) {
            if (anchor === void 0) { anchor = this.leftTop(); }
            this.y = y + (this.y - anchor.y);
            return this;
        };
        /**
         * @param {?} offsetX
         * @param {?} offsetY
         * @return {?}
         */
        Rectangle.prototype.translate = /**
         * @param {?} offsetX
         * @param {?} offsetY
         * @return {?}
         */
        function (offsetX, offsetY) {
            this.left += offsetX;
            this.top += offsetY;
            this.right += offsetX;
            this.bottom += offsetY;
            return this;
        };
        /**
         * @param {?} offsetX
         * @return {?}
         */
        Rectangle.prototype.translateX = /**
         * @param {?} offsetX
         * @return {?}
         */
        function (offsetX) {
            return this.translate(offsetX, 0);
        };
        /**
         * @param {?} offsetY
         * @return {?}
         */
        Rectangle.prototype.translateY = /**
         * @param {?} offsetY
         * @return {?}
         */
        function (offsetY) {
            return this.translate(0, offsetY);
        };
        /**
         * @param {?} factor
         * @return {?}
         */
        Rectangle.prototype.scale = /**
         * @param {?} factor
         * @return {?}
         */
        function (factor) {
            this.left *= factor;
            this.top *= factor;
            this.right *= factor;
            this.bottom *= factor;
            return this;
        };
        /**
         * @param {?} yAxis
         * @return {?}
         */
        Rectangle.prototype.flipX = /**
         * @param {?} yAxis
         * @return {?}
         */
        function (yAxis) {
            var /** @type {?} */ offsetY = 2 * (this.top - yAxis) + this.height;
            return this.translate(0, -offsetY);
        };
        /**
         * @param {?} xAxis
         * @return {?}
         */
        Rectangle.prototype.flipY = /**
         * @param {?} xAxis
         * @return {?}
         */
        function (xAxis) {
            var /** @type {?} */ offsetX = 2 * (this.left - xAxis) + this.width;
            return this.translate(-offsetX, 0);
        };
        /**
         * @param {?} point
         * @return {?}
         */
        Rectangle.prototype.flip = /**
         * @param {?} point
         * @return {?}
         */
        function (point) {
            return this
                .flipX(point.y)
                .flipY(point.x);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        Rectangle.prototype.map = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.left = fn.call(this, this.left);
            this.top = fn.call(this, this.top);
            this.right = fn.call(this, this.right);
            this.bottom = fn.call(this, this.bottom);
            return this;
        };
        /**
         * @param {?} p
         * @return {?}
         */
        Rectangle.prototype.isBelow = /**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            return this.top >= p.y;
        };
        /**
         * @param {?} p
         * @return {?}
         */
        Rectangle.prototype.isAbove = /**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            return this.bottom <= p.y;
        };
        /**
         * @param {?} p
         * @return {?}
         */
        Rectangle.prototype.isOnTheLeft = /**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            return this.right <= p.x;
        };
        /**
         * @param {?} p
         * @return {?}
         */
        Rectangle.prototype.isOnTheRight = /**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            return this.left >= p.x;
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.position = /**
         * @return {?}
         */
        function () {
            return this.leftTop();
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.leftTop = /**
         * @return {?}
         */
        function () {
            return Point.create(this.left, this.top);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.centerTop = /**
         * @return {?}
         */
        function () {
            return Point.create(this.left + (this.width / 2), this.top);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.rightTop = /**
         * @return {?}
         */
        function () {
            return Point.create(this.right, this.top);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.leftCenter = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ x = this.x;
            var /** @type {?} */ y = this.y + (this.height / 2);
            return Point.create(x, y);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.center = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ x = this.x + (this.width / 2);
            var /** @type {?} */ y = this.y + (this.height / 2);
            return Point.create(x, y);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.rightCenter = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ x = this.x + this.width;
            var /** @type {?} */ y = this.y + (this.height / 2);
            return Point.create(x, y);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.leftBottom = /**
         * @return {?}
         */
        function () {
            return Point.create(this.left, this.bottom);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.centerBottom = /**
         * @return {?}
         */
        function () {
            return Point.create(this.left + (this.width / 2), this.bottom);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.rightBottom = /**
         * @return {?}
         */
        function () {
            return Point.create(this.right, this.bottom);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.isEmpty = /**
         * @return {?}
         */
        function () {
            return this.width <= 0 || this.height <= 0;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.containsRect = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            if (other.isEmpty()) {
                return true;
            }
            if (this.isEmpty()) {
                return false;
            }
            return other.left >= this.left &&
                other.top >= this.top &&
                other.right <= this.right &&
                other.bottom <= this.bottom;
        };
        /**
         * @param {?} point
         * @return {?}
         */
        Rectangle.prototype.containsPoint = /**
         * @param {?} point
         * @return {?}
         */
        function (point) {
            if (this.isEmpty()) {
                return false;
            }
            return point.x >= this.left &&
                point.x <= this.right &&
                point.y >= this.top &&
                point.y <= this.bottom;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflows = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.overflowsLeft(other) ||
                this.overflowsTop(other) ||
                this.overflowsRight(other) ||
                this.overflowsBottom(other);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflowsLeft = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.overflow(other).left > 0;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflowsTop = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.overflow(other).top > 0;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflowsRight = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.overflow(other).right > 0;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflowsBottom = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.overflow(other).bottom > 0;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.overflow = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return Overflow.create(Math.max(0, other.left - this.left), Math.max(0, other.top - this.top), Math.max(0, this.right - other.right), Math.max(0, this.bottom - other.bottom));
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.intersects = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            if (this.isEmpty() || other.isEmpty()) {
                return false;
            }
            return this.left < other.right &&
                this.right > other.left &&
                this.top < other.bottom &&
                this.bottom > other.top;
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.intersect = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this
                .clone()
                .restrictTo(other);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.union = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this
                .clone()
                .expandToContain(other);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.restrictTo = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            if (this.isEmpty() || other.isEmpty()) {
                return this.setRectangle(0, 0, 0, 0);
            }
            var /** @type {?} */ left = Math.max(this.left, other.left);
            var /** @type {?} */ top = Math.max(this.top, other.top);
            var /** @type {?} */ right = Math.min(this.right, other.right);
            var /** @type {?} */ bottom = Math.min(this.bottom, other.bottom);
            return this.setRectangle(left, top, Math.max(0, right - left), Math.max(0, bottom - top));
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.expandToContain = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            if (this.isEmpty()) {
                return this.copyFrom(other);
            }
            if (other.isEmpty()) {
                return this;
            }
            var /** @type {?} */ left = Math.min(this.left, other.left);
            var /** @type {?} */ top = Math.min(this.top, other.top);
            var /** @type {?} */ right = Math.max(this.right, other.right);
            var /** @type {?} */ bottom = Math.max(this.bottom, other.bottom);
            return this.setRectangle(left, top, right - left, bottom - top);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.translateInside = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this
                .translateXInside(other)
                .translateYInside(other);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.translateXInside = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            var /** @type {?} */ offsetX = 0;
            if (this.left <= other.left) {
                offsetX = other.left - this.left;
            }
            if (this.right >= other.right) {
                offsetX = other.right - this.right;
            }
            return this.translate(offsetX, 0);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.translateYInside = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            var /** @type {?} */ offsetY = 0;
            if (this.top <= other.top) {
                offsetY = other.top - this.top;
            }
            if (this.bottom >= other.bottom) {
                offsetY = other.bottom - this.bottom;
            }
            return this.translate(0, offsetY);
        };
        /**
         * @param {?} rect
         * @param {?} scalar
         * @return {?}
         */
        Rectangle.prototype.blend = /**
         * @param {?} rect
         * @param {?} scalar
         * @return {?}
         */
        function (rect, scalar) {
            return Rectangle.fromBounds(this.left + (rect.left - this.left) * scalar, this.top + (rect.top - this.top) * scalar, this.right + (rect.right - this.right) * scalar, this.bottom + (rect.bottom - this.bottom) * scalar);
        };
        /**
         * @param {?} xScale
         * @param {?=} yScale
         * @return {?}
         */
        Rectangle.prototype.inflate = /**
         * @param {?} xScale
         * @param {?=} yScale
         * @return {?}
         */
        function (xScale, yScale) {
            if (yScale === void 0) { yScale = xScale; }
            var /** @type {?} */ xAdjust = (this.width * xScale - this.width) / 2;
            var /** @type {?} */ yAdjust = (this.height * yScale - this.height) / 2;
            this.left -= xAdjust;
            this.right += xAdjust;
            this.top -= yAdjust;
            this.bottom += yAdjust;
            return this;
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.expandToIntegers = /**
         * @return {?}
         */
        function () {
            this.left = Math.floor(this.left);
            this.top = Math.floor(this.top);
            this.right = Math.ceil(this.right);
            this.bottom = Math.ceil(this.bottom);
            return this;
        };
        /**
         * @param {?} parent
         * @return {?}
         */
        Rectangle.prototype.relativeTo = /**
         * @param {?} parent
         * @return {?}
         */
        function (parent) {
            return Rectangle.create(this.left - parent.left, this.top - parent.top, this.width, this.height);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Rectangle.prototype.equals = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return (this.isEmpty() && other.isEmpty() ||
                this.top === other.top &&
                    this.left === other.left &&
                    this.bottom === other.bottom &&
                    this.right === other.right);
        };
        /**
         * @return {?}
         */
        Rectangle.prototype.toString = /**
         * @return {?}
         */
        function () {
            return "(" + this.x + ", " + this.y + ", " + this.width + ", " + this.height + ")";
        };
        return Rectangle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RectangleFactory = (function () {
        function RectangleFactory() {
        }
        /**
         * @param {?} el
         * @return {?}
         */
        RectangleFactory.fromHtmlElement = /**
         * @param {?} el
         * @return {?}
         */
        function (el) {
            var /** @type {?} */ w = this.getWindow();
            return Rectangle.create(el.getBoundingClientRect().left + w.pageXOffset, el.getBoundingClientRect().top + w.pageYOffset, el.offsetWidth, el.offsetHeight);
        };
        /**
         * @param {?} el
         * @return {?}
         */
        RectangleFactory.fromSvgElement = /**
         * @param {?} el
         * @return {?}
         */
        function (el) {
            var /** @type {?} */ w = this.getWindow();
            return Rectangle.create(el.getBoundingClientRect().left + w.pageXOffset, el.getBoundingClientRect().top + w.pageYOffset, el.clientWidth, el.clientHeight);
        };
        /**
         * @return {?}
         */
        RectangleFactory.fromWindow = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ w = this.getWindow();
            return Rectangle.create(w.pageXOffset, w.pageYOffset, w.document.documentElement.clientWidth, w.document.documentElement.clientHeight);
        };
        /**
         * @return {?}
         */
        RectangleFactory.getWindow = /**
         * @return {?}
         */
        function () {
            return window;
        };
        return RectangleFactory;
    }());

    var __assign$5 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var PlacementService = (function () {
        function PlacementService(placementStrategies) {
            if (placementStrategies === void 0) { placementStrategies = []; }
            this.placementStrategies = placementStrategies;
        }
        /**
         * @param {?=} options
         * @return {?}
         */
        PlacementService.getEffectiveOptions = /**
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            return __assign$5({ anchor: Rectangle.empty(), element: Rectangle.empty(), placementId: 'bottom', parent: RectangleFactory.fromWindow(), offsetAlong: 0, offsetAcross: 0, constrainToParent: true, flip: true }, options);
        };
        /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        PlacementService.pickPlacementStrategy = /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        function (placementStrategies, placementId) {
            /**
             * @param {?} strategy
             * @return {?}
             */
            function matchStrategy(strategy) {
                return strategy.getId() === placementId;
            }
            return (placementStrategies || []).find(matchStrategy);
        };
        /**
         * @param {?=} options
         * @return {?}
         */
        PlacementService.prototype.place = /**
         * @param {?=} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ effectiveOptions = PlacementService.getEffectiveOptions(options);
            var /** @type {?} */ placementStrategy = PlacementService.pickPlacementStrategy(this.placementStrategies, effectiveOptions.placementId);
            if (!placementStrategy) {
                throw new Error('Placement not supported: ' + effectiveOptions.placementId);
            }
            return placementStrategy.calculate(effectiveOptions);
        };
        return PlacementService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ noop$1 = function () { };
    var /** @type {?} */ UX_AUTOCOMPLETETAG_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return UxAutocompleteTagComponent; }),
        multi: true,
    };
    var UxAutocompleteTagComponent = (function () {
        function UxAutocompleteTagComponent(uxService, renderer, placementService) {
            this.uxService = uxService;
            this.renderer = renderer;
            this.placementService = placementService;
            this.isReadOnly = false;
            this.items = [];
            this.selectedItems = [];
            this.isFreeTagsAllowed = false;
            this.isBadgeSmall = false;
            this.isDisplayTagsListBelow = false;
            this.selectionChanged = new core.EventEmitter();
            this.isSelectionValid = new core.EventEmitter();
            this.itemAdded = new core.EventEmitter();
            this.itemRemoved = new core.EventEmitter();
            this.onChange = noop$1;
            this.onTouched = noop$1;
            this.query = '';
            this.filteredList = [];
            this.selectedIdx = -1;
            this.isValid = true;
            this.badgeSizeClass = '';
        }
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.renderer.appendChild(document.body, this.dropdownEl.nativeElement);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.focusOut = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.reset();
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.items.length === 0) {
                this.isFreeTagsAllowed = true;
            }
            if (this.isBadgeSmall) {
                this.badgeSizeClass = 'badge--small';
            }
            this.checkValidity();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.onInputKeyup = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            if (event.code === 'ArrowDown' && this.filteredList.length === 0) {
                this.updateFilteredList();
            }
            else if (event.code === 'ArrowDown' && this.selectedIdx < this.filteredList.length - 1) {
                this.selectedIdx++;
                this.query = this.filteredList[this.selectedIdx].label;
            }
            else if (event.code === 'ArrowUp' && this.selectedIdx > 0) {
                this.selectedIdx--;
                this.query = this.filteredList[this.selectedIdx].label;
            }
            else if (event.keyCode === 13 && this.query !== '') {
                var /** @type {?} */ itemInFilteredList = this.filteredList.find(function (item) { return item.label === _this.query; });
                var /** @type {?} */ itemInSelectedItems = this.selectedItems.find(function (item) { return item.label === _this.query; });
                if (!itemInFilteredList) {
                    if (!itemInSelectedItems && this.isFreeTagsAllowed) {
                        var /** @type {?} */ newItem = new UxAutocompleteTagItem({ label: this.query });
                        this.selectedItems.push(newItem);
                        this.query = '';
                        this.itemAdded.emit(newItem);
                        this.selectionChanged.emit(this.selectedItems);
                        this.onChange(this.selectedItems);
                    }
                }
                else {
                    if (this.selectedIdx < 0) {
                        this.selectItem(itemInFilteredList);
                    }
                    else {
                        this.selectItem(this.filteredList[this.selectedIdx]);
                    }
                }
            }
            else {
                if (this.query === '' && event.keyCode !== 9 && event.keyCode !== 16) {
                    this.filteredList = [];
                }
                else {
                    if (event.code !== 'ArrowUp' && event.code !== 'ArrowDown') {
                        this.updateFilteredList();
                    }
                }
            }
        };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.trackByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        function (index, item) {
            return item.id;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.onInputClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            this.updateFilteredList();
            this.uxService.consumeEvent(event);
            // Hide temporarily, to avoid flash of unwanted content
            // show again after reposition
            this.dropdownEl.nativeElement.style.visibility = 'hidden';
            setTimeout(function () {
                _this.repositionDropdown();
            });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.onToggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.updateFilteredList();
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.onSuggestionsMouseDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // Prevent the scrolling on suggestions from losing focus on the input field; and therefore from closing the suggestions.
            // This happens for example when an auto-complete is put inside a modal dialog.
            // non-IE11 fix:
            this.uxService.consumeEvent(event);
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.selectItem = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.selectedItems.push(item);
            this.reset();
            this.itemAdded.emit(item);
            this.updateSelection();
        };
        /**
         * @param {?} item
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.removeItem = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
            this.itemRemoved.emit(item);
            this.updateSelection();
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectedItems = value || [];
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.isReadOnly = isDisabled;
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.repositionDropdown = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ inputRect = RectangleFactory.fromHtmlElement(this.inputEl.nativeElement);
            this.dropdownEl.nativeElement.style.width = inputRect.width + 'px';
            var /** @type {?} */ dropdownRect = RectangleFactory.fromHtmlElement(this.dropdownEl.nativeElement);
            var /** @type {?} */ positionedRect = this.placementService.place({
                anchor: inputRect,
                element: dropdownRect,
                placementId: 'bottom left',
                flip: true,
                constrainToParent: true
            });
            this.dropdownEl.nativeElement.style.top = positionedRect.top + 'px';
            this.dropdownEl.nativeElement.style.left = positionedRect.left + 'px';
            this.dropdownEl.nativeElement.style.visibility = 'visible';
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.updateSelection = /**
         * @return {?}
         */
        function () {
            this.checkValidity();
            this.selectionChanged.emit(this.selectedItems);
            this.onChange(this.selectedItems);
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.reset = /**
         * @return {?}
         */
        function () {
            this.query = '';
            this.filteredList = [];
            this.selectedIdx = -1;
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.updateFilteredList = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.filteredList = this.items.filter(function (item) {
                var /** @type {?} */ foundItem = _this.selectedItems.find(function (selectedItem) {
                    return selectedItem.label === item.label;
                });
                if (foundItem) {
                    return false;
                }
                return item.label.toLowerCase().indexOf(_this.query.toLowerCase()) > -1;
            });
            this.onTouched(this.selectedItems);
        };
        /**
         * @return {?}
         */
        UxAutocompleteTagComponent.prototype.checkValidity = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ validationMessages = [];
            if (this.minRequiredItemsCount) {
                if (this.minRequiredItemsCount > this.selectedItems.length) {
                    var /** @type {?} */ remainingItems = this.minRequiredItemsCount - this.selectedItems.length;
                    validationMessages.push(this.uxService.translate('autocompleteTagRequiredItemsValidation')
                        .replace('%PARAM%', remainingItems.toString()));
                }
            }
            if (this.maxRequiredItemsCount) {
                if (this.selectedItems.length > this.maxRequiredItemsCount) {
                    validationMessages.push(this.uxService.translate('autocompleteTagMaxRequiredItemsValidation')
                        .replace('%PARAM_1%', this.maxRequiredItemsCount.toString())
                        .replace('%PARAM_2%', this.selectedItems.length.toString()));
                }
            }
            this.isValid = validationMessages.length === 0;
            this.requiredItemsCountValidationMessage = validationMessages.join('\n');
            this.isSelectionValid.emit(this.isValid);
        };
        UxAutocompleteTagComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-autocomplete-tag',
                        template: "<div class=\"ux-autocomplete-tag\"> <div class=\"form-group\"> <div class=\"ux-autocomplete-tag__tags ux-autocomplete-tag__tags-top\" *ngIf=\"!isDisplayTagsListBelow && selectedItems?.length !== 0\"> <div *ngFor=\"let item of selectedItems\" class=\"ux-autocomplete-tag__tags-item\"> <div class=\"badge {{badgeSizeClass}} badge-primary badge-{{item.typeClass}}\"> <i *ngIf=\"item.iconClass\" class=\"mr-1 {{item.iconClass}}\"></i> <span>{{item.label}}</span> <span *ngIf=\"!isReadOnly && (item && item.isDeletable)\" class=\"ux-autocomplete-tag__tags-item-close ux-icon ux-icon-times\" (click)=\"removeItem(item)\"></span> </div> </div> </div> <div *ngIf=\"!isReadOnly\"> <div class=\"ux-autocomplete-tag__input\"> <input #input class=\"form-control custom-select\" type=\"text\" [(ngModel)]=\"query\" placeholder=\"{{placeholder}}\" (keyup)=\"onInputKeyup($event)\" (click)=\"onInputClick($event)\" /> <!--<span class=\"ux-icon ux-icon-sort ux-autocomplete-tag__input-icon\" (click)=\"onToggle($event)\"></span>--> </div> <ux-control-feedback *ngIf=\"!isValid\" typeClass=\"danger\"> {{requiredItemsCountValidationMessage}} </ux-control-feedback> </div> <div #dropdown class=\"ux-autocomplete-tag__dropdown-list dropdown-menu\" [style.display]=\"filteredList.length > 0 ? 'block' : 'none'\" (mousedown)=\"onSuggestionsMouseDown($event)\"> <ux-list-item *ngFor=\"let item of filteredList; let idx = index; trackBy: trackByFn\" [isActive]=\"idx == selectedIdx\" typeClass=\"{{item.typeClass}}\" (click)=\"selectItem(item)\" label=\"{{item.label}}\" iconClass=\"{{item.iconClass}}\"> </ux-list-item> </div> <div class=\"ux-autocomplete-tag__tags ux-autocomplete-tag__tags-bottom mt-1\" *ngIf=\"isDisplayTagsListBelow && selectedItems.length !== 0\"> <div *ngFor=\"let item of selectedItems\" class=\"ux-autocomplete-tag__tags-item\"> <div class=\"mt-1 badge {{badgeSizeClass}} badge-primary badge-{{item.typeClass}}\"> <i *ngIf=\"item.iconClass\" class=\"mr-1 {{item.iconClass}}\"></i> <span>{{item.label}}</span> <span *ngIf=\"!isReadOnly && (item && item.isDeletable)\" class=\"ux-autocomplete-tag__tags-item-close ux-icon ux-icon-times\" (click)=\"removeItem(item)\"></span> </div> </div> </div> </div> </div> ",
                        providers: [UX_AUTOCOMPLETETAG_VALUE_ACCESSOR]
                    },] },
        ];
        /** @nocollapse */
        UxAutocompleteTagComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: core.Renderer2, },
            { type: PlacementService, },
        ]; };
        UxAutocompleteTagComponent.propDecorators = {
            "isReadOnly": [{ type: core.Input },],
            "items": [{ type: core.Input },],
            "selectedItems": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "isFreeTagsAllowed": [{ type: core.Input },],
            "maxRequiredItemsCount": [{ type: core.Input },],
            "minRequiredItemsCount": [{ type: core.Input },],
            "isBadgeSmall": [{ type: core.Input },],
            "formControlName": [{ type: core.Input },],
            "isDisplayTagsListBelow": [{ type: core.Input },],
            "selectionChanged": [{ type: core.Output },],
            "isSelectionValid": [{ type: core.Output },],
            "itemAdded": [{ type: core.Output },],
            "itemRemoved": [{ type: core.Output },],
            "inputEl": [{ type: core.ViewChild, args: ['input',] },],
            "dropdownEl": [{ type: core.ViewChild, args: ['dropdown',] },],
            "focusOut": [{ type: core.HostListener, args: ['focusout', ['$event'],] },],
        };
        return UxAutocompleteTagComponent;
    }());
    var UxAutocompleteTagComponentModule = (function () {
        function UxAutocompleteTagComponentModule() {
        }
        UxAutocompleteTagComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, UxControlFeedbackComponentModule, UxListItemComponentModule],
                        exports: [UxAutocompleteTagComponent],
                        declarations: [UxAutocompleteTagComponent]
                    },] },
        ];
        return UxAutocompleteTagComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxButtonGroupItemComponent = (function () {
        function UxButtonGroupItemComponent() {
            this.isActive = false;
        }
        UxButtonGroupItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-button-group-item',
                        template: "<div></div> ",
                    },] },
        ];
        /** @nocollapse */
        UxButtonGroupItemComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "isActive": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
        };
        return UxButtonGroupItemComponent;
    }());
    var UxButtonGroupItemComponentModule = (function () {
        function UxButtonGroupItemComponentModule() {
        }
        UxButtonGroupItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxButtonGroupItemComponent],
                        declarations: [UxButtonGroupItemComponent]
                    },] },
        ];
        return UxButtonGroupItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxButtonGroupComponent = (function () {
        function UxButtonGroupComponent(uxService) {
            this.uxService = uxService;
            this.typeClass = 'primary';
            this.isOutline = false;
            this.links = [];
            this.isCheckboxButtons = false;
            this.isRadioButtons = false;
            this.hasPairedIcon = false;
            this.isSmall = false;
            this.isLarge = false;
            this.clicked = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxButtonGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.items && this.links.length === 0) {
                this.links = [];
                this.items.forEach(function (item) {
                    _this.links.push(new UxLink({
                        id: item.id,
                        label: item.label,
                        iconClass: item.iconClass,
                        active: item.isActive,
                        typeClass: item.typeClass
                    }));
                });
            }
            this.btnSizeClass = '';
            if (this.isSmall) {
                this.btnSizeClass = 'btn-sm';
            }
            if (this.isLarge) {
                this.btnSizeClass = 'btn-lg';
            }
        };
        /**
         * @param {?} link
         * @param {?} event
         * @return {?}
         */
        UxButtonGroupComponent.prototype.onClick = /**
         * @param {?} link
         * @param {?} event
         * @return {?}
         */
        function (link, event) {
            if (this.isCheckboxButtons) {
                this.links.forEach(function (currentLink) {
                    if (JSON.stringify(currentLink) === JSON.stringify(link)) {
                        currentLink.active = !currentLink.active;
                    }
                });
            }
            else if (this.isRadioButtons) {
                this.links.forEach(function (currentLink) {
                    currentLink.active = false;
                    if (JSON.stringify(currentLink) === JSON.stringify(link)) {
                        currentLink.active = !currentLink.active;
                    }
                });
            }
            this.uxService.consumeEvent(event);
            this.clicked.emit(link);
        };
        UxButtonGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-button-group',
                        template: "<div class=\"ux-button-group btn-group {{styleClass}} {{btnSizeClass}}\" data-toggle=\"buttons\"> <ng-template [ngIf]=\"isCheckboxButtons\"> <label *ngFor=\"let link of links\" (click)=\"onClick(link, $event)\" class=\"btn btn-{{isOutline ? 'outline-' : ''}}{{link.typeClass || typeClass}} {{btnSizeClass}}\" [class.active]=\"link.active\"> <input type=\"checkbox\" autocomplete=\"off\" [attr.checked]=\"link.active\"> {{link.label}} <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </label> </ng-template> <ng-template [ngIf]=\"isRadioButtons\"> <label *ngFor=\"let link of links\" (click)=\"onClick(link, $event)\" class=\"btn btn-{{isOutline ? 'outline-' : ''}}{{link.typeClass || typeClass}} {{btnSizeClass}}\" [class.active]=\"link.active\"> <input type=\"radio\" name=\"options\" id=\"option1\" autocomplete=\"off\" [attr.checked]=\"link.active\"> {{link.label}} <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </label> </ng-template> <ng-template [ngIf]=\"!isCheckboxButtons && !isRadioButtons\"> <ng-template [ngIf]=\"hasPairedIcon\"> <button type=\"button\" (click)=\"onClick(links[0], $event)\" class=\"btn ux-button btn-{{typeClass}} {{btnSizeClass}}\"> <span class=\"ux-button__content\">{{links[0].label}}</span> </button> <button type=\"button\" (click)=\"onClick(links[1], $event)\" class=\"btn ux-button btn-{{typeClass}}-dark {{btnSizeClass}}\"> <span class=\"{{links[1].iconClass}}\"></span> </button> </ng-template> <ng-template [ngIf]=\"!hasPairedIcon\"> <button type=\"button\" *ngFor=\"let link of links; let i = index\" (click)=\"onClick(link, $event)\" class=\"btn ux-button btn-{{typeClass}} {{btnSizeClass}} mr-2\"> <span class=\"ux-button__content\">{{link.label}}</span> <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </button> </ng-template> </ng-template> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxButtonGroupComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxButtonGroupComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "isOutline": [{ type: core.Input },],
            "links": [{ type: core.Input },],
            "isCheckboxButtons": [{ type: core.Input },],
            "isRadioButtons": [{ type: core.Input },],
            "hasPairedIcon": [{ type: core.Input },],
            "isSmall": [{ type: core.Input },],
            "isLarge": [{ type: core.Input },],
            "clicked": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxButtonGroupItemComponent; }),] },],
        };
        return UxButtonGroupComponent;
    }());
    var UxButtonGroupComponentModule = (function () {
        function UxButtonGroupComponentModule() {
        }
        UxButtonGroupComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxButtonGroupComponent],
                        declarations: [UxButtonGroupComponent]
                    },] },
        ];
        return UxButtonGroupComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxSplitButtonComponent = (function () {
        function UxSplitButtonComponent() {
            this.typeClass = 'secondary';
            this.isOutline = false;
            this.links = [];
            this.isDropDownRightAligned = false;
            this.linkSelected = new core.EventEmitter();
            this.buttonClicked = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxSplitButtonComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.btnTypeClass = 'btn-' + this.typeClass;
            if (this.isOutline) {
                this.btnTypeClass = 'btn-outline-' + this.typeClass;
            }
        };
        /**
         * @param {?} link
         * @return {?}
         */
        UxSplitButtonComponent.prototype.onLinkSelected = /**
         * @param {?} link
         * @return {?}
         */
        function (link) {
            this.linkSelected.emit(link);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxSplitButtonComponent.prototype.onButtonClicked = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.buttonClicked.emit(event);
        };
        UxSplitButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-split-button',
                        template: "\n        <div class=\"btn-group\">\n            <button type=\"button\" class=\"btn {{btnTypeClass}}\" (click)=\"onButtonClicked($event)\">{{label}}</button>\n            <ux-dropdown-button [links]=\"links\"\n                                typeClass=\"{{typeClass}}\" [isSplitButtonToggle]=\"true\"\n                                [isOutline]=\"isOutline\"\n                                (linkSelected)=\"onLinkSelected($event)\"\n                                [isDropDownRightAligned]=\"isDropDownRightAligned\"\n                                [hasItems]=\"items.length !== 0\">\n                <ng-content></ng-content>\n            </ux-dropdown-button>\n        </div>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxSplitButtonComponent.ctorParameters = function () { return []; };
        UxSplitButtonComponent.propDecorators = {
            "typeClass": [{ type: core.Input },],
            "isOutline": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "links": [{ type: core.Input },],
            "isDropDownRightAligned": [{ type: core.Input },],
            "linkSelected": [{ type: core.Output },],
            "buttonClicked": [{ type: core.Output },],
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxDropdownButtonItemComponent; }),] },],
        };
        return UxSplitButtonComponent;
    }());
    var UxSplitButtonComponentModule = (function () {
        function UxSplitButtonComponentModule() {
        }
        UxSplitButtonComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxDropdownButtonComponentModule, UxDropdownButtonItemComponentModule],
                        exports: [UxSplitButtonComponent],
                        declarations: [UxSplitButtonComponent]
                    },] },
        ];
        return UxSplitButtonComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxMessageBoxComponent = (function () {
        function UxMessageBoxComponent(uxService) {
            this.uxService = uxService;
            this.id = 'messagebox_modal';
            this.typeClass = 'warning';
            this.messageBoxType = 'confirmation';
            this.isFooterCustomAlignment = false;
            this.clicked = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxMessageBoxComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (!this.acceptLabel) {
                this.acceptLabel = this.uxService.translate('YES');
            }
            if (!this.dismissLabel) {
                this.dismissLabel = this.uxService.translate('NO');
            }
            this.stateClasses = '';
            if (this.typeClass) {
                this.stateClasses += 'ux-message-box--' + this.typeClass + ' ';
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxMessageBoxComponent.prototype.onClick = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.uxService.closeModal(this.id);
            this.clicked.emit(value);
        };
        UxMessageBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-message-box',
                        template: "\n        <ux-modal id=\"{{id}}\" titleLabel=\"{{titleLabel}}\"\n                  styleClass=\"ux-message-box {{stateClasses}} {{styleClass}}\"\n                  [isSizeSmall]=\"true\" [isFooterCustomAlignment]=\"isFooterCustomAlignment\"\n                  [isCloseModalOnEscape]=\"false\"\n                  [isShowCloseButton]=\"false\"\n                  [isMessageBox]=\"true\">\n            <uxModalBody>\n                <div class=\"ux-message-box__body\">\n                    <div class=\"ux-message-box__body-icon\"></div>\n                    <div class=\"ux-message-box__body-content\">\n                        <ng-content></ng-content>\n                    </div>\n                </div>\n            </uxModalBody>\n            <uxModalFooter>\n                <ng-template [ngIf]=\"customFooterContent\">\n                    <ng-content select=\"uxMessageBoxFooter\"></ng-content>\n                </ng-template>\n                <ng-template [ngIf]=\"!customFooterContent\">\n                    <ng-template [ngIf]=\"messageBoxType === 'confirmation'\">\n                        <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(false)\">{{dismissLabel}}</button>\n                        <button type=\"button\" class=\"btn btn-primary\" (click)=\"onClick(true)\">{{acceptLabel}}</button>\n                    </ng-template>\n                    <ng-template [ngIf]=\"messageBoxType === 'ok'\">\n                        <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(true)\">OK</button>\n                    </ng-template>\n                </ng-template>\n            </uxModalFooter>\n        </ux-modal>\n  "
                    },] },
        ];
        /** @nocollapse */
        UxMessageBoxComponent.ctorParameters = function () { return [
            { type: UxService, },
        ]; };
        UxMessageBoxComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "titleLabel": [{ type: core.Input },],
            "message": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "messageBoxType": [{ type: core.Input },],
            "acceptLabel": [{ type: core.Input },],
            "dismissLabel": [{ type: core.Input },],
            "isFooterCustomAlignment": [{ type: core.Input },],
            "clicked": [{ type: core.Output },],
            "customFooterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxMessageBoxFooterTagDirective; }),] },],
        };
        return UxMessageBoxComponent;
    }());
    var UxMessageBoxFooterTagDirective = (function () {
        function UxMessageBoxFooterTagDirective() {
        }
        UxMessageBoxFooterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxMessageBoxFooter' },] },
        ];
        return UxMessageBoxFooterTagDirective;
    }());
    var UxMessageBoxComponentModule = (function () {
        function UxMessageBoxComponentModule() {
        }
        UxMessageBoxComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxModalComponentModule],
                        exports: [UxMessageBoxComponent, UxMessageBoxFooterTagDirective],
                        declarations: [UxMessageBoxComponent, UxMessageBoxFooterTagDirective]
                    },] },
        ];
        return UxMessageBoxComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxStickyComponent = (function () {
        function UxStickyComponent(element) {
            this.element = element;
            this.zIndex = 10;
            this.width = 'auto';
            this.offsetTop = 0;
            this.offsetBottom = 0;
            this.start = 0;
            this.stickClass = 'ux-sticky';
            this.endStickClass = 'ux-sticky-end';
            this.mediaQuery = '';
            this.parentMode = true;
            this.activated = new core.EventEmitter();
            this.deactivated = new core.EventEmitter();
            this.onScrollBind = this.onScroll.bind(this);
            this.onResizeBind = this.onResize.bind(this);
            this.isStuck = false;
            this.elem = element.nativeElement;
        }
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            window.addEventListener('scroll', this.onScrollBind);
            window.addEventListener('resize', this.onResizeBind);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            // define scroll container as parent element
            this.container = this.elem.parentNode;
            this.originalCss = {
                zIndex: this.getCssValue(this.elem, 'zIndex'),
                position: this.getCssValue(this.elem, 'position'),
                top: this.getCssValue(this.elem, 'top'),
                right: this.getCssValue(this.elem, 'right'),
                left: this.getCssValue(this.elem, 'left'),
                bottom: this.getCssValue(this.elem, 'bottom'),
                width: this.getCssValue(this.elem, 'width'),
            };
            if (this.width === 'auto') {
                this.width = this.originalCss.width;
            }
            this.defineDimensions();
            this.sticker();
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            window.removeEventListener('scroll', this.onScrollBind);
            window.removeEventListener('resize', this.onResizeBind);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.onScroll = /**
         * @return {?}
         */
        function () {
            this.defineDimensions();
            this.sticker();
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.onResize = /**
         * @return {?}
         */
        function () {
            this.defineDimensions();
            this.sticker();
            if (this.isStuck) {
                this.unstuckElement();
                this.stuckElement();
            }
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.defineDimensions = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ containerTop = this.getBoundingClientRectValue(this.container, 'top');
            this.windowHeight = window.innerHeight;
            this.elemHeight = this.getCssNumber(this.elem, 'height');
            this.containerHeight = this.getCssNumber(this.container, 'height');
            this.containerStart = containerTop + this.scrollbarYPos() - this.offsetTop + this.start;
            if (this.parentMode) {
                this.scrollFinish = this.containerStart - this.start - this.offsetBottom + (this.containerHeight - this.elemHeight);
            }
            else {
                this.scrollFinish = document.body.offsetHeight;
            }
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.resetElement = /**
         * @return {?}
         */
        function () {
            this.elem.classList.remove(this.stickClass);
            Object.assign(this.elem.style, this.originalCss);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.stuckElement = /**
         * @return {?}
         */
        function () {
            this.isStuck = true;
            this.elem.classList.remove(this.endStickClass);
            this.elem.classList.add(this.stickClass);
            var /** @type {?} */ elementLeft = this.getBoundingClientRectValue(this.elem, 'left');
            this.elem.style.zIndex = this.zIndex;
            this.elem.style.position = 'fixed';
            this.elem.style.top = this.offsetTop + 'px';
            this.elem.style.right = 'auto';
            this.elem.style.left = elementLeft + 'px';
            this.elem.style.bottom = 'auto';
            this.elem.style.width = this.width;
            this.activated.next(this.elem);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.unstuckElement = /**
         * @return {?}
         */
        function () {
            this.isStuck = false;
            this.elem.classList.add(this.endStickClass);
            this.container.style.position = 'relative';
            this.elem.style.position = 'absolute';
            this.elem.style.top = 'auto';
            this.elem.style.right = 0;
            this.elem.style.left = 'auto';
            this.elem.style.bottom = this.offsetBottom + 'px';
            this.elem.style.width = this.width;
            this.deactivated.next(this.elem);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.matchMediaQuery = /**
         * @return {?}
         */
        function () {
            if (!this.mediaQuery) {
                return true;
            }
            return (window.matchMedia('(' + this.mediaQuery + ')').matches ||
                window.matchMedia(this.mediaQuery).matches);
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.sticker = /**
         * @return {?}
         */
        function () {
            // check media query
            if (this.isStuck && !this.matchMediaQuery()) {
                this.resetElement();
                return;
            }
            // detecting when a container's height changes
            var /** @type {?} */ currentContainerHeight = this.getCssNumber(this.container, 'height');
            if (currentContainerHeight !== this.containerHeight) {
                this.defineDimensions();
            }
            var /** @type {?} */ position = this.scrollbarYPos();
            // unstick
            if (this.isStuck && (position < this.containerStart || position > this.scrollFinish) || position > this.scrollFinish) {
                this.resetElement();
                if (position > this.scrollFinish) {
                    this.unstuckElement();
                }
                this.isStuck = false;
                // stick
            }
            else if (this.isStuck === false && position > this.containerStart && position < this.scrollFinish) {
                this.stuckElement();
            }
        };
        /**
         * @return {?}
         */
        UxStickyComponent.prototype.scrollbarYPos = /**
         * @return {?}
         */
        function () {
            return window.pageYOffset || document.documentElement.scrollTop;
        };
        /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        UxStickyComponent.prototype.getBoundingClientRectValue = /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        function (element, property) {
            var /** @type {?} */ result = 0;
            if (element.getBoundingClientRect) {
                var /** @type {?} */ rect = element.getBoundingClientRect();
                result = (typeof rect[property] !== 'undefined') ? rect[property] : 0;
            }
            return result;
        };
        /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        UxStickyComponent.prototype.getCssValue = /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        function (element, property) {
            var /** @type {?} */ result = '';
            if (typeof window.getComputedStyle !== 'undefined') {
                result = window.getComputedStyle(element, null).getPropertyValue(property);
            }
            else if (typeof element.currentStyle !== 'undefined') {
                result = element.currentStyle[property];
            }
            return result;
        };
        /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        UxStickyComponent.prototype.getCssNumber = /**
         * @param {?} element
         * @param {?} property
         * @return {?}
         */
        function (element, property) {
            return parseInt(this.getCssValue(element, property), 10) || 0;
        };
        UxStickyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-sticky',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        /** @nocollapse */
        UxStickyComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
        ]; };
        UxStickyComponent.propDecorators = {
            "zIndex": [{ type: core.Input },],
            "width": [{ type: core.Input },],
            "offsetTop": [{ type: core.Input },],
            "offsetBottom": [{ type: core.Input },],
            "start": [{ type: core.Input },],
            "stickClass": [{ type: core.Input },],
            "endStickClass": [{ type: core.Input },],
            "mediaQuery": [{ type: core.Input },],
            "parentMode": [{ type: core.Input },],
            "activated": [{ type: core.Output },],
            "deactivated": [{ type: core.Output },],
        };
        return UxStickyComponent;
    }());
    var UxStickyComponentModule = (function () {
        function UxStickyComponentModule() {
        }
        UxStickyComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxStickyComponent],
                        declarations: [UxStickyComponent]
                    },] },
        ];
        return UxStickyComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPieChartLegendItemComponent = (function () {
        function UxPieChartLegendItemComponent() {
        }
        /**
         * @return {?}
         */
        UxPieChartLegendItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        UxPieChartLegendItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-pie-chart-legend-item',
                        template: "<li class=\"chart-legend-item {{styleClass}}\"> <span class=\"chart-legend-item-marker ux-icon ux-icon-fw ux-icon-circle\" [style.color]=\"markerColor\"></span> <span class=\"chart-legend-item-label\">{{ label }}</span> <span class=\"chart-legend-item-counter pr-2\"> <span>{{ value }}</span> </span> <span class=\"chart-legend-item-label\"> <ng-content></ng-content> </span> </li> ",
                    },] },
        ];
        /** @nocollapse */
        UxPieChartLegendItemComponent.ctorParameters = function () { return []; };
        UxPieChartLegendItemComponent.propDecorators = {
            "styleClass": [{ type: core.Input },],
            "markerColor": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "value": [{ type: core.Input },],
        };
        return UxPieChartLegendItemComponent;
    }());
    var UxPieChartLegendItemComponentModule = (function () {
        function UxPieChartLegendItemComponentModule() {
        }
        UxPieChartLegendItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxButtonComponentModule],
                        exports: [UxPieChartLegendItemComponent],
                        declarations: [UxPieChartLegendItemComponent]
                    },] },
        ];
        return UxPieChartLegendItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DEFAULT_OPTIONS = {
        animation: {
            animateRotate: false,
        },
        legend: {
            display: false,
        },
        tooltips: { enabled: false },
    };
    var /** @type {?} */ innerDougnutData = function (data, labels) {
        if (data.length === 0) {
            return;
        }
        var /** @type {?} */ totalAmount = data[0].amount;
        if (totalAmount === 0) {
            return;
        }
        var /** @type {?} */ innerData = data.reduce(function (acc, item, index) {
            if (index > 0) {
                acc.data.push(Math.max(0, Math.round(item.amount / totalAmount * 100)));
                acc.backgroundColor.push(item.color);
            }
            return acc;
        }, { data: [], backgroundColor: [] });
        // Add white "space" left
        var /** @type {?} */ pctLeft = 100 - innerData.data.reduce(function (acc, pct) { return acc + pct; }, 0);
        innerData.data.push(pctLeft);
        innerData.backgroundColor.push('white');
        var /** @type {?} */ innerLabels = data.reduce(function (acc, item, index) {
            if (index > 0) {
                acc.labels.push(item.label);
            }
            return acc;
        }, { labels: [] });
        return { datasets: [innerData], labels: innerLabels.labels };
    };
    var /** @type {?} */ pieData = function (data, labels) {
        if (data.length === 0) {
            return;
        }
        var /** @type {?} */ pieDataset = data.reduce(function (acc, item, index) {
            acc.data.push(item.amount);
            acc.backgroundColor.push(item.color);
            return acc;
        }, { data: [], backgroundColor: [] });
        if (!labels) {
            labels = [];
        }
        return { datasets: [pieDataset], labels: labels };
    };
    var UxPieChartComponent = (function () {
        function UxPieChartComponent() {
            this.data = [];
            this.chartType = 'doughnut';
            this.isShowLabel = true;
            this.isDoughnutRenderZeroAmount = true;
            this.isDoughnutRenderAmountAsCurrency = true;
            this.emptyLabel = 'N/A';
            this.isDoughnutRendered = true;
        }
        /**
         * @return {?}
         */
        UxPieChartComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.initChart();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxPieChartComponent.prototype.ngOnChanges = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.initChart();
        };
        /**
         * @return {?}
         */
        UxPieChartComponent.prototype.initChart = /**
         * @return {?}
         */
        function () {
            this.pieOptions = this.options ? Object.assign({}, DEFAULT_OPTIONS, this.options) : Object.assign({}, DEFAULT_OPTIONS);
            this.innerData = innerDougnutData(this.data.values, this.data.labels);
            this.pieData = pieData(this.data.values, this.data.labels);
            if (this.chartType === 'doughnut') {
                if (!this.isDoughnutRenderZeroAmount) {
                    if (this.data.values[0].amount === 0) {
                        this.isDoughnutRendered = false;
                    }
                    else {
                        this.isDoughnutRendered = true;
                    }
                }
                this.pieOptions.cutoutPercentage = 75;
            }
        };
        UxPieChartComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-pie-chart',
                        template: "<div class=\"chart-title\" *ngIf=\"chartTitle\"> {{chartTitle}} </div> <div class=\"chart-container\"> <ng-container *ngIf=\"chartType === 'doughnut'\"> <!--Outer doughnut--> <div *ngIf=\"isDoughnutRendered\"> <p-chart type=\"doughnut\" [data]=\"{ labels: [data.values[0].label], datasets: [{data: [100], backgroundColor: [data.values[0].color || 'blue']}]}\" [options]=\"pieOptions\"></p-chart> </div> <div *ngIf=\"!isDoughnutRendered\"> <p-chart type=\"doughnut\" [data]=\"{ labels: [data.values[0].label], datasets: [{data: [0], backgroundColor: [data.values[0].color || 'transparent']}]}\" [options]=\"pieOptions\"></p-chart> </div> <!--Inner doughnut--> <div class=\"inner-chart\" *ngIf=\"innerData\"> <p-chart type=\"doughnut\" [data]=\"innerData\" [options]=\"pieOptions\"></p-chart> </div> </ng-container> <ng-container *ngIf=\"chartType === 'pie'\"> <div> <p-chart type=\"pie\" [data]=\"pieData\" [options]=\"pieOptions\"></p-chart> </div> </ng-container> <!--Label center--> <div class=\"chart-inner-labels small\" *ngIf=\"isShowLabel\"> <span *ngIf=\"isDoughnutRendered\" class=\"amount\"> <span *ngIf=\"isDoughnutRenderAmountAsCurrency\">{{ data.values[0].amount | uxCurrency: 0 }}</span> <span *ngIf=\"!isDoughnutRenderAmountAsCurrency\">{{ data.values[0].amount }}</span> </span> <span *ngIf=\"!isDoughnutRendered\" class=\"amount\">{{emptyLabel}}</span> </div> </div> <ul class=\"chart-legend chart-legend-custom\" *ngIf=\"customFooterContent\"> <ng-content select=\"uxPieChartCustomLegend\"></ng-content> </ul> <!--Legend--> <ul class=\"chart-legend\" *ngIf=\"!customFooterContent\"> <li class=\"chart-legend-item\" *ngFor=\"let item of data.values\"> <span class=\"chart-legend-item-marker ux-icon ux-icon-fw ux-icon-circle\" [style.color]=\"item.color\"></span> <span class=\"chart-legend-item-label\">{{item.label}}</span> <span class=\"chart-legend-item-counter\" *ngIf=\"chartType === 'doughnut'\"> <span *ngIf=\"isDoughnutRenderAmountAsCurrency\">{{ item.amount | uxCurrency: 0 }}</span> <span *ngIf=\"!isDoughnutRenderAmountAsCurrency\">{{ item.amount }}</span> </span> <span class=\"chart-legend-item-counter\" *ngIf=\"chartType === 'pie'\">{{item.amount}}</span> </li> </ul> ",
                    },] },
        ];
        /** @nocollapse */
        UxPieChartComponent.ctorParameters = function () { return []; };
        UxPieChartComponent.propDecorators = {
            "data": [{ type: core.Input },],
            "options": [{ type: core.Input },],
            "chartTitle": [{ type: core.Input },],
            "chartType": [{ type: core.Input },],
            "isShowLabel": [{ type: core.Input },],
            "isDoughnutRenderZeroAmount": [{ type: core.Input },],
            "isDoughnutRenderAmountAsCurrency": [{ type: core.Input },],
            "emptyLabel": [{ type: core.Input },],
            "customFooterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxPieChartCustomLegendTagDirective; }),] },],
        };
        return UxPieChartComponent;
    }());
    var UxPieChartCustomLegendTagDirective = (function () {
        function UxPieChartCustomLegendTagDirective() {
        }
        UxPieChartCustomLegendTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxPieChartCustomLegend' },] },
        ];
        return UxPieChartCustomLegendTagDirective;
    }());
    var UxPieChartComponentModule = (function () {
        function UxPieChartComponentModule() {
        }
        UxPieChartComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, chart.ChartModule, UxCurrencyPipeModule, UxPieChartLegendItemComponentModule],
                        exports: [UxPieChartComponent, UxPieChartCustomLegendTagDirective],
                        declarations: [UxPieChartComponent, UxPieChartCustomLegendTagDirective]
                    },] },
        ];
        return UxPieChartComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPieChartGroupComponent = (function () {
        function UxPieChartGroupComponent(asService) {
            this.asService = asService;
            this.itemsArray = [];
        }
        /**
         * @return {?}
         */
        UxPieChartGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.itemsArray = this.items.toArray();
        };
        UxPieChartGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-pie-chart-group',
                        template: "\n        <ng-template [ngIf]=\"!(asService.breakpoints$ | async).isMobile\">\n            <div class=\"row\">\n                <div *ngFor=\"let item of itemsArray\" class=\"col-{{12 / itemsArray.length}}\">\n                   <ux-pie-chart chartTitle=\"{{item.chartTitle}}\"\n                                 [data]=\"item.data\"\n                                 [isShowLabel]=\"item.isShowLabel\"\n                                 chartType=\"{{item.chartType}}\">\n                   </ux-pie-chart>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngIf=\"(asService.breakpoints$ | async).isMobile\">\n            <ux-carousel-items>\n                <ux-carousel-item *ngFor=\"let item of itemsArray\">\n                    <ux-pie-chart chartTitle=\"{{item.chartTitle}}\"\n                                    [data]=\"item.data\"\n                                    [isShowLabel]=\"item.isShowLabel\"\n                                    chartType=\"{{item.chartType}}\">\n                    </ux-pie-chart>\n                </ux-carousel-item>\n            </ux-carousel-items>\n        </ng-container>\n    "
                    },] },
        ];
        /** @nocollapse */
        UxPieChartGroupComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxPieChartGroupComponent.propDecorators = {
            "items": [{ type: core.ContentChildren, args: [core.forwardRef(function () { return UxPieChartComponent; }),] },],
        };
        return UxPieChartGroupComponent;
    }());
    var UxPieChartGroupComponentModule = (function () {
        function UxPieChartGroupComponentModule() {
        }
        UxPieChartGroupComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxPieChartComponentModule,
                            UxCarouselItemComponentModule, UxCarouselItemsComponentModule
                        ],
                        exports: [UxPieChartGroupComponent],
                        declarations: [UxPieChartGroupComponent]
                    },] },
        ];
        return UxPieChartGroupComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicModalConfig = (function () {
        function UxDynamicModalConfig(values) {
            this.id = 'single_modal';
            this.dismissLabel = 'Cancel';
            this.dismissDisabled = false;
            this.acceptLabel = 'OK';
            this.acceptActionDisabled = false;
            this.dismissActionDisabled = false;
            this.isFooterVisible = true;
            this.isKeepBodyScroll = false;
            this.isSizeSmall = false;
            this.isSizeLarge = false;
            this.isSizeFullScreen = false;
            this.isSizeFullHeight = false;
            this.isSizeMediumHeight = false;
            this.isShowActionIcons = false;
            this.messageBoxType = '';
            this.acceptIconClass = 'ux-icon ux-icon-check';
            this.dismissIconClass = 'ux-icon ux-icon-close';
            this.hasNoBodyPadding = false;
            this.isFooterCustomAlignment = false;
            this.isCloseModalOnEscape = true;
            this.isShowCloseButton = true;
            this.isMessageBox = false;
            this.isHandleCloseOnDismiss = true;
            this.isHandleCloseOnAccept = true;
            this.isHandleCloseOnClose = true;
            this.isOverflowVisible = false;
            this.content = '';
            Object.assign(this, values);
        }
        return UxDynamicModalConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicModalComponent = (function () {
        function UxDynamicModalComponent(uxService, uxDynamicComponentConfig, uxDynamicComponentService) {
            this.uxService = uxService;
            this.uxDynamicComponentService = uxDynamicComponentService;
            this.stateClasses = '';
            this.config = uxDynamicComponentConfig;
        }
        /**
         * @return {?}
         */
        UxDynamicModalComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.config.isSizeSmall) {
                this.stateClasses = 'ux-modal--small';
            }
            if (this.config.isSizeLarge) {
                this.stateClasses = 'ux-modal--large';
            }
            if (this.config.isSizeFullScreen) {
                this.stateClasses = 'ux-modal--full-screen';
            }
            if (this.config.bodyInjectedComponent && this.config.bodyInjectedComponent.component) {
                setTimeout(function () {
                    var /** @type {?} */ injectedComponentConfig = Object.assign(_this.config.bodyInjectedComponent.config, { parent: {
                            portalHostRef: _this.config['portalHostRef'],
                            portalRef: _this.config['portalRef'],
                            portalComponentInstanceRef: _this.config['portalComponentInstanceRef'],
                        } });
                    var /** @type {?} */ injectedComponent = _this.uxDynamicComponentService.add(_this.config.bodyInjectedComponent.component, _this.uxModalBody, _this.config.bodyInjectedComponent.config);
                    if (injectedComponent) {
                        Object.assign(_this.config, { child: {
                                portalHostRef: injectedComponent['portalHost'],
                                portalRef: injectedComponent['portal'],
                                portalComponentInstanceRef: injectedComponent['portalComponentInstance'],
                            } });
                    }
                }, 0);
            }
        };
        /**
         * @return {?}
         */
        UxDynamicModalComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.vcCloseButton) {
                this.vcCloseButton.nativeElement.focus();
            }
        };
        /**
         * Close modal function
         * @param {?} event
         * @return {?}
         */
        UxDynamicModalComponent.prototype.close = /**
         * Close modal function
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.config.isHandleCloseOnClose) {
                // This function is defined as closeDynamicModal in ux-dynamic-modal.service if the component user didn't define it
                this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
            }
        };
        /**
         * Close modal on escape(key 27) press
         * @param {?} event
         * @return {?}
         */
        UxDynamicModalComponent.prototype.closeModalOnEscape = /**
         * Close modal on escape(key 27) press
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.config.isCloseModalOnEscape) {
                if (event.keyCode === 27) {
                    this.close(event);
                }
            }
        };
        /**
         * Trigger by the message-box when user click on OK button
         * @param {?} event
         * @return {?}
         */
        UxDynamicModalComponent.prototype.onAcceptActionClick = /**
         * Trigger by the message-box when user click on OK button
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.config.isHandleCloseOnAccept) {
                this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
            }
            if (this.config.onAccept) {
                this.config.onAccept(this.config['portalHostRef'], this.config['portalRef']);
            }
            if (this.config.onClick) {
                this.config.onClick(true);
            }
        };
        /**
         * Trigger by the message-box when user click on NO button
         * @param {?} event
         * @return {?}
         */
        UxDynamicModalComponent.prototype.onDismissActionClick = /**
         * Trigger by the message-box when user click on NO button
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.config.isHandleCloseOnDismiss) {
                this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
            }
            if (this.config.onDismiss) {
                this.config.onDismiss(this.config['portalHostRef'], this.config['portalRef']);
            }
            if (this.config.onClick) {
                this.config.onClick(false);
            }
        };
        /**
         * Trigger by the message-box when user click on a custom buttons defined in the config
         * @param {?} button
         * @return {?}
         */
        UxDynamicModalComponent.prototype.customFooterButtonClick = /**
         * Trigger by the message-box when user click on a custom buttons defined in the config
         * @param {?} button
         * @return {?}
         */
        function (button) {
            button.onClick(this.config['portalHostRef'], this.config['portalRef'], this.config['portalComponentInstanceRef']);
        };
        /**
         * Trigger by the message-box when user click on NO or OK buttons
         * @param {?} value
         * @return {?}
         */
        UxDynamicModalComponent.prototype.onClick = /**
         * Trigger by the message-box when user click on NO or OK buttons
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.config.onClick) {
                this.config.onClick(value);
            }
            if (this.config.onClose) {
                this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
            }
        };
        UxDynamicModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dynamic-modal',
                        template: "<div id=\"{{config.id}}\" cdkTrapFocus #modal class=\"modal fx ux-modal {{config.styleClass}} {{stateClasses}}\" tabindex=\"-1\" role=\"dialog\" [class.slideInDown]=\"!config.isMessageBox\" [class.flipInY]=\"config.isMessageBox\" [class.ux-modal--full-height]=\"config.isSizeFullHeight\" [class.ux-modal--medium-height]=\"config.isSizeMediumHeight\" (keydown)=\"closeModalOnEscape($event)\" tabIndex=\"-1\" [style.display]=\"'block'\"> <div class=\"modal-dialog ux-modal__dialog\" role=\"document\" [style.max-width]=\"config.customWidth\"> <div class=\"modal-content ux-modal__content\" [class.ux-u-overflow-visible]=\"config.isOverflowVisible\"> <div class=\"modal-header ux-modal__header\"> <ng-template [ngIf]=\"customHeaderContent\"> <ng-content select=\"uxModalHeader\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customHeaderContent\"> <h5 class=\"modal-title ux-modal__header-title\">{{config.titleLabel}}</h5> </ng-template> <button #closeButton type=\"button\" class=\"ux-modal__header-close close\" data-dismiss=\"modal\" aria-label=\"Close\" (click)=\"close($event)\" *ngIf=\"config.isShowCloseButton\"> <span>&times;</span> </button> </div> <div #uxmodalbody class=\"modal-body ux-modal__body {{config.bodyStyleClass}}\" [class.p-0]=\"config.hasNoBodyPadding\" [class.ux-u-overflow-visible]=\"config.isOverflowVisible\"> <span [outerHTML]=\"config.content\" *ngIf=\"!config.isMessageBox\"></span> <div class=\"ux-message-box__body\" *ngIf=\"config.isMessageBox\"> <div class=\"ux-message-box__body-icon\"></div> <div class=\"ux-message-box__body-content\"> <span [outerHTML]=\"config.content\"></span> </div> </div> </div> <div *ngIf=\"config.isFooterVisible\" class=\"modal-footer ux-modal__footer {{config.footerStyleClass}}\" [class.ux-modal__footer--custom-alignment]=\"config.customFooterContent\"> <!-- MODAL CUSTOM FOOTER --> <uxDynamicModalFooter *ngIf=\"config.customFooterContent && !config.isMessageBox\"> <ux-layout-horizontal> <uxLayoutHorizontalLeft *ngIf=\"config.customFooterContent.left\"> <ux-button *ngFor=\"let button of config.customFooterContent.left.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalLeft> <uxLayoutHorizontalRight *ngIf=\"config.customFooterContent.right\"> <ux-button *ngFor=\"let button of config.customFooterContent.right.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalRight> </ux-layout-horizontal> </uxDynamicModalFooter> <!-- /MODAL CUSTOM FOOTER --> <!-- MESSAGE-BOX CUSTOM FOOTER --> <uxDynamicMessageBoxFooter *ngIf=\"config.customFooterContent && config.isMessageBox\"> <ux-layout-horizontal> <uxLayoutHorizontalLeft *ngIf=\"config.customFooterContent.left\"> <ux-button *ngFor=\"let button of config.customFooterContent.left.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalLeft> <uxLayoutHorizontalRight *ngIf=\"config.customFooterContent.right\"> <ux-button *ngFor=\"let button of config.customFooterContent.right.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalRight> </ux-layout-horizontal> </uxDynamicMessageBoxFooter> <!-- /MESSAGE-BOX CUSTOM FOOTER --> <ng-template [ngIf]=\"!config.customFooterContent\"> <ng-template [ngIf]=\"!config.isMessageBox\"> <button type=\"button\" class=\"btn btn-secondary\" [disabled]=\"config.dismissActionDisabled\" (click)=\"onDismissActionClick($event)\"> <i *ngIf=\"config.isShowActionIcons\" class=\"ux-modal__action-icon-element {{config.dismissIconClass}}\"></i> {{config.dismissLabel}} </button> <button type=\"button\" class=\"btn btn-primary\" [disabled]=\"config.acceptActionDisabled\" (click)=\"onAcceptActionClick($event)\"> <i *ngIf=\"config.isShowActionIcons\" class=\"ux-modal__action-icon-element {{config.acceptIconClass}}\"></i> {{config.acceptLabel}} </button> </ng-template> <ng-template [ngIf]=\"config.isMessageBox\"> <ng-template [ngIf]=\"config.messageBoxType && config.messageBoxType === 'confirmation'\"> <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(false)\">{{config.dismissLabel}}</button> <button type=\"button\" class=\"btn btn-primary\" (click)=\"onClick(true)\">{{config.acceptLabel}}</button> </ng-template> <ng-template [ngIf]=\"config.messageBoxType && config.messageBoxType === 'ok'\"> <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(true)\">OK</button> </ng-template> </ng-template> </ng-template> </div> </div> </div> </div> <div class=\"modal-backdrop fade in show\" [style.display]=\"'block'\" (focus)=\"close($event)\"></div> "
                    },] },
        ];
        /** @nocollapse */
        UxDynamicModalComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxDynamicModalConfig, decorators: [{ type: core.Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
            { type: UxDynamicComponentService, },
        ]; };
        UxDynamicModalComponent.propDecorators = {
            "customFooterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxDynamicModalFooterTagDirective; }),] },],
            "customHeaderContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxDynamicModalHeaderTagDirective; }),] },],
            "customMessageBoxFooterContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxDynamicMessageBoxFooterTagDirective; }),] },],
            "uxModalBody": [{ type: core.ViewChild, args: ['uxmodalbody',] },],
            "vcCloseButton": [{ type: core.ViewChild, args: ['closeButton',] },],
        };
        return UxDynamicModalComponent;
    }());
    var UxDynamicModalBodyTagDirective = (function () {
        function UxDynamicModalBodyTagDirective() {
        }
        UxDynamicModalBodyTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxDynamicModalBody' },] },
        ];
        return UxDynamicModalBodyTagDirective;
    }());
    var UxDynamicModalFooterTagDirective = (function () {
        function UxDynamicModalFooterTagDirective() {
        }
        UxDynamicModalFooterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxDynamicModalFooter' },] },
        ];
        return UxDynamicModalFooterTagDirective;
    }());
    var UxDynamicModalHeaderTagDirective = (function () {
        function UxDynamicModalHeaderTagDirective() {
        }
        UxDynamicModalHeaderTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxDynamicModalHeader' },] },
        ];
        return UxDynamicModalHeaderTagDirective;
    }());
    var UxDynamicMessageBoxFooterTagDirective = (function () {
        function UxDynamicMessageBoxFooterTagDirective() {
        }
        UxDynamicMessageBoxFooterTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxDynamicMessageBoxFooter' },] },
        ];
        return UxDynamicMessageBoxFooterTagDirective;
    }());
    var UxDynamicModalComponentModule = (function () {
        function UxDynamicModalComponentModule() {
        }
        UxDynamicModalComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxButtonComponentModule,
                            UxLayoutHorizontalModule,
                            a11y.A11yModule
                        ],
                        exports: [
                            UxDynamicModalComponent,
                            UxDynamicModalBodyTagDirective,
                            UxDynamicModalFooterTagDirective,
                            UxDynamicModalHeaderTagDirective,
                            UxDynamicMessageBoxFooterTagDirective,
                        ],
                        declarations: [
                            UxDynamicModalComponent,
                            UxDynamicModalBodyTagDirective,
                            UxDynamicModalFooterTagDirective,
                            UxDynamicModalHeaderTagDirective,
                            UxDynamicMessageBoxFooterTagDirective,
                        ],
                        entryComponents: [
                            UxDynamicModalComponent,
                        ],
                    },] },
        ];
        return UxDynamicModalComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicMessageBoxConfig = (function () {
        function UxDynamicMessageBoxConfig(values) {
            this.id = 'messagebox_modal';
            this.typeClass = 'warning';
            this.messageBoxType = 'confirmation';
            this.isFooterCustomAlignment = false;
            Object.assign(this, values);
        }
        return UxDynamicMessageBoxConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicMessageBoxComponent = (function () {
        function UxDynamicMessageBoxComponent(uxService, uxDynamicComponentConfig, uxDynamicComponentService) {
            this.uxService = uxService;
            this.uxDynamicComponentService = uxDynamicComponentService;
            this.stateClasses = '';
            this.config = uxDynamicComponentConfig;
        }
        /**
         * @return {?}
         */
        UxDynamicMessageBoxComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.config.acceptLabel) {
                this.config.acceptLabel = this.uxService.translate('YES');
            }
            if (!this.config.dismissLabel) {
                this.config.dismissLabel = this.uxService.translate('NO');
            }
            if (this.config.typeClass) {
                this.stateClasses += 'ux-message-box--' + this.config.typeClass + ' ';
            }
            setTimeout(function () {
                _this.config = Object.assign({}, _this.config, {
                    isMessageBox: true,
                    isShowCloseButton: false,
                    isCloseModalOnEscape: false,
                    isSizeSmall: true,
                    styleClass: 'ux-message-box ' + _this.stateClasses + ' ' + _this.config.styleClass,
                });
                var /** @type {?} */ modalConfig = new UxDynamicModalConfig(_this.config);
                _this.uxDynamicComponentService.add(UxDynamicModalComponent, _this.uxMessageBoxBody, modalConfig);
            }, 0);
        };
        UxDynamicMessageBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dynamic-message-box',
                        template: '<div #uxmessageboxbody id="{{config.id}}"></div>',
                    },] },
        ];
        /** @nocollapse */
        UxDynamicMessageBoxComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxDynamicMessageBoxConfig, decorators: [{ type: core.Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
            { type: UxDynamicComponentService, },
        ]; };
        UxDynamicMessageBoxComponent.propDecorators = {
            "uxMessageBoxBody": [{ type: core.ViewChild, args: ['uxmessageboxbody',] },],
        };
        return UxDynamicMessageBoxComponent;
    }());
    var UxDynamicMessageBoxComponentModule = (function () {
        function UxDynamicMessageBoxComponentModule() {
        }
        UxDynamicMessageBoxComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        exports: [
                            UxDynamicMessageBoxComponent,
                        ],
                        declarations: [
                            UxDynamicMessageBoxComponent,
                        ],
                        entryComponents: [
                            UxDynamicMessageBoxComponent,
                        ],
                    },] },
        ];
        return UxDynamicMessageBoxComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicModalService = (function () {
        /**
         * Constructor
         */
        function UxDynamicModalService(uxDynamicComponentService) {
            this.uxDynamicComponentService = uxDynamicComponentService;
        }
        /**
         * Open a modal dynamically (Add it to the DOM)
         */
        /**
         * Open a modal dynamically (Add it to the DOM)
         * @param {?} config
         * @return {?}
         */
        UxDynamicModalService.prototype.openModal = /**
         * Open a modal dynamically (Add it to the DOM)
         * @param {?} config
         * @return {?}
         */
        function (config) {
            var /** @type {?} */ component;
            document.body.classList.add('modal-open');
            if (config instanceof UxDynamicModalConfig) {
                if (!(/** @type {?} */ (config)).onClose) {
                    (/** @type {?} */ (config)).onClose = this.closeModal.bind(this);
                }
                component = UxDynamicModalComponent;
            }
            else {
                component = UxDynamicMessageBoxComponent;
            }
            return this.uxDynamicComponentService.add(component, null, config);
        };
        /**
         * Close a modal created dynamically (Remove it from the DOM)
         */
        /**
         * Close a modal created dynamically (Remove it from the DOM)
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @return {?}
         */
        UxDynamicModalService.prototype.closeModal = /**
         * Close a modal created dynamically (Remove it from the DOM)
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @return {?}
         */
        function (portalHostRef, portalRef) {
            document.body.classList.remove('modal-open');
            this.uxDynamicComponentService.remove(portalHostRef, portalRef);
        };
        UxDynamicModalService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicModalService.ctorParameters = function () { return [
            { type: UxDynamicComponentService, },
        ]; };
        return UxDynamicModalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicMessageBoxService = (function () {
        function UxDynamicMessageBoxService(uxDynamicModalService) {
            this.uxDynamicModalService = uxDynamicModalService;
        }
        /**
         * Open a message-box dynamically (Add it to the DOM)
         */
        /**
         * Open a message-box dynamically (Add it to the DOM)
         * @param {?} config
         * @return {?}
         */
        UxDynamicMessageBoxService.prototype.openMessageBox = /**
         * Open a message-box dynamically (Add it to the DOM)
         * @param {?} config
         * @return {?}
         */
        function (config) {
            if (!(/** @type {?} */ (config)).onClose) {
                (/** @type {?} */ (config)).onClose = this.closeMessageBox.bind(this);
            }
            var _a = this.uxDynamicModalService.openModal(config), portalHost = _a.portalHost, portal$$1 = _a.portal;
            this.portalHost = portalHost;
            this.portal = portal$$1;
        };
        /**
         * Close a message-box created dynamically (Remove it from the DOM)
         */
        /**
         * Close a message-box created dynamically (Remove it from the DOM)
         * @return {?}
         */
        UxDynamicMessageBoxService.prototype.closeMessageBox = /**
         * Close a message-box created dynamically (Remove it from the DOM)
         * @return {?}
         */
        function () {
            this.uxDynamicModalService.closeModal(this.portalHost, this.portal);
        };
        UxDynamicMessageBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicMessageBoxService.ctorParameters = function () { return [
            { type: UxDynamicModalService, },
        ]; };
        return UxDynamicMessageBoxService;
    }());

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var UxMenuItemConfig = (function (_super) {
        __extends$4(UxMenuItemConfig, _super);
        function UxMenuItemConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.hasBorder = false;
            return _this;
        }
        UxMenuItemConfig.decorators = [
            { type: core.Injectable },
        ];
        return UxMenuItemConfig;
    }(UxItemConfig));

    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var UxMenuItemComponent = (function (_super) {
        __extends$5(UxMenuItemComponent, _super);
        function UxMenuItemComponent(config) {
            var _this = _super.call(this, config) || this;
            _this.customContent = false;
            _this.customSubLabel = false;
            return _this;
        }
        UxMenuItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-menu-item',
                        template: "<div class=\"ux-list-item-wrapper\" [class.ux-list-item-wrapper--hovered]=\"isHovered && !isExpanded\" (click)=\"onClick()\" (mouseenter)=\"onMouseenter()\" (mouseleave)=\"onMouseleave()\"> <div *ngIf=\"isHovered && !isExpanded\" class=\"ux-list-item-hover-content\" [class.ux-list-item-hover-content--left-positioned]=\"isLeftPositioned\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\"></ux-a-label> </div> <div class=\"ux-list-item ux-list-item--{{typeClass}} {{styleClass}}\" [class.ux-list-item--small]=\"isSmall\" [class.ux-list-item--large]=\"isLarge\" [class.ux-list-item--hovered]=\"isHovered && !isExpanded\" [class.ux-list-item--not-hoverable]=\"!isHoverable\" [class.ux-list-item--bordered]=\"hasBorder\" [class.ux-list-item--collapsed]=\"!isExpanded\" [class.ux-list-item--active]=\"isActive\" [class.ux-list-item--seperator]=\"!label && !subLabel && !customContent\" [class.ux-list-item--disabled]=\"isDisabled\" tabindex=\"0\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxListItemContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isDisabled]=\"isDisabled\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-list-item__right-content\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\" [isRounded]=\"isTagRounded\"> </ux-a-tag> </div> </ng-template> </div> </div> "
                    },] },
        ];
        /** @nocollapse */
        UxMenuItemComponent.ctorParameters = function () { return [
            { type: UxMenuItemConfig, },
        ]; };
        return UxMenuItemComponent;
    }(UxItemComponent));
    var UxMenuItemComponentModule = (function () {
        function UxMenuItemComponentModule() {
        }
        /**
         * @return {?}
         */
        UxMenuItemComponentModule.forRoot = /**
         * @return {?}
         */
        function () { return { ngModule: UxItemComponentModule, providers: [UxMenuItemConfig] }; };
        UxMenuItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxItemComponentModule],
                        exports: [UxMenuItemComponent],
                        declarations: [UxMenuItemComponent]
                    },] },
        ];
        return UxMenuItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxLoadingIndicatorComponent = (function () {
        function UxLoadingIndicatorComponent() {
            this.hidden = true;
        }
        /**
         * @return {?}
         */
        UxLoadingIndicatorComponent.prototype.show = /**
         * @return {?}
         */
        function () {
            this.hidden = false;
        };
        /**
         * @return {?}
         */
        UxLoadingIndicatorComponent.prototype.hide = /**
         * @return {?}
         */
        function () {
            this.hidden = true;
        };
        /**
         * @return {?}
         */
        UxLoadingIndicatorComponent.prototype.isShown = /**
         * @return {?}
         */
        function () {
            return !this.hidden;
        };
        /**
         * @return {?}
         */
        UxLoadingIndicatorComponent.prototype.isHidden = /**
         * @return {?}
         */
        function () {
            return this.hidden;
        };
        UxLoadingIndicatorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-loading-indicator',
                        template: "<div class=\"ux-loading-indicator\" [hidden]=\"hidden\"><div></div><div></div><div></div></div>",
                        styles: [".ux-loading-indicator{display:inline-block;vertical-align:middle}.ux-loading-indicator>div{animation:ux-loading-indicator-bouncedelay 1s infinite ease-in-out both;background-color:black;border-radius:100%;display:inline-block;height:.5rem;margin:.25rem;width:.5rem}.ux-loading-indicator>div:nth-child(1){animation-delay:-0.4s}.ux-loading-indicator>div:nth-child(2){animation-delay:-0.2s}@keyframes ux-loading-indicator-bouncedelay{0%,80%,100%{opacity:0;transform:scale(0) rotate(0.02deg)}40%{opacity:1;transform:scale(1) rotate(0.02deg)}} /*# sourceMappingURL=ux-loading-indicator.component.css.map */"],
                    },] },
        ];
        /** @nocollapse */
        UxLoadingIndicatorComponent.propDecorators = {
            "hidden": [{ type: core.Input },],
        };
        return UxLoadingIndicatorComponent;
    }());
    var UxLoadingIndicatorComponentModule = (function () {
        function UxLoadingIndicatorComponentModule() {
        }
        UxLoadingIndicatorComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxLoadingIndicatorComponent],
                        declarations: [UxLoadingIndicatorComponent]
                    },] },
        ];
        return UxLoadingIndicatorComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LeftPlacementStrategy = (function () {
        function LeftPlacementStrategy() {
        }
        /**
         * @return {?}
         */
        LeftPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'left';
        };
        /**
         * @param {?} options
         * @return {?}
         */
        LeftPlacementStrategy.prototype.calculate = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ placedRect = options.element
                .clone()
                .moveTo(options.anchor.leftCenter(), options.element.rightCenter())
                .translateX(-options.offsetAlong)
                .translateY(options.offsetAcross);
            if (options.flip && placedRect.overflowsLeft(options.parent)) {
                placedRect.flipY(options.anchor.center().x);
            }
            if (options.constrainToParent) {
                placedRect.translateInside(options.parent);
            }
            return placedRect;
        };
        return LeftPlacementStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TopPlacementStrategy = (function () {
        function TopPlacementStrategy() {
        }
        /**
         * @return {?}
         */
        TopPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'top';
        };
        /**
         * @param {?} options
         * @return {?}
         */
        TopPlacementStrategy.prototype.calculate = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ placedRect = options.element
                .clone()
                .moveTo(options.anchor.centerTop(), options.element.centerBottom())
                .translateY(-options.offsetAlong)
                .translateX(options.offsetAcross);
            if (options.flip && placedRect.overflowsTop(options.parent)) {
                placedRect.flipX(options.anchor.center().y);
            }
            if (options.constrainToParent) {
                placedRect.translateInside(options.parent);
            }
            return placedRect;
        };
        return TopPlacementStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BottomPlacementStrategy = (function () {
        function BottomPlacementStrategy() {
        }
        /**
         * @return {?}
         */
        BottomPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'bottom';
        };
        /**
         * @param {?} options
         * @return {?}
         */
        BottomPlacementStrategy.prototype.calculate = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ placedRect = options.element
                .clone()
                .moveTo(options.anchor.centerBottom(), options.element.centerTop())
                .translateY(options.offsetAlong)
                .translateX(options.offsetAcross);
            if (options.flip && placedRect.overflowsBottom(options.parent)) {
                placedRect.flipX(options.anchor.center().y);
            }
            if (options.constrainToParent) {
                placedRect.translateInside(options.parent);
            }
            return placedRect;
        };
        return BottomPlacementStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RightPlacementStrategy = (function () {
        function RightPlacementStrategy() {
        }
        /**
         * @return {?}
         */
        RightPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'right';
        };
        /**
         * @param {?} options
         * @return {?}
         */
        RightPlacementStrategy.prototype.calculate = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ placedRect = options.element
                .clone()
                .moveTo(options.anchor.rightCenter(), options.element.leftCenter())
                .translateX(options.offsetAlong)
                .translateY(options.offsetAcross);
            if (options.flip && placedRect.overflowsRight(options.parent)) {
                placedRect.flipY(options.anchor.center().x);
            }
            if (options.constrainToParent) {
                placedRect.translateInside(options.parent);
            }
            return placedRect;
        };
        return RightPlacementStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BottomLeftPlacementStrategy = (function () {
        function BottomLeftPlacementStrategy() {
        }
        /**
         * @return {?}
         */
        BottomLeftPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'bottom left';
        };
        /**
         * @param {?} options
         * @return {?}
         */
        BottomLeftPlacementStrategy.prototype.calculate = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            var /** @type {?} */ placedRect = options.element
                .clone()
                .moveTo(options.anchor.leftBottom(), options.element.leftTop())
                .translateY(options.offsetAlong)
                .translateX(options.offsetAcross);
            if (options.flip && placedRect.overflowsBottom(options.parent)) {
                placedRect.flipX(options.anchor.center().y);
            }
            if (options.constrainToParent) {
                placedRect.translateInside(options.parent);
            }
            return placedRect;
        };
        return BottomLeftPlacementStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @return {?}
     */
    function placementServiceFactory() {
        return new PlacementService([
            new LeftPlacementStrategy(),
            new TopPlacementStrategy(),
            new BottomPlacementStrategy(),
            new RightPlacementStrategy(),
            new BottomLeftPlacementStrategy()
        ]);
    }
    var GeometryModule = (function () {
        function GeometryModule() {
        }
        GeometryModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [],
                        declarations: [],
                        providers: [
                            { provide: PlacementService, useFactory: placementServiceFactory },
                        ]
                    },] },
        ];
        return GeometryModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ constants = {
        offset: 15,
        directionClass: {
            none: 'no-direction',
            left: 'left',
            top: 'top',
            right: 'right',
            bottom: 'bottom',
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Offset = (function () {
        function Offset(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        Offset.create = /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x, y) {
            return new Offset(x, y);
        };
        /**
         * @param {?} other
         * @return {?}
         */
        Offset.prototype.equals = /**
         * @param {?} other
         * @return {?}
         */
        function (other) {
            return this.x === other.x &&
                this.y === other.y;
        };
        /**
         * @return {?}
         */
        Offset.prototype.toString = /**
         * @return {?}
         */
        function () {
            return "(" + this.x + ", " + this.y + ")";
        };
        return Offset;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverVM = (function () {
        function PopoverVM(placementClassModifier, popoverPosition, arrowOffset) {
            if (placementClassModifier === void 0) { placementClassModifier = 'no-direction'; }
            if (popoverPosition === void 0) { popoverPosition = Point.create(0, 0); }
            if (arrowOffset === void 0) { arrowOffset = Offset.create(0, 0); }
            this.placementClassModifier = placementClassModifier;
            this.popoverPosition = popoverPosition;
            this.arrowOffset = arrowOffset;
        }
        /**
         * @param {?=} popoverDetails
         * @return {?}
         */
        PopoverVM.create = /**
         * @param {?=} popoverDetails
         * @return {?}
         */
        function (popoverDetails) {
            if (!popoverDetails) {
                return new PopoverVM();
            }
            return new PopoverVM(popoverDetails.placementClassModifier, popoverDetails.popoverPosition, popoverDetails.arrowOffset);
        };
        return PopoverVM;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RightPlacementStrategy$1 = (function () {
        function RightPlacementStrategy(placementService) {
            this.placementService = placementService;
        }
        /**
         * @return {?}
         */
        RightPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'right';
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        RightPlacementStrategy.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ positionedPopoverRect = this.placementService.place({
                anchor: placementOptions.anchorRect,
                element: placementOptions.popoverRect,
                placementId: this.getId(),
                offsetAlong: constants.offset
            });
            var /** @type {?} */ arrowOffset = getArrowOffset(placementOptions.anchorRect, positionedPopoverRect);
            var /** @type {?} */ placementClassModifier = getPlacementClassModifier(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
            var /** @type {?} */ popoverPosition = positionedPopoverRect.position();
            return PopoverVM.create({
                popoverPosition: popoverPosition, arrowOffset: arrowOffset, placementClassModifier: placementClassModifier
            });
        };
        return RightPlacementStrategy;
    }());
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function getArrowOffset(anchorRect, popoverRect) {
        var /** @type {?} */ offsetX = 0;
        var /** @type {?} */ offsetY = anchorRect.center().y - popoverRect.center().y;
        return Offset.create(offsetX, offsetY);
    }
    /**
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getMaxArrowOffset(popoverRect, arrowRect) {
        return (popoverRect.height - arrowRect.height) / 2;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function isArrowTooFar(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ arrowOffset = getArrowOffset(anchorRect, popoverRect);
        var /** @type {?} */ maxOffset = getMaxArrowOffset(popoverRect, arrowRect);
        var /** @type {?} */ isTooFar = Math.abs(arrowOffset.y) >= maxOffset;
        return isTooFar;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getPlacementClassModifier(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ isFlip = isFlipped(anchorRect, popoverRect);
        var /** @type {?} */ isTooFar = isArrowTooFar(anchorRect, popoverRect, arrowRect);
        if (isTooFar) {
            return constants.directionClass.none;
        }
        return isFlip ? constants.directionClass.left : constants.directionClass.right;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function isFlipped(anchorRect, popoverRect) {
        return popoverRect.isOnTheLeft(anchorRect.center());
    }

    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LeftPlacementStrategy$1 = (function (_super) {
        __extends$6(LeftPlacementStrategy, _super);
        function LeftPlacementStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        LeftPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'left';
        };
        return LeftPlacementStrategy;
    }(RightPlacementStrategy$1));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BottomPlacementStrategy$1 = (function () {
        function BottomPlacementStrategy(placementService) {
            this.placementService = placementService;
        }
        /**
         * @return {?}
         */
        BottomPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'bottom';
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        BottomPlacementStrategy.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ positionedPopoverRect = this.placementService.place({
                anchor: placementOptions.anchorRect,
                element: placementOptions.popoverRect,
                placementId: this.getId(),
                offsetAlong: constants.offset
            });
            var /** @type {?} */ arrowOffset = getArrowOffset$1(placementOptions.anchorRect, positionedPopoverRect);
            var /** @type {?} */ placementClassModifier = getPlacementClassModifier$1(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
            var /** @type {?} */ popoverPosition = positionedPopoverRect.position();
            return PopoverVM.create({
                popoverPosition: popoverPosition, arrowOffset: arrowOffset, placementClassModifier: placementClassModifier
            });
        };
        return BottomPlacementStrategy;
    }());
    /**
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getMaxArrowOffset$1(popoverRect, arrowRect) {
        return (popoverRect.width - arrowRect.width) / 2;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function getArrowOffset$1(anchorRect, popoverRect) {
        var /** @type {?} */ offsetX = anchorRect.center().x - popoverRect.center().x;
        var /** @type {?} */ offsetY = 0;
        return Offset.create(offsetX, offsetY);
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function isArrowTooFar$1(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ arrowOffset = getArrowOffset$1(anchorRect, popoverRect);
        var /** @type {?} */ maxOffset = getMaxArrowOffset$1(popoverRect, arrowRect);
        var /** @type {?} */ isTooFar = Math.abs(arrowOffset.x) >= maxOffset;
        return isTooFar;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function isFlipped$1(anchorRect, popoverRect) {
        return popoverRect.isAbove(anchorRect.center());
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getPlacementClassModifier$1(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ isFlip = isFlipped$1(anchorRect, popoverRect);
        var /** @type {?} */ isTooFar = isArrowTooFar$1(anchorRect, popoverRect, arrowRect);
        if (isTooFar) {
            return constants.directionClass.none;
        }
        return isFlip ? constants.directionClass.top : constants.directionClass.bottom;
    }

    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TopPlacementStrategy$1 = (function (_super) {
        __extends$7(TopPlacementStrategy, _super);
        function TopPlacementStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        TopPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'top';
        };
        return TopPlacementStrategy;
    }(BottomPlacementStrategy$1));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverService = (function () {
        function PopoverService() {
            this.placementStrategies = [];
        }
        /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        PopoverService.pickPlacementStrategy = /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        function (placementStrategies, placementId) {
            /**
             * @param {?} strategy
             * @return {?}
             */
            function matchStrategy(strategy) {
                return strategy.getId() === placementId;
            }
            return (placementStrategies || []).find(matchStrategy);
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        PopoverService.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ placementStrategy = PopoverService.pickPlacementStrategy(this.placementStrategies, placementOptions.placement);
            if (!placementStrategy) {
                throw new Error('Placement not supported: ' + placementOptions.placement);
            }
            return placementStrategy.calculate(placementOptions);
        };
        PopoverService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PopoverService.ctorParameters = function () { return []; };
        return PopoverService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxPopoverComponent = (function () {
        function UxPopoverComponent(popoverService, renderer, cd, uxService) {
            this.popoverService = popoverService;
            this.renderer = renderer;
            this.cd = cd;
            this.uxService = uxService;
            this.title = '';
            this.showCloseIcon = true;
            this.type = 'default';
            this.placement = 'bottom';
            this.size = 'default';
            this.hasNoContentPadding = false;
            this.isDismissable = true;
            this.isVisible = false;
            this.vm = PopoverVM.create();
        }
        /**
         * @return {?}
         */
        UxPopoverComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.handleWindowResize();
            this.handleDocumentEvents();
        };
        /**
         * @return {?}
         */
        UxPopoverComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.renderer.appendChild(document.body, this.popoverEl.nativeElement);
        };
        /**
         * @return {?}
         */
        UxPopoverComponent.prototype.handleWindowResize = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.windowResizedSubscription = this.uxService.activeBreakpoint
                .debounceTime(300)
                .subscribe(function (bkp) {
                if (_this.lastTriggerElement) {
                    _this.reposition(_this.lastTriggerElement);
                }
            });
        };
        /**
         * @return {?}
         */
        UxPopoverComponent.prototype.handleDocumentEvents = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isDismissable) {
                this.documentClickListener = this.renderer.listen('document', 'click', function (evt) {
                    if (!_this.popoverEl.nativeElement.contains(evt.target)) {
                        _this.hide(evt);
                    }
                    _this.cd.markForCheck();
                });
            }
            this.documentKeyupListener = this.renderer.listen('document', 'keyup', function (evt) {
                if (evt.keyCode === 27) {
                    // 27 = escape
                    _this.hide(evt);
                }
            });
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        UxPopoverComponent.prototype.onCloseClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this.hide(evt);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPopoverComponent.prototype.toggle = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var /** @type {?} */ triggerElement = event.target;
            if (this.lastTriggerElement === triggerElement) {
                this.isVisible ? this.hide(event) : this.show(event);
            }
            else {
                this.show(event);
            }
            this.lastTriggerElement = triggerElement;
        };
        /**
         * @param {?} element
         * @return {?}
         */
        UxPopoverComponent.prototype.reposition = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            var /** @type {?} */ anchorRect = RectangleFactory.fromHtmlElement(element);
            var /** @type {?} */ popoverRect = RectangleFactory.fromHtmlElement(this.popoverEl.nativeElement);
            var /** @type {?} */ arrowRect = RectangleFactory.fromHtmlElement(this.arrowEl.nativeElement);
            var /** @type {?} */ placement = this.placement;
            this.vm = this.popoverService.calculate({
                placement: placement,
                anchorRect: anchorRect,
                popoverRect: popoverRect,
                arrowRect: arrowRect
            });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPopoverComponent.prototype.show = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            // makes sure that this is called after document click event
            setTimeout(function () {
                _this.reposition(event.target);
                _this.isVisible = true;
                _this.cd.markForCheck();
            });
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxPopoverComponent.prototype.hide = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isVisible = false;
        };
        /**
         * @return {?}
         */
        UxPopoverComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.documentClickListener) {
                this.documentClickListener();
            }
            if (this.documentKeyupListener) {
                this.documentKeyupListener();
            }
            if (this.windowResizedSubscription) {
                this.windowResizedSubscription.unsubscribe();
            }
            if (this.popoverEl) {
                this.renderer.removeChild(document.body, this.popoverEl.nativeElement);
            }
        };
        UxPopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div #popoverContainer class=\"ux-popover ux-popover--{{ vm.placementClassModifier }} ux-popover--{{ type }} ux-popover--size-{{ size }}\" [class.ux-popover--visible]=\"isVisible\" [style.left]=\"vm.popoverPosition.x + 'px'\" [style.top]=\"vm.popoverPosition.y + 'px'\"> <div #popoverArrow class=\"ux-popover__arrow\" [style.marginLeft]=\"vm.arrowOffset.x + 'px'\" [style.marginTop]=\"vm.arrowOffset.y + 'px'\" > <div class=\"ux-popover__arrow-inner\"></div> </div> <div *ngIf=\"title\" class=\"ux-popover__header  {{ headerStyleClass }}\"> <div class=\"ux-popover__title\">{{ title }}</div> <div *ngIf=\"showCloseIcon\" (click)=\"onCloseClick($event)\" class=\"ux-popover__close\"> <i class=\"ux-icon ux-icon-close\"></i> </div> </div> <div class=\"ux-popover__content\" [class.p-0]=\"hasNoContentPadding\"> <ng-content></ng-content> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxPopoverComponent.ctorParameters = function () { return [
            { type: PopoverService, },
            { type: core.Renderer2, },
            { type: core.ChangeDetectorRef, },
            { type: UxService, },
        ]; };
        UxPopoverComponent.propDecorators = {
            "popoverEl": [{ type: core.ViewChild, args: ['popoverContainer',] },],
            "arrowEl": [{ type: core.ViewChild, args: ['popoverArrow',] },],
            "title": [{ type: core.Input },],
            "showCloseIcon": [{ type: core.Input },],
            "type": [{ type: core.Input },],
            "placement": [{ type: core.Input },],
            "size": [{ type: core.Input },],
            "hasNoContentPadding": [{ type: core.Input },],
            "isDismissable": [{ type: core.Input },],
            "headerStyleClass": [{ type: core.Input },],
        };
        return UxPopoverComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} placementService
     * @return {?}
     */
    function placementServiceFactory$1(placementService) {
        var /** @type {?} */ popoverService = new PopoverService();
        popoverService.placementStrategies = [
            new LeftPlacementStrategy$1(placementService),
            new TopPlacementStrategy$1(placementService),
            new RightPlacementStrategy$1(placementService),
            new BottomPlacementStrategy$1(placementService),
        ];
        return popoverService;
    }
    var UxPopoverComponentModule = (function () {
        function UxPopoverComponentModule() {
        }
        UxPopoverComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, GeometryModule],
                        exports: [UxPopoverComponent],
                        declarations: [UxPopoverComponent],
                        providers: [
                            {
                                provide: PopoverService,
                                useFactory: placementServiceFactory$1,
                                deps: [PlacementService]
                            },
                            UxAssetsService,
                        ]
                    },] },
        ];
        return UxPopoverComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDiscussionThreadItemComponent = (function () {
        function UxDiscussionThreadItemComponent() {
            this.isOdd = false;
        }
        Object.defineProperty(UxDiscussionThreadItemComponent.prototype, "iconClass", {
            get: /**
             * @return {?}
             */
            function () {
                var /** @type {?} */ iconClass = 'ion ion-quote';
                switch (this.typeClass) {
                    case 'success':
                        iconClass = 'ux-icon ux-icon-check';
                        break;
                    case 'danger':
                        iconClass = 'ux-icon ux-icon-times';
                        break;
                }
                return iconClass;
            },
            enumerable: true,
            configurable: true
        });
        UxDiscussionThreadItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-discussion-thread-item',
                        template: "<li class=\"ux-discussion-thread__item\" [class.ux-discussion-thread-inverted]=\"isOdd\"> <div class=\"ux-discussion-thread-badge {{typeClass}}\"> <span class=\"{{iconClass}}\"></span> </div> <div class=\"ux-discussion-thread-panel\"> <div class=\"ux-discussion-thread-header\"> <div class=\"ux-discussion-thread-heading\"> <div class=\"ux-discussion-thread-title\"> {{ date | amLocal | amDateFormat: 'DD/MM/YYYY' }} </div> <div class=\"ux-discussion-thread-time\"> <span class=\"ion ion-android-time\"></span> {{ date | amLocal | amDateFormat: 'HH:mm' }} </div> </div> <div class=\"ux-discussion-thread-subheading\"> {{ author }} </div> </div> <div class=\"ux-discussion-thread-body\"> <p>{{ body }}</p> </div> </div> </li> "
                    },] },
        ];
        /** @nocollapse */
        UxDiscussionThreadItemComponent.propDecorators = {
            "isOdd": [{ type: core.Input },],
            "id": [{ type: core.Input },],
            "typeClass": [{ type: core.Input },],
            "date": [{ type: core.Input },],
            "author": [{ type: core.Input },],
            "body": [{ type: core.Input },],
        };
        return UxDiscussionThreadItemComponent;
    }());
    var UxDiscussionThreadItemComponentModule = (function () {
        function UxDiscussionThreadItemComponentModule() {
        }
        UxDiscussionThreadItemComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            angular2Moment.MomentModule,
                            UxIconComponentModule,
                            UxDropdownButtonComponentModule
                        ],
                        exports: [UxDiscussionThreadItemComponent],
                        declarations: [UxDiscussionThreadItemComponent]
                    },] },
        ];
        return UxDiscussionThreadItemComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDiscussionThreadComponent = (function () {
        function UxDiscussionThreadComponent() {
        }
        UxDiscussionThreadComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-discussion-thread',
                        template: "<div class=\"ux-discussion-thread-wrapper\"> <div class=\"section-title page-sub-title ux-u-font-size-h4 mt-0 mb-2 pb-2\">{{titleLabel}}</div> <div class=\"section-sub-title ux-u-font-size-h5 ux-u-font-light mb-2\">{{subTitleLabel}}</div> <ul class=\"ux-discussion-thread\"> <ng-template [ngIf]=\"items\"> <ux-discussion-thread-item *ngFor=\"let item of items; let o = odd; let e = even;\" [isOdd]=\"o\" id=\"{{item.id}}\" typeClass=\"{{item.typeClass}}\" date=\"{{item.date}}\" author=\"{{item.author}}\" body=\"{{item.body}}\"> </ux-discussion-thread-item> </ng-template> <ng-template [ngIf]=\"!items\"> <ng-content></ng-content> </ng-template> </ul> </div> "
                    },] },
        ];
        /** @nocollapse */
        UxDiscussionThreadComponent.ctorParameters = function () { return []; };
        UxDiscussionThreadComponent.propDecorators = {
            "items": [{ type: core.Input },],
            "titleLabel": [{ type: core.Input },],
            "subTitleLabel": [{ type: core.Input },],
        };
        return UxDiscussionThreadComponent;
    }());
    var UxDiscussionThreadComponentModule = (function () {
        function UxDiscussionThreadComponentModule() {
        }
        UxDiscussionThreadComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxDiscussionThreadItemComponentModule,
                        ],
                        exports: [UxDiscussionThreadComponent],
                        declarations: [UxDiscussionThreadComponent]
                    },] },
        ];
        return UxDiscussionThreadComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDiscussionThreadItem = (function () {
        function UxDiscussionThreadItem(values) {
            if (values === void 0) { values = {}; }
            Object.assign(this, values);
        }
        return UxDiscussionThreadItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFormGroupComponent = (function () {
        function UxFormGroupComponent(uxFieldsetComponent) {
            this.isVertical = false;
            this.isReadOnly = false;
            this.isValid = true;
            this.isLoadingIndicatorActive = false;
            this.isCompact = false;
            this.isRenderHTML = false;
            this.iconClass = 'ux-icon ux-icon-info-circle';
            this.iconTypeClass = 'grey-darkest';
            this.isInline = false;
            this.uxFieldsetComponent = uxFieldsetComponent;
        }
        /**
         * @return {?}
         */
        UxFormGroupComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.uxFieldsetComponent) {
                this.isCompact = this.uxFieldsetComponent.isCompactFields;
            }
            if (this.uxFieldsetComponent) {
                this.isVertical = this.uxFieldsetComponent.isVerticalFields;
            }
            if (!this.label && !this.labelWidthClass && !this.isInline) {
                this.labelWidthClass = 'col-md-4';
            }
            if (this.isVertical || (!this.label && !this.labelWidthClass)) {
                this.labelWidthClass = '';
                this.inputWidthClass = '';
            }
            else {
                if (this.uxFieldsetComponent) {
                    if (this.uxFieldsetComponent.labelWidthClass && !this.labelWidthClass) {
                        this.labelWidthClass = this.uxFieldsetComponent.labelWidthClass;
                    }
                    if (this.uxFieldsetComponent.inputWidthClass && !this.inputWidthClass) {
                        this.inputWidthClass = this.uxFieldsetComponent.inputWidthClass;
                    }
                }
                if (!this.labelWidthClass && !this.isInline) {
                    this.labelWidthClass = 'col-md-4';
                }
                if (!this.inputWidthClass && !this.isInline) {
                    this.inputWidthClass = 'col-md-8';
                }
            }
            this.stateClass = '';
            if (!this.isVertical) {
                if (!this.isInline) {
                    this.stateClass += 'row ';
                }
                else {
                    this.stateClass += 'ux-form-group--inline ';
                }
            }
            else {
                this.stateClass += 'ux-form-group--vertical ';
            }
            if (!this.label) {
                this.stateClass += 'ux-form-group--no-label ';
            }
            if (this.isCompact) {
                this.stateClass += 'ux-form-group--compact';
            }
        };
        Object.defineProperty(UxFormGroupComponent.prototype, "dynamicStateClass", {
            get: /**
             * @return {?}
             */
            function () {
                var /** @type {?} */ dynamicStateClass = '';
                if (this.feedbackTypeClass) {
                    dynamicStateClass += 'has-' + this.feedbackTypeClass + ' ';
                }
                else {
                    if (!this.isValid && !this.validationErrorFeedbackClass) {
                        dynamicStateClass += 'has-danger ';
                    }
                    else if (!this.isValid && this.validationErrorFeedbackClass) {
                        dynamicStateClass += 'has-' + this.validationErrorFeedbackClass + ' ';
                    }
                }
                return dynamicStateClass;
            },
            enumerable: true,
            configurable: true
        });
        UxFormGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-form-group',
                        template: "<div class=\"ux-form-group form-group {{stateClass}} {{dynamicStateClass}} {{styleClass}}\" [class.has-danger]=\"!isValid && !validationErrorFeedbackClass\"> <label for=\"{{id}}\" class=\"ux-form-group__label-wrapper {{labelWidthClass}}\" *ngIf=\"label\" [class.col-form-label]=\"!isVertical\" [class.form-control-label]=\"isVertical\"> <span *ngIf=\"isRenderHTML\" class=\"ux-form-group__label\" [innerHTML]=\"label\"></span> <span *ngIf=\"!isRenderHTML\" class=\"ux-form-group__label\"> <ng-container *ngIf=\"label\">{{label}}</ng-container> <ng-container *ngIf=\"!label\">&nbsp;</ng-container> </span> <span *ngIf=\"isRequired\" class=\"ux-form-group__required-indicator ux-u-color-{{isRequiredTooltipTypeClass?isRequiredTooltipTypeClass:'danger'}}\">*</span> <span *ngIf=\"infoLabel\" class=\"ux-form-group__info-label {{ iconClass }} ux-u-color-{{iconTypeClass}}\" [class.ux-u-cursor-help]=\"infoLabel !== ''\" title=\"{{infoLabel}}\"> </span> </label> <label for=\"{{id}}\" class=\"ux-form-group__label-wrapper {{labelWidthClass}}\" *ngIf=\"!label\" [class.col-form-label]=\"!isVertical\" [class.form-control-label]=\"isVertical\"> </label> <div class=\"{{inputWidthClass}}\"> <div class=\"ux-form-group__input-content\"> <div [class.ux-form-group__read-only]=\"isReadOnly\"> <ng-content></ng-content> </div> <span *ngIf=\"isLoadingIndicatorActive\" class=\"ux-form-group__loading-indicator ux-icon ux-icon-refresh ux-icon-spin ux-u-color-primary\"> </span> </div> </div> <span *ngIf=\"isRequired && !label\" class=\"ux-form-group__required-indicator ux-u-color-{{isRequiredTooltipTypeClass?isRequiredTooltipTypeClass:'danger'}}\">*</span> </div> <div class=\"ux-form-group__messages-wrapper {{stateClass}}\"> <div class=\"{{labelWidthClass}}\"></div> <div class=\"{{inputWidthClass}}\"> <ng-container *ngIf=\"!isValid\"> <ux-control-feedback *ngIf=\"validationErrorMessage\" typeClass=\"{{validationErrorFeedbackClass?validationErrorFeedbackClass:'danger'}}\"> {{validationErrorMessage}} </ux-control-feedback> </ng-container> </div> </div> <ng-template [ngIf]=\"customSubContent\"> <div class=\"ux-form-group__messages-wrapper {{stateClass}}\"> <div class=\"{{labelWidthClass}}\"></div> <div class=\"{{inputWidthClass}}\"> <ng-content select=\"uxFormGroupSubContent\"></ng-content> </div> </div> </ng-template> "
                    },] },
        ];
        /** @nocollapse */
        UxFormGroupComponent.ctorParameters = function () { return [
            { type: UxFieldsetComponent, decorators: [{ type: core.Optional }, { type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxFieldsetComponent; }),] },] },
        ]; };
        UxFormGroupComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "label": [{ type: core.Input },],
            "isVertical": [{ type: core.Input },],
            "isRequired": [{ type: core.Input },],
            "isRequiredTooltipTypeClass": [{ type: core.Input },],
            "feedbackTypeClass": [{ type: core.Input },],
            "labelWidthClass": [{ type: core.Input },],
            "inputWidthClass": [{ type: core.Input },],
            "isReadOnly": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "validationErrorMessage": [{ type: core.Input },],
            "validationErrorFeedbackClass": [{ type: core.Input },],
            "infoLabel": [{ type: core.Input },],
            "isValid": [{ type: core.Input },],
            "isLoadingIndicatorActive": [{ type: core.Input },],
            "isCompact": [{ type: core.Input },],
            "isRenderHTML": [{ type: core.Input },],
            "iconClass": [{ type: core.Input },],
            "iconTypeClass": [{ type: core.Input },],
            "isInline": [{ type: core.Input },],
            "customSubContent": [{ type: core.ContentChild, args: [core.forwardRef(function () { return UxFormGroupSubContentTagDirective; }),] },],
        };
        return UxFormGroupComponent;
    }());
    var UxFormGroupSubContentTagDirective = (function () {
        function UxFormGroupSubContentTagDirective() {
        }
        UxFormGroupSubContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFormGroupSubContent' },] },
        ];
        return UxFormGroupSubContentTagDirective;
    }());
    var UxFormGroupComponentModule = (function () {
        function UxFormGroupComponentModule() {
        }
        UxFormGroupComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxControlFeedbackComponentModule,
                        ],
                        exports: [UxFormGroupComponent, UxFormGroupSubContentTagDirective],
                        declarations: [UxFormGroupComponent, UxFormGroupSubContentTagDirective]
                    },] },
        ];
        return UxFormGroupComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ calendarLocales = {
        'fr': {
            firstDayOfWeek: 0,
            dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
            dayNamesShort: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'],
            dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
            monthNames: [
                'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
                'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
            ],
            monthNamesShort: [
                'Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Jun',
                'Jul', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'
            ],
            today: 'Aujourd\'hui',
            clear: 'Effacer'
        },
        'en': {
            firstDayOfWeek: 0,
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            monthNames: [
                'January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'
            ],
            monthNamesShort: [
                'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
            ],
            today: 'Today',
            clear: 'Clear'
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFormControlComponent = (function () {
        function UxFormControlComponent(uxFormGroupComponent, uxService, translateService, cd, elementRef) {
            var _this = this;
            this.uxService = uxService;
            this.translateService = translateService;
            this.cd = cd;
            this.elementRef = elementRef;
            this.isReadOnly = false;
            this.isRequired = false;
            this.isInputText = false;
            this.isTextarea = false;
            this.rows = 2;
            this.isTextareaAutoresize = false;
            this.isDatepicker = false;
            this.isDatetimepicker = false;
            this.datepickerDateformat = 'dd/mm/yy';
            this.datepickerYearRange = '1900:2050';
            this.isSelect = false;
            this.selectKeyName = 'id';
            this.selectValueName = 'value';
            this.isCheckbox = false;
            this.isRadio = false;
            this.isNumber = false;
            this.decimalSeparator = null;
            this.isNumberFormatPlaceholder = true;
            this.isDisabled = false;
            this.tabindex = '0';
            this.groupId = '';
            this.modelChange = new core.EventEmitter();
            this.touched = new core.EventEmitter();
            this.isMaxLengthValid = true;
            this.isSelectHasOptions = false;
            this.ariaInvalid = false;
            this.hasFormGroupParent = false;
            // Stores the isValid value for the parent form in case the user edits the field for the first time,
            // i.e.: not "touched" yet, but still invalid.
            // In such cases, the parent formGroup should become invalid when the user blurs the field.
            this.intendedFormGroupIsValid = true;
            this.propagateChange = function (_) {
            };
            this.propagateTouched = function () {
            };
            this.uxFormGroupComponent = uxFormGroupComponent;
            if (this.uxFormGroupComponent) {
                this.hasFormGroupParent = true;
            }
            else {
                this.hasFormGroupParent = false;
            }
            this.languageChangeSubscription = translateService.onLangChange.subscribe(function (evt) {
                if (_this.calendarControl && !_this.datepickerLocale) {
                    var /** @type {?} */ locale = calendarLocales[evt.lang] || calendarLocales['en'];
                    _this.calendarControl.locale = locale;
                }
            });
        }
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.calendarControl && this.datepickerLocale) {
                this.calendarControl.locale = this.datepickerLocale;
            }
        };
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (!this.id) {
                this.generatedId = 'ux-form-control-' + (Math.floor(Math.random() * 1000000) + 1).toString();
            }
            else {
                this.generatedId = this.id;
            }
            if (this.uxFormGroupComponent && !this.uxFormGroupComponent.id) {
                this.uxFormGroupComponent.id = this.generatedId;
                if (!this.uxFormGroupComponent.isRequired) {
                    this.uxFormGroupComponent.isRequired = this.isRequired;
                }
                else if (!this.isRequired) {
                    this.isRequired = true;
                }
            }
            if (!this.isInputText && !this.isTextarea &&
                !this.isDatepicker && !this.isDatetimepicker && !this.isSelect && !this.isCheckbox && !this.isRadio &&
                !this.isNumber) {
                this.isInputText = true;
            }
            if (this.isDatepicker && this.datepickerDateformat === 'dd/mm/yy') {
                this.placeholderLabel = 'dd/mm/yyyy';
            }
            if (this.isDatetimepicker && this.datepickerDateformat === 'dd/mm/yy') {
                this.placeholderLabel = 'dd/mm/yyyy hh:mm';
            }
            if (this.isNumber && this.maxlength) {
                this.thousandSeparator = '';
            }
            if (this.isNumber && this.isNumberFormatPlaceholder && !this.maxlength) {
                if (this.decimalSeparator) {
                    if (this.decimalSeparator === ',') {
                        this.thousandSeparator = ' ';
                    }
                    else {
                        this.thousandSeparator = this.thousandSeparator === this.decimalSeparator ? ',' : this.thousandSeparator;
                    }
                }
                else {
                    this.decimalSeparator = ',';
                }
                if (this.thousandSeparator) {
                    if (this.thousandSeparator === ',') {
                        this.decimalSeparator = '.';
                    }
                    else {
                        this.decimalSeparator = !this.decimalSeparator || (this.decimalSeparator !== '.' && this.decimalSeparator !== ',') ?
                            ',' :
                            this.decimalSeparator;
                    }
                }
                else {
                    this.thousandSeparator = '';
                }
                // console.log('thousandsSeparator in comp: ' + this.thousandSeparator);
                // console.log('decimalSeparator in comp: ' + this.decimalSeparator);
                this.placeholderLabel = '###' + this.thousandSeparator + '###' + this.decimalSeparator + '##';
            }
            if (this._formControl) {
                this._formControl.statusChanges.subscribe(function (v) {
                    if (_this.uxFormGroupComponent) {
                        _this.intendedFormGroupIsValid = true;
                        _this.uxFormGroupComponent.isValid = (v !== 'INVALID');
                        if (!_this._formControl.touched) {
                            _this.intendedFormGroupIsValid = _this.uxFormGroupComponent.isValid;
                            _this.uxFormGroupComponent.isValid = true;
                        }
                        if (!_this.uxFormGroupComponent.validationErrorMessage && _this.validationErrorMessage) {
                            _this.uxFormGroupComponent.validationErrorMessage = _this.validationErrorMessage;
                        }
                        else if (_this._formControl.errors && _this._formControl.errors["uxValidationError"]) {
                            _this.setUxValidationErrorsToParentFormGroup();
                        }
                    }
                    else if (_this._formControl.errors && _this._formControl.errors["uxValidationError"]) {
                        _this.setUxValidationErrorsToFormControl();
                    }
                });
            }
            if (this.isSelect && this.selectOptions) {
                this.selectOptions.forEach(function (item) {
                    if (item.options) {
                        _this.isSelectHasOptions = true;
                        return;
                    }
                });
            }
            this.lastAutoCorrectedValue = this.inputValue;
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxFormControlComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            // Bug fix for when a user types an invalid value, and then switching off read-only mode.
            // In such cases, the last characters would remain in the (read-only) value.
            // To prevent this, we will force the value to the last known correct value.
            if (changes && changes['isReadOnly'] && (this.isNumber || this.maxlength)) {
                if (this.isReadOnly) {
                    this.inputValue = this.lastAutoCorrectedValue;
                }
            }
            this.updateAriaInvalid();
        };
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.languageChangeSubscription) {
                this.languageChangeSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.setUxValidationErrorsToFormControl = /**
         * @return {?}
         */
        function () {
            if (this._formControl.errors["uxValidationError"].message) {
                this.validationErrorMessage = this._formControl.errors["uxValidationError"].message;
            }
            if (this._formControl.errors["uxValidationError"].type) {
                this.validationErrorType = this._formControl.errors["uxValidationError"].type;
            }
        };
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.setUxValidationErrorsToParentFormGroup = /**
         * @return {?}
         */
        function () {
            if (this._formControl.errors["uxValidationError"].message) {
                this.uxFormGroupComponent.validationErrorMessage = this._formControl.errors["uxValidationError"].message;
            }
            if (this._formControl.errors["uxValidationError"].type) {
                this.uxFormGroupComponent.validationErrorFeedbackClass = this._formControl.errors["uxValidationError"].type;
            }
        };
        Object.defineProperty(UxFormControlComponent.prototype, "isFieldValid", {
            get: /**
             * @return {?}
             */
            function () {
                if (this._formControl) {
                    if (this._formControl.touched && this._formControl.invalid) {
                        return false;
                    }
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @return {?}
         */
        UxFormControlComponent.prototype.OnMaxLengthValidityChange = /**
         * @param {?} state
         * @return {?}
         */
        function (state) {
            this.isMaxLengthValid = state;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxFormControlComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.isNumber) {
                this.inputValue = this.uxService.formatNumber(value, 2, this.decimalSeparator, this.thousandSeparator);
            }
            else {
                if (this.isRadio) {
                    if (this.isReadOnly) {
                        this.inputValue = value;
                    }
                    else {
                        this.checked = (value === this.formControlValue);
                        if (this.radioElement) {
                            this.radioElement.nativeElement.checked = this.checked;
                        }
                    }
                }
                else {
                    this.inputValue = value;
                }
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxFormControlComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.propagateChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxFormControlComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            if (this._formControl &&
                !this._formControl.touched &&
                this.uxFormGroupComponent &&
                (typeof this.intendedFormGroupIsValid !== 'undefined')) {
                this.uxFormGroupComponent.isValid = this.intendedFormGroupIsValid;
            }
            this.propagateTouched = fn;
        };
        /**
         * @param {?} c
         * @return {?}
         */
        UxFormControlComponent.prototype.validate = /**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            var _this = this;
            this._formControl = c;
            setTimeout(function () {
                _this.updateAriaInvalid();
            }, 0);
            return (c.invalid) ? {
                fieldError: {
                    errorMessage: this.validationErrorMessage || 'error'
                }
            } : null;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFormControlComponent.prototype.onChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.target) {
                // Ignore, if TAB, Shift + Tab key combinations are used
                if (event.keyCode === 9 || event.keyCode === 16) {
                    return;
                }
                var /** @type {?} */ newValue = event.target.value;
                if (this.isCheckbox) {
                    newValue = event.target.checked;
                }
                if (this.isDatepicker) {
                    var /** @type {?} */ momentDate = moment$1(event.target.value, 'DD/MM/YYYY');
                    if (momentDate.isValid()) {
                        newValue = momentDate;
                    }
                }
                if (this.isDatetimepicker) {
                    var /** @type {?} */ momentDate = moment$1(event.target.value, 'DD/MM/YYYY HH:mm');
                    if (momentDate.isValid()) {
                        newValue = momentDate;
                    }
                }
                if (this.isNumber) {
                    if (event.target.value.length > 0) {
                        if (this.decimalSeparator === ',') {
                            newValue = Number(event.target.value.split(this.thousandSeparator).join('').replace(new RegExp(',', 'g'), '.'));
                        }
                        else {
                            newValue = Number(event.target.value.split(this.thousandSeparator).join(''));
                        }
                    }
                    else {
                        newValue = null;
                    }
                }
                if (this.isSelect) {
                    if (event.target.value === 'null' || event.target.value === '') {
                        newValue = null;
                    }
                    else {
                        var /** @type {?} */ value = event.target.value;
                        if (isNaN(Number(value))) {
                            newValue = value;
                        }
                        else {
                            newValue = Number(value);
                        }
                    }
                }
                if (this.isNumber || this.maxlength) {
                    this.lastAutoCorrectedValue = newValue;
                }
                this.data = newValue;
                this.propagateChange(this.data);
                this.modelChange.emit(this.data);
            }
            else {
                this.propagateChange(event);
                this.modelChange.emit(event);
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFormControlComponent.prototype.onTouched = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.touched.emit(event);
            this.propagateTouched();
            this.updateFormGroupValidationStatus();
        };
        Object.defineProperty(UxFormControlComponent.prototype, "selectValue", {
            get: /**
             * @return {?}
             */
            function () {
                var _this = this;
                var /** @type {?} */ valueItem = null;
                if (this.selectOptions) {
                    valueItem = this.selectOptions.find(function (item) { return item[_this.selectKeyName] === _this.inputValue; });
                }
                if (valueItem) {
                    return valueItem[this.selectValueName];
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.updateAriaInvalid = /**
         * @return {?}
         */
        function () {
            this.ariaInvalid = (!this.isMaxLengthValid || (this._formControl && this._formControl.touched && this._formControl.invalid));
        };
        /**
         * @return {?}
         */
        UxFormControlComponent.prototype.updateFormGroupValidationStatus = /**
         * @return {?}
         */
        function () {
            if (this._formControl &&
                this.uxFormGroupComponent &&
                this._formControl.dirty) {
                this.uxFormGroupComponent.isValid = !this._formControl.invalid;
            }
        };
        UxFormControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-form-control',
                        template: "<ng-container *ngIf=\"isInputText && !isReadOnly\"> <span> <input id=\"{{generatedId}}\" type=\"text\" [(ngModel)]=\"inputValue\" class=\"form-control {{inputStyleClass}}\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [uxMaxlength]=\"maxlength\" (validityChange)=\"OnMaxLengthValidityChange($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> </span> </ng-container> <ng-container *ngIf=\"isTextarea && !isReadOnly\"> <span> <textarea id=\"{{generatedId}}\" class=\"form-control {{inputStyleClass}}\" [(ngModel)]=\"inputValue\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [uxMaxlength]=\"maxlength\" (validityChange)=\"OnMaxLengthValidityChange($event)\" rows=\"{{rows}}\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"> </textarea> </span> </ng-container> <ng-container *ngIf=\"isDatepicker && !isReadOnly && !isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" yearRange=\"{{datepickerYearRange}}\" placeholder=\"{{placeholderLabel}}\" [showIcon]=\"true\" [monthNavigator]=\"true\" [yearNavigator]=\"true\" [disabled]=\"false\" inputStyleClass=\"{{inputStyleClass}}\" (onSelect)=\"onChange($event)\" (onInput)=\"onChange($event)\" (onBlur)=\"onTouched($event)\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatepicker && isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [disabled]=\"true\" inputStyleClass=\"ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatepicker && isReadOnly\"> <span attr.aria-labelledby=\"{{generatedId}}\" class=\"ux-form-group__read-only\" [tabindex]=\"tabindex\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [disabled]=\"true\" inputStyleClass=\"ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </span> </ng-container> <ng-container *ngIf=\"isDatetimepicker && !isReadOnly && !isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" yearRange=\"{{datepickerYearRange}}\" placeholder=\"{{placeholderLabel}}\" [showIcon]=\"true\" [showTime]=\"true\" [monthNavigator]=\"true\" [yearNavigator]=\"true\" [disabled]=\"false\" inputStyleClass=\"datetime {{inputStyleClass}}\" (onSelect)=\"onChange($event)\" (onInput)=\"onChange($event)\" (onBlur)=\"onTouched($event)\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatetimepicker && isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [showTime]=\"true\" [disabled]=\"true\" inputStyleClass=\"datetime ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatetimepicker && isReadOnly\"> <span attr.aria-labelledby=\"{{generatedId}}\" class=\"ux-form-group__read-only\" [tabindex]=\"tabindex\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [showTime]=\"true\" [disabled]=\"true\" inputStyleClass=\"datetime ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </span> </ng-container> <ng-container *ngIf=\"isSelect && !isReadOnly\"> <select id=\"{{generatedId}}\" class=\"form-control custom-select {{inputStyleClass}}\" [(ngModel)]=\"inputValue\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"> <ng-container *ngIf=\"selectOptions\"> <option [value]=\"'' || null\" class=\"ux-u-color-grey\">{{placeholderLabel}}</option> <ng-template [ngIf]=\"isSelectHasOptions\"> <ng-template ngFor let-item [ngForOf]=\"selectOptions\"> <optgroup *ngIf=\"item.options\" label=\"{{item.value}}\" class=\"ux-u-font-regular\"> <option *ngFor=\"let opt of item.options\" [value]=\"opt[selectKeyName]\" [selected]=\"inputValue == opt[selectKeyName]\"> {{opt[selectValueName]}} </option> </optgroup> <option *ngIf=\"!item.options\" [value]=\"item[selectKeyName]\" [selected]=\"inputValue == item[selectKeyName]\"> {{item[selectValueName]}} </option> </ng-template> </ng-template> <ng-template [ngIf]=\"!isSelectHasOptions\"> <option *ngFor=\"let opt of selectOptions\" [value]=\"opt[selectKeyName]\" [selected]=\"inputValue == opt[selectKeyName]\"> {{opt[selectValueName]}} </option> </ng-template> </ng-container> <ng-content *ngIf=\"! selectOptions\"></ng-content> </select> </ng-container> <ng-container *ngIf=\"isReadOnly && isSelect\"> <input type=\"text\" role=\"combobox\" [attr.aria-readonly]=\"true\" readonly=\"readonly\" id=\"{{generatedId}}\" class=\"ux-form-control__read-only {{inputStyleClass}}\" [value]=\"selectValue\" [tabindex]=\"tabindex\" /> </ng-container> <ng-container *ngIf=\"isCheckbox && !isReadOnly\"> <input id=\"{{generatedId}}\" type=\"checkbox\" [(ngModel)]=\"inputValue\" (click)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> <label for=\"{{generatedId}}\" class=\"checkbox-label\">{{checkboxLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isCheckbox && isReadOnly\"> <input id=\"{{generatedId}}\" type=\"checkbox\" [checked]=\"inputValue\" onclick=\"return false;\" [tabindex]=\"tabindex\" readonly=\"readonly\" aria-readonly=\"true\" /> <label for=\"{{generatedId}}\">{{checkboxLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isRadio && !isReadOnly\"> <input #radioElement id=\"{{generatedId}}\" class=\"radio\" type=\"radio\" [checked]=\"checked\" [name]=\"formControlName + groupId\" [value]=\"formControlValue\" (click)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> <label for=\"{{generatedId}}\" class=\"radio-label\">{{radioLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isNumber && !isReadOnly\"> <span> <input id=\"{{generatedId}}\" uxCleave=\"numeral\" [decimalSeparator]=\"decimalSeparator\" [thousandSeparator]=\"thousandSeparator\" type=\"text\" [(ngModel)]=\"inputValue\" class=\"form-control {{inputStyleClass}}\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [disabled]=\"isDisabled\" [uxMaxlength]=\"maxlength\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"/> </span> </ng-container> <ng-container *ngIf=\"isNumber && isReadOnly\"> <div id=\"{{generatedId}}\" class=\"ux-form-group__read-only {{inputStyleClass}}\" [tabindex]=\"tabindex\"> {{inputValue | uxNumberFormat: decimalSeparator}} </div> </ng-container> <ng-container *ngIf=\"isReadOnly && !isDatepicker && !isDatetimepicker && !isCheckbox && !isNumber && !isSelect\"> <div id=\"{{generatedId}}\" class=\"ux-form-group__read-only {{inputStyleClass}}\" [tabindex]=\"tabindex\"> {{inputValue}} </div> </ng-container> <ng-container *ngIf=\"!isFieldValid && !hasFormGroupParent\"> <ux-control-feedback *ngIf=\"validationErrorMessage\" typeClass=\"{{validationErrorType ? validationErrorType : 'danger' }}\"> {{validationErrorMessage}} </ux-control-feedback> </ng-container> <ng-container *ngIf=\"!isMaxLengthValid\"> <ux-control-feedback *ngIf=\"maxLengthValidationErrorMessage\" typeClass=\"danger\"> {{maxLengthValidationErrorMessage}} </ux-control-feedback> </ng-container> ",
                        providers: [{
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef(function () { return UxFormControlComponent; }),
                                multi: true,
                            }, {
                                provide: forms.NG_VALIDATORS,
                                useExisting: core.forwardRef(function () { return UxFormControlComponent; }),
                                multi: true,
                            }],
                        styles: ["\n                 :host {\n                     width: 100%;\n                 }\n             "]
                    },] },
        ];
        /** @nocollapse */
        UxFormControlComponent.ctorParameters = function () { return [
            { type: UxFormGroupComponent, decorators: [{ type: core.Optional }, { type: core.Host }, { type: core.Inject, args: [core.forwardRef(function () { return UxFormGroupComponent; }),] },] },
            { type: UxService, },
            { type: core$1.TranslateService, },
            { type: core.ChangeDetectorRef, },
            { type: core.ElementRef, },
        ]; };
        UxFormControlComponent.propDecorators = {
            "id": [{ type: core.Input },],
            "feedbackTypeClass": [{ type: core.Input },],
            "isReadOnly": [{ type: core.Input },],
            "isRequired": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "validationErrorMessage": [{ type: core.Input },],
            "infoLabel": [{ type: core.Input },],
            "placeholderLabel": [{ type: core.Input },],
            "formControlName": [{ type: core.Input },],
            "isInputText": [{ type: core.Input },],
            "isTextarea": [{ type: core.Input },],
            "rows": [{ type: core.Input },],
            "minRows": [{ type: core.Input },],
            "isTextareaAutoresize": [{ type: core.Input },],
            "isDatepicker": [{ type: core.Input },],
            "isDatetimepicker": [{ type: core.Input },],
            "datepickerDateformat": [{ type: core.Input },],
            "datepickerYearRange": [{ type: core.Input },],
            "datepickerLocale": [{ type: core.Input },],
            "isSelect": [{ type: core.Input },],
            "selectOptions": [{ type: core.Input },],
            "selectKeyName": [{ type: core.Input },],
            "selectValueName": [{ type: core.Input },],
            "isCheckbox": [{ type: core.Input },],
            "checkboxLabel": [{ type: core.Input },],
            "isRadio": [{ type: core.Input },],
            "radioLabel": [{ type: core.Input },],
            "formControlValue": [{ type: core.Input },],
            "isNumber": [{ type: core.Input },],
            "decimalSeparator": [{ type: core.Input },],
            "thousandSeparator": [{ type: core.Input },],
            "isNumberFormatPlaceholder": [{ type: core.Input },],
            "maxlength": [{ type: core.Input },],
            "maxLengthValidationErrorMessage": [{ type: core.Input },],
            "isDisabled": [{ type: core.Input },],
            "inputStyleClass": [{ type: core.Input },],
            "tabindex": [{ type: core.Input },],
            "groupId": [{ type: core.Input },],
            "modelChange": [{ type: core.Output },],
            "touched": [{ type: core.Output },],
            "calendarControl": [{ type: core.ViewChild, args: ['calendar',] },],
            "radioElement": [{ type: core.ViewChild, args: ['radioElement',] },],
        };
        return UxFormControlComponent;
    }());
    var UxFormControlComponentModule = (function () {
        function UxFormControlComponentModule() {
        }
        UxFormControlComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxControlFeedbackComponentModule,
                            calendar.CalendarModule,
                            forms.FormsModule,
                            UxCleaveModule,
                            UxNumberFormatPipeModule,
                            UxMaxlengthModule
                        ],
                        exports: [UxFormControlComponent],
                        declarations: [UxFormControlComponent]
                    },] },
        ];
        return UxFormControlComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverService$1 = (function () {
        function PopoverService() {
            this.placementStrategies = [];
        }
        /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        PopoverService.pickPlacementStrategy = /**
         * @param {?} placementStrategies
         * @param {?} placementId
         * @return {?}
         */
        function (placementStrategies, placementId) {
            /**
             * @param {?} strategy
             * @return {?}
             */
            function matchStrategy(strategy) {
                return strategy.getId() === placementId;
            }
            return (placementStrategies || []).find(matchStrategy);
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        PopoverService.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ placementStrategy = PopoverService.pickPlacementStrategy(this.placementStrategies, placementOptions.placement);
            if (!placementStrategy) {
                throw new Error('Placement not supported: ' + placementOptions.placement);
            }
            return placementStrategy.calculate(placementOptions);
        };
        PopoverService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PopoverService.ctorParameters = function () { return []; };
        return PopoverService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicOpenedPopoverService = (function () {
        /**
         * Constructor
         */
        function UxDynamicOpenedPopoverService() {
            this.openedPopover = {};
        }
        /**
         * @param {?} id
         * @param {?} domPortalHost
         * @param {?} portal
         * @return {?}
         */
        UxDynamicOpenedPopoverService.prototype.add = /**
         * @param {?} id
         * @param {?} domPortalHost
         * @param {?} portal
         * @return {?}
         */
        function (id, domPortalHost, portal$$1) {
            if (id) {
                this.openedPopover[String(id)] = { domPortalHost: domPortalHost, portal: portal$$1 };
            }
        };
        /**
         * @param {?} id
         * @return {?}
         */
        UxDynamicOpenedPopoverService.prototype.remove = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            if (id) {
                delete this.openedPopover[String(id)];
            }
        };
        /**
         * @param {?} id
         * @return {?}
         */
        UxDynamicOpenedPopoverService.prototype.isOpenedPopover = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            return !!id ? this.openedPopover[String(id)] : void 0;
        };
        UxDynamicOpenedPopoverService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicOpenedPopoverService.ctorParameters = function () { return []; };
        return UxDynamicOpenedPopoverService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicPopoverConfig = (function () {
        function UxDynamicPopoverConfig(values) {
            this.title = '';
            this.showCloseIcon = true;
            this.type = 'default';
            this.placement = 'bottom';
            this.size = 'default';
            this.hasNoContentPadding = false;
            this.isDismissable = true;
            this.headerStyleClass = '';
            Object.assign(this, values);
        }
        return UxDynamicPopoverConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverVM$1 = (function () {
        function PopoverVM(placementClassModifier, popoverPosition, arrowOffset) {
            if (placementClassModifier === void 0) { placementClassModifier = 'no-direction'; }
            if (popoverPosition === void 0) { popoverPosition = Point.create(0, 0); }
            if (arrowOffset === void 0) { arrowOffset = Offset.create(0, 0); }
            this.placementClassModifier = placementClassModifier;
            this.popoverPosition = popoverPosition;
            this.arrowOffset = arrowOffset;
        }
        /**
         * @param {?=} popoverDetails
         * @return {?}
         */
        PopoverVM.create = /**
         * @param {?=} popoverDetails
         * @return {?}
         */
        function (popoverDetails) {
            if (!popoverDetails) {
                return new PopoverVM();
            }
            return new PopoverVM(popoverDetails.placementClassModifier, popoverDetails.popoverPosition, popoverDetails.arrowOffset);
        };
        return PopoverVM;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicPopoverComponent = (function () {
        function UxDynamicPopoverComponent(popoverService, uxService, router$$1, uxDynamicComponentService, uxDynamicOpenedPopoverService, config) {
            this.popoverService = popoverService;
            this.uxService = uxService;
            this.router = router$$1;
            this.uxDynamicComponentService = uxDynamicComponentService;
            this.uxDynamicOpenedPopoverService = uxDynamicOpenedPopoverService;
            this.config = config;
            this.isVisible = false;
            this.explicitRepositionSubject = new Subject.Subject();
            this.destroySubject = new ReplaySubject.ReplaySubject();
            this.vm = PopoverVM$1.create();
        }
        /**
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ repositionTrigger$ = this.explicitRepositionSubject.asObservable();
            var /** @type {?} */ destroyed$ = this.destroySubject.asObservable();
            var /** @type {?} */ breakpointTrigger$ = this.uxService.activeBreakpoint
                .switchMap(function () {
                return timer$1.timer(300)
                    .pipe(operators.takeUntil(repositionTrigger$));
            });
            var /** @type {?} */ repositionNeeded$ = Observable.Observable.merge(repositionTrigger$, breakpointTrigger$).pipe(operators.takeUntil(destroyed$));
            repositionNeeded$.subscribe(function () {
                if (_this.config.anchor) {
                    _this.reposition(_this.config.anchor);
                }
                else {
                    _this.hide();
                }
            });
            // close on router event
            this.router.events.take(1)
                .subscribe(function () {
                _this.hide();
            });
            fromEvent.fromEvent(document, 'keyup').pipe(operators.filter(function (evt) { return evt.keyCode === 27; }), operators.takeUntil(destroyed$)).subscribe(function () { return _this.hide(); });
            // dismiss on click
            fromEvent.fromEvent(document, 'click')
                .pipe(operators.withLatestFrom(repositionTrigger$, function (event /*, trigger*/) { return event.target; }), operators.takeUntil(destroyed$))
                .subscribe(function (eventTarget) {
                if (_this.config.isDismissable
                    && !_this.popoverEl.nativeElement.contains(eventTarget)
                    && eventTarget !== _this.config.anchor) {
                    _this.hide();
                }
            });
            if (this.config.width) {
                this.config.size = 'auto';
            }
        };
        /**
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.config.anchor) {
                this.config.anchor.classList.add('popover-open');
                setTimeout(function () {
                    if (_this.config.bodyInjectedComponent && _this.config.bodyInjectedComponent.component) {
                        _this.uxDynamicComponentService.add(_this.config.bodyInjectedComponent.component, _this.uxPopoverContent, _this.config.bodyInjectedComponent.config);
                        setTimeout(function () {
                            _this.show();
                        }, 0);
                    }
                    else {
                        _this.show();
                    }
                }, 0);
            }
            else {
                this.hide();
            }
        };
        /**
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.destroySubject.next(void 0);
            if (this.config.anchor) {
                this.config.anchor.classList.remove('popover-open');
            }
        };
        /**
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.show = /**
         * @return {?}
         */
        function () {
            this.explicitRepositionSubject.next(void 0);
        };
        /**
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.hide = /**
         * @return {?}
         */
        function () {
            this.uxDynamicComponentService.remove(this.config['portalHostRef'], this.config['portalRef']);
            this.uxDynamicOpenedPopoverService.remove(this.config.id);
        };
        /**
         * @param {?} element
         * @return {?}
         */
        UxDynamicPopoverComponent.prototype.reposition = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            var /** @type {?} */ anchorRect = RectangleFactory.fromHtmlElement(element);
            var /** @type {?} */ popoverRect = RectangleFactory.fromHtmlElement(this.popoverEl.nativeElement);
            var /** @type {?} */ arrowRect = RectangleFactory.fromHtmlElement(this.arrowEl.nativeElement);
            var /** @type {?} */ placement = this.config.placement;
            this.vm = this.popoverService.calculate({ placement: placement, anchorRect: anchorRect, popoverRect: popoverRect, arrowRect: arrowRect });
            this.isVisible = true;
        };
        UxDynamicPopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dynamic-popover',
                        template: "<div #popoverContainer class=\"ux-popover ux-popover--{{ vm.placementClassModifier }} ux-popover--{{ config.type }} ux-popover--size-{{ config.size }} ux-popover--visible\" [class.ux-popover--visible]=\"isVisible\" [style.left]=\"vm.popoverPosition.x + 'px'\" [style.top]=\"vm.popoverPosition.y + 'px'\" [style.width]=\"config.width + 'px'\"> <div #popoverArrow class=\"ux-popover__arrow\" [style.marginLeft]=\"vm.arrowOffset.x + 'px'\" [style.marginTop]=\"vm.arrowOffset.y + 'px'\"> <div class=\"ux-popover__arrow-inner\"></div> </div> <div *ngIf=\"config.title\" class=\"ux-popover__header {{ config.headerStyleClass }}\"> <div class=\"ux-popover__title\">{{ config.title }}</div> <div *ngIf=\"config.showCloseIcon\" (click)=\"hide()\" class=\"ux-popover__close\"> <i class=\"ux-icon ux-icon-close\"></i> </div> </div> <div #uxpopovercontent class=\"ux-popover__content\" [class.p-0]=\"config.hasNoContentPadding\"> <span *ngIf=\"config.content\" [outerHTML]=\"config.content\"></span> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxDynamicPopoverComponent.ctorParameters = function () { return [
            { type: PopoverService$1, },
            { type: UxService, },
            { type: router.Router, },
            { type: UxDynamicComponentService, },
            { type: UxDynamicOpenedPopoverService, },
            { type: UxDynamicPopoverConfig, decorators: [{ type: core.Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
        ]; };
        UxDynamicPopoverComponent.propDecorators = {
            "popoverEl": [{ type: core.ViewChild, args: ['popoverContainer',] },],
            "arrowEl": [{ type: core.ViewChild, args: ['popoverArrow',] },],
            "uxPopoverContent": [{ type: core.ViewChild, args: ['uxpopovercontent',] },],
        };
        return UxDynamicPopoverComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxDynamicPopoverService = (function () {
        /**
         * Constructor
         */
        function UxDynamicPopoverService(uxDynamicComponentService, uxDynamicOpenedPopoverService) {
            this.uxDynamicComponentService = uxDynamicComponentService;
            this.uxDynamicOpenedPopoverService = uxDynamicOpenedPopoverService;
        }
        /**
         * Toggle the popover
         * @param {?} config
         * @return {?}
         */
        UxDynamicPopoverService.prototype.toggle = /**
         * Toggle the popover
         * @param {?} config
         * @return {?}
         */
        function (config) {
            config = this.processConfig(config);
            if (this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id)) {
                this.hide(config);
            }
            else {
                this.show(config);
            }
        };
        /**
         * Show a popover
         * @param {?} config
         * @return {?}
         */
        UxDynamicPopoverService.prototype.show = /**
         * Show a popover
         * @param {?} config
         * @return {?}
         */
        function (config) {
            config = this.processConfig(config);
            var /** @type {?} */ popover = this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id);
            if (!popover) {
                var _a = this.uxDynamicComponentService.add(UxDynamicPopoverComponent, null, config), portalHost = _a.portalHost, portal$$1 = _a.portal;
                this.uxDynamicOpenedPopoverService.add(config.id, portalHost, portal$$1);
            }
        };
        /**
         * Hide a popover
         * @param {?} config
         * @return {?}
         */
        UxDynamicPopoverService.prototype.hide = /**
         * Hide a popover
         * @param {?} config
         * @return {?}
         */
        function (config) {
            config = this.processConfig(config);
            var /** @type {?} */ popover = this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id);
            if (popover) {
                this.uxDynamicComponentService.remove(popover.domPortalHost, popover.portal);
                this.uxDynamicOpenedPopoverService.remove(config.id);
            }
        };
        /**
         * @param {?} config
         * @return {?}
         */
        UxDynamicPopoverService.prototype.processConfig = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            if (!config || !!config.anchor) {
                return config;
            }
            return Object.assign({}, config, {
                // BLACK MAGIC as it was present in the original version of the UxDynamicPopoverComponent
                // If the anchor element is not specified in the config object, the global 'event' var is used to identify the anchor element.
                anchor: event && /** @type {?} */ (event.target)
            });
        };
        UxDynamicPopoverService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        UxDynamicPopoverService.ctorParameters = function () { return [
            { type: UxDynamicComponentService, },
            { type: UxDynamicOpenedPopoverService, },
        ]; };
        return UxDynamicPopoverService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxFilterResultsComponent = (function () {
        function UxFilterResultsComponent(uxService, asService) {
            var _this = this;
            this.uxService = uxService;
            this.asService = asService;
            this.isAdvancedFilterVisible = false;
            this.isScrollableNavigation = true;
            this.navigationLabel = 'Navigation';
            this.isLoadingResults = false;
            this.resultsHasNoContentPadding = false;
            this.isFilterCollapsed = false;
            this.mainStateClass = '';
            this.breakpointsSub = asService.breakpoints$.subscribe(function (bkps) {
                _this.isFilterCollapsed = bkps.isLtDesktop;
            });
        }
        /**
         * @return {?}
         */
        UxFilterResultsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this.filtersLabel) {
                this.translatedFiltersLabel = this.uxService.translate('filters');
            }
            else {
                this.translatedFiltersLabel = this.filtersLabel;
            }
            if (!this.resultsLabel) {
                this.translatedResultsLabel = this.uxService.translate('results');
            }
            else {
                this.translatedResultsLabel = this.resultsLabel;
            }
            if (!this.advancedFilterLabel) {
                this.translatedAdvancedFilterLabel = this.uxService.translate('advancedFilter');
            }
            else {
                this.translatedAdvancedFilterLabel = this.advancedFilterLabel;
            }
            if (!this.quickFilterLabel) {
                this.translatedQuickFilterLabel = this.uxService.translate('quickFilter');
            }
            else {
                this.translatedQuickFilterLabel = this.quickFilterLabel;
            }
            this.advancedFilterShowhide();
        };
        /**
         * @return {?}
         */
        UxFilterResultsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.breakpointsSub) {
                this.breakpointsSub.unsubscribe();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxFilterResultsComponent.prototype.onFilterClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.isAdvancedFilterVisible = !this.isAdvancedFilterVisible;
            this.advancedFilterShowhide();
        };
        /**
         * @param {?} collapsed
         * @return {?}
         */
        UxFilterResultsComponent.prototype.onCollapse = /**
         * @param {?} collapsed
         * @return {?}
         */
        function (collapsed) {
            this.isFilterCollapsed = collapsed;
        };
        /**
         * @return {?}
         */
        UxFilterResultsComponent.prototype.advancedFilterShowhide = /**
         * @return {?}
         */
        function () {
            if (this.isScrollableNavigation) {
                if (this.isAdvancedFilterVisible) {
                    this.mainStateClass = 'ux-filter-results__filter-main--limited-height';
                }
                else {
                    this.mainStateClass = '';
                }
            }
        };
        UxFilterResultsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-results',
                        template: "<div class=\"ux-filter-results\" [class.ux-filter-results--filter-collapsed]=\"isFilterCollapsed\"> <div class=\"ux-filter-results__filter\"> <ux-panel label=\"{{translatedFiltersLabel}}\" isFlat=true isCollapsible=true [isCollapsed]=\"isFilterCollapsed\" (panelCollapsed)=\"onCollapse($event)\"> <uxPanelHeaderRightContent *ngIf=\"customNavigationContent.length !== 0\"> <span class=\"ux-u-font-size-h7 ux-u-font-light\">{{translatedAdvancedFilterLabel}}:&nbsp;</span> <ux-switch [isChecked]=\"isAdvancedFilterVisible\" (click)=\"onFilterClick($event)\"></ux-switch> </uxPanelHeaderRightContent> <ng-template [ngIf]=\"customQuickFilterContent.length !== 0\"> <h6 class=\"ux-u-font-bold\">{{translatedQuickFilterLabel}}</h6> <div class=\"ux-filter-results__filter-quick\"> <ng-content select=\"uxFilterResultsQuickFilterContent\"></ng-content> </div> <hr> </ng-template> <ng-template [ngIf]=\"customNavigationContent.length !== 0\"> <h6 class=\"ux-u-font-bold\">{{navigationLabel}}</h6> <div class=\"ux-filter-results__filter-main {{mainStateClass}}\"> <ng-content select=\"uxFilterResultsNavigationContent\"></ng-content> </div> </ng-template> <div *ngIf=\"isAdvancedFilterVisible || customNavigationContent.length === 0\"> <ng-template [ngIf]=\"customNavigationContent.length !== 0\"> <hr> <h6 class=\"ux-u-font-bold\">{{translatedAdvancedFilterLabel}}</h6> </ng-template> <ng-content select=\"uxFilterResultsFilterContent\"></ng-content> </div> </ux-panel> </div> <div class=\"ux-filter-results__results\"> <ux-block-content [isBlocked]=\"isLoadingResults\"> <ng-container *ngIf=\"customResultsFullContent.length !== 0\"> <ng-content select=\"uxFilterResultsFullContent\"></ng-content> </ng-container> <ng-container *ngIf=\"customResultsFullContent.length === 0\"> <ng-template [ngIf]=\"customResultsHeaderContent.length === 0\"> <ux-panel label=\"{{translatedResultsLabel}}\" isFlat=true [hasNoContentPadding]=\"resultsHasNoContentPadding\" badgeLabel=\"{{resultsHeaderBadgeLabel}}\" labelInfos=\"{{resultsHeaderInfosLabel}}\"> <ng-container *ngTemplateOutlet=\"resultsContent\"></ng-container> </ux-panel> </ng-template> <ng-template [ngIf]=\"customResultsHeaderContent.length !== 0\"> <ux-panel isFlat=true [hasNoContentPadding]=\"resultsHasNoContentPadding\"> <uxPanelHeader> <ng-content select=\"uxFilterResultsHeaderContent\"></ng-content> </uxPanelHeader> <ng-container *ngTemplateOutlet=\"resultsContent\"></ng-container> </ux-panel> </ng-template> </ng-container> </ux-block-content> </div> </div> <ng-template #resultsContent> <ng-content select=\"uxFilterResultsContent\"></ng-content> <ng-template> ",
                    },] },
        ];
        /** @nocollapse */
        UxFilterResultsComponent.ctorParameters = function () { return [
            { type: UxService, },
            { type: UxAppShellService, },
        ]; };
        UxFilterResultsComponent.propDecorators = {
            "filtersLabel": [{ type: core.Input },],
            "resultsLabel": [{ type: core.Input },],
            "quickFilterLabel": [{ type: core.Input },],
            "advancedFilterLabel": [{ type: core.Input },],
            "isAdvancedFilterVisible": [{ type: core.Input },],
            "isScrollableNavigation": [{ type: core.Input },],
            "navigationLabel": [{ type: core.Input },],
            "isLoadingResults": [{ type: core.Input },],
            "resultsHeaderBadgeLabel": [{ type: core.Input },],
            "resultsHeaderInfosLabel": [{ type: core.Input },],
            "resultsHasNoContentPadding": [{ type: core.Input },],
            "customNavigationContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsNavigationContentTagDirective;
                        }),] },],
            "customFilterContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsFilterContentTagDirective;
                        }),] },],
            "customQuickFilterContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsQuickFilterContentTagDirective;
                        }),] },],
            "customResultsContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsFilterContentTagDirective;
                        }),] },],
            "customResultsFullContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsFullContentTagDirective;
                        }),] },],
            "customResultsHeaderContent": [{ type: core.ContentChildren, args: [core.forwardRef(function () {
                            return UxFilterResultsHeaderContentTagDirective;
                        }),] },],
        };
        return UxFilterResultsComponent;
    }());
    var UxFilterResultsNavigationContentTagDirective = (function () {
        function UxFilterResultsNavigationContentTagDirective() {
        }
        UxFilterResultsNavigationContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsNavigationContent' },] },
        ];
        return UxFilterResultsNavigationContentTagDirective;
    }());
    var UxFilterResultsFilterContentTagDirective = (function () {
        function UxFilterResultsFilterContentTagDirective() {
        }
        UxFilterResultsFilterContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsFilterContent' },] },
        ];
        return UxFilterResultsFilterContentTagDirective;
    }());
    var UxFilterResultsQuickFilterContentTagDirective = (function () {
        function UxFilterResultsQuickFilterContentTagDirective() {
        }
        UxFilterResultsQuickFilterContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsQuickFilterContent' },] },
        ];
        return UxFilterResultsQuickFilterContentTagDirective;
    }());
    var UxFilterResultsHeaderContentTagDirective = (function () {
        function UxFilterResultsHeaderContentTagDirective() {
        }
        UxFilterResultsHeaderContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsHeaderContent' },] },
        ];
        return UxFilterResultsHeaderContentTagDirective;
    }());
    var UxFilterResultsContentTagDirective = (function () {
        function UxFilterResultsContentTagDirective() {
        }
        UxFilterResultsContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsContent' },] },
        ];
        return UxFilterResultsContentTagDirective;
    }());
    var UxFilterResultsFullContentTagDirective = (function () {
        function UxFilterResultsFullContentTagDirective() {
        }
        UxFilterResultsFullContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxFilterResultsFullContent' },] },
        ];
        return UxFilterResultsFullContentTagDirective;
    }());
    var UxFilterResultsComponentModule = (function () {
        function UxFilterResultsComponentModule() {
        }
        UxFilterResultsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            UxPanelComponentModule,
                            UxButtonComponentModule,
                            UxSwitchComponentModule,
                            UxBlockContentComponentModule,
                        ],
                        exports: [
                            UxFilterResultsComponent,
                            UxFilterResultsNavigationContentTagDirective,
                            UxFilterResultsFilterContentTagDirective,
                            UxFilterResultsContentTagDirective,
                            UxFilterResultsQuickFilterContentTagDirective,
                            UxFilterResultsHeaderContentTagDirective,
                            UxFilterResultsFullContentTagDirective,
                        ],
                        declarations: [
                            UxFilterResultsComponent,
                            UxFilterResultsNavigationContentTagDirective,
                            UxFilterResultsFilterContentTagDirective,
                            UxFilterResultsContentTagDirective,
                            UxFilterResultsQuickFilterContentTagDirective,
                            UxFilterResultsHeaderContentTagDirective,
                            UxFilterResultsFullContentTagDirective,
                        ],
                    },] },
        ];
        return UxFilterResultsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EDITOR_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return UxEditorComponent; }),
        multi: true
    };
    var UxEditorComponent = (function () {
        function UxEditorComponent(el, sanitizer) {
            this.el = el;
            this.sanitizer = sanitizer;
            this.isEnabledOnFocus = false;
            this.isReadOnly = false;
            this.theme = 'snow';
            this.onInit = new core.EventEmitter();
            this.onTextChange = new core.EventEmitter();
            this.onSelectionChange = new core.EventEmitter();
            this.isEnabled = true;
            this.crlf = String.fromCharCode(10, 13);
            this.blank = ' ';
            this.onModelChange = function () { };
            this.onModelTouched = function () { };
        }
        /**
         * @return {?}
         */
        UxEditorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.isEnabledOnFocus || this.isReadOnly) {
                this.isEnabled = false;
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        UxEditorComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var _this = this;
            // console.log('ngOnChanges() - changes:', changes);
            if (changes) {
                if (changes["isReadOnly"] && changes["isReadOnly"].currentValue === true) {
                    this.isEnabled = false;
                }
                else {
                    this.isEnabled = true;
                }
                // Set Quill instance
                setTimeout(function () {
                    _this.initQuill();
                });
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        UxEditorComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if ((value === 'undefined') || (value === 'null')) {
                this.value += this.blank;
            }
            else {
                this.value = value;
            }
            // console.log('writeValue() - this.value:', this.value );
            if (this.quill) {
                this.quill.clipboard.dangerouslyPasteHTML(this.value);
                this.secureHtmlValue = this.getSecureHTMLValue(this.value);
            }
        };
        // ControlValueAccessors
        /**
         * @param {?} fn
         * @return {?}
         */
        UxEditorComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onModelChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        UxEditorComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onModelTouched = fn;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxEditorComponent.prototype.editorOnFocus = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            var _this = this;
            if (this.isEnabledOnFocus && !this.isReadOnly) {
                this.isEnabled = true;
                setTimeout(function () {
                    _this.initQuill();
                });
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        UxEditorComponent.prototype.editorOnBlur = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event) {
                // Do not blur when using toolbar
                if ((event.srcElement.localName === 'span') ||
                    // Style classes & Font face popups
                    (event.srcElement.localName === 'line' || event.srcElement.localName === 'polyline') ||
                    // Font color popup
                    (event.srcElement.localName === 'svg')) ;
                else {
                    this.isEnabled = false;
                }
            }
        };
        /**
         * @return {?}
         */
        UxEditorComponent.prototype.editorUndo = /**
         * @return {?}
         */
        function () {
            this.quill.history.undo();
        };
        /**
         * @return {?}
         */
        UxEditorComponent.prototype.editorRedo = /**
         * @return {?}
         */
        function () {
            this.quill.history.redo();
        };
        /**
         * @param {?} element
         * @param {?} selector
         * @return {?}
         */
        UxEditorComponent.prototype.findSingle = /**
         * @param {?} element
         * @param {?} selector
         * @return {?}
         */
        function (element, selector) {
            return element.querySelector(selector);
        };
        /**
         * @return {?}
         */
        UxEditorComponent.prototype.initQuill = /**
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ editorElement = this.findSingle(this.el.nativeElement, 'div.ux-editor__content');
            var /** @type {?} */ toolbarElement = this.findSingle(this.el.nativeElement, 'div.ux-editor__toolbar');
            this.quill = new Quill(editorElement, {
                modules: {
                    toolbar: toolbarElement,
                    clipboard: true,
                    history: {
                        delay: 1000,
                        maxStack: 100,
                        userOnly: true
                    }
                },
                placeholder: this.placeholder,
                readOnly: this.isReadOnly,
                theme: this.theme,
                formats: this.formats
            });
            // Populate with initial value
            this.writeValue(this.value);
            this.quill.on('text-change', function (delta, oldContents, source) {
                // console.log('text-change - source:', source);
                if (source === 'user') {
                    var /** @type {?} */ html = editorElement.children[0].innerHTML;
                    var /** @type {?} */ text = _this.quill.getText().trim();
                    if (text.length === 0) {
                        html = null;
                    }
                    // Update with changed value
                    // Update with changed value
                    _this.value = html;
                    _this.onTextChange.emit({
                        htmlValue: html,
                        textValue: text,
                        delta: delta,
                        source: source
                    });
                    _this.onModelChange(html);
                    _this.onModelTouched();
                }
            });
            this.quill.on('selection-change', function (range, oldRange, source) {
                // console.log('selection-change - source:', source);
                // Track in/out blur (for future release!)
                // if (range === null && oldRange !== null) {
                //     this.editorOnBlur(event);
                // }
                // console.log('selection-change - source:', source);
                // Track in/out blur (for future release!)
                // if (range === null && oldRange !== null) {
                //     this.editorOnBlur(event);
                // }
                _this.onSelectionChange.emit({
                    range: range,
                    oldRange: oldRange,
                    source: source
                });
            });
            this.onInit.emit({
                editor: this.quill
            });
        };
        /**
         * @param {?} data
         * @return {?}
         */
        UxEditorComponent.prototype.getSecureHTMLValue = /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            return this.sanitizer.bypassSecurityTrustHtml(data);
        };
        UxEditorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-editor',
                        template: " <!-- <ng-template [ngIf]=\"isEnabledOnFocus && isEnabled || !isEnabledOnFocus\"> --> <ng-template [ngIf]=\"isEnabled\"> <div class=\"ux-editor {{styleClass}}\"> <div class=\"ux-editor__toolbar\"> <span class=\"ql-formats\"> <button class=\"ql-script\" aria-label=\"Undo\" title=\"Undo{{crlf}}Cancels the previous action\" (click)=\"editorUndo()\"><span class=\"fa fa-undo\"></span></button> <button class=\"ql-script\" aria-label=\"Redo\" title=\"Redo{{crlf}}Do the next history action again\" (click)=\"editorRedo()\"><span class=\"fa fa-repeat\"></span></button> </span> <span class=\"ql-formats\"> <select class=\"ql-header\" title=\"Style{{crlf}}Apply an HTML tag or CSS class to the selected text\"> <option value=\"1\">Heading</option> <option value=\"2\">Subheading</option> <option selected>Normal</option> </select> <select class=\"ql-font\" title=\"Font{{crlf}}Change the font face\"> <option selected>Sans Serif</option> <option value=\"serif\">Serif</option> <option value=\"monospace\">Monospace</option> </select> </span> <span class=\"ql-formats\"> <button class=\"ql-bold\" aria-label=\"Bold (Ctrl + B)\" title=\"Bold (Ctrl + B){{crlf}}Make the selected text bold\"></button> <button class=\"ql-italic\" aria-label=\"Italic (Ctrl + I)\" title=\"Italic (Ctrl + I){{crlf}}Italicize the selected text\"></button> <button class=\"ql-underline\" aria-label=\"Underline (Ctrl + U)\" title=\"Underline (Ctrl + U){{crlf}}Underline the selected text\"></button> <button class=\"ql-strike\" aria-label=\"Strikethrough\" title=\"Strikethrough{{crlf}}Draw a line to the middle of the selected text\"></button> </span> <span class=\"ql-formats\"> <select class=\"ql-color\" aria-label=\"Font Color\" title=\"Font Color{{crlf}}Change the text color\"></select> <select class=\"ql-background\" aria-label=\"Text Highlight Color\" title=\"Text Highlight Color{{crlf}}Change the background color of the text\"></select> </span> <span class=\"ql-formats\"> <button class=\"ql-script\" value=\"sub\" aria-label=\"Subscript\" title=\"Subscript{{crlf}}Create ssmall letters below the text baseline\"></button> <button class=\"ql-script\" value=\"super\" aria-label=\"Superscript\" title=\"Superscript{{crlf}}Create small letters above the line of the text\"></button> </span> <span class=\"ql-formats\"> <select class=\"ql-align\" aria-label=\"Text Align\" title=\"Text Align{{crlf}}Align the text to the selected position: left (default), center, right or justify\"> <option selected></option> <option value=\"center\"></option> <option value=\"right\"></option> <option value=\"justify\"></option> </select> </span> <span class=\"ql-formats\"> <button class=\"ql-list\" value=\"ordered\" aria-label=\"Ordered List\" title=\"Numbering{{crlf}}Start an ordered list\"></button> <button class=\"ql-list\" value=\"bullet\" aria-label=\"Unordered List\" title=\"Bullets{{crlf}}Start a bulleted list\"></button> <button class=\"ql-indent\" value=\"-1\" type=\"button\" aria-label=\"Decrease Indent\" title=\"Decrease Indent{{crlf}}Decrease the indent level of the paragraph\"></button> <button class=\"ql-indent\" value=\"+1\" type=\"button\" aria-label=\"Increase Indent\" title=\"Increase Indent{{crlf}}Increase the indent level of the paragraph\"></button> </span> <span class=\"ql-formats\"> <button class=\"ql-blockquote\" aria-label=\"Blockquote\" title=\"Blockquote{{crlf}}Create a quoted block of the selected text\"></button> <button class=\"ql-code-block\" aria-label=\"Insert Code Block\" title=\"Insert Code Block{{crlf}}Insert a code block at the cursor row position\"></button> <button class=\"ql-link\" aria-label=\"Insert Link\" title=\"Insert Hyperlink (Ctrl + K){{crlf}}Create a link to a Web page, a picture, an e-mail address or a program\"></button> <button class=\"ql-image\" aria-label=\"Insert Image\" title=\"Insert Picture{{crlf}}Insert a picture from a file\"></button> </span> <!-- <span class=\"ql-formats\" *ngIf=\"hasTable\"> <button id=\"insert-table\" aria-label=\"Insert Table\" title=\"Insert Table{{crlf}}Insert a table at the cursor's position\" (click)=\"onTableInsert()\"><span class=\"ux-icon-table ux-icon-table__add\"></span></button> <button id=\"delete-table\" aria-label=\"Delete Table\" title=\"Delete Table{{crlf}}Delete the table at the cursor's position\" (click)=\"onTableDelete()\"><span class=\"ux-icon-table ux-icon-table__delete\"></span></button> <button id=\"insert-row-above\" aria-label=\"Insert row before\" title=\"Insert row before{{crlf}}Add a table row above the cursor's position\" (click)=\"onRowInsertBefore()\"><span class=\"ux-icon-table ux-icon-table__row-insert--before\"></span></button> <button id=\"insert-row-below\" aria-label=\"Insert row after\" title=\"Insert row after{{crlf}}Add a table row below the cursor's position\" (click)=\"onRowInsertAfter()\"><span class=\"ux-icon-table ux-icon-table__row-insert--after\"></span></button> <button id=\"delete-row\" aria-label=\"Delete row\" title=\"Delete row{{crlf}}Delete the table row at the cursor position\" (click)=\"onRowDelete()\"><span class=\"ux-icon-table ux-icon-table__row-delete\"></span></button> <button id=\"insert-column-left\" aria-label=\"Insert column before\" title=\"Insert column before{{crlf}}Inserts a column at the left of the cursor's position\" (click)=\"onColumnInsertBefore()\"><span class=\"ux-icon-table ux-icon-table__col-insert--before\"></span></button> <button id=\"insert-column-right\" aria-label=\"Insert column after\" title=\"Insert column after{{crlf}}Inserts a column at the right of the cursor's position\" (click)=\"onColumnInsertAfter()\"><span class=\"ux-icon-table ux-icon-table__col-insert--after\"></span></button> <button id=\"delete-column\" aria-label=\"Delete column\" title=\"Delete column{{crlf}}Delete the column at the cursor's position\" (click)=\"onColumnDelete()\"><span class=\"ux-icon-table ux-icon-table__col-delete\"></span></button> </span> --> <span class=\"ql-formats\"> <button class=\"ql-clean\" aria-label=\"Remove Styles\" title=\"Remove Styles{{crlf}}Remove the styles of the selected text\"></button> </span> </div> <div class=\"ux-editor__content\" style=\"overflow: auto; text-overflow: ellipsis; resize: vertical;\" [ngStyle]=\"style\"></div> </div> </ng-template> <!-- <ng-template [ngIf]=\"isEnabledOnFocus && !isEnabled\"> --> <ng-template [ngIf]=\"!isEnabled\"> <div class=\"ux-editor__toolbar\" style=\"visibility:hidden;\"></div> <div class=\"ux-editor__content p-2 ux-u-bg-grey-lightester ux-u-color-black ux-u-cursor-text\" [ngClass]=\"isReadOnly ? 'ux-u-cursor-not-allowed' : 'ux-u-cursor-text'\" (click)=\"editorOnFocus($event)\" style=\"border: 1px solid #ccc; overflow: auto; text-overflow: ellipsis; resize: vertical;\"> <p [innerHTML]=\"secureHtmlValue\"></p> </div> </ng-template> ",
                        providers: [EDITOR_VALUE_ACCESSOR],
                    },] },
        ];
        /** @nocollapse */
        UxEditorComponent.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: platformBrowser.DomSanitizer, },
        ]; };
        UxEditorComponent.propDecorators = {
            "style": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
            "placeholder": [{ type: core.Input },],
            "formats": [{ type: core.Input },],
            "isEnabledOnFocus": [{ type: core.Input },],
            "isReadOnly": [{ type: core.Input },],
            "theme": [{ type: core.Input },],
            "onInit": [{ type: core.Output },],
            "onTextChange": [{ type: core.Output },],
            "onSelectionChange": [{ type: core.Output },],
        };
        return UxEditorComponent;
    }());
    var UxEditorComponentModule = (function () {
        function UxEditorComponentModule() {
        }
        UxEditorComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [UxEditorComponent],
                        declarations: [UxEditorComponent]
                    },] },
        ];
        return UxEditorComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxErrorOutputComponent = (function () {
        function UxErrorOutputComponent(uxErrorFeedbackService) {
            this.uxErrorFeedbackService = uxErrorFeedbackService;
            this.errorFeedBacks = [];
            this.errors = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        UxErrorOutputComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.initShape();
        };
        /**
         * @return {?}
         */
        UxErrorOutputComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this.initShape();
        };
        /**
         * @return {?}
         */
        UxErrorOutputComponent.prototype.initShape = /**
         * @return {?}
         */
        function () {
            if (this.uxErrorOutput) {
                this.errorFeedBacks = this.uxErrorOutput.getFeedBacks();
            }
            else if (this.errorManager) {
                this.runErrorSubscription();
            }
            else {
                this.errorManager = this.uxErrorFeedbackService.createGlobalErrorManager();
                this.runErrorSubscription();
            }
        };
        /**
         * @return {?}
         */
        UxErrorOutputComponent.prototype.runErrorSubscription = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.errorManager.errors().subscribe(function (evt) {
                if (evt instanceof UxPublishErrorFeedbackEvent && evt.err) {
                    if (_this.itemKey) {
                        _this.errorFeedBacks = _this.errorFeedBacks.concat(evt.err.getFeedBacks(_this.itemKey));
                    }
                    else {
                        _this.errorFeedBacks = _this.errorFeedBacks.concat(evt.err.getFeedBacks());
                    }
                }
                else {
                    _this.errorFeedBacks = [];
                }
                _this.errors.emit(_this.errorFeedBacks);
            });
        };
        /**
         * @param {?} index
         * @return {?}
         */
        UxErrorOutputComponent.prototype.removeAt = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.errorFeedBacks.splice(index, 1);
        };
        UxErrorOutputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-error-output',
                        template: "<div *ngIf=\"errorFeedBacks.length>0 && isAlert\"> <div *ngFor=\"let feedBack of errorFeedBacks;let i = index;\"> <ux-alert [isCloseable]=\"true\" [isMuted]=\"true\" styleClass=\"ux-reduced-margin\" typeClass=\"{{feedBack.severity ? feedBack.severity : 'danger' }}\" (close)=\"removeAt(i)\"> {{feedBack.msgId}} </ux-alert> </div> </div> <div *ngIf=\"errorFeedBacks.length>0 && !isAlert\"> <div *ngFor=\"let feedBack of errorFeedBacks;\"> <ux-control-feedback typeClass=\"{{feedBack.severity ? feedBack.severity : 'danger' }}\"> {{feedBack.msgId}} </ux-control-feedback> </div> </div> ",
                    },] },
        ];
        /** @nocollapse */
        UxErrorOutputComponent.ctorParameters = function () { return [
            { type: UxErrorFeedbackService, },
        ]; };
        UxErrorOutputComponent.propDecorators = {
            "errorManager": [{ type: core.Input },],
            "itemKey": [{ type: core.Input },],
            "isCustom": [{ type: core.Input },],
            "uxErrorOutput": [{ type: core.Input },],
            "isAlert": [{ type: core.Input },],
            "errors": [{ type: core.Output },],
        };
        return UxErrorOutputComponent;
    }());
    var UxErrorOutputComponentModule = (function () {
        function UxErrorOutputComponentModule() {
        }
        UxErrorOutputComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, UxControlFeedbackComponentModule, UxAlertComponentModule],
                        exports: [UxErrorOutputComponent],
                        declarations: [UxErrorOutputComponent]
                    },] },
        ];
        return UxErrorOutputComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxMessage = (function () {
        function UxMessage() {
        }
        return UxMessage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxButtonConfig = (function () {
        function UxButtonConfig(values) {
            this.type = 'button';
            this.isOutline = false;
            this.isSecondary = false;
            this.isSmall = false;
            this.isLarge = false;
            this.isBlock = false;
            this.isFlat = false;
            this.isDisabled = false;
            Object.assign(this, values);
        }
        /**
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @param {?} componentInstance
         * @return {?}
         */
        UxButtonConfig.prototype.onClick = /**
         * @param {?} portalHostRef
         * @param {?} portalRef
         * @param {?} componentInstance
         * @return {?}
         */
        function (portalHostRef, portalRef, componentInstance) { };
        return UxButtonConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxModule = (function () {
        function UxModule() {
        }
        UxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, router.RouterModule, forms.ReactiveFormsModule, forms.FormsModule,
                            UxLayoutAppShellComponentModule,
                            UxLayoutHeaderProfileComponentModule,
                            UxLayoutSidebarItemComponentModule,
                            UxLayoutSidebarItemsComponentModule,
                            UxLayoutNavBarActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemComponentModule,
                            UxLayoutNavBarActionItemNotificationsComponentModule,
                            UxLayoutOverlayPanelComponentModule,
                            UxLayoutBreadcrumbsComponentModule,
                            UxLayoutTopMessageComponentModule,
                            UxLayoutBannerComponentModule,
                            UxLayoutPageHeaderComponentModule,
                            UxGrowlComponentModule,
                            UxBlockDocumentComponentModule,
                            UxPanelComponentModule,
                            UxPanelsComponentModule,
                            UxLanguageSelectorComponentModule,
                            UxSearchInputComponentModule
                        ],
                        declarations: [],
                        exports: [
                            common.CommonModule, router.RouterModule, forms.ReactiveFormsModule, forms.FormsModule,
                            UxLayoutAppShellComponentModule,
                            UxLayoutHeaderProfileComponentModule,
                            UxLayoutSidebarItemComponentModule,
                            UxLayoutSidebarItemsComponentModule,
                            UxLayoutNavBarActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemComponentModule,
                            UxLayoutNavBarActionItemNotificationsComponentModule,
                            UxLayoutOverlayPanelComponentModule,
                            UxLayoutBreadcrumbsComponentModule,
                            UxLayoutTopMessageComponentModule,
                            UxLayoutBannerComponentModule,
                            UxLayoutPageHeaderComponentModule,
                            UxGrowlComponentModule,
                            UxBlockDocumentComponentModule,
                            UxPanelComponentModule,
                            UxPanelsComponentModule,
                            UxLanguageSelectorComponentModule,
                            UxSearchInputComponentModule
                        ]
                    },] },
        ];
        return UxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ constants$1 = {
        offset: 15,
        directionClass: {
            none: 'no-direction',
            left: 'left',
            top: 'top',
            right: 'right',
            bottom: 'bottom',
        },
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BottomPlacementStrategy$2 = (function () {
        function BottomPlacementStrategy(placementService) {
            this.placementService = placementService;
        }
        /**
         * @return {?}
         */
        BottomPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'bottom';
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        BottomPlacementStrategy.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ positionedPopoverRect = this.placementService.place({
                anchor: placementOptions.anchorRect,
                element: placementOptions.popoverRect,
                placementId: this.getId(),
                offsetAlong: constants$1.offset
            });
            var /** @type {?} */ arrowOffset = getArrowOffset$2(placementOptions.anchorRect, positionedPopoverRect);
            var /** @type {?} */ placementClassModifier = getPlacementClassModifier$2(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
            var /** @type {?} */ popoverPosition = positionedPopoverRect.position();
            return PopoverVM$1.create({
                popoverPosition: popoverPosition, arrowOffset: arrowOffset, placementClassModifier: placementClassModifier
            });
        };
        return BottomPlacementStrategy;
    }());
    /**
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getMaxArrowOffset$2(popoverRect, arrowRect) {
        return (popoverRect.width - arrowRect.width) / 2;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function getArrowOffset$2(anchorRect, popoverRect) {
        var /** @type {?} */ offsetX = anchorRect.center().x - popoverRect.center().x;
        var /** @type {?} */ offsetY = 0;
        return Offset.create(offsetX, offsetY);
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function isArrowTooFar$2(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ arrowOffset = getArrowOffset$2(anchorRect, popoverRect);
        var /** @type {?} */ maxOffset = getMaxArrowOffset$2(popoverRect, arrowRect);
        var /** @type {?} */ isTooFar = Math.abs(arrowOffset.x) >= maxOffset;
        return isTooFar;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function isFlipped$2(anchorRect, popoverRect) {
        return popoverRect.isAbove(anchorRect.center());
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getPlacementClassModifier$2(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ isFlip = isFlipped$2(anchorRect, popoverRect);
        var /** @type {?} */ isTooFar = isArrowTooFar$2(anchorRect, popoverRect, arrowRect);
        if (isTooFar) {
            return constants$1.directionClass.none;
        }
        return isFlip ? constants$1.directionClass.top : constants$1.directionClass.bottom;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RightPlacementStrategy$2 = (function () {
        function RightPlacementStrategy(placementService) {
            this.placementService = placementService;
        }
        /**
         * @return {?}
         */
        RightPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'right';
        };
        /**
         * @param {?} placementOptions
         * @return {?}
         */
        RightPlacementStrategy.prototype.calculate = /**
         * @param {?} placementOptions
         * @return {?}
         */
        function (placementOptions) {
            var /** @type {?} */ positionedPopoverRect = this.placementService.place({
                anchor: placementOptions.anchorRect,
                element: placementOptions.popoverRect,
                placementId: this.getId(),
                offsetAlong: constants$1.offset
            });
            var /** @type {?} */ arrowOffset = getArrowOffset$3(placementOptions.anchorRect, positionedPopoverRect);
            var /** @type {?} */ placementClassModifier = getPlacementClassModifier$3(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
            var /** @type {?} */ popoverPosition = positionedPopoverRect.position();
            return PopoverVM$1.create({
                popoverPosition: popoverPosition, arrowOffset: arrowOffset, placementClassModifier: placementClassModifier
            });
        };
        return RightPlacementStrategy;
    }());
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function getArrowOffset$3(anchorRect, popoverRect) {
        var /** @type {?} */ offsetX = 0;
        var /** @type {?} */ offsetY = anchorRect.center().y - popoverRect.center().y;
        return Offset.create(offsetX, offsetY);
    }
    /**
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getMaxArrowOffset$3(popoverRect, arrowRect) {
        return (popoverRect.height - arrowRect.height) / 2;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function isArrowTooFar$3(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ arrowOffset = getArrowOffset$3(anchorRect, popoverRect);
        var /** @type {?} */ maxOffset = getMaxArrowOffset$3(popoverRect, arrowRect);
        var /** @type {?} */ isTooFar = Math.abs(arrowOffset.y) >= maxOffset;
        return isTooFar;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @param {?} arrowRect
     * @return {?}
     */
    function getPlacementClassModifier$3(anchorRect, popoverRect, arrowRect) {
        var /** @type {?} */ isFlip = isFlipped$3(anchorRect, popoverRect);
        var /** @type {?} */ isTooFar = isArrowTooFar$3(anchorRect, popoverRect, arrowRect);
        if (isTooFar) {
            return constants$1.directionClass.none;
        }
        return isFlip ? constants$1.directionClass.left : constants$1.directionClass.right;
    }
    /**
     * @param {?} anchorRect
     * @param {?} popoverRect
     * @return {?}
     */
    function isFlipped$3(anchorRect, popoverRect) {
        return popoverRect.isOnTheLeft(anchorRect.center());
    }

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LeftPlacementStrategy$2 = (function (_super) {
        __extends$8(LeftPlacementStrategy, _super);
        function LeftPlacementStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        LeftPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'left';
        };
        return LeftPlacementStrategy;
    }(RightPlacementStrategy$2));

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TopPlacementStrategy$2 = (function (_super) {
        __extends$9(TopPlacementStrategy, _super);
        function TopPlacementStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        TopPlacementStrategy.prototype.getId = /**
         * @return {?}
         */
        function () {
            return 'top';
        };
        return TopPlacementStrategy;
    }(BottomPlacementStrategy$2));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} placementService
     * @return {?}
     */
    function placementServiceFactory$2(placementService) {
        var /** @type {?} */ popoverService = new PopoverService$1();
        popoverService.placementStrategies = [
            new LeftPlacementStrategy$2(placementService),
            new TopPlacementStrategy$2(placementService),
            new RightPlacementStrategy$2(placementService),
            new BottomPlacementStrategy$2(placementService),
        ];
        return popoverService;
    }
    var UxDynamicPopoverComponentModule = (function () {
        function UxDynamicPopoverComponentModule() {
        }
        UxDynamicPopoverComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, GeometryModule],
                        exports: [UxDynamicPopoverComponent],
                        declarations: [UxDynamicPopoverComponent],
                        providers: [
                            {
                                provide: PopoverService$1,
                                useFactory: placementServiceFactory$2,
                                deps: [PlacementService]
                            },
                            UxAssetsService,
                            UxDynamicOpenedPopoverService,
                        ],
                        entryComponents: [
                            UxDynamicPopoverComponent,
                        ],
                    },] },
        ];
        return UxDynamicPopoverComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCardItemComponent = (function () {
        function UxCardItemComponent(uxAppShellService) {
            this.uxAppShellService = uxAppShellService;
            this.hasNumberRows = false;
            this.hasHeader = false;
            this.hasHeaderSort = false;
            this.isCompact = false;
            this.index = 0;
            this.hasCardItemCustomContent = false;
            this.sortClicked = new core.EventEmitter();
            this.orderBy = {};
            this.sortedColumn = {};
            this.breakpointsValue = {
                isMobile: false,
                isTablet: false,
                isLtDesktop: false,
                isDesktop: false,
                isXL: false,
                isXXL: false,
            };
        }
        /**
         * @return {?}
         */
        UxCardItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe(function (bkps) {
                _this.breakpointsValue = bkps;
            });
            // Map Data to columns (default)
            if (this.rowItem) {
                this.columns = Object.keys(this.rowItem);
                Object.keys(this.rowItem).map(function (col) {
                    Object.assign(_this.orderBy, (_a = {}, _a[col] = '', _a));
                    var _a;
                });
            }
            // Custom
            if (!this.rowItem && this.columnLabels) {
                this.columns = Object.keys(this.columnLabels);
                Object.keys(this.columnLabels).map(function (col) {
                    Object.assign(_this.orderBy, (_a = {}, _a[col] = '', _a));
                    var _a;
                });
            }
        };
        /**
         * @return {?}
         */
        UxCardItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.breakpointsSubscription.unsubscribe();
        };
        /**
         * Sort columns data based on strings & numbers. 2DO: sort by dates!
         * @param {?} column
         * @param {?=} order
         * @return {?}
         */
        UxCardItemComponent.prototype.sortColumn = /**
         * Sort columns data based on strings & numbers. 2DO: sort by dates!
         * @param {?} column
         * @param {?=} order
         * @return {?}
         */
        function (column, order) {
            // First Reset all columns
            for (var /** @type {?} */ col in this.orderBy) {
                if (this.orderBy[col]) {
                    Object.assign(this.orderBy, (_a = {}, _a[col] = '', _a));
                }
            }
            // Then assign the new orderBy column value
            this.orderBy[column] = order; // or use:   Object.assign(this.orderBy, { [column]: order });
            this.sortedColumn = { column: column, order: this.orderBy[column] };
            console.log('sortColumn() - 2DO:', this.sortedColumn);
            // 2DO !
            // this.sortClicked.emit( this.sortedColumn );
            var _a;
        };
        UxCardItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-item',
                        template: "<div *ngIf=\"hasHeader && index === 0\" class=\"ux-card-item__header\"> <div class=\"ux-card-item__header-row\"> <div *ngIf=\"hasNumberRows && !((uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile)\" class=\"ux-card-item__header-row--hasNumberRows\">&nbsp;</div> <ng-template [ngIf]=\"hasHeaderSort\"> <div *ngFor=\"let col of columns;\" class=\"ux-card-item__header-cell ux-card-item__header-cell--sortable\" (click)=\"sortColumn( col, orderBy[col] === '' || orderBy[col] === 'desc' ? 'asc' : 'desc' )\"> {{ columnLabels[col] ? columnLabels[col] : col }} <span class=\"ml-1 fa\" [ngClass]=\"orderBy[col] === '' ? 'fa-sort ux-u-color-grey-light' : orderBy[col] === 'desc' ? 'fa-sort-desc' : 'fa-sort-asc'\"></span> </div> </ng-template> <ng-template [ngIf]=\"!hasHeaderSort && !((uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile)\"> <div class=\"ux-card-item__header-cell\" *ngFor=\"let col of columns;\"> {{ columnLabels[col] ? columnLabels[col] : col }} </div> </ng-template> </div> </div> <div class=\"ux-card-item__row\" [class.ux-card-item__row--odd]=\"isOdd\"> <!-- DESKTOP --> <ng-template [ngIf]=\"!( (uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile )\"> <div class=\"ux-card-item__row-content\" [class.ux-card-item__row-content--compact]=\"isCompact\"> <div *ngIf=\"hasNumberRows\" class=\"ux-card-item__row-content--hasNumberRows\"> <span class=\"badge badge-secondary badge-small\">{{index + 1}}</span> </div> <ng-container *ngIf=\"rowItem\"> <ux-card-item-cell *ngFor=\"let cellItem of columns\"> {{ rowItem[cellItem] }} </ux-card-item-cell> </ng-container> <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> <!-- <ng-content></ng-content> --> </div> </ng-template> <!-- TABLET / MOBILE --> <ng-template [ngIf]=\"(uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile\"> <div class=\"ux-card-item__row-content\" [class.ux-card-item__row-content--compact]=\"isCompact\"> <div *ngIf=\"hasNumberRows\" class=\"ux-card-item__row-content--hasNumberRows\"> <span class=\"badge badge-secondary badge-small\">{{index + 1}}</span> </div> <div *ngFor=\"let col of columns; let j = index\" class=\"Zd-flex p-2\"> <!-- <div class=\"ux-card-item__row-cell\"> --> <strong class=\"ux-u-color-grey-darker\">{{ columnLabels[col] ? columnLabels[col] : col }}</strong> <!-- </div> --> <ng-container *ngIf=\"rowItem\"> <ux-card-item-cell>{{ rowItem[col] }}</ux-card-item-cell> </ng-container> <!-- <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> --> </div> <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> <!-- <ng-content></ng-content> --> </div> </ng-template> </div> ",
                        styles: ["ux-card-item{flex:1 1 0}uxCardItemCustomContent{display:flex;flex:1 1 0;width:100% !important}.ux-card-item{align-items:center;border:0;border-bottom:1px solid #d2d2d2;display:flex;width:100%}.ux-card-item__header{background:#f5f5f5;display:flex;overflow:hidden;text-overflow:ellipsis;vertical-align:top;width:100%}.ux-card-item__header-row{border-bottom:1px solid #bdbdbd !important;display:flex;vertical-align:bottom;width:100%;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-card-item__header-row--hasNumberRows{min-width:3rem !important}.ux-card-item__header-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-item__header-cell--sortable:hover:not(.ui-state-active){background-color:#4d7cb4;color:white !important;cursor:pointer}.ux-card-item__row{align-items:center;border:0;border-bottom:1px solid #d2d2d2;display:flex;width:100%}.ux-card-item__row-content{align-items:center;display:flex;flex-wrap:wrap;margin-bottom:.89rem !important;margin-top:.89rem !important;width:100% !important}.ux-card-item__row-content--hasNumberRows{padding-left:.89rem;min-width:3rem !important}.ux-card-item__row-content--compact{margin-bottom:.66rem !important;margin-top:.66rem !important}.ux-card-item__row-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-item__row--odd{background-color:#fafafa}.ux-card-item__row:focus,.ux-card-item__row:hover{background-color:#f5f5f5} /*# sourceMappingURL=ux-card-item.component.css.map */"],
                        encapsulation: core.ViewEncapsulation.None,
                    },] },
        ];
        /** @nocollapse */
        UxCardItemComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxCardItemComponent.propDecorators = {
            "rowItem": [{ type: core.Input },],
            "columnLabels": [{ type: core.Input },],
            "hasNumberRows": [{ type: core.Input },],
            "hasHeader": [{ type: core.Input },],
            "hasHeaderSort": [{ type: core.Input },],
            "isCompact": [{ type: core.Input },],
            "isOdd": [{ type: core.Input },],
            "index": [{ type: core.Input },],
            "hasCardItemCustomContent": [{ type: core.Input },],
            "sortClicked": [{ type: core.Output },],
        };
        return UxCardItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCardItemCellComponent = (function () {
        // Breakpoints Observables
        // breakpointsSubscription: Subscription;
        // breakpointsValue: any = {
        //     isMobile: false,
        //     isTablet: false,
        //     isLtDesktop: false,
        //     isDesktop: false,
        //     isXL: false,
        //     isXXL: false,
        // };
        function UxCardItemCellComponent() {
        }
        UxCardItemCellComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-item-cell',
                        template: "<div *ngIf=\"cellItem\" class=\"ux-card-item__cell {{styleClass}}\"> {{ cellItem }} </div> <div *ngIf=\"!cellItem\" class=\"ux-card-item__cell {{styleClass}}\"> <ng-content></ng-content> </div> ",
                        styles: ["ux-card-item-cell{flex:1 1 0}.ux-card-item__cell{display:flex;width:100%} /*# sourceMappingURL=ux-card-item-cell.component.css.map */"],
                        encapsulation: core.ViewEncapsulation.None,
                    },] },
        ];
        // ngOnInit() {
        //     this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe((bkps) => {
        //         this.breakpointsValue = bkps;
        //     });
        // }
        // ngOnDestroy() {
        //     this.breakpointsSubscription.unsubscribe();
        // }
        /** @nocollapse */
        UxCardItemCellComponent.ctorParameters = function () { return []; };
        UxCardItemCellComponent.propDecorators = {
            "cellItem": [{ type: core.Input },],
            "column": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
        };
        return UxCardItemCellComponent;
    }());
    /* tslint:disable */
    // @Directive({ selector: 'uxCardCellContent' })
    // export class UxCardCellContentTagDirective { }
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxCardItemsComponent = (function () {
        function UxCardItemsComponent(uxAppShellService) {
            this.uxAppShellService = uxAppShellService;
            this.columnLabels = {};
            this.hasNumberRows = false;
            this.hasBorders = false;
            this.hasHeader = false;
            this.hasHeaderSort = false;
            this.isCompact = false;
            this.pageSize = 10;
            this.orderBy = {};
            this.breakpointsValue = {
                isMobile: false,
                isTablet: false,
                isLtDesktop: false,
                isDesktop: false,
                isXL: false,
                isXXL: false,
            };
        }
        /**
         * @return {?}
         */
        UxCardItemsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Subscribing to breakpoint changes to adapt the display dynamically
            this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe(function (bkps) {
                _this.breakpointsValue = bkps;
            });
            // Using default config
            if (this.payload) {
                this.payload = this.payload.filter(function (data, index) {
                    return index < _this.pageSize;
                });
                this.columns = Object.keys(this.payload);
                Object.keys(this.payload).map(function (col) {
                    Object.assign(_this.orderBy, (_a = {}, _a[col] = '', _a));
                    var _a;
                });
            }
            // Using custom config
            // ...
        };
        /**
         * @return {?}
         */
        UxCardItemsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.breakpointsSubscription.unsubscribe();
        };
        /**
         * Sort cards data based on strings & numbers. 2DO: sort by dates!
         * @param {?} event
         * @return {?}
         */
        UxCardItemsComponent.prototype.sortCards = /**
         * Sort cards data based on strings & numbers. 2DO: sort by dates!
         * @param {?} event
         * @return {?}
         */
        function (event) {
            console.log('sortCards() event:', event);
            // let response: any;
            // let data: any = this.payload;
            if (this.payload && event) {
                this.payload.sort(function (a, b) {
                    // console.log ( 'A:', typeof(a[event.column]), a[event.column], 'B:', typeof(b[event.column]), b[event.column] );
                    // Set to empty if null values
                    if (a[event.column] === null) {
                        a[event.column] = '';
                    }
                    if (b[event.column] === null) {
                        b[event.column] = '';
                    }
                    if (typeof (a[event.column]) === 'string' && typeof (b[event.column]) === 'string') {
                        if (a[event.column].toLowerCase() < b[event.column].toLowerCase()) {
                            return -1;
                        }
                        if (a[event.column].toLowerCase() > b[event.column].toLowerCase()) {
                            return 1;
                        }
                        return 0;
                    }
                    else {
                        if (a[event.column] < b[event.column]) {
                            return -1;
                        }
                        if (a[event.column] > b[event.column]) {
                            return 1;
                        }
                        return 0;
                    }
                });
                if (event.order === 'desc') {
                    this.payload.reverse();
                }
            }
            // this.payload = response;
            // return response;
        };
        /**
         * @param {?} size
         * @return {?}
         */
        UxCardItemsComponent.prototype._setPageSize = /**
         * @param {?} size
         * @return {?}
         */
        function (size) {
            if (size) {
                this.payload = this.payload.filter(function (data, index) {
                    return index < size;
                });
            }
        };
        UxCardItemsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-items',
                        template: "<div class=\"ux-card-items {{styleClass}}\"> <div class=\"ux-card-items__wrapper\" [ngClass]=\"hasBorders ? 'ux-card-items__wrapper--borders' : 'ux-card-items__wrapper--no-borders'\"> <!-- DEFAULT TEMPLATE --> <ng-template [ngIf]=\"payload\"> <ux-card-item *ngFor=\"let rowItem of payload; let i = index; let odd = odd;\" [rowItem]=\"rowItem\" [columnLabels]=\"columnLabels\" [hasNumberRows]=\"hasNumberRows\" [hasHeader]=\"hasHeader\" [hasHeaderSort]=\"hasHeaderSort\" [isCompact]=\"isCompact\" [isOdd]=\"odd\" [index]=\"i\" (sortClicked)=\"sortCards($event)\"> </ux-card-item> </ng-template> <!-- CUSTOM TEMPLATE --> <ng-template [ngIf]=\"!payload\"> <ng-content></ng-content> </ng-template> </div> </div> ",
                        styles: ["ux-card-items{flex:1 1 0}.ux-card-items{display:flex;margin-bottom:1.25rem}.ux-card-items__wrapper{background:white;border:0;outline:0;width:100%}.ux-card-items__wrapper--no-borders{border:0 solid transparent !important}.ux-card-items__wrapper--borders{border:1px solid #d2d2d2 !important}.ux-card-items__header{background:#f5f5f5;display:flex;overflow:hidden;text-overflow:ellipsis;vertical-align:top;width:100%}.ux-card-items__header-row{border-bottom:1px solid #bdbdbd !important;display:flex;vertical-align:bottom;width:100%;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-card-items__header-row--hasNumberRows{padding-left:.89rem;min-width:3rem !important}.ux-card-items__header-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-items__header-cell--sortable:hover:not(.ui-state-active){background-color:#4d7cb4;color:white !important;cursor:pointer} /*# sourceMappingURL=ux-card-items.component.css.map */"],
                        encapsulation: core.ViewEncapsulation.None,
                    },] },
        ];
        /** @nocollapse */
        UxCardItemsComponent.ctorParameters = function () { return [
            { type: UxAppShellService, },
        ]; };
        UxCardItemsComponent.propDecorators = {
            "payload": [{ type: core.Input },],
            "columnLabels": [{ type: core.Input },],
            "hasNumberRows": [{ type: core.Input },],
            "hasBorders": [{ type: core.Input },],
            "hasHeader": [{ type: core.Input },],
            "hasHeaderSort": [{ type: core.Input },],
            "isCompact": [{ type: core.Input },],
            "pageSize": [{ type: core.Input },],
            "styleClass": [{ type: core.Input },],
        };
        return UxCardItemsComponent;
    }());
    var UxCardItemCustomContentTagDirective = (function () {
        function UxCardItemCustomContentTagDirective() {
        }
        UxCardItemCustomContentTagDirective.decorators = [
            { type: core.Directive, args: [{ selector: 'uxCardItemCustomContent' },] },
        ];
        return UxCardItemCustomContentTagDirective;
    }());
    var UxCardItemsComponentModule = (function () {
        function UxCardItemsComponentModule() {
        }
        UxCardItemsComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                        ],
                        exports: [
                            UxCardItemsComponent,
                            UxCardItemComponent,
                            UxCardItemCellComponent,
                            UxCardItemCustomContentTagDirective,
                        ],
                        declarations: [
                            UxCardItemsComponent,
                            UxCardItemComponent,
                            UxCardItemCellComponent,
                            UxCardItemCustomContentTagDirective,
                        ],
                    },] },
        ];
        return UxCardItemsComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var UxAllModule = (function () {
        function UxAllModule() {
        }
        UxAllModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule, router.RouterModule, forms.ReactiveFormsModule, forms.FormsModule,
                            UxLayoutAppShellComponentModule,
                            UxLayoutHeaderProfileComponentModule,
                            UxLayoutSidebarItemComponentModule,
                            UxLayoutSidebarItemsComponentModule,
                            UxLayoutNavBarActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemComponentModule,
                            UxLayoutNavBarActionItemNotificationsComponentModule,
                            UxLayoutOverlayPanelComponentModule,
                            UxLayoutBreadcrumbsComponentModule,
                            UxLayoutTopMessageComponentModule,
                            UxLayoutBannerComponentModule,
                            UxLayoutHorizontalModule,
                            UxLayoutPageHeaderComponentModule,
                            UxLayoutPageHeaderActionIconItemComponentModule,
                            UxLayoutFooterActionBarComponentModule,
                            UxLayoutFlexContentModule,
                            UxOrderByPipeModule,
                            UxFilterPipeModule,
                            UxTruncatePipeModule,
                            UxCurrencyPipeModule,
                            UxNumberFormatPipeModule,
                            UxMomentTzPipeModule,
                            UxIsoToCountryPipeModule,
                            UxScrollHandlerDirectiveModule,
                            UxMaxlengthModule,
                            UxTooltipModule,
                            UxAutoResizeModule,
                            UxCollapsibleDirectiveModule,
                            UxHasPermissionDirectiveModule,
                            UxTemplateDirectiveModule,
                            UxSmoothScrollDirectiveModule,
                            UxCleaveModule,
                            NguiAutoCompleteDropdownButtonModule,
                            UxAlertComponentModule,
                            UxDashboardCardComponentModule,
                            UxDashboardButtonsComponentModule,
                            UxDashboardButtonComponentModule,
                            UxActionBoxComponentModule,
                            UxPanelComponentModule,
                            UxPanelsComponentModule,
                            UxTabComponentModule,
                            UxTabsComponentModule,
                            UxTabsBarComponentModule,
                            UxStaticTabsComponentModule,
                            UxTimelineItemsComponentModule,
                            UxTimelineItemComponentModule,
                            UxWizardStepComponentModule,
                            UxWizardStepsComponentModule,
                            UxTreeListComponentModule,
                            UxTreeListItemComponentModule,
                            UxSwitchComponentModule,
                            UxButtonComponentModule,
                            UxControlFeedbackComponentModule,
                            UxDropdownButtonComponentModule,
                            UxDropdownButtonItemComponentModule,
                            UxFieldsetComponentModule,
                            UxModalComponentModule,
                            UxDynamicModalComponentModule,
                            UxDynamicMessageBoxComponentModule,
                            UxDynamicPopoverComponentModule,
                            UxLanguageSelectorComponentModule,
                            UxSearchInputComponentModule,
                            UxBlockContentComponentModule,
                            UxTagComponentModule,
                            UxIconComponentModule,
                            UxIconToggleComponentModule,
                            UxIconBoxComponentModule,
                            UxMarkerComponentModule,
                            UxLabelComponentModule,
                            UxDateTagComponentModule,
                            UxProgressCircleComponentModule,
                            UxCarouselItemsComponentModule,
                            UxCarouselItemComponentModule,
                            UxGrowlComponentModule,
                            UxBlockDocumentComponentModule,
                            UxTreeComponentModule,
                            UxTimebarComponentModule,
                            UxBadgeComponentModule,
                            UxAutocompleteTagComponentModule,
                            UxToolbarFilterComponentModule,
                            UxButtonGroupComponentModule,
                            UxButtonGroupItemComponentModule,
                            UxSplitButtonComponentModule,
                            UxMessageBoxComponentModule,
                            UxBadgeGroupComponentModule,
                            UxNotificationsPanelComponentModule,
                            UxNotificationItemComponentModule,
                            UxStickyComponentModule,
                            UxPieChartComponentModule,
                            UxPieChartLegendItemComponentModule,
                            UxPieChartGroupComponentModule,
                            UxOverlayComponentModule,
                            UxListItemComponentModule.forRoot(),
                            UxListItemsComponentModule,
                            UxMenuItemComponentModule.forRoot(),
                            UxDropdownComponentModule,
                            UxFieldSearchComponentModule,
                            UxLoadingIndicatorComponentModule,
                            UxPopoverComponentModule,
                            UxDiscussionThreadComponentModule,
                            UxDiscussionThreadItemComponentModule,
                            UxFormControlComponentModule,
                            UxFormGroupComponentModule,
                            UxDisableContentComponentModule,
                            UxFilterResultsComponentModule,
                            UxEditorComponentModule,
                            UxCardItemsComponentModule,
                            UxErrorOutputComponentModule
                        ],
                        declarations: [],
                        exports: [
                            common.CommonModule, router.RouterModule, forms.ReactiveFormsModule, forms.FormsModule,
                            UxLayoutAppShellComponentModule,
                            UxLayoutHeaderProfileComponentModule,
                            UxLayoutSidebarItemComponentModule,
                            UxLayoutSidebarItemsComponentModule,
                            UxLayoutNavBarActionItemComponentModule,
                            UxLayoutNavBarLeftActionItemComponentModule,
                            UxLayoutNavBarActionItemNotificationsComponentModule,
                            UxLayoutOverlayPanelComponentModule,
                            UxLayoutBreadcrumbsComponentModule,
                            UxLayoutTopMessageComponentModule,
                            UxLayoutBannerComponentModule,
                            UxLayoutHorizontalModule,
                            UxLayoutPageHeaderComponentModule,
                            UxLayoutPageHeaderActionIconItemComponentModule,
                            UxLayoutFooterActionBarComponentModule,
                            UxLayoutFlexContentModule,
                            UxOrderByPipeModule,
                            UxFilterPipeModule,
                            UxTruncatePipeModule,
                            UxCurrencyPipeModule,
                            UxNumberFormatPipeModule,
                            UxMomentTzPipeModule,
                            UxIsoToCountryPipeModule,
                            UxScrollHandlerDirectiveModule,
                            UxMaxlengthModule,
                            UxTooltipModule,
                            UxAutoResizeModule,
                            UxCollapsibleDirectiveModule,
                            UxHasPermissionDirectiveModule,
                            UxSmoothScrollDirectiveModule,
                            UxTemplateDirectiveModule,
                            UxCleaveModule,
                            NguiAutoCompleteDropdownButtonModule,
                            UxAlertComponentModule,
                            UxDashboardCardComponentModule,
                            UxDashboardButtonsComponentModule,
                            UxDashboardButtonComponentModule,
                            UxActionBoxComponentModule,
                            UxPanelComponentModule,
                            UxPanelsComponentModule,
                            UxTabComponentModule,
                            UxTabsComponentModule,
                            UxTabsBarComponentModule,
                            UxStaticTabsComponentModule,
                            UxTimelineItemsComponentModule,
                            UxTimelineItemComponentModule,
                            UxWizardStepComponentModule,
                            UxWizardStepsComponentModule,
                            UxTreeListComponentModule,
                            UxTreeListItemComponentModule,
                            UxSwitchComponentModule,
                            UxButtonComponentModule,
                            UxControlFeedbackComponentModule,
                            UxDropdownButtonComponentModule,
                            UxDropdownButtonItemComponentModule,
                            UxFieldsetComponentModule,
                            UxModalComponentModule,
                            UxDynamicModalComponentModule,
                            UxDynamicMessageBoxComponentModule,
                            UxDynamicPopoverComponentModule,
                            UxLanguageSelectorComponentModule,
                            UxSearchInputComponentModule,
                            UxBlockContentComponentModule,
                            UxTagComponentModule,
                            UxIconComponentModule,
                            UxIconToggleComponentModule,
                            UxIconBoxComponentModule,
                            UxMarkerComponentModule,
                            UxLabelComponentModule,
                            UxDateTagComponentModule,
                            UxProgressCircleComponentModule,
                            UxCarouselItemsComponentModule,
                            UxCarouselItemComponentModule,
                            UxGrowlComponentModule,
                            UxBlockDocumentComponentModule,
                            UxTreeComponentModule,
                            UxTimebarComponentModule,
                            UxBadgeComponentModule,
                            UxAutocompleteTagComponentModule,
                            UxToolbarFilterComponentModule,
                            UxButtonGroupComponentModule,
                            UxButtonGroupItemComponentModule,
                            UxSplitButtonComponentModule,
                            UxMessageBoxComponentModule,
                            UxBadgeGroupComponentModule,
                            UxNotificationsPanelComponentModule,
                            UxNotificationItemComponentModule,
                            UxStickyComponentModule,
                            UxPieChartComponentModule,
                            UxPieChartLegendItemComponentModule,
                            UxPieChartGroupComponentModule,
                            UxOverlayComponentModule,
                            UxListItemComponentModule,
                            UxListItemsComponentModule,
                            UxMenuItemComponentModule,
                            UxDropdownComponentModule,
                            UxFieldSearchComponentModule,
                            UxLoadingIndicatorComponentModule,
                            UxPopoverComponentModule,
                            UxDiscussionThreadComponentModule,
                            UxDiscussionThreadItemComponentModule,
                            UxFormControlComponentModule,
                            UxFormGroupComponentModule,
                            UxDisableContentComponentModule,
                            UxFilterResultsComponentModule,
                            UxEditorComponentModule,
                            UxCardItemsComponentModule,
                            UxErrorOutputComponentModule
                        ],
                        providers: [
                            UxDynamicModalService,
                            UxDynamicMessageBoxService,
                            UxDynamicPopoverService,
                            UxDynamicComponentService,
                        ]
                    },] },
        ];
        return UxAllModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /* tslint:enable */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.CoreModule = CoreModule;
    exports.getConfig = getConfig;
    exports.CONFIG_TOKEN = CONFIG_TOKEN;
    exports.LocalizationService = LocalizationService;
    exports.translateStaticLoader = translateStaticLoader;
    exports.translateConfig = translateConfig;
    exports.StorageService = StorageService;
    exports.LocalstorageService = LocalstorageService;
    exports.UserService = UserService;
    exports.UxAuthService = UxAuthService;
    exports.UxAuthGuardService = UxAuthGuardService;
    exports.UxPermissionService = UxPermissionService;
    exports.UxDynamicMenuService = UxDynamicMenuService;
    exports.RouteService = RouteService;
    exports.GlobalErrorHandler = GlobalErrorHandler;
    exports.QueueApiService = QueueApiService;
    exports.UxService = UxService;
    exports.UxDomService = UxDomService;
    exports.UxAppShellService = UxAppShellService;
    exports.DYNAMIC_COMPONENT_CONFIG = DYNAMIC_COMPONENT_CONFIG;
    exports.UxDynamicComponentService = UxDynamicComponentService;
    exports.UxAssetsService = UxAssetsService;
    exports.UxTimezoneService = UxTimezoneService;
    exports.UxErrorFeedbackService = UxErrorFeedbackService;
    exports.UxErrorManager = UxErrorManager;
    exports.OpenidConnectService = OpenidConnectService;
    exports.StoreService = StoreService;
    exports.reducers = reducers;
    exports.localStorageSync = localStorageSync;
    exports.getAppState = getAppState;
    exports.getUserState = getUserState;
    exports.getUserIdState = getUserIdState;
    exports.getUserPrefsState = getUserPrefsState;
    exports.getAppConnection = getAppConnection;
    exports.getAppStatus = getAppStatus;
    exports.getApiQueue = getApiQueue;
    exports.getApiQueueById = getApiQueueById;
    exports.appReducer = reducer;
    exports.userReducer = reducer$2;
    exports.getUserId = getUserId;
    exports.getUserPreferences = getUserPreferences;
    exports.notificationReducer = reducer$1;
    exports.RouteUpdateAction = RouteUpdateAction;
    exports.ChangeModuleAction = ChangeModuleAction;
    exports.ApiQueueAdd = ApiQueueAdd;
    exports.ApiQueueRemove = ApiQueueRemove;
    exports.UpdateListAction = UpdateListAction;
    exports.UpdateUserDetailAction = UpdateUserDetailAction;
    exports.UpdateUserPreferencesAction = UpdateUserPreferencesAction;
    exports.CoreModuleEffects = CoreModuleEffects;
    exports.LOG_LEVEL = LOG_LEVEL;
    exports.TraceService = TraceService;
    exports.HttpService = HttpService;
    exports.RequestErrorInterceptor = RequestErrorInterceptor;
    exports.ResponseErrorHandlerTypes = ResponseErrorHandlerTypes;
    exports.CachePreventionInterceptor = CachePreventionInterceptor;
    exports.CorsSecurityInterceptor = CorsSecurityInterceptor;
    exports.CsrfPreventionInterceptor = CsrfPreventionInterceptor;
    exports.EuLoginSessionTimeoutHandlingInterceptor = EuLoginSessionTimeoutHandlingInterceptor;
    exports.OpenidConnectInterceptor = OpenidConnectInterceptor;
    exports.UxBadge = UxBadge;
    exports.UxLink = UxLink;
    exports.UxErrorOutput = UxErrorOutput;
    exports.UxMessageSeverity = UxMessageSeverity;
    exports.UxValidationErrorClass = UxValidationErrorClass;
    exports.transformToUxHttpResponse = transformToUxHttpResponse;
    exports.UxPublishErrorFeedbackEvent = UxPublishErrorFeedbackEvent;
    exports.UxClearErrorFeedbackEvent = UxClearErrorFeedbackEvent;
    exports.withUxErrorManager = withUxErrorManager;
    exports.UX_COLORS = UX_COLORS;
    exports.UX_I18N = UX_I18N;
    exports.UX_COUNTRIES = UX_COUNTRIES;
    exports.UX_TIMEZONES = UX_TIMEZONES;
    exports.UxOrderByPipe = UxOrderByPipe;
    exports.UxOrderByPipeModule = UxOrderByPipeModule;
    exports.UxFilterPipe = UxFilterPipe;
    exports.UxFilterPipeModule = UxFilterPipeModule;
    exports.UxTruncatePipe = UxTruncatePipe;
    exports.UxTruncatePipeModule = UxTruncatePipeModule;
    exports.UxCurrencyPipe = UxCurrencyPipe;
    exports.UxCurrencyPipeModule = UxCurrencyPipeModule;
    exports.UxNumberFormatPipe = UxNumberFormatPipe;
    exports.UxNumberFormatPipeModule = UxNumberFormatPipeModule;
    exports.UxMomentTzPipe = UxMomentTzPipe;
    exports.UxMomentTzPipeModule = UxMomentTzPipeModule;
    exports.UxIsoToCountryPipe = UxIsoToCountryPipe;
    exports.UxIsoToCountryPipeModule = UxIsoToCountryPipeModule;
    exports.UxScrollHandlerDirective = UxScrollHandlerDirective;
    exports.UxScrollHandlerElementDirective = UxScrollHandlerElementDirective;
    exports.UxScrollHandlerDirectiveModule = UxScrollHandlerDirectiveModule;
    exports.UxMaxlengthDirective = UxMaxlengthDirective;
    exports.UxMaxlengthModule = UxMaxlengthModule;
    exports.UxTooltip = UxTooltip;
    exports.UxTooltipModule = UxTooltipModule;
    exports.UxAutoResizeDirective = UxAutoResizeDirective;
    exports.UxAutoResizeModule = UxAutoResizeModule;
    exports.UxCollapsibleDirective = UxCollapsibleDirective;
    exports.UxCollapsibleDirectiveModule = UxCollapsibleDirectiveModule;
    exports.UxHasPermissionDirective = UxHasPermissionDirective;
    exports.UxHasPermissionDirectiveModule = UxHasPermissionDirectiveModule;
    exports.UxSmoothScrollToDirective = UxSmoothScrollToDirective;
    exports.UxSmoothScrollDirective = UxSmoothScrollDirective;
    exports.UxSmoothScrollDirectiveModule = UxSmoothScrollDirectiveModule;
    exports.UxCleaveDirective = UxCleaveDirective;
    exports.UxCleaveModule = UxCleaveModule;
    exports.UxTemplateDirective = UxTemplateDirective;
    exports.UxTemplateDirectiveModule = UxTemplateDirectiveModule;
    exports.NguiAutoCompleteDropdownButtonDirective = NguiAutoCompleteDropdownButtonDirective;
    exports.NguiAutoCompleteDropdownButtonModule = NguiAutoCompleteDropdownButtonModule;
    exports.UxLayoutAppShellComponent = UxLayoutAppShellComponent;
    exports.UxAppShellSidebarContentTagDirective = UxAppShellSidebarContentTagDirective;
    exports.UxAppShellSidebarHeaderContentTagDirective = UxAppShellSidebarHeaderContentTagDirective;
    exports.UxAppShellHeaderRightContentTagDirective = UxAppShellHeaderRightContentTagDirective;
    exports.UxAppShellHeaderTitleContentTagDirective = UxAppShellHeaderTitleContentTagDirective;
    exports.UxAppShellMainContentTagDirective = UxAppShellMainContentTagDirective;
    exports.UxAppShellNavBarItemsContentTagDirective = UxAppShellNavBarItemsContentTagDirective;
    exports.UxAppShellNavBarLeftItemsContentTagDirective = UxAppShellNavBarLeftItemsContentTagDirective;
    exports.UxAppShellFooterContentTagDirective = UxAppShellFooterContentTagDirective;
    exports.UxAppShellOverlayPanelHeaderTagDirective = UxAppShellOverlayPanelHeaderTagDirective;
    exports.UxAppShellTopMessageContentTagDirective = UxAppShellTopMessageContentTagDirective;
    exports.UxAppShellErrorStateContentTagDirective = UxAppShellErrorStateContentTagDirective;
    exports.UxLayoutAppShellComponentModule = UxLayoutAppShellComponentModule;
    exports.UxLayoutHeaderProfileComponent = UxLayoutHeaderProfileComponent;
    exports.UxLayoutHeaderProfileMenuContentTagDirective = UxLayoutHeaderProfileMenuContentTagDirective;
    exports.UxLayoutHeaderProfileNotLoggedInContentTagDirective = UxLayoutHeaderProfileNotLoggedInContentTagDirective;
    exports.UxLayoutHeaderProfileSubContentTagDirective = UxLayoutHeaderProfileSubContentTagDirective;
    exports.UxLayoutHeaderProfileComponentModule = UxLayoutHeaderProfileComponentModule;
    exports.UxLayoutSidebarItemsComponent = UxLayoutSidebarItemsComponent;
    exports.UxLayoutSidebarItemsComponentModule = UxLayoutSidebarItemsComponentModule;
    exports.UxLayoutSidebarItemComponent = UxLayoutSidebarItemComponent;
    exports.UxLayoutSidebarItemComponentModule = UxLayoutSidebarItemComponentModule;
    exports.UxLayoutNavBarActionItemComponent = UxLayoutNavBarActionItemComponent;
    exports.UxLayoutNavBarOverlayPanelContentTagDirective = UxLayoutNavBarOverlayPanelContentTagDirective;
    exports.UxLayoutNavBarOverlayHeaderPanelContentTagDirective = UxLayoutNavBarOverlayHeaderPanelContentTagDirective;
    exports.UxLayoutNavBarItemContentTagDirective = UxLayoutNavBarItemContentTagDirective;
    exports.UxLayoutNavBarActionItemComponentModule = UxLayoutNavBarActionItemComponentModule;
    exports.UxLayoutNavBarLeftActionItemComponent = UxLayoutNavBarLeftActionItemComponent;
    exports.UxLayoutNavBarLeftActionItemComponentModule = UxLayoutNavBarLeftActionItemComponentModule;
    exports.UxLayoutNavBarActionItemNotificationsComponent = UxLayoutNavBarActionItemNotificationsComponent;
    exports.UxLayoutNavBarActionItemNotificationsComponentModule = UxLayoutNavBarActionItemNotificationsComponentModule;
    exports.UxAppComponent = UxAppComponent;
    exports.UxAppModule = UxAppModule;
    exports.UxLayoutBreadcrumbsComponent = UxLayoutBreadcrumbsComponent;
    exports.UxLayoutBreadcrumbsComponentModule = UxLayoutBreadcrumbsComponentModule;
    exports.UxBreadcrumbsService = UxBreadcrumbsService;
    exports.UxLayoutOverlayPanelComponent = UxLayoutOverlayPanelComponent;
    exports.UxLayoutOverlayPanelComponentModule = UxLayoutOverlayPanelComponentModule;
    exports.UxLayoutTopMessageComponent = UxLayoutTopMessageComponent;
    exports.UxLayoutTopMessageComponentModule = UxLayoutTopMessageComponentModule;
    exports.UxLayoutBannerComponent = UxLayoutBannerComponent;
    exports.UxLayoutBannerComponentModule = UxLayoutBannerComponentModule;
    exports.UxLayoutHorizontalComponent = UxLayoutHorizontalComponent;
    exports.UxLayoutHorizontalLeftTagDirective = UxLayoutHorizontalLeftTagDirective;
    exports.UxLayoutHorizontalRightTagDirective = UxLayoutHorizontalRightTagDirective;
    exports.UxLayoutHorizontalCenterTagDirective = UxLayoutHorizontalCenterTagDirective;
    exports.UxLayoutHorizontalModule = UxLayoutHorizontalModule;
    exports.UxLayoutPageHeaderComponent = UxLayoutPageHeaderComponent;
    exports.UxLayoutPageHeaderActionsContentTagDirective = UxLayoutPageHeaderActionsContentTagDirective;
    exports.UxLayoutPageHeaderActionIconsContentTagDirective = UxLayoutPageHeaderActionIconsContentTagDirective;
    exports.UxLayoutPageHeaderComponentModule = UxLayoutPageHeaderComponentModule;
    exports.UxLayoutPageHeaderActionIconItemComponent = UxLayoutPageHeaderActionIconItemComponent;
    exports.UxLayoutPageHeaderActionIconItemComponentModule = UxLayoutPageHeaderActionIconItemComponentModule;
    exports.UxLayoutFooterActionBarComponent = UxLayoutFooterActionBarComponent;
    exports.UxLayoutFooterActionBarContentTagDirective = UxLayoutFooterActionBarContentTagDirective;
    exports.UxLayoutFooterActionBarComponentModule = UxLayoutFooterActionBarComponentModule;
    exports.UxLayoutFlexContentComponent = UxLayoutFlexContentComponent;
    exports.UxLayoutFlexContentModule = UxLayoutFlexContentModule;
    exports.UxLanguageSelectorComponent = UxLanguageSelectorComponent;
    exports.UxLanguageSelectorComponentModule = UxLanguageSelectorComponentModule;
    exports.UxLanguage = UxLanguage;
    exports.UxEuLanguages = UxEuLanguages;
    exports.UxSearchInputComponent = UxSearchInputComponent;
    exports.UxSearchInputComponentModule = UxSearchInputComponentModule;
    exports.UxTagComponent = UxTagComponent;
    exports.UxTagComponentModule = UxTagComponentModule;
    exports.UxIconComponent = UxIconComponent;
    exports.UxIconComponentModule = UxIconComponentModule;
    exports.UxIconToggleComponent = UxIconToggleComponent;
    exports.UxIconToggleComponentModule = UxIconToggleComponentModule;
    exports.UxIconBoxComponent = UxIconBoxComponent;
    exports.UxIconBoxComponentModule = UxIconBoxComponentModule;
    exports.UxMarkerComponent = UxMarkerComponent;
    exports.UxMarkerComponentModule = UxMarkerComponentModule;
    exports.UxLabelComponent = UxLabelComponent;
    exports.UxLabelContentTagDirective = UxLabelContentTagDirective;
    exports.UxLabelSubLabelTagDirective = UxLabelSubLabelTagDirective;
    exports.UxLabelComponentModule = UxLabelComponentModule;
    exports.UxDateTagComponent = UxDateTagComponent;
    exports.UxDateTagComponentModule = UxDateTagComponentModule;
    exports.UxToolbarFilterComponent = UxToolbarFilterComponent;
    exports.UxToolbarFilterButtonsTagDirective = UxToolbarFilterButtonsTagDirective;
    exports.UxToolbarFilterComponentModule = UxToolbarFilterComponentModule;
    exports.UxBlockDocumentComponent = UxBlockDocumentComponent;
    exports.UxBlockDocumentComponentModule = UxBlockDocumentComponentModule;
    exports.UxBlockContentComponent = UxBlockContentComponent;
    exports.UxBlockContentComponentModule = UxBlockContentComponentModule;
    exports.UxDisableContentComponent = UxDisableContentComponent;
    exports.UxDisableContentComponentModule = UxDisableContentComponentModule;
    exports.UxProgressCircleComponent = UxProgressCircleComponent;
    exports.UxProgressCircleComponentModule = UxProgressCircleComponentModule;
    exports.UxPanelComponent = UxPanelComponent;
    exports.UxPanelHeaderTagDirective = UxPanelHeaderTagDirective;
    exports.UxPanelFooterTagDirective = UxPanelFooterTagDirective;
    exports.UxPanelHeaderRightContentTagDirective = UxPanelHeaderRightContentTagDirective;
    exports.UxPanelHeaderWithDescendantsTagDirective = UxPanelHeaderWithDescendantsTagDirective;
    exports.UxPanelFooterWithDescendantsTagDirective = UxPanelFooterWithDescendantsTagDirective;
    exports.UxPanelHeaderRightContentWithDescendantsTagDirective = UxPanelHeaderRightContentWithDescendantsTagDirective;
    exports.UxPanelHeaderStatusIndicatorContentTagDirective = UxPanelHeaderStatusIndicatorContentTagDirective;
    exports.UxPanelSubHeaderContentTagDirective = UxPanelSubHeaderContentTagDirective;
    exports.UxPanelComponentModule = UxPanelComponentModule;
    exports.UxPanelsComponent = UxPanelsComponent;
    exports.UxPanelsComponentModule = UxPanelsComponentModule;
    exports.UxActionBoxComponent = UxActionBoxComponent;
    exports.UxActionBoxComponentModule = UxActionBoxComponentModule;
    exports.UxActionBoxItem = UxActionBoxItem;
    exports.UxAlertComponent = UxAlertComponent;
    exports.UxAlertComponentModule = UxAlertComponentModule;
    exports.UxDashboardCardComponent = UxDashboardCardComponent;
    exports.UxDashboardCardComponentModule = UxDashboardCardComponentModule;
    exports.UxControlFeedbackComponent = UxControlFeedbackComponent;
    exports.UxControlFeedbackComponentModule = UxControlFeedbackComponentModule;
    exports.UxFieldSearchComponent = UxFieldSearchComponent;
    exports.UxFieldSearchFilterContentTagDirective = UxFieldSearchFilterContentTagDirective;
    exports.UxFieldSearchComponentModule = UxFieldSearchComponentModule;
    exports.UxFieldsetComponent = UxFieldsetComponent;
    exports.UxFieldsetLabelRightContentTagDirective = UxFieldsetLabelRightContentTagDirective;
    exports.UxFieldsetComponentModule = UxFieldsetComponentModule;
    exports.UX_SWITCH_VALUE_ACCESSOR = UX_SWITCH_VALUE_ACCESSOR;
    exports.UxSwitchComponent = UxSwitchComponent;
    exports.UxSwitchComponentModule = UxSwitchComponentModule;
    exports.UxBadgeComponent = UxBadgeComponent;
    exports.UxBadgeComponentModule = UxBadgeComponentModule;
    exports.UxBadgeGroupComponent = UxBadgeGroupComponent;
    exports.UxBadgeGroupComponentModule = UxBadgeGroupComponentModule;
    exports.UxButtonComponent = UxButtonComponent;
    exports.UxButtonComponentModule = UxButtonComponentModule;
    exports.UX_DROPDOWNBUTTON_VALUE_ACCESSOR = UX_DROPDOWNBUTTON_VALUE_ACCESSOR;
    exports.UxDropdownButtonComponent = UxDropdownButtonComponent;
    exports.UxDropdownButtonComponentModule = UxDropdownButtonComponentModule;
    exports.UxDropdownButtonItemComponent = UxDropdownButtonItemComponent;
    exports.UxDropdownButtonItemComponentModule = UxDropdownButtonItemComponentModule;
    exports.UxDropdownComponent = UxDropdownComponent;
    exports.UxDropdownComponentModule = UxDropdownComponentModule;
    exports.UxGrowlComponent = UxGrowlComponent;
    exports.UxGrowlComponentModule = UxGrowlComponentModule;
    exports.UxDashboardButtonsComponent = UxDashboardButtonsComponent;
    exports.UxDashboardButtonsComponentModule = UxDashboardButtonsComponentModule;
    exports.UxDashboardButtonComponent = UxDashboardButtonComponent;
    exports.UxDashboardButtonComponentModule = UxDashboardButtonComponentModule;
    exports.UxTabComponent = UxTabComponent;
    exports.UxTabComponentModule = UxTabComponentModule;
    exports.UxTabsComponent = UxTabsComponent;
    exports.UxTabsRightContentTagDirective = UxTabsRightContentTagDirective;
    exports.UxTabsComponentModule = UxTabsComponentModule;
    exports.UxTab = UxTab;
    exports.UxTabService = UxTabService;
    exports.UxTabsBarComponent = UxTabsBarComponent;
    exports.UxTabsBarRightContentTagDirective = UxTabsBarRightContentTagDirective;
    exports.UxTabsBarComponentModule = UxTabsBarComponentModule;
    exports.UxStaticTabsComponent = UxStaticTabsComponent;
    exports.UxStaticTabsComponentModule = UxStaticTabsComponentModule;
    exports.UxTimelineItemsComponent = UxTimelineItemsComponent;
    exports.UxTimelineItemsComponentModule = UxTimelineItemsComponentModule;
    exports.UxTimelineItemComponent = UxTimelineItemComponent;
    exports.UxTimelineItemComponentModule = UxTimelineItemComponentModule;
    exports.UxWizardStepComponent = UxWizardStepComponent;
    exports.UxWizardStepContentTagDirective = UxWizardStepContentTagDirective;
    exports.UxWizardStepComponentModule = UxWizardStepComponentModule;
    exports.UxWizardStepsComponent = UxWizardStepsComponent;
    exports.UxWizardStepsComponentModule = UxWizardStepsComponentModule;
    exports.UxWizardStep = UxWizardStep;
    exports.UxWizardStepService = UxWizardStepService;
    exports.UxTreeListComponent = UxTreeListComponent;
    exports.UxTreeListToolbarContentTagDirective = UxTreeListToolbarContentTagDirective;
    exports.UxTreeListComponentModule = UxTreeListComponentModule;
    exports.UxTreeListItemComponent = UxTreeListItemComponent;
    exports.UxTreeListItemCustomContentTagDirective = UxTreeListItemCustomContentTagDirective;
    exports.UxTreeListItemRightContentTagDirective = UxTreeListItemRightContentTagDirective;
    exports.UxTreeListItemSubLabelTagDirective = UxTreeListItemSubLabelTagDirective;
    exports.UxTreeListItemDetailsContentTagDirective = UxTreeListItemDetailsContentTagDirective;
    exports.UxTreeListItemSubContainerContentTagDirective = UxTreeListItemSubContainerContentTagDirective;
    exports.UxTreeListItemComponentModule = UxTreeListItemComponentModule;
    exports.UxModalComponent = UxModalComponent;
    exports.UxModalBodyTagDirective = UxModalBodyTagDirective;
    exports.UxModalFooterTagDirective = UxModalFooterTagDirective;
    exports.UxModalHeaderTagDirective = UxModalHeaderTagDirective;
    exports.UxModalComponentModule = UxModalComponentModule;
    exports.UxCarouselItemComponent = UxCarouselItemComponent;
    exports.UxCarouselItemComponentModule = UxCarouselItemComponentModule;
    exports.UxCarouselItemsComponent = UxCarouselItemsComponent;
    exports.UxCarouselItemsComponentModule = UxCarouselItemsComponentModule;
    exports.UxTreeNodeComponent = UxTreeNodeComponent;
    exports.UxTreeComponent = UxTreeComponent;
    exports.UxTreeComponentModule = UxTreeComponentModule;
    exports.UxTimebarItemUI = UxTimebarItemUI;
    exports.UxTimebarComponent = UxTimebarComponent;
    exports.UxTimebarComponentModule = UxTimebarComponentModule;
    exports.UxTimebarItem = UxTimebarItem;
    exports.UxAutocompleteTagItem = UxAutocompleteTagItem;
    exports.UX_AUTOCOMPLETETAG_VALUE_ACCESSOR = UX_AUTOCOMPLETETAG_VALUE_ACCESSOR;
    exports.UxAutocompleteTagComponent = UxAutocompleteTagComponent;
    exports.UxAutocompleteTagComponentModule = UxAutocompleteTagComponentModule;
    exports.UxButtonGroupComponent = UxButtonGroupComponent;
    exports.UxButtonGroupComponentModule = UxButtonGroupComponentModule;
    exports.UxButtonGroupItemComponent = UxButtonGroupItemComponent;
    exports.UxButtonGroupItemComponentModule = UxButtonGroupItemComponentModule;
    exports.UxSplitButtonComponent = UxSplitButtonComponent;
    exports.UxSplitButtonComponentModule = UxSplitButtonComponentModule;
    exports.UxMessageBoxComponent = UxMessageBoxComponent;
    exports.UxMessageBoxFooterTagDirective = UxMessageBoxFooterTagDirective;
    exports.UxMessageBoxComponentModule = UxMessageBoxComponentModule;
    exports.UxOverlayComponent = UxOverlayComponent;
    exports.UxOverlayComponentModule = UxOverlayComponentModule;
    exports.UxNotificationItemComponent = UxNotificationItemComponent;
    exports.UxNotificationItemComponentModule = UxNotificationItemComponentModule;
    exports.UxNotificationsPanelComponent = UxNotificationsPanelComponent;
    exports.UxNotificationsPanelComponentModule = UxNotificationsPanelComponentModule;
    exports.UxStickyComponent = UxStickyComponent;
    exports.UxStickyComponentModule = UxStickyComponentModule;
    exports.UxPieChartComponent = UxPieChartComponent;
    exports.UxPieChartCustomLegendTagDirective = UxPieChartCustomLegendTagDirective;
    exports.UxPieChartComponentModule = UxPieChartComponentModule;
    exports.UxPieChartLegendItemComponent = UxPieChartLegendItemComponent;
    exports.UxPieChartLegendItemComponentModule = UxPieChartLegendItemComponentModule;
    exports.UxPieChartGroupComponent = UxPieChartGroupComponent;
    exports.UxPieChartGroupComponentModule = UxPieChartGroupComponentModule;
    exports.UxDynamicMessageBoxService = UxDynamicMessageBoxService;
    exports.UxDynamicMessageBoxComponent = UxDynamicMessageBoxComponent;
    exports.UxDynamicMessageBoxComponentModule = UxDynamicMessageBoxComponentModule;
    exports.UxDynamicMessageBoxConfig = UxDynamicMessageBoxConfig;
    exports.UxDynamicModalComponent = UxDynamicModalComponent;
    exports.UxDynamicModalBodyTagDirective = UxDynamicModalBodyTagDirective;
    exports.UxDynamicModalFooterTagDirective = UxDynamicModalFooterTagDirective;
    exports.UxDynamicModalHeaderTagDirective = UxDynamicModalHeaderTagDirective;
    exports.UxDynamicMessageBoxFooterTagDirective = UxDynamicMessageBoxFooterTagDirective;
    exports.UxDynamicModalComponentModule = UxDynamicModalComponentModule;
    exports.UxDynamicModalService = UxDynamicModalService;
    exports.UxItemComponent = UxItemComponent;
    exports.UxItemComponentModule = UxItemComponentModule;
    exports.UxListItemComponent = UxListItemComponent;
    exports.UxListItemSubLabelTagDirective = UxListItemSubLabelTagDirective;
    exports.UxListtemContentTagDirective = UxListtemContentTagDirective;
    exports.UxListItemComponentModule = UxListItemComponentModule;
    exports.UxListItemsComponent = UxListItemsComponent;
    exports.UxListItemsComponentModule = UxListItemsComponentModule;
    exports.UxMenuItemComponent = UxMenuItemComponent;
    exports.UxMenuItemComponentModule = UxMenuItemComponentModule;
    exports.UxLoadingIndicatorComponent = UxLoadingIndicatorComponent;
    exports.UxLoadingIndicatorComponentModule = UxLoadingIndicatorComponentModule;
    exports.placementServiceFactory = placementServiceFactory$1;
    exports.UxPopoverComponentModule = UxPopoverComponentModule;
    exports.UxPopoverComponent = UxPopoverComponent;
    exports.UxDiscussionThreadComponent = UxDiscussionThreadComponent;
    exports.UxDiscussionThreadComponentModule = UxDiscussionThreadComponentModule;
    exports.UxDiscussionThreadItemComponent = UxDiscussionThreadItemComponent;
    exports.UxDiscussionThreadItemComponentModule = UxDiscussionThreadItemComponentModule;
    exports.UxDiscussionThreadItem = UxDiscussionThreadItem;
    exports.UxFormControlComponent = UxFormControlComponent;
    exports.UxFormControlComponentModule = UxFormControlComponentModule;
    exports.UxFormGroupComponent = UxFormGroupComponent;
    exports.UxFormGroupSubContentTagDirective = UxFormGroupSubContentTagDirective;
    exports.UxFormGroupComponentModule = UxFormGroupComponentModule;
    exports.UxDynamicPopoverService = UxDynamicPopoverService;
    exports.UxDynamicPopoverConfig = UxDynamicPopoverConfig;
    exports.UxFilterResultsComponent = UxFilterResultsComponent;
    exports.UxFilterResultsNavigationContentTagDirective = UxFilterResultsNavigationContentTagDirective;
    exports.UxFilterResultsFilterContentTagDirective = UxFilterResultsFilterContentTagDirective;
    exports.UxFilterResultsQuickFilterContentTagDirective = UxFilterResultsQuickFilterContentTagDirective;
    exports.UxFilterResultsHeaderContentTagDirective = UxFilterResultsHeaderContentTagDirective;
    exports.UxFilterResultsContentTagDirective = UxFilterResultsContentTagDirective;
    exports.UxFilterResultsFullContentTagDirective = UxFilterResultsFullContentTagDirective;
    exports.UxFilterResultsComponentModule = UxFilterResultsComponentModule;
    exports.EDITOR_VALUE_ACCESSOR = EDITOR_VALUE_ACCESSOR;
    exports.UxEditorComponent = UxEditorComponent;
    exports.UxEditorComponentModule = UxEditorComponentModule;
    exports.UxErrorOutputComponent = UxErrorOutputComponent;
    exports.UxErrorOutputComponentModule = UxErrorOutputComponentModule;
    exports.UxMessage = UxMessage;
    exports.UxButtonConfig = UxButtonConfig;
    exports.UxDynamicModalConfig = UxDynamicModalConfig;
    exports.UxModule = UxModule;
    exports.UxAllModule = UxAllModule;
    exports.ɵbv = RectangleFactory;
    exports.ɵby = GeometryModule;
    exports.ɵbx = placementServiceFactory;
    exports.ɵbu = Rectangle;
    exports.ɵbs = PlacementService;
    exports.ɵcd = BottomLeftPlacementStrategy;
    exports.ɵcb = BottomPlacementStrategy;
    exports.ɵbz = LeftPlacementStrategy;
    exports.ɵcc = RightPlacementStrategy;
    exports.ɵca = TopPlacementStrategy;
    exports.ɵz = UxLayoutFooterAppInfosTagDirective;
    exports.ɵy = UxLayoutFooterComponent;
    exports.ɵbb = UxLayoutFooterComponentModule;
    exports.ɵba = UxLayoutFooterLinksTagDirective;
    exports.ɵr = UxLayoutHeaderComponent;
    exports.ɵv = UxLayoutHeaderComponentModule;
    exports.ɵs = UxLayoutHeaderRightContentTagDirective;
    exports.ɵu = UxLayoutHeaderTitleContentTagDirective;
    exports.ɵt = UxLayoutHeaderUserProfileLinksTagDirective;
    exports.ɵbg = UxLayoutNavBarActionsComponent;
    exports.ɵbh = UxLayoutNavBarActionsComponentModule;
    exports.ɵbi = UxLayoutNavBarLeftActionItemSidebarToggleComponent;
    exports.ɵbj = UxLayoutNavBarLeftActionItemSidebarToggleComponentModule;
    exports.ɵbk = UxLayoutNavBarLeftActionsComponent;
    exports.ɵbl = UxLayoutNavBarLeftActionsComponentModule;
    exports.ɵbm = UxLayoutNavBarTopMenuComponent;
    exports.ɵbn = UxLayoutNavBarTopMenuComponentModule;
    exports.ɵbc = UxLayoutNavBarComponent;
    exports.ɵbf = UxLayoutNavBarComponentModule;
    exports.ɵbd = UxLayoutNavBarElementsContentTagDirective;
    exports.ɵbe = UxLayoutNavBarLeftActionsContentTagDirective;
    exports.ɵbo = UxLayoutSidebarComponent;
    exports.ɵbr = UxLayoutSidebarComponentModule;
    exports.ɵbq = UxLayoutSidebarContentTagDirective;
    exports.ɵbp = UxLayoutSidebarHeaderTagDirective;
    exports.ɵco = UxCardItemCellComponent;
    exports.ɵcn = UxCardItemComponent;
    exports.ɵcl = UxCardItemCustomContentTagDirective;
    exports.ɵck = UxCardItemsComponent;
    exports.ɵcm = UxCardItemsComponentModule;
    exports.ɵcj = PopoverService$1;
    exports.ɵcf = UxDynamicOpenedPopoverService;
    exports.ɵci = UxDynamicPopoverComponent;
    exports.ɵch = UxDynamicPopoverComponentModule;
    exports.ɵcg = placementServiceFactory$2;
    exports.ɵw = UxItemConfig;
    exports.ɵx = UxListItemConfig;
    exports.ɵbw = UxMenuItemConfig;
    exports.ɵce = PopoverService;
    exports.ɵm = AppService;
    exports.ɵn = EnvConfigService;
    exports.ɵj = APP_CONFIG_TOKEN;
    exports.ɵk = ENVIRONMENT_TOKEN;
    exports.ɵa = OptionalDeps;
    exports.ɵi = errorFeedbackServiceFactory;
    exports.ɵh = localizationServiceFactory;
    exports.ɵb = providersModule;
    exports.ɵc = storeServiceFactory;
    exports.ɵe = uxAuthGuardServiceFactory;
    exports.ɵd = uxAuthServiceFactory;
    exports.ɵg = uxDynamicMenuServiceFactory;
    exports.ɵf = uxPermissionsServiceFactory;
    exports.ɵo = UxRequestErrorModelInterceptor;
    exports.ɵp = initApp;
    exports.ɵl = AppEffects;
    exports.ɵq = RoutesEffects;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
