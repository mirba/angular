import 'rxjs/add/operator/map';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/delay';
import 'rxjs/add/operator/take';
import 'rxjs/add/operator/filter';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/forkJoin';
import 'rxjs/add/observable/throw';
import { InjectionToken, Injectable, Inject, Optional, Injector, ComponentFactoryResolver, ApplicationRef, PLATFORM_ID, EventEmitter, ErrorHandler, APP_INITIALIZER, NgModule, SkipSelf, Pipe, Directive, HostListener, Input, ElementRef, Output, HostBinding, TemplateRef, ViewContainerRef, Component, IterableDiffers, ViewChild, ContentChild, forwardRef, Host, ContentChildren, ChangeDetectionStrategy, ChangeDetectorRef, Renderer2, ViewEncapsulation, Renderer, ViewChildren } from '@angular/core';
import extendProxy from 'extend';
import { LOCATION_INITIALIZED, isPlatformBrowser, CommonModule } from '@angular/common';
import { format } from 'util';
import { Store } from '@ngrx/store';
import { _throw } from 'rxjs/observable/throw';
import { createSelector } from 'reselect';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Router, NavigationEnd, NavigationStart, RouterModule, ActivatedRoute } from '@angular/router';
import { FormGroup, FormArray, ControlContainer, NG_VALUE_ACCESSOR, FormsModule, FormControl, ReactiveFormsModule, NG_VALIDATORS } from '@angular/forms';
import { Observable } from 'rxjs/Observable';
import { Effect, Actions, EffectsModule } from '@ngrx/effects';
import { HttpClient, HttpHeaders, HttpErrorResponse, HttpClientModule, HTTP_INTERCEPTORS, HttpResponse, HttpRequest, HttpParams } from '@angular/common/http';
import { TranslateService, TranslateLoader, TranslateModule } from '@ngx-translate/core';
import { of } from 'rxjs/observable/of';
import { Subject } from 'rxjs/Subject';
import { filter, map, startWith, withLatestFrom, takeUntil } from 'rxjs/operators';
import { DomPortalHost, ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import 'rxjs/add/observable/zip';
import moment from 'moment-timezone';
import { DOCUMENT, DomSanitizer } from '@angular/platform-browser';
import { fromEvent } from 'rxjs/observable/fromEvent';
import 'rxjs/add/observable/concat';
import 'rxjs/add/observable/timer';
import 'rxjs/add/operator/switchMapTo';
import * as Cleave from 'cleave.js';
import { A11yModule } from '@angular/cdk/a11y';
import { TooltipModule } from 'primeng/tooltip';
import { MomentModule } from 'angular2-moment';
import 'rxjs/add/observable/fromEvent';
import { timer } from 'rxjs/observable/timer';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { SPACE } from '@angular/cdk/keycodes';
import { ChartModule } from 'primeng/components/chart/chart';
import { CalendarModule } from 'primeng/components/calendar/calendar';
import moment$1 from 'moment';
import { ReplaySubject } from 'rxjs/ReplaySubject';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ extend = (/** @type {?} */ (extendProxy)).default || extendProxy;
const /** @type {?} */ CONFIG_TOKEN = new InjectionToken('config');
const /** @type {?} */ APP_CONFIG_TOKEN = new InjectionToken('appConfig');
const /** @type {?} */ ENVIRONMENT_TOKEN = new InjectionToken('environment');
/**
 * @param {?} appConfig
 * @param {?=} environment
 * @return {?}
 */
function getConfig(appConfig, environment = {}) {
    return extend(true, {}, appConfig, environment);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} appConfig
 * @param {?} storeService
 * @param {?} userService
 * @param {?} localizationService
 * @param {?} injector
 * @param {?} appService
 * @param {?} envConfigService
 * @return {?}
 */
function initApp(appConfig, storeService, userService, localizationService, injector, appService, envConfigService) {
    return () => {
        return new Promise((resolve, reject) => {
            // FIX for bug in IE
            // https://github.com/angular/angular-cli/issues/5762  |  https://github.com/angular/angular/issues/15501
            // TODO: remove when Angular update fixes this
            const /** @type {?} */ locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
            locationInitialized.then(() => {
                console.log('Startup configurator for eUI...');
                if (typeof appConfig === 'function') {
                    appConfig = appConfig();
                }
                appService.listenForConnectionUpdate();
                /**
                                 * Load User Details
                                 * then initialize the store with the user details
                                 * then initialize app language (if not found --> falls back to defaultLanguage)
                                 */
                envConfigService.loadDynamicConfig()
                    .switchMap(() => userService.loadUserDetail())
                    .do((user) => {
                    storeService.initializeStore(appConfig.versions, user);
                    userService.observePreferencesUpdate();
                })
                    .switchMap(() => userService.loadUserPreferences())
                    .switchMap(() => localizationService.init(appConfig.global.languages, appConfig.global.defaultLanguage))
                    .subscribe(() => {
                    /**
                                             * Handle auto save of the Redux store
                                             */
                    storeService.handleAutoSave();
                    resolve();
                }, error => {
                    console.log(error);
                    resolve();
                });
            });
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const LOG_LEVEL = {
    info: 'info',
    warning: 'warning',
    error: 'error',
};
class TraceService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        if (config.global && config.global.logLevel) {
            this.logLevel = config.global.logLevel;
        }
        else {
            this.logLevel = LOG_LEVEL.error;
        }
    }
    /**
     * @param {?} message
     * @return {?}
     */
    info(message) {
        const /** @type {?} */ levels = [LOG_LEVEL.info];
        if (levels.indexOf(this.logLevel) >= 0) {
            console.log(`[INFO] ${message}`);
        }
        this.log(message, LOG_LEVEL.info);
    }
    /**
     * @param {?} message
     * @return {?}
     */
    warning(message) {
        const /** @type {?} */ levels = [LOG_LEVEL.warning, LOG_LEVEL.error];
        if (levels.indexOf(this.logLevel) >= 0) {
            console.log(`[WARNING] ${message}`);
        }
        this.log(message, LOG_LEVEL.warning);
    }
    /**
     * @param {?} message
     * @return {?}
     */
    error(message) {
        const /** @type {?} */ levels = [LOG_LEVEL.info, LOG_LEVEL.warning, LOG_LEVEL.error];
        if (levels.indexOf(this.logLevel) >= 0) {
            console.log(`[ERROR] ${message}`);
        }
        this.log(message, LOG_LEVEL.error);
    }
    /**
     * @param {?} message
     * @param {?} severity
     * @return {?}
     */
    log(message, severity) {
        // TODO: log somewhere on server...
    }
}
TraceService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TraceService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ errorCodes = {
    ERR_GENERIC: 'ERR_GENERIC',
    ERR_NGRX_MISSING: 'ERR_NGRX_MISSING',
    ERR_TRANSLATION_FILE_MISSING: 'ERR_TRANSLATION_FILE_MISSING',
    ERR_QUEUE_METHOD_NOT_ALLOWED: 'ERR_QUEUE_METHOD_NOT_ALLOWED',
};
const /** @type {?} */ getMessage = (text, ...args) => format(text, ...args);
const ɵ1 = (lang) => getMessage('Translation file not found for language "%s"', lang);
const /** @type {?} */ messages = {
    ERR_GENERIC: 'An error occured',
    ERR_NGRX_MISSING: 'NGRX missing. "store.dispatch" and "store.select" are not available.',
    ERR_TRANSLATION_FILE_MISSING: ɵ1,
};
class ErrorSubClass {
    /**
     * @param {?=} code
     * @param {?=} msg
     * @param {?=} args
     */
    constructor(code, msg, args) {
        if (!msg && code && code in messages) {
            if (typeof messages[code] === 'function') {
                msg = messages[code](...args.messageParams);
            }
            else {
                msg = messages[code];
            }
        }
        this.name = 'ErrorSubClass';
        this.message = msg;
        this.code = code;
        this.stack = (new Error(msg)).stack;
        if (args) {
            Object.keys(args).forEach((k) => {
                if (k !== 'messageParams') {
                    this[k] = args[k];
                }
            });
        }
    }
}
// This replaces the "extends" on the Class
ErrorSubClass.prototype = /** @type {?} */ (Object.create(Error.prototype));
class EuiError extends ErrorSubClass {
    /**
     * @param {?=} code
     * @param {?=} msg
     * @param {?=} args
     */
    constructor(code = errorCodes.ERR_GENERIC, msg, args) {
        super(code, msg, args);
        this.name = 'EuiError';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// import { type } from './shared/utils/ngrx-store';
const /** @type {?} */ CORE_INIT_STORE = '[Core] Init Store';
const /** @type {?} */ APP_CHANGE_MODULE = '[App] Change module';
const /** @type {?} */ APP_CONNECTION_UPDATE = '[App] Connection update';
const /** @type {?} */ APP_STATUS_UPDATE = '[App] Status update';
const /** @type {?} */ APP_CONNECTION_UPDATE_CONFIRMED = '[App] Connection update confirmed';
const /** @type {?} */ UPDATE_ROUTE = '[Route] Update';
const /** @type {?} */ API_QUEUE_ADD = '[API Queue] Add';
const /** @type {?} */ API_QUEUE_REMOVE = '[API Queue] Remove';
// Notifications
const /** @type {?} */ NOTIFS_UPDATE_LIST = '[NOTIFS] Update list';
// User
const /** @type {?} */ USER_UPDATE_DETAIL = '[User] Update detail';
const /** @type {?} */ USER_UPDATE_PREFERENCES = '[User] Update preferences';

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
class StoreService {
    /**
     * @param {?} store
     * @param {?} logger
     */
    constructor(store, logger) {
        this.store = store;
        this.logger = logger;
        /**
         * autoSave handlers to call before saving in local Storage
         */
        this._autoSaveHandlers = {};
    }
    /**
     * @return {?}
     */
    static loadState() {
        try {
            const /** @type {?} */ serializedState = localStorage.getItem('state');
            if (serializedState === null) {
                return undefined;
            }
            return JSON.parse(serializedState);
        }
        catch (/** @type {?} */ err) {
            return undefined;
        }
    }
    /**
     * @param {?} versions
     * @param {?=} user
     * @return {?}
     */
    initializeStore(versions, user) {
        this.dispatch({ type: CORE_INIT_STORE, payload: { versions, user } });
    }
    /**
     * @param {?} stateSlice
     * @param {?} handler
     * @return {?}
     */
    addAutoSaveHandler(stateSlice, handler) {
        if (!this.store) {
            this.logger.warning('StoreService.addAutoSaveHandler() not available withouth ngrx');
            return;
        }
        this._autoSaveHandlers[stateSlice] = handler;
    }
    /**
     * @return {?}
     */
    handleAutoSave() {
        if (!this.store) {
            return;
        }
        this.store.debounceTime(1000)
            .distinctUntilChanged()
            .subscribe(state => {
            this.saveState(state);
        });
    }
    /**
     * Proxy to ngrx store.dispatch()
     * that allows to intercept if the store is present
     * @param {?} action
     * @return {?}
     */
    dispatch(action) {
        if (this.store) {
            return this.store.dispatch(action);
        }
    }
    /**
     * Proxy to ngrx store.select()
     * that allows to intercept if the store is present
     * @param {?} key
     * @return {?}
     */
    select(key) {
        if (!this.store) {
            return _throw(new EuiError(errorCodes.ERR_NGRX_MISSING));
        }
        return this.store.select(key);
    }
    /**
     * @param {?} state
     * @return {?}
     */
    saveState(state) {
        let /** @type {?} */ stateToSave = {
            app: state.app,
        };
        if (state.user) {
            const _a = state.user, { userId, preferences } = _a, rest = __rest(_a, ["userId", "preferences"]);
            stateToSave.user = { userId, preferences };
        }
        Object.keys(this._autoSaveHandlers).forEach((sliceState) => {
            const /** @type {?} */ handler = this._autoSaveHandlers[sliceState];
            stateToSave = Object.assign(stateToSave, { [sliceState]: handler(state[sliceState]) });
        });
        try {
            const /** @type {?} */ serializedState = JSON.stringify(stateToSave);
            localStorage.setItem('state', serializedState);
        }
        catch (/** @type {?} */ err) {
            // Ignore write errors.
        }
    }
}
StoreService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
StoreService.ctorParameters = () => [
    { type: Store, decorators: [{ type: Optional },] },
    { type: TraceService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Initial State (can be overriden when creating the store)
const /** @type {?} */ initialState = {
    currentModule: '',
    version: '0.0.0',
    connected: true,
    status: 'idle',
    apiQueue: {},
};
// --------
// Reducers
// --------
const /** @type {?} */ changeModule = (state, action) => {
    return Object.assign({}, state, { currentModule: action.payload });
};
const /** @type {?} */ appConnectionUpdate = (state, action) => {
    return Object.assign({}, state, { connected: action.payload });
};
const /** @type {?} */ appStatusUpdate = (state, action) => (Object.assign({}, state, { status: action.payload }));
const /** @type {?} */ apiQueueAdd = (state, action) => {
    const /** @type {?} */ data = Object.assign({}, action.payload.data, { timestamp: new Date().getTime() });
    const /** @type {?} */ apiQueue = Object.assign({}, state.apiQueue, { [action.payload.id]: data });
    return Object.assign({}, state, { apiQueue });
};
const /** @type {?} */ apiQueueRemove = (state, action) => {
    const /** @type {?} */ apiQueue = Object.keys(state.apiQueue)
        .filter(k => k !== action.payload)
        .reduce((acc, key) => {
        acc[key] = state.apiQueue[key];
        return acc;
    }, {});
    return Object.assign({}, state, { apiQueue });
};
// ----------------------
const /** @type {?} */ actionToReducerMap = {
    [APP_CHANGE_MODULE]: changeModule,
    [APP_CONNECTION_UPDATE_CONFIRMED]: appConnectionUpdate,
    [API_QUEUE_ADD]: apiQueueAdd,
    [API_QUEUE_REMOVE]: apiQueueRemove,
    [APP_STATUS_UPDATE]: appStatusUpdate,
};
const /** @type {?} */ reducer = (state = initialState, action) => {
    if (actionToReducerMap[action.type]) {
        return actionToReducerMap[action.type](state, action);
    }
    return state;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ initialState$1 = {
    list: [],
};
// Reducers
const /** @type {?} */ updateList = (state, action) => {
    return Object.assign({}, state, { list: [...action.payload] });
};
// ----------------------
const /** @type {?} */ actionToReducerMap$1 = {
    [NOTIFS_UPDATE_LIST]: updateList,
};
const /** @type {?} */ reducer$1 = (state = initialState$1, action) => {
    if (actionToReducerMap$1[action.type]) {
        return actionToReducerMap$1[action.type](state, action);
    }
    return state;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ initialState$2 = {
    userId: '',
    firstName: '',
    lastName: '',
    fullName: '',
    preferences: {},
};
// --------
// Reducers
// --------
const /** @type {?} */ userUpdateDetail = (state, action) => {
    const /** @type {?} */ fullName = `${action.payload.firstName || ''} ${action.payload.lastName || ''}`.trim();
    return Object.assign({}, state, action.payload, { fullName });
};
const /** @type {?} */ userUpdatePreferences = (state, action) => {
    const /** @type {?} */ preferences = Object.assign({}, state.preferences, action.payload);
    return Object.assign({}, state, { preferences });
};
// ----------------------
const /** @type {?} */ actionToReducerMap$2 = {
    [USER_UPDATE_DETAIL]: userUpdateDetail,
    [USER_UPDATE_PREFERENCES]: userUpdatePreferences,
};
const /** @type {?} */ reducer$2 = (state = initialState$2, action) => {
    if (actionToReducerMap$2[action.type]) {
        return actionToReducerMap$2[action.type](state, action);
    }
    return state;
};
// ----------------
// State Selectors
// ----------------
const /** @type {?} */ getUserId = (state) => state.userId;
const /** @type {?} */ getUserPreferences = (state) => state.preferences;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ reducers = {
    app: reducer,
    user: reducer$2,
    notifications: reducer$1,
};
/**
 * @param {?} reducer
 * @return {?}
 */
function localStorageSync(reducer$$1) {
    return function (state, action) {
        if (action.type === CORE_INIT_STORE) {
            /**
             * This action is dispatched from the startupConfigurator
             * We load the state from local storage and compare the version
             * with the one provided. If the version are the same we merge
             * the local storage state into the initial state.
             * If there is a version mismatch, we don't merge the local storage state
             * and we just update the state app version.
             */
            const /** @type {?} */ localStorageState = StoreService.loadState();
            const /** @type {?} */ payloadUser = action.payload && action.payload.user && action.payload.user.userId;
            const /** @type {?} */ payloadVersion = action.payload && action.payload.versions && action.payload.versions.app;
            if (localStorageState) {
                const /** @type {?} */ localUser = localStorageState.user && localStorageState.user.userId;
                const /** @type {?} */ localVersion = localStorageState && localStorageState.app && localStorageState.app.version;
                const /** @type {?} */ isVersionOK = (!localVersion || !payloadVersion || localVersion === payloadVersion);
                const /** @type {?} */ isUserOK = localUser === payloadUser;
                if (isVersionOK && isUserOK) {
                    state = Object.assign({}, state, localStorageState);
                }
            }
            if (payloadUser) {
                const /** @type {?} */ user = Object.assign({}, state.user, action.payload.user);
                state = Object.assign({}, state, { user });
            }
            if (payloadVersion) {
                state = Object.assign({}, state, { app: Object.assign({}, state.app, { version: payloadVersion }) });
            }
        }
        const /** @type {?} */ nextState = reducer$$1(state, action);
        return nextState;
    };
}
/**
 * A selector function is a map function factory. We pass it parameters and it
 * returns a function that maps from the larger state tree into a smaller
 */
const /** @type {?} */ getAppState = (state) => state.app;
const /** @type {?} */ getAppConnection = createSelector(getAppState, (state) => state.connected);
const /** @type {?} */ getAppStatus = createSelector(getAppState, (state) => state.status);
const /** @type {?} */ getApiQueue = createSelector(getAppState, (state) => state.apiQueue);
const /** @type {?} */ getApiQueueById = id => createSelector(getAppState, (state) => state.apiQueue[id]);
// User
const /** @type {?} */ getUserState = (state) => state.user;
const /** @type {?} */ getUserIdState = createSelector(getUserState, getUserId);
const /** @type {?} */ getUserPrefsState = createSelector(getUserState, getUserPreferences);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Action Creators
 */
class ChangeModuleAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = APP_CHANGE_MODULE;
    }
}
class RouteUpdateAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = UPDATE_ROUTE;
    }
}
class AppConnectionUpdate {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = APP_CONNECTION_UPDATE;
    }
}
class AppStatusUpdate {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = APP_STATUS_UPDATE;
    }
}
class ApiQueueAdd {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = API_QUEUE_ADD;
    }
}
class ApiQueueRemove {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = API_QUEUE_REMOVE;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UpdateListAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = NOTIFS_UPDATE_LIST;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UpdateUserDetailAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = USER_UPDATE_DETAIL;
    }
}
class UpdateUserPreferencesAction {
    /**
     * @param {?} payload
     */
    constructor(payload) {
        this.payload = payload;
        this.type = USER_UPDATE_PREFERENCES;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ UX_COLORS = {
    primary: '#004494',
    primaryDark: '#003675',
    primaryDarker: '#002857',
    primaryDarkest: '#001a38',
    primaryDarkester: '#000c1a',
    primaryLight: '#0052b3',
    primaryLighter: '#0060d1',
    primaryLightest: '#1a83ff',
    primaryLightester: '#52a1ff',
    primaryLightester2: '#9ecbff',
    accent: '#ffeb3b',
    accentDark: '#fdd835',
    accentDarker: '#fbc02d',
    accentDarkest: '#f9a825',
    accentDarkester: '#f57f17',
    accentLight: '#ffee58',
    accentLighter: '#fff176',
    accentLightest: '#fff59d',
    accentLightester: '#fff9c4',
    accentLightester2: '#fffde7',
    info: '#03a9f4',
    infoDark: '#039be5',
    infoDarker: '#0288d1',
    infoDarkest: '#0277bd',
    infoDarkester: '#01579b',
    infoLight: '#29b6f6',
    infoLighter: '#4fc3f7',
    infoLightest: '#81d4fa',
    infoLightester: '#b3e5fc',
    infoLightester2: '#e1f5fe',
    success: '#4caf50',
    successDark: '#43a047',
    successDarker: '#388e3c',
    successDarkest: '#2e7d32',
    successDarkester: '#1b5e20',
    successLight: '#66bb6a',
    successLighter: '#81c784',
    successLightest: '#a5d6a7',
    successLightester: '#c8e6c9',
    successLightester2: '#e8f5e9',
    warning: '#ff9800',
    warningDark: '#fb8c00',
    warningDarker: '#f57c00',
    warningDarkest: '#ef6c00',
    warningDarkester: '#e65100',
    warningLight: '#ffa726',
    warningLighter: '#ffb74d',
    warningLightest: '#ffcc80',
    warningLightester: '#fff3e0',
    warningLightester2: '#fff3e0',
    danger: '#f44336',
    dangerDark: '#e53935',
    dangerDarker: '#d32f2f',
    dangerDarkest: '#c62828',
    dangerDarkester: '#b71c1c',
    dangerLight: '#ef5350',
    dangerLighter: '#e57373',
    dangerLightest: '#ef9a9a',
    dangerLightester: '#ffcdd2',
    dangerLightester2: '#ffebee',
    grey: '#9e9e9e',
    greyDark: '#757575',
    greyDarker: '#616161',
    greyDarkest: '#424242',
    greyDarkester: '#212121',
    greyLight: '#bdbdbd',
    greyLighter: '#e0e0e0',
    greyLightest: '#eeeeee',
    greyLightester: '#f5f5f5',
    greyLightester2: '#fafafa'
};
const /** @type {?} */ UX_I18N = {
    fr: {
        expandAll: 'Etendre tout',
        collapseAll: 'Fermer tout',
        filter: 'Filtrer',
        today: 'aujourd\'hui',
        oneDayAgo: 'il y a un jour',
        inOneDay: 'dans un jour',
        xDaysAgo: 'il y a %PARAM% jours',
        inXDays: 'dans %PARAM% jours',
        YES: 'OUI',
        NO: 'NON',
        yes: 'Oui',
        no: 'Non',
        viewAllNotifications: 'Voir toutes les notifications',
        myNotifications: 'Mes notifications',
        noNotificationFound: 'Pas de notification trouvée',
        notificationMarkAsRead: 'Marquer comme lu',
        notificationMarkAsUnRead: 'Marquer comme non-lu',
        notificationsToday: 'Notification du jour',
        notificationsOldest: 'Notifications précédentes',
        notificationsUnread: 'non lues',
        notificationsTotal: 'Total',
        autocompleteTagRequiredItemsValidation: 'Vous devez sélectionner encore %PARAM% élément(s)',
        autocompleteTagMaxRequiredItemsValidation: 'Le nombre maximum d\'élements a été dépassé (maximum : %PARAM_1% / actuel: %PARAM_2%)',
        filters: 'Filtres',
        advancedFilter: 'Filtre avancé',
        quickFilter: 'Filtre rapide',
        search: 'Chercher',
        results: 'Résultats',
    },
    en: {
        expandAll: 'Expand all',
        collapseAll: 'Collapse all',
        filter: 'Filter',
        today: 'today',
        oneDayAgo: 'one day ago',
        inOneDay: 'in one day',
        xDaysAgo: '%PARAM% days ago',
        inXDays: 'in %PARAM% days',
        YES: 'YES',
        NO: 'NO',
        yes: 'Yes',
        no: 'No',
        viewAllNotifications: 'View all notifications',
        myNotifications: 'My notifications',
        noNotificationFound: 'No notification found',
        notificationMarkAsRead: 'Mark as read',
        notificationMarkAsUnRead: 'Mark as unread',
        notificationsToday: 'Today\'s notifications',
        notificationsOldest: 'Oldest notifications',
        notificationsUnread: 'unread',
        notificationsTotal: 'Total',
        autocompleteTagRequiredItemsValidation: 'You must select %PARAM% more item(s) in the list',
        autocompleteTagMaxRequiredItemsValidation: 'Maximum number of elements exceeded (maximum : %PARAM_1% / actual: %PARAM_2%)',
        filters: 'Filters',
        advancedFilter: 'Advanced filter',
        quickFilter: 'Quick filter',
        search: 'Search',
        results: 'Results',
    }
};
const /** @type {?} */ UX_COUNTRIES = {
    AF: 'Afghanistan',
    AX: 'Aland Islands',
    AL: 'Albania',
    DZ: 'Algeria',
    AS: 'American Samoa',
    AD: 'Andorra',
    AO: 'Angola',
    AI: 'Anguilla',
    AQ: 'Antarctica',
    AG: 'Antigua and Barbuda',
    AR: 'Argentina',
    AM: 'Armenia',
    AW: 'Aruba',
    AU: 'Australia',
    AT: 'Austria',
    AZ: 'Azerbaijan',
    BS: 'Bahamas',
    BH: 'Bahrain',
    BD: 'Bangladesh',
    BB: 'Barbados',
    BY: 'Belarus',
    BE: 'Belgium',
    BZ: 'Belize',
    BJ: 'Benin',
    BM: 'Bermuda',
    BT: 'Bhutan',
    BO: 'Bolivia',
    BA: 'Bosnia and Herzegovina',
    BW: 'Botswana',
    BV: 'Bouvet Island',
    BR: 'Brazil',
    VG: 'British Virgin Islands',
    IO: 'British Indian Ocean Territory',
    BN: 'Brunei Darussalam',
    BG: 'Bulgaria',
    BF: 'Burkina Faso',
    BI: 'Burundi',
    KH: 'Cambodia',
    CM: 'Cameroon',
    CA: 'Canada',
    CV: 'Cape Verde',
    KY: 'Cayman Islands',
    CF: 'Central African Republic',
    TD: 'Chad',
    CL: 'Chile',
    CN: 'China',
    HK: 'Hong Kong',
    MO: 'Macao',
    CX: 'Christmas Island',
    CC: 'Cocos (Keeling) Islands',
    CO: 'Colombia',
    KM: 'Comoros',
    CG: 'Congo (Brazzaville)',
    CD: 'Congo, (Kinshasa)',
    CK: 'Cook Islands',
    CR: 'Costa Rica',
    CI: 'Côte d\'Ivoire',
    HR: 'Croatia',
    CU: 'Cuba',
    CY: 'Cyprus',
    CZ: 'Czech Republic',
    DK: 'Denmark',
    DJ: 'Djibouti',
    DM: 'Dominica',
    DO: 'Dominican Republic',
    EC: 'Ecuador',
    EG: 'Egypt',
    SV: 'El Salvador',
    GQ: 'Equatorial Guinea',
    ER: 'Eritrea',
    EE: 'Estonia',
    ET: 'Ethiopia',
    FK: 'Falkland Islands (Malvinas)',
    FO: 'Faroe Islands',
    FJ: 'Fiji',
    FI: 'Finland',
    FR: 'France',
    GF: 'French Guiana',
    PF: 'French Polynesia',
    TF: 'French Southern Territories',
    GA: 'Gabon',
    GM: 'Gambia',
    GE: 'Georgia',
    DE: 'Germany',
    GH: 'Ghana',
    GI: 'Gibraltar',
    GR: 'Greece',
    GL: 'Greenland',
    GD: 'Grenada',
    GP: 'Guadeloupe',
    GU: 'Guam',
    GT: 'Guatemala',
    GG: 'Guernsey',
    GN: 'Guinea',
    GW: 'Guinea-Bissau',
    GY: 'Guyana',
    HT: 'Haiti',
    HM: 'Heard and Mcdonald Islands',
    VA: 'Vatican City State',
    HN: 'Honduras',
    HU: 'Hungary',
    IS: 'Iceland',
    IN: 'India',
    ID: 'Indonesia',
    IR: 'Iran',
    IQ: 'Iraq',
    IE: 'Ireland',
    IM: 'Isle of Man',
    IL: 'Israel',
    IT: 'Italy',
    JM: 'Jamaica',
    JP: 'Japan',
    JE: 'Jersey',
    JO: 'Jordan',
    KZ: 'Kazakhstan',
    KE: 'Kenya',
    KI: 'Kiribati',
    KP: 'Korea (North)',
    KR: 'Korea (South)',
    KW: 'Kuwait',
    KG: 'Kyrgyzstan',
    LA: 'Lao PDR',
    LV: 'Latvia',
    LB: 'Lebanon',
    LS: 'Lesotho',
    LR: 'Liberia',
    LY: 'Libya',
    LI: 'Liechtenstein',
    LT: 'Lithuania',
    LU: 'Luxembourg',
    MK: 'Macedonia',
    MG: 'Madagascar',
    MW: 'Malawi',
    MY: 'Malaysia',
    MV: 'Maldives',
    ML: 'Mali',
    MT: 'Malta',
    MH: 'Marshall Islands',
    MQ: 'Martinique',
    MR: 'Mauritania',
    MU: 'Mauritius',
    YT: 'Mayotte',
    MX: 'Mexico',
    FM: 'Micronesia',
    MD: 'Moldova',
    MC: 'Monaco',
    MN: 'Mongolia',
    ME: 'Montenegro',
    MS: 'Montserrat',
    MA: 'Morocco',
    MZ: 'Mozambique',
    MM: 'Myanmar',
    NA: 'Namibia',
    NR: 'Nauru',
    NP: 'Nepal',
    NL: 'Netherlands',
    AN: 'Netherlands Antilles',
    NC: 'New Caledonia',
    NZ: 'New Zealand',
    NI: 'Nicaragua',
    NE: 'Niger',
    NG: 'Nigeria',
    NU: 'Niue',
    NF: 'Norfolk Island',
    MP: 'Northern Mariana Islands',
    NO: 'Norway',
    OM: 'Oman',
    PK: 'Pakistan',
    PW: 'Palau',
    PS: 'Palestinian Territory',
    PA: 'Panama',
    PG: 'Papua New Guinea',
    PY: 'Paraguay',
    PE: 'Peru',
    PH: 'Philippines',
    PN: 'Pitcairn',
    PL: 'Poland',
    PT: 'Portugal',
    PR: 'Puerto Rico',
    QA: 'Qatar',
    RE: 'Réunion',
    RO: 'Romania',
    RU: 'Russian Federation',
    RW: 'Rwanda',
    BL: 'Saint-Barthélemy',
    SH: 'Saint Helena',
    KN: 'Saint Kitts and Nevis',
    LC: 'Saint Lucia',
    MF: 'Saint-Martin (French part)',
    PM: 'Saint Pierre and Miquelon',
    VC: 'Saint Vincent and Grenadines',
    WS: 'Samoa',
    SM: 'San Marino',
    ST: 'Sao Tome and Principe',
    SA: 'Saudi Arabia',
    SN: 'Senegal',
    RS: 'Serbia',
    SC: 'Seychelles',
    SL: 'Sierra Leone',
    SG: 'Singapore',
    SK: 'Slovakia',
    SI: 'Slovenia',
    SB: 'Solomon Islands',
    SO: 'Somalia',
    ZA: 'South Africa',
    GS: 'South Georgia and the South Sandwich Islands',
    SS: 'South Sudan',
    ES: 'Spain',
    LK: 'Sri Lanka',
    SD: 'Sudan',
    SR: 'Suriname',
    SJ: 'Svalbard and Jan Mayen Islands',
    SZ: 'Swaziland',
    SE: 'Sweden',
    CH: 'Switzerland',
    SY: 'Syria',
    TW: 'Taiwan',
    TJ: 'Tajikistan',
    TZ: 'Tanzania',
    TH: 'Thailand',
    TL: 'Timor-Leste',
    TG: 'Togo',
    TK: 'Tokelau',
    TO: 'Tonga',
    TT: 'Trinidad and Tobago',
    TN: 'Tunisia',
    TR: 'Turkey',
    TM: 'Turkmenistan',
    TC: 'Turks and Caicos Islands',
    TV: 'Tuvalu',
    UG: 'Uganda',
    UA: 'Ukraine',
    AE: 'United Arab Emirates',
    GB: 'United Kingdom (GB)',
    US: 'United States of America (USA)',
    UM: 'US Minor Outlying Islands',
    UY: 'Uruguay',
    UZ: 'Uzbekistan',
    VU: 'Vanuatu',
    VE: 'Venezuela',
    VN: 'Viet Nam',
    VI: 'Virgin Islands, US',
    WF: 'Wallis and Futuna Islands',
    EH: 'Western Sahara',
    YE: 'Yemen',
    ZM: 'Zambia',
    ZW: 'Zimbabwe'
};
const /** @type {?} */ UX_TIMEZONES = [
    { name: 'Europe/Andorra', desc: 'Andorra - Andorra (GMT+02:00)' },
    { name: 'Asia/Dubai', desc: 'United Arab Emirates - Dubai (GMT+04:00)' },
    { name: 'Asia/Kabul', desc: 'Afghanistan - Kabul (GMT+04:30)' },
    { name: 'America/Antigua', desc: 'Antigua and Barbuda - Antigua (GMT-04:00)' },
    { name: 'America/Anguilla', desc: 'Anguilla - Anguilla (GMT-04:00)' },
    { name: 'Europe/Tirane', desc: 'Albania - Tirane (GMT+02:00)' },
    { name: 'Asia/Yerevan', desc: 'Armenia - Yerevan (GMT+04:00)' },
    { name: 'Africa/Luanda', desc: 'Angola - Luanda (GMT+01:00)' },
    { name: 'Antarctica/McMurdo', desc: 'Antarctica - McMurdo (GMT+12:00)' },
    { name: 'Antarctica/Rothera', desc: 'Antarctica - Rothera (GMT-03:00)' },
    { name: 'Antarctica/Palmer', desc: 'Antarctica - Palmer (GMT-03:00)' },
    { name: 'Antarctica/Mawson', desc: 'Antarctica - Mawson (GMT+05:00)' },
    { name: 'Antarctica/Davis', desc: 'Antarctica - Davis (GMT+07:00)' },
    { name: 'Antarctica/Casey', desc: 'Antarctica - Casey (GMT+08:00)' },
    { name: 'Antarctica/Vostok', desc: 'Antarctica - Vostok (GMT+06:00)' },
    { name: 'Antarctica/DumontDUrville', desc: 'Antarctica - DumontDUrville (GMT+10:00)' },
    { name: 'Antarctica/Syowa', desc: 'Antarctica - Syowa (GMT+03:00)' },
    { name: 'Antarctica/Troll', desc: 'Antarctica - Troll (GMT+02:00)' },
    { name: 'America/Argentina/Buenos_Aires', desc: 'Argentina - Buenos Aires (GMT-03:00)' },
    { name: 'America/Argentina/Cordoba', desc: 'Argentina - Cordoba (GMT-03:00)' },
    { name: 'America/Argentina/Salta', desc: 'Argentina - Salta (GMT-03:00)' },
    { name: 'America/Argentina/Jujuy', desc: 'Argentina - Jujuy (GMT-03:00)' },
    { name: 'America/Argentina/Tucuman', desc: 'Argentina - Tucuman (GMT-03:00)' },
    { name: 'America/Argentina/Catamarca', desc: 'Argentina - Catamarca (GMT-03:00)' },
    { name: 'America/Argentina/La_Rioja', desc: 'Argentina - La Rioja (GMT-03:00)' },
    { name: 'America/Argentina/San_Juan', desc: 'Argentina - San Juan (GMT-03:00)' },
    { name: 'America/Argentina/Mendoza', desc: 'Argentina - Mendoza (GMT-03:00)' },
    { name: 'America/Argentina/San_Luis', desc: 'Argentina - San Luis (GMT-03:00)' },
    { name: 'America/Argentina/Rio_Gallegos', desc: 'Argentina - Rio Gallegos (GMT-03:00)' },
    { name: 'America/Argentina/Ushuaia', desc: 'Argentina - Ushuaia (GMT-03:00)' },
    { name: 'Pacific/Pago_Pago', desc: 'American Samoa - Pago Pago (GMT-11:00)' },
    { name: 'Pacific/Samoa', desc: 'American Samoa - Samoa (GMT-11:00)' },
    { name: 'Europe/Vienna', desc: 'Austria - Vienna (GMT+02:00)' },
    { name: 'Australia/Lord_Howe', desc: 'Australia - Lord Howe (GMT+10:30)' },
    { name: 'Antarctica/Macquarie', desc: 'Australia - Macquarie (GMT+11:00)' },
    { name: 'Australia/Hobart', desc: 'Australia - Hobart (GMT+10:00)' },
    { name: 'Australia/Currie', desc: 'Australia - Currie (GMT+10:00)' },
    { name: 'Australia/Melbourne', desc: 'Australia - Melbourne (GMT+10:00)' },
    { name: 'Australia/Sydney', desc: 'Australia - Sydney (GMT+10:00)' },
    { name: 'Australia/Broken_Hill', desc: 'Australia - Broken Hill (GMT+09:30)' },
    { name: 'Australia/Brisbane', desc: 'Australia - Brisbane (GMT+10:00)' },
    { name: 'Australia/Lindeman', desc: 'Australia - Lindeman (GMT+10:00)' },
    { name: 'Australia/Adelaide', desc: 'Australia - Adelaide (GMT+09:30)' },
    { name: 'Australia/Darwin', desc: 'Australia - Darwin (GMT+09:30)' },
    { name: 'Australia/Perth', desc: 'Australia - Perth (GMT+08:00)' },
    { name: 'Australia/Eucla', desc: 'Australia - Eucla (GMT+08:45)' },
    { name: 'Australia/Canberra', desc: 'Australia - Canberra (GMT+10:00)' },
    { name: 'Australia/Queensland', desc: 'Australia - Queensland (GMT+10:00)' },
    { name: 'Australia/Tasmania', desc: 'Australia - Tasmania (GMT+10:00)' },
    { name: 'Australia/Victoria', desc: 'Australia - Victoria (GMT+10:00)' },
    { name: 'America/Aruba', desc: 'Aruba - Aruba (GMT-04:00)' },
    { name: 'Europe/Mariehamn', desc: 'Aland Islands - Mariehamn (GMT+03:00)' },
    { name: 'Asia/Baku', desc: 'Azerbaijan - Baku (GMT+04:00)' },
    { name: 'Europe/Sarajevo', desc: 'Bosnia and Herzegovina - Sarajevo (GMT+02:00)' },
    { name: 'America/Barbados', desc: 'Barbados - Barbados (GMT-04:00)' },
    { name: 'Asia/Dhaka', desc: 'Bangladesh - Dhaka (GMT+06:00)' },
    { name: 'Europe/Brussels', desc: 'Belgium - Brussels (GMT+02:00)' },
    { name: 'Africa/Ouagadougou', desc: 'Burkina Faso - Ouagadougou (GMT+00:00)' },
    { name: 'Europe/Sofia', desc: 'Bulgaria - Sofia (GMT+03:00)' },
    { name: 'Asia/Bahrain', desc: 'Bahrain - Bahrain (GMT+03:00)' },
    { name: 'Africa/Bujumbura', desc: 'Burundi - Bujumbura (GMT+02:00)' },
    { name: 'Africa/Porto-Novo', desc: 'Benin - Porto-Novo (GMT+01:00)' },
    { name: 'America/St_Barthelemy', desc: 'Saint-Barthélemy - St Barthelemy (GMT-04:00)' },
    { name: 'Atlantic/Bermuda', desc: 'Bermuda - Bermuda (GMT-03:00)' },
    { name: 'Asia/Brunei', desc: 'Brunei Darussalam - Brunei (GMT+08:00)' },
    { name: 'America/La_Paz', desc: 'Bolivia - La Paz (GMT-04:00)' },
    { name: 'America/Kralendijk', desc: 'BQ - Kralendijk (GMT-04:00)' },
    { name: 'America/Noronha', desc: 'Brazil - Noronha (GMT-02:00)' },
    { name: 'America/Belem', desc: 'Brazil - Belem (GMT-03:00)' },
    { name: 'America/Fortaleza', desc: 'Brazil - Fortaleza (GMT-03:00)' },
    { name: 'America/Recife', desc: 'Brazil - Recife (GMT-03:00)' },
    { name: 'America/Araguaina', desc: 'Brazil - Araguaina (GMT-03:00)' },
    { name: 'America/Maceio', desc: 'Brazil - Maceio (GMT-03:00)' },
    { name: 'America/Bahia', desc: 'Brazil - Bahia (GMT-03:00)' },
    { name: 'America/Sao_Paulo', desc: 'Brazil - Sao Paulo (GMT-03:00)' },
    { name: 'America/Campo_Grande', desc: 'Brazil - Campo Grande (GMT-04:00)' },
    { name: 'America/Cuiaba', desc: 'Brazil - Cuiaba (GMT-04:00)' },
    { name: 'America/Santarem', desc: 'Brazil - Santarem (GMT-03:00)' },
    { name: 'America/Porto_Velho', desc: 'Brazil - Porto Velho (GMT-04:00)' },
    { name: 'America/Boa_Vista', desc: 'Brazil - Boa Vista (GMT-04:00)' },
    { name: 'America/Manaus', desc: 'Brazil - Manaus (GMT-04:00)' },
    { name: 'America/Eirunepe', desc: 'Brazil - Eirunepe (GMT-05:00)' },
    { name: 'America/Rio_Branco', desc: 'Brazil - Rio Branco (GMT-05:00)' },
    { name: 'America/Nassau', desc: 'Bahamas - Nassau (GMT-04:00)' },
    { name: 'Asia/Thimphu', desc: 'Bhutan - Thimphu (GMT+06:00)' },
    { name: 'Africa/Gaborone', desc: 'Botswana - Gaborone (GMT+02:00)' },
    { name: 'Europe/Minsk', desc: 'Belarus - Minsk (GMT+03:00)' },
    { name: 'America/Belize', desc: 'Belize - Belize (GMT-06:00)' },
    { name: 'America/St_Johns', desc: 'Canada - St Johns (GMT-02:30)' },
    { name: 'America/Halifax', desc: 'Canada - Halifax (GMT-03:00)' },
    { name: 'America/Glace_Bay', desc: 'Canada - Glace Bay (GMT-03:00)' },
    { name: 'America/Moncton', desc: 'Canada - Moncton (GMT-03:00)' },
    { name: 'America/Goose_Bay', desc: 'Canada - Goose Bay (GMT-03:00)' },
    { name: 'America/Blanc-Sablon', desc: 'Canada - Blanc-Sablon (GMT-04:00)' },
    { name: 'America/Toronto', desc: 'Canada - Toronto (GMT-04:00)' },
    { name: 'America/Nipigon', desc: 'Canada - Nipigon (GMT-04:00)' },
    { name: 'America/Thunder_Bay', desc: 'Canada - Thunder Bay (GMT-04:00)' },
    { name: 'America/Iqaluit', desc: 'Canada - Iqaluit (GMT-04:00)' },
    { name: 'America/Pangnirtung', desc: 'Canada - Pangnirtung (GMT-04:00)' },
    { name: 'America/Resolute', desc: 'Canada - Resolute (GMT-05:00)' },
    { name: 'America/Atikokan', desc: 'Canada - Atikokan (GMT-05:00)' },
    { name: 'America/Rankin_Inlet', desc: 'Canada - Rankin Inlet (GMT-05:00)' },
    { name: 'America/Winnipeg', desc: 'Canada - Winnipeg (GMT-05:00)' },
    { name: 'America/Rainy_River', desc: 'Canada - Rainy River (GMT-05:00)' },
    { name: 'America/Regina', desc: 'Canada - Regina (GMT-06:00)' },
    { name: 'America/Swift_Current', desc: 'Canada - Swift Current (GMT-06:00)' },
    { name: 'America/Edmonton', desc: 'Canada - Edmonton (GMT-06:00)' },
    { name: 'America/Cambridge_Bay', desc: 'Canada - Cambridge Bay (GMT-06:00)' },
    { name: 'America/Yellowknife', desc: 'Canada - Yellowknife (GMT-06:00)' },
    { name: 'America/Inuvik', desc: 'Canada - Inuvik (GMT-06:00)' },
    { name: 'America/Creston', desc: 'Canada - Creston (GMT-07:00)' },
    { name: 'America/Dawson_Creek', desc: 'Canada - Dawson Creek (GMT-07:00)' },
    { name: 'America/Vancouver', desc: 'Canada - Vancouver (GMT-07:00)' },
    { name: 'America/Whitehorse', desc: 'Canada - Whitehorse (GMT-07:00)' },
    { name: 'America/Dawson', desc: 'Canada - Dawson (GMT-07:00)' },
    { name: 'America/Montreal', desc: 'Canada - Montreal (GMT-04:00)' },
    { name: 'Canada/Atlantic', desc: 'Canada - Atlantic (GMT-03:00)' },
    { name: 'Canada/Central', desc: 'Canada - Central (GMT-05:00)' },
    { name: 'Canada/Eastern', desc: 'Canada - Eastern (GMT-04:00)' },
    { name: 'Canada/Mountain', desc: 'Canada - Mountain (GMT-06:00)' },
    { name: 'Canada/Newfoundland', desc: 'Canada - Newfoundland (GMT-02:30)' },
    { name: 'Canada/Pacific', desc: 'Canada - Pacific (GMT-07:00)' },
    { name: 'Canada/Saskatchewan', desc: 'Canada - Saskatchewan (GMT-06:00)' },
    { name: 'Canada/Yukon', desc: 'Canada - Yukon (GMT-07:00)' },
    { name: 'Indian/Cocos', desc: 'Cocos (Keeling) Islands - Cocos (GMT+06:30)' },
    { name: 'Africa/Kinshasa', desc: 'Congo, (Kinshasa) - Kinshasa (GMT+01:00)' },
    { name: 'Africa/Lubumbashi', desc: 'Congo, (Kinshasa) - Lubumbashi (GMT+02:00)' },
    { name: 'Africa/Bangui', desc: 'Central African Republic - Bangui (GMT+01:00)' },
    { name: 'Africa/Brazzaville', desc: 'Congo (Brazzaville) - Brazzaville (GMT+01:00)' },
    { name: 'Europe/Zurich', desc: 'Switzerland - Zurich (GMT+02:00)' },
    { name: 'Africa/Abidjan', desc: 'Côte d\'Ivoire - Abidjan (GMT+00:00)' },
    { name: 'Pacific/Rarotonga', desc: 'Cook Islands - Rarotonga (GMT-10:00)' },
    { name: 'America/Santiago', desc: 'Chile - Santiago (GMT-04:00)' },
    { name: 'Pacific/Easter', desc: 'Chile - Easter (GMT-06:00)' },
    { name: 'Chile/Continental', desc: 'Chile - Continental (GMT-04:00)' },
    { name: 'Chile/EasterIsland', desc: 'Chile - EasterIsland (GMT-06:00)' },
    { name: 'Africa/Douala', desc: 'Cameroon - Douala (GMT+01:00)' },
    { name: 'Asia/Shanghai', desc: 'China - Shanghai (GMT+08:00)' },
    { name: 'Asia/Harbin', desc: 'China - Harbin (GMT+08:00)' },
    { name: 'Asia/Chongqing', desc: 'China - Chongqing (GMT+08:00)' },
    { name: 'Asia/Urumqi', desc: 'China - Urumqi (GMT+06:00)' },
    { name: 'Asia/Kashgar', desc: 'China - Kashgar (GMT+06:00)' },
    { name: 'America/Bogota', desc: 'Colombia - Bogota (GMT-05:00)' },
    { name: 'America/Costa_Rica', desc: 'Costa Rica - Costa Rica (GMT-06:00)' },
    { name: 'America/Havana', desc: 'Cuba - Havana (GMT-04:00)' },
    { name: 'Atlantic/Cape_Verde', desc: 'Cape Verde - Cape Verde (GMT-01:00)' },
    { name: 'America/Curacao', desc: 'CW - Curacao (GMT-04:00)' },
    { name: 'Indian/Christmas', desc: 'Christmas Island - Christmas (GMT+07:00)' },
    { name: 'Asia/Nicosia', desc: 'Cyprus - Nicosia (GMT+03:00)' },
    { name: 'Europe/Prague', desc: 'Czech Republic - Prague (GMT+02:00)' },
    { name: 'Europe/Berlin', desc: 'Germany - Berlin (GMT+02:00)' },
    { name: 'Africa/Djibouti', desc: 'Djibouti - Djibouti (GMT+03:00)' },
    { name: 'Europe/Copenhagen', desc: 'Denmark - Copenhagen (GMT+02:00)' },
    { name: 'America/Dominica', desc: 'Dominica - Dominica (GMT-04:00)' },
    { name: 'America/Santo_Domingo', desc: 'Dominican Republic - Santo Domingo (GMT-04:00)' },
    { name: 'Africa/Algiers', desc: 'Algeria - Algiers (GMT+01:00)' },
    { name: 'America/Guayaquil', desc: 'Ecuador - Guayaquil (GMT-05:00)' },
    { name: 'Pacific/Galapagos', desc: 'Ecuador - Galapagos (GMT-06:00)' },
    { name: 'Europe/Tallinn', desc: 'Estonia - Tallinn (GMT+03:00)' },
    { name: 'Egypt', desc: 'Egypt - Egypt (GMT+02:00)' },
    { name: 'Africa/El_Aaiun', desc: 'Western Sahara - El Aaiun (GMT+00:00)' },
    { name: 'Africa/Asmara', desc: 'Eritrea - Asmara (GMT+03:00)' },
    { name: 'Europe/Madrid', desc: 'Spain - Madrid (GMT+02:00)' },
    { name: 'Africa/Ceuta', desc: 'Spain - Ceuta (GMT+02:00)' },
    { name: 'Atlantic/Canary', desc: 'Spain - Canary (GMT+01:00)' },
    { name: 'Africa/Addis_Ababa', desc: 'Ethiopia - Addis Ababa (GMT+03:00)' },
    { name: 'Europe/Helsinki', desc: 'Finland - Helsinki (GMT+03:00)' },
    { name: 'Pacific/Fiji', desc: 'Fiji - Fiji (GMT+12:00)' },
    { name: 'Atlantic/Stanley', desc: 'Falkland Islands (Malvinas) - Stanley (GMT-03:00)' },
    { name: 'Pacific/Chuuk', desc: 'Micronesia - Chuuk (GMT+10:00)' },
    { name: 'Pacific/Pohnpei', desc: 'Micronesia - Pohnpei (GMT+11:00)' },
    { name: 'Pacific/Kosrae', desc: 'Micronesia - Kosrae (GMT+11:00)' },
    { name: 'Atlantic/Faroe', desc: 'Faroe Islands - Faroe (GMT+01:00)' },
    { name: 'Europe/Paris', desc: 'France - Paris (GMT+02:00)' },
    { name: 'Africa/Libreville', desc: 'Gabon - Libreville (GMT+01:00)' },
    { name: 'Europe/London', desc: 'United Kingdom (GB) - London (GMT+01:00)' },
    { name: 'America/Grenada', desc: 'Grenada - Grenada (GMT-04:00)' },
    { name: 'Asia/Tbilisi', desc: 'Georgia - Tbilisi (GMT+04:00)' },
    { name: 'America/Cayenne', desc: 'French Guiana - Cayenne (GMT-03:00)' },
    { name: 'Europe/Guernsey', desc: 'Guernsey - Guernsey (GMT+01:00)' },
    { name: 'Africa/Accra', desc: 'Ghana - Accra (GMT+00:00)' },
    { name: 'Europe/Gibraltar', desc: 'Gibraltar - Gibraltar (GMT+02:00)' },
    { name: 'America/Godthab', desc: 'Greenland - Godthab (GMT-02:00)' },
    { name: 'America/Danmarkshavn', desc: 'Greenland - Danmarkshavn (GMT+00:00)' },
    { name: 'America/Scoresbysund', desc: 'Greenland - Scoresbysund (GMT+00:00)' },
    { name: 'America/Thule', desc: 'Greenland - Thule (GMT-03:00)' },
    { name: 'Africa/Banjul', desc: 'Gambia - Banjul (GMT+00:00)' },
    { name: 'Africa/Conakry', desc: 'Guinea - Conakry (GMT+00:00)' },
    { name: 'America/Guadeloupe', desc: 'Guadeloupe - Guadeloupe (GMT-04:00)' },
    { name: 'Africa/Malabo', desc: 'Equatorial Guinea - Malabo (GMT+01:00)' },
    { name: 'Europe/Athens', desc: 'Greece - Athens (GMT+03:00)' },
    { name: 'Atlantic/South_Georgia', desc: 'South Georgia and the South Sandwich Islands - South Georgia (GMT-02:00)' },
    { name: 'America/Guatemala', desc: 'Guatemala - Guatemala (GMT-06:00)' },
    { name: 'Pacific/Guam', desc: 'Guam - Guam (GMT+10:00)' },
    { name: 'Africa/Bissau', desc: 'Guinea-Bissau - Bissau (GMT+00:00)' },
    { name: 'America/Guyana', desc: 'Guyana - Guyana (GMT-04:00)' },
    { name: 'Asia/Hong_Kong', desc: 'Hong Kong - Hong Kong (GMT+08:00)' },
    { name: 'America/Tegucigalpa', desc: 'Honduras - Tegucigalpa (GMT-06:00)' },
    { name: 'Europe/Zagreb', desc: 'Croatia - Zagreb (GMT+02:00)' },
    { name: 'America/Port-au-Prince', desc: 'Haiti - Port-au-Prince (GMT-04:00)' },
    { name: 'Europe/Budapest', desc: 'Hungary - Budapest (GMT+02:00)' },
    { name: 'Asia/Jakarta', desc: 'Indonesia - Jakarta (GMT+07:00)' },
    { name: 'Asia/Pontianak', desc: 'Indonesia - Pontianak (GMT+07:00)' },
    { name: 'Asia/Makassar', desc: 'Indonesia - Makassar (GMT+08:00)' },
    { name: 'Asia/Jayapura', desc: 'Indonesia - Jayapura (GMT+09:00)' },
    { name: 'Europe/Dublin', desc: 'Ireland - Dublin (GMT+01:00)' },
    { name: 'Asia/Jerusalem', desc: 'Israel - Jerusalem (GMT+03:00)' },
    { name: 'Europe/Isle_of_Man', desc: 'Isle of Man - Isle of_Man (GMT+01:00)' },
    { name: 'Asia/Kolkata', desc: 'India - Kolkata (GMT+05:30)' },
    { name: 'Indian/Chagos', desc: 'British Indian Ocean Territory - Chagos (GMT+06:00)' },
    { name: 'Asia/Baghdad', desc: 'Iraq - Baghdad (GMT+03:00)' },
    { name: 'Asia/Tehran', desc: 'Iran - Tehran (GMT+04:30)' },
    { name: 'Atlantic/Reykjavik', desc: 'Iceland - Reykjavik (GMT+00:00)' },
    { name: 'Europe/Rome', desc: 'Italy - Rome (GMT+02:00)' },
    { name: 'Europe/Jersey', desc: 'Jersey - Jersey (GMT+01:00)' },
    { name: 'America/Jamaica', desc: 'Jamaica - Jamaica (GMT-05:00)' },
    { name: 'Asia/Amman', desc: 'Jordan - Amman (GMT+03:00)' },
    { name: 'Asia/Tokyo', desc: 'Japan - Tokyo (GMT+09:00)' },
    { name: 'Africa/Nairobi', desc: 'Kenya - Nairobi (GMT+03:00)' },
    { name: 'Asia/Bishkek', desc: 'Kyrgyzstan - Bishkek (GMT+06:00)' },
    { name: 'Asia/Phnom_Penh', desc: 'Cambodia - Phnom Penh (GMT+07:00)' },
    { name: 'Pacific/Tarawa', desc: 'Kiribati - Tarawa (GMT+12:00)' },
    { name: 'Pacific/Enderbury', desc: 'Kiribati - Enderbury (GMT+13:00)' },
    { name: 'Pacific/Kiritimati', desc: 'Kiribati - Kiritimati (GMT+14:00)' },
    { name: 'Indian/Comoro', desc: 'Comoros - Comoro (GMT+03:00)' },
    { name: 'America/St_Kitts', desc: 'Saint Kitts and Nevis - St Kitts (GMT-04:00)' },
    { name: 'Asia/Pyongyang', desc: 'Korea (North) - Pyongyang (GMT+09:00)' },
    { name: 'Asia/Seoul', desc: 'Korea (South) - Seoul (GMT+09:00)' },
    { name: 'Asia/Kuwait', desc: 'Kuwait - Kuwait (GMT+03:00)' },
    { name: 'America/Cayman', desc: 'Cayman Islands - Cayman (GMT-05:00)' },
    { name: 'Asia/Almaty', desc: 'Kazakhstan - Almaty (GMT+06:00)' },
    { name: 'Asia/Qyzylorda', desc: 'Kazakhstan - Qyzylorda (GMT+06:00)' },
    { name: 'Asia/Aqtobe', desc: 'Kazakhstan - Aqtobe (GMT+05:00)' },
    { name: 'Asia/Aqtau', desc: 'Kazakhstan - Aqtau (GMT+05:00)' },
    { name: 'Asia/Oral', desc: 'Kazakhstan - Oral (GMT+05:00)' },
    { name: 'Asia/Vientiane', desc: 'Lao PDR - Vientiane (GMT+07:00)' },
    { name: 'Asia/Beirut', desc: 'Lebanon - Beirut (GMT+03:00)' },
    { name: 'America/St_Lucia', desc: 'Saint Lucia - St Lucia (GMT-04:00)' },
    { name: 'Europe/Vaduz', desc: 'Liechtenstein - Vaduz (GMT+02:00)' },
    { name: 'Asia/Colombo', desc: 'Sri Lanka - Colombo (GMT+05:30)' },
    { name: 'Africa/Monrovia', desc: 'Liberia - Monrovia (GMT+00:00)' },
    { name: 'Africa/Maseru', desc: 'Lesotho - Maseru (GMT+02:00)' },
    { name: 'Europe/Vilnius', desc: 'Lithuania - Vilnius (GMT+03:00)' },
    { name: 'Europe/Luxembourg', desc: 'Luxembourg - Luxembourg (GMT+02:00)' },
    { name: 'Europe/Riga', desc: 'Latvia - Riga (GMT+03:00)' },
    { name: 'Africa/Tripoli', desc: 'Libya - Tripoli (GMT+02:00)' },
    { name: 'Africa/Casablanca', desc: 'Morocco - Casablanca (GMT+00:00)' },
    { name: 'Europe/Monaco', desc: 'Monaco - Monaco (GMT+02:00)' },
    { name: 'Europe/Chisinau', desc: 'Moldova - Chisinau (GMT+03:00)' },
    { name: 'Europe/Podgorica', desc: 'Montenegro - Podgorica (GMT+02:00)' },
    { name: 'America/Marigot', desc: 'Saint-Martin (French part) - Marigot (GMT-04:00)' },
    { name: 'Indian/Antananarivo', desc: 'Madagascar - Antananarivo (GMT+03:00)' },
    { name: 'Pacific/Majuro', desc: 'Marshall Islands - Majuro (GMT+12:00)' },
    { name: 'Pacific/Kwajalein', desc: 'Marshall Islands - Kwajalein (GMT+12:00)' },
    { name: 'Europe/Skopje', desc: 'Macedonia - Skopje (GMT+02:00)' },
    { name: 'Africa/Bamako', desc: 'Mali - Bamako (GMT+00:00)' },
    { name: 'Asia/Rangoon', desc: 'Myanmar - Rangoon (GMT+06:30)' },
    { name: 'Asia/Ulaanbaatar', desc: 'Mongolia - Ulaanbaatar (GMT+08:00)' },
    { name: 'Asia/Hovd', desc: 'Mongolia - Hovd (GMT+07:00)' },
    { name: 'Asia/Choibalsan', desc: 'Mongolia - Choibalsan (GMT+08:00)' },
    { name: 'Asia/Macau', desc: 'Macao - Macau (GMT+08:00)' },
    { name: 'Pacific/Saipan', desc: 'Northern Mariana Islands - Saipan (GMT+10:00)' },
    { name: 'America/Martinique', desc: 'Martinique - Martinique (GMT-04:00)' },
    { name: 'Africa/Nouakchott', desc: 'Mauritania - Nouakchott (GMT+00:00)' },
    { name: 'America/Montserrat', desc: 'Montserrat - Montserrat (GMT-04:00)' },
    { name: 'Europe/Malta', desc: 'Malta - Malta (GMT+02:00)' },
    { name: 'Indian/Mauritius', desc: 'Mauritius - Mauritius (GMT+04:00)' },
    { name: 'Indian/Maldives', desc: 'Maldives - Maldives (GMT+05:00)' },
    { name: 'Africa/Blantyre', desc: 'Malawi - Blantyre (GMT+02:00)' },
    { name: 'America/Mexico_City', desc: 'Mexico - Mexico City (GMT-05:00)' },
    { name: 'America/Cancun', desc: 'Mexico - Cancun (GMT-05:00)' },
    { name: 'America/Merida', desc: 'Mexico - Merida (GMT-05:00)' },
    { name: 'America/Monterrey', desc: 'Mexico - Monterrey (GMT-05:00)' },
    { name: 'America/Matamoros', desc: 'Mexico - Matamoros (GMT-05:00)' },
    { name: 'America/Mazatlan', desc: 'Mexico - Mazatlan (GMT-06:00)' },
    { name: 'America/Chihuahua', desc: 'Mexico - Chihuahua (GMT-06:00)' },
    { name: 'America/Ojinaga', desc: 'Mexico - Ojinaga (GMT-06:00)' },
    { name: 'America/Hermosillo', desc: 'Mexico - Hermosillo (GMT-07:00)' },
    { name: 'America/Tijuana', desc: 'Mexico - Tijuana (GMT-07:00)' },
    { name: 'America/Santa_Isabel', desc: 'Mexico - Santa Isabel (GMT-07:00)' },
    { name: 'America/Bahia_Banderas', desc: 'Mexico - Bahia Banderas (GMT-05:00)' },
    { name: 'Asia/Kuala_Lumpur', desc: 'Malaysia - Kuala Lumpur (GMT+08:00)' },
    { name: 'Asia/Kuching', desc: 'Malaysia - Kuching (GMT+08:00)' },
    { name: 'Africa/Maputo', desc: 'Mozambique - Maputo (GMT+02:00)' },
    { name: 'Africa/Windhoek', desc: 'Namibia - Windhoek (GMT+02:00)' },
    { name: 'Pacific/Noumea', desc: 'New Caledonia - Noumea (GMT+11:00)' },
    { name: 'Africa/Niamey', desc: 'Niger - Niamey (GMT+01:00)' },
    { name: 'Pacific/Norfolk', desc: 'Norfolk Island - Norfolk (GMT+11:00)' },
    { name: 'Africa/Lagos', desc: 'Nigeria - Lagos (GMT+01:00)' },
    { name: 'America/Managua', desc: 'Nicaragua - Managua (GMT-06:00)' },
    { name: 'Europe/Amsterdam', desc: 'Netherlands - Amsterdam (GMT+02:00)' },
    { name: 'Europe/Oslo', desc: 'Norway - Oslo (GMT+02:00)' },
    { name: 'Asia/Kathmandu', desc: 'Nepal - Kathmandu (GMT+05:45)' },
    { name: 'Pacific/Nauru', desc: 'Nauru - Nauru (GMT+12:00)' },
    { name: 'Pacific/Niue', desc: 'Niue - Niue (GMT-11:00)' },
    { name: 'Pacific/Auckland', desc: 'New Zealand - Auckland (GMT+12:00)' },
    { name: 'Pacific/Chatham', desc: 'New Zealand - Chatham (GMT+12:45)' },
    { name: 'Asia/Muscat', desc: 'Oman - Muscat (GMT+04:00)' },
    { name: 'America/Panama', desc: 'Panama - Panama (GMT-05:00)' },
    { name: 'America/Lima', desc: 'Peru - Lima (GMT-05:00)' },
    { name: 'Pacific/Tahiti', desc: 'French Polynesia - Tahiti (GMT-10:00)' },
    { name: 'Pacific/Marquesas', desc: 'French Polynesia - Marquesas (GMT-09:30)' },
    { name: 'Pacific/Gambier', desc: 'French Polynesia - Gambier (GMT-09:00)' },
    { name: 'Pacific/Port_Moresby', desc: 'Papua New Guinea - Port Moresby (GMT+10:00)' },
    { name: 'Asia/Manila', desc: 'Philippines - Manila (GMT+08:00)' },
    { name: 'Asia/Karachi', desc: 'Pakistan - Karachi (GMT+05:00)' },
    { name: 'Europe/Warsaw', desc: 'Poland - Warsaw (GMT+02:00)' },
    { name: 'Poland', desc: 'Poland - Poland (GMT+02:00)' },
    { name: 'America/Miquelon', desc: 'Saint Pierre and Miquelon - Miquelon (GMT-02:00)' },
    { name: 'Pacific/Pitcairn', desc: 'Pitcairn - Pitcairn (GMT-08:00)' },
    { name: 'America/Puerto_Rico', desc: 'Puerto Rico - Puerto Rico (GMT-04:00)' },
    { name: 'Asia/Gaza', desc: 'Palestinian Territory - Gaza (GMT+03:00)' },
    { name: 'Asia/Hebron', desc: 'Palestinian Territory - Hebron (GMT+03:00)' },
    { name: 'Europe/Lisbon', desc: 'Portugal - Lisbon (GMT+01:00)' },
    { name: 'Atlantic/Madeira', desc: 'Portugal - Madeira (GMT+01:00)' },
    { name: 'Atlantic/Azores', desc: 'Portugal - Azores (GMT+00:00)' },
    { name: 'Pacific/Palau', desc: 'Palau - Palau (GMT+09:00)' },
    { name: 'America/Asuncion', desc: 'Paraguay - Asuncion (GMT-04:00)' },
    { name: 'Asia/Qatar', desc: 'Qatar - Qatar (GMT+03:00)' },
    { name: 'Indian/Reunion', desc: 'Réunion - Reunion (GMT+04:00)' },
    { name: 'Europe/Bucharest', desc: 'Romania - Bucharest (GMT+03:00)' },
    { name: 'Europe/Belgrade', desc: 'Serbia - Belgrade (GMT+02:00)' },
    { name: 'Europe/Kaliningrad', desc: 'Russian Federation - Kaliningrad (GMT+02:00)' },
    { name: 'Europe/Moscow', desc: 'Russian Federation - Moscow (GMT+03:00)' },
    { name: 'Europe/Volgograd', desc: 'Russian Federation - Volgograd (GMT+03:00)' },
    { name: 'Europe/Samara', desc: 'Russian Federation - Samara (GMT+04:00)' },
    { name: 'Europe/Simferopol', desc: 'Russian Federation - Simferopol (GMT+03:00)' },
    { name: 'Asia/Yekaterinburg', desc: 'Russian Federation - Yekaterinburg (GMT+05:00)' },
    { name: 'Asia/Omsk', desc: 'Russian Federation - Omsk (GMT+06:00)' },
    { name: 'Asia/Novosibirsk', desc: 'Russian Federation - Novosibirsk (GMT+07:00)' },
    { name: 'Asia/Novokuznetsk', desc: 'Russian Federation - Novokuznetsk (GMT+07:00)' },
    { name: 'Asia/Krasnoyarsk', desc: 'Russian Federation - Krasnoyarsk (GMT+07:00)' },
    { name: 'Asia/Irkutsk', desc: 'Russian Federation - Irkutsk (GMT+08:00)' },
    { name: 'Asia/Yakutsk', desc: 'Russian Federation - Yakutsk (GMT+09:00)' },
    { name: 'Asia/Khandyga', desc: 'Russian Federation - Khandyga (GMT+09:00)' },
    { name: 'Asia/Vladivostok', desc: 'Russian Federation - Vladivostok (GMT+10:00)' },
    { name: 'Asia/Sakhalin', desc: 'Russian Federation - Sakhalin (GMT+11:00)' },
    { name: 'Asia/Ust-Nera', desc: 'Russian Federation - Ust-Nera (GMT+10:00)' },
    { name: 'Asia/Magadan', desc: 'Russian Federation - Magadan (GMT+11:00)' },
    { name: 'Asia/Kamchatka', desc: 'Russian Federation - Kamchatka (GMT+12:00)' },
    { name: 'Asia/Anadyr', desc: 'Russian Federation - Anadyr (GMT+12:00)' },
    { name: 'Africa/Kigali', desc: 'Rwanda - Kigali (GMT+02:00)' },
    { name: 'Asia/Riyadh', desc: 'Saudi Arabia - Riyadh (GMT+03:00)' },
    { name: 'Pacific/Guadalcanal', desc: 'Solomon Islands - Guadalcanal (GMT+11:00)' },
    { name: 'Indian/Mahe', desc: 'Seychelles - Mahe (GMT+04:00)' },
    { name: 'Africa/Khartoum', desc: 'Sudan - Khartoum (GMT+02:00)' },
    { name: 'Europe/Stockholm', desc: 'Sweden - Stockholm (GMT+02:00)' },
    { name: 'Asia/Singapore', desc: 'Singapore - Singapore (GMT+08:00)' },
    { name: 'Atlantic/St_Helena', desc: 'Saint Helena - St Helena (GMT+00:00)' },
    { name: 'Europe/Ljubljana', desc: 'Slovenia - Ljubljana (GMT+02:00)' },
    { name: 'Arctic/Longyearbyen', desc: 'Svalbard and Jan Mayen Islands - Longyearbyen (GMT+02:00)' },
    { name: 'Europe/Bratislava', desc: 'Slovakia - Bratislava (GMT+02:00)' },
    { name: 'Africa/Freetown', desc: 'Sierra Leone - Freetown (GMT+00:00)' },
    { name: 'Europe/San_Marino', desc: 'San Marino - San Marino (GMT+02:00)' },
    { name: 'Africa/Dakar', desc: 'Senegal - Dakar (GMT+00:00)' },
    { name: 'Africa/Mogadishu', desc: 'Somalia - Mogadishu (GMT+03:00)' },
    { name: 'America/Paramaribo', desc: 'Suriname - Paramaribo (GMT-03:00)' },
    { name: 'Africa/Juba', desc: 'South Sudan - Juba (GMT+03:00)' },
    { name: 'Africa/Sao_Tome', desc: 'Sao Tome and Principe - Sao Tome (GMT+01:00)' },
    { name: 'America/El_Salvador', desc: 'El Salvador - El Salvador (GMT-06:00)' },
    { name: 'America/Lower_Princes', desc: 'SX - Lower Princes (GMT-04:00)' },
    { name: 'Asia/Damascus', desc: 'Syria - Damascus (GMT+03:00)' },
    { name: 'Africa/Mbabane', desc: 'Swaziland - Mbabane (GMT+02:00)' },
    { name: 'America/Grand_Turk', desc: 'Turks and Caicos Islands - Grand Turk (GMT-04:00)' },
    { name: 'Africa/Ndjamena', desc: 'Chad - Ndjamena (GMT+01:00)' },
    { name: 'Indian/Kerguelen', desc: 'French Southern Territories - Kerguelen (GMT+05:00)' },
    { name: 'Africa/Lome', desc: 'Togo - Lome (GMT+00:00)' },
    { name: 'Asia/Bangkok', desc: 'Thailand - Bangkok (GMT+07:00)' },
    { name: 'Asia/Dushanbe', desc: 'Tajikistan - Dushanbe (GMT+05:00)' },
    { name: 'Pacific/Fakaofo', desc: 'Tokelau - Fakaofo (GMT+13:00)' },
    { name: 'Asia/Dili', desc: 'Timor-Leste - Dili (GMT+09:00)' },
    { name: 'Asia/Ashgabat', desc: 'Turkmenistan - Ashgabat (GMT+05:00)' },
    { name: 'Africa/Tunis', desc: 'Tunisia - Tunis (GMT+01:00)' },
    { name: 'Pacific/Tongatapu', desc: 'Tonga - Tongatapu (GMT+13:00)' },
    { name: 'Europe/Istanbul', desc: 'Turkey - Istanbul (GMT+03:00)' },
    { name: 'America/Port_of_Spain', desc: 'Trinidad and Tobago - Port of_Spain (GMT-04:00)' },
    { name: 'Pacific/Funafuti', desc: 'Tuvalu - Funafuti (GMT+12:00)' },
    { name: 'Asia/Taipei', desc: 'Taiwan - Taipei (GMT+08:00)' },
    { name: 'Africa/Dar_es_Salaam', desc: 'Tanzania - Dar es_Salaam (GMT+03:00)' },
    { name: 'Europe/Kiev', desc: 'Ukraine - Kiev (GMT+03:00)' },
    { name: 'Europe/Uzhgorod', desc: 'Ukraine - Uzhgorod (GMT+03:00)' },
    { name: 'Europe/Zaporozhye', desc: 'Ukraine - Zaporozhye (GMT+03:00)' },
    { name: 'Africa/Kampala', desc: 'Uganda - Kampala (GMT+03:00)' },
    { name: 'Pacific/Johnston', desc: 'US Minor Outlying Islands - Johnston (GMT-10:00)' },
    { name: 'Pacific/Midway', desc: 'US Minor Outlying Islands - Midway (GMT-11:00)' },
    { name: 'Pacific/Wake', desc: 'US Minor Outlying Islands - Wake (GMT+12:00)' },
    { name: 'America/New_York', desc: 'United States of America (USA) - New York (GMT-04:00)' },
    { name: 'America/Detroit', desc: 'United States of America (USA) - Detroit (GMT-04:00)' },
    { name: 'America/Kentucky/Louisville', desc: 'United States of America (USA) - Louisville (GMT-04:00)' },
    { name: 'America/Kentucky/Monticello', desc: 'United States of America (USA) - Monticello (GMT-04:00)' },
    { name: 'America/Indiana/Indianapolis', desc: 'United States of America (USA) - Indianapolis (GMT-04:00)' },
    { name: 'America/Indiana/Vincennes', desc: 'United States of America (USA) - Vincennes (GMT-04:00)' },
    { name: 'America/Indiana/Winamac', desc: 'United States of America (USA) - Winamac (GMT-04:00)' },
    { name: 'America/Indiana/Marengo', desc: 'United States of America (USA) - Marengo (GMT-04:00)' },
    { name: 'America/Indiana/Petersburg', desc: 'United States of America (USA) - Petersburg (GMT-04:00)' },
    { name: 'America/Indiana/Vevay', desc: 'United States of America (USA) - Vevay (GMT-04:00)' },
    { name: 'America/Chicago', desc: 'United States of America (USA) - Chicago (GMT-05:00)' },
    { name: 'America/Indiana/Tell_City', desc: 'United States of America (USA) - Tell City (GMT-05:00)' },
    { name: 'America/Indiana/Knox', desc: 'United States of America (USA) - Knox (GMT-05:00)' },
    { name: 'America/Menominee', desc: 'United States of America (USA) - Menominee (GMT-05:00)' },
    { name: 'America/North_Dakota/Center', desc: 'United States of America (USA) - Center (GMT-05:00)' },
    { name: 'America/North_Dakota/New_Salem', desc: 'United States of America (USA) - New Salem (GMT-05:00)' },
    { name: 'America/North_Dakota/Beulah', desc: 'United States of America (USA) - Beulah (GMT-05:00)' },
    { name: 'America/Denver', desc: 'United States of America (USA) - Denver (GMT-06:00)' },
    { name: 'America/Boise', desc: 'United States of America (USA) - Boise (GMT-06:00)' },
    { name: 'America/Phoenix', desc: 'United States of America (USA) - Phoenix (GMT-07:00)' },
    { name: 'America/Los_Angeles', desc: 'United States of America (USA) - Los Angeles (GMT-07:00)' },
    { name: 'America/Anchorage', desc: 'United States of America (USA) - Anchorage (GMT-08:00)' },
    { name: 'America/Juneau', desc: 'United States of America (USA) - Juneau (GMT-08:00)' },
    { name: 'America/Sitka', desc: 'United States of America (USA) - Sitka (GMT-08:00)' },
    { name: 'America/Yakutat', desc: 'United States of America (USA) - Yakutat (GMT-08:00)' },
    { name: 'America/Nome', desc: 'United States of America (USA) - Nome (GMT-08:00)' },
    { name: 'America/Adak', desc: 'United States of America (USA) - Adak (GMT-09:00)' },
    { name: 'America/Metlakatla', desc: 'United States of America (USA) - Metlakatla (GMT-08:00)' },
    { name: 'Pacific/Honolulu', desc: 'United States of America (USA) - Honolulu (GMT-10:00)' },
    { name: 'America/Montevideo', desc: 'Uruguay - Montevideo (GMT-03:00)' },
    { name: 'Asia/Samarkand', desc: 'Uzbekistan - Samarkand (GMT+05:00)' },
    { name: 'Asia/Tashkent', desc: 'Uzbekistan - Tashkent (GMT+05:00)' },
    { name: 'Europe/Vatican', desc: 'Vatican City State - Vatican (GMT+02:00)' },
    { name: 'America/St_Vincent', desc: 'Saint Vincent and Grenadines - St Vincent (GMT-04:00)' },
    { name: 'America/Caracas', desc: 'Venezuela - Caracas (GMT-04:00)' },
    { name: 'America/Tortola', desc: 'British Virgin Islands - Tortola (GMT-04:00)' },
    { name: 'America/St_Thomas', desc: 'Virgin Islands, US - St Thomas (GMT-04:00)' },
    { name: 'Asia/Ho_Chi_Minh', desc: 'Viet Nam - Ho Chi_Minh (GMT+07:00)' },
    { name: 'Pacific/Efate', desc: 'Vanuatu - Efate (GMT+11:00)' },
    { name: 'Pacific/Wallis', desc: 'Wallis and Futuna Islands - Wallis (GMT+12:00)' },
    { name: 'Pacific/Apia', desc: 'Samoa - Apia (GMT+13:00)' },
    { name: 'Asia/Aden', desc: 'Yemen - Aden (GMT+03:00)' },
    { name: 'Indian/Mayotte', desc: 'Mayotte - Mayotte (GMT+03:00)' },
    { name: 'Africa/Johannesburg', desc: 'South Africa - Johannesburg (GMT+02:00)' },
    { name: 'Africa/Lusaka', desc: 'Zambia - Lusaka (GMT+02:00)' },
    { name: 'Africa/Harare', desc: 'Zimbabwe - Harare (GMT+02:00)' },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ initialState$3 = {
    isSidebarOpen: false,
    isSidebarActive: false,
    isSidebarInnerActive: false,
    isSidebarStateCloseWithIcons: false,
    windowWidth: 0,
    windowHeight: 0,
    wrapperClasses: '',
    breakpoint: '',
    breakpoints: {
        isMobile: false,
        isTablet: false,
        isLtDesktop: false,
        isDesktop: false,
        isXL: false,
        isXXL: false,
    },
    menuLinks: [],
    sidebarLinks: [],
    combinedLinks: [],
    isBlockDocumentActive: false,
};
class UxAppShellService {
    constructor() {
        this._state$ = new BehaviorSubject(initialState$3);
        this._breakpoint$ = new BehaviorSubject('');
        this._breakpoints$ = new BehaviorSubject({});
    }
    /**
     * @return {?}
     */
    get state$() {
        return this._state$.asObservable();
    }
    /**
     * @return {?}
     */
    get breakpoint$() {
        return this._breakpoint$.asObservable();
    }
    /**
     * @return {?}
     */
    get breakpoints$() {
        return this._breakpoints$.asObservable();
    }
    /**
     * @return {?}
     */
    get state() {
        return this._state$.getValue();
    }
    /**
     * @param {?} nextState
     * @return {?}
     */
    setState(nextState) {
        let /** @type {?} */ breakpoint, /** @type {?} */ breakpoints, /** @type {?} */ wrapperClasses;
        let /** @type {?} */ combinedLinks;
        const /** @type {?} */ state = this.state;
        // check if window width has been updated from previous state
        if (this.state.windowWidth !== nextState.windowWidth) {
            breakpoint = this.getBreakpoint(nextState.windowWidth);
            breakpoints = this.getBreakpoints(breakpoint);
            this._breakpoint$.next(breakpoint);
            this._breakpoints$.next(breakpoints);
            // if not propagate the old ones without doing any calculations
        }
        else {
            breakpoint = state.breakpoint;
            breakpoints = state.breakpoints;
        }
        // finally get the wrapper classes when both the state and breakpoint are known
        wrapperClasses = this.getWrapperClasses(nextState, breakpoint);
        // check if the menuLinks or sidebarLinks have changed from previous state
        if (this.state.menuLinks !== nextState.menuLinks || this.state.sidebarLinks !== nextState.sidebarLinks) {
            combinedLinks = [...nextState.menuLinks, ...nextState.sidebarLinks];
        }
        else {
            combinedLinks = this.state.combinedLinks;
        }
        // we put it all together with the calculated properties
        this._state$.next(Object.assign({}, nextState, { wrapperClasses,
            breakpoint,
            breakpoints,
            combinedLinks }));
    }
    /**
     * @param {?} isOpen
     * @return {?}
     */
    set isSidebarOpen(isOpen) {
        this.setState(Object.assign({}, this.state, { isSidebarOpen: isOpen }));
    }
    /**
     * @return {?}
     */
    sidebarToggle() {
        this.isSidebarOpen = !this.state.isSidebarOpen;
    }
    /**
     * @param {?} links
     * @return {?}
     */
    set sidebarLinks(links) {
        this.setState(Object.assign({}, this.state, { sidebarLinks: links }));
    }
    /**
     * @param {?} links
     * @return {?}
     */
    set menuLinks(links) {
        this.setState(Object.assign({}, this.state, { menuLinks: links }));
    }
    /**
     * @param {?} isActive
     * @return {?}
     */
    set isBlockDocumentActive(isActive) {
        this.setState(Object.assign({}, this.state, { isBlockDocumentActive: isActive }));
    }
    /**
     * @param {?} state
     * @param {?} breakpoint
     * @return {?}
     */
    getWrapperClasses(state, breakpoint) {
        let /** @type {?} */ classes = [];
        classes.push(breakpoint);
        if (state.isSidebarOpen && (state.isSidebarActive || state.isSidebarInnerActive)) {
            classes.push('sidebar-state-open');
        }
        if (!state.isSidebarOpen && (state.isSidebarActive || state.isSidebarInnerActive)) {
            classes.push('sidebar-state-close');
        }
        if (state.isSidebarActive) {
            classes.push('sidebar-active');
        }
        if (state.isSidebarInnerActive) {
            classes.push('sidebar-inner-active');
        }
        if (state.isSidebarStateCloseWithIcons) {
            classes.push('sidebar-state-close-with-icons');
        }
        return classes.join(' ');
    }
    /**
     * @param {?} windowWidth
     * @return {?}
     */
    getBreakpoint(windowWidth) {
        let /** @type {?} */ bkp = '';
        switch (true) {
            case (windowWidth >= 0 && windowWidth < 576):
                bkp = 'xs';
                break;
            case (windowWidth >= 576 && windowWidth < 768):
                bkp = 'sm';
                break;
            case (windowWidth >= 768 && windowWidth < 992):
                bkp = 'md';
                break;
            case (windowWidth >= 992 && windowWidth < 1200):
                bkp = 'lg';
                break;
            case (windowWidth >= 1200 && windowWidth < 1400):
                bkp = 'xl';
                break;
            case (windowWidth >= 1400):
                bkp = 'xxl';
                break;
        }
        return bkp;
    }
    /**
     * @param {?} bkp
     * @return {?}
     */
    getBreakpoints(bkp) {
        return {
            isMobile: (bkp === 'xs' || bkp === 'sm'),
            isTablet: bkp === 'md',
            isLtDesktop: (bkp === 'xs' || bkp === 'sm' || bkp === 'md'),
            isDesktop: bkp === 'lg',
            isXL: bkp === 'xl',
            isXXL: bkp === 'xxl',
        };
    }
}
UxAppShellService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxAppShellService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxModal {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        Object.assign(this, values);
    }
}
class UxService {
    /**
     * @param {?} router
     * @param {?} componentFactoryResolver
     * @param {?} appRef
     * @param {?} injector
     * @param {?} asService
     * @param {?} platformId
     */
    constructor(router, componentFactoryResolver, appRef, injector, asService, platformId) {
        this.router = router;
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.injector = injector;
        this.asService = asService;
        this.platformId = platformId;
        this.isNavigationBlockDocumentActive = false;
        this.isLoggingActive = false;
        this.activeLanguage = {
            code: 'en',
            label: 'English'
        };
        this.growlMessages = [];
        this.isGrowlSticky = false;
        this.growlLife = 3000;
        this.growlPosition = 'bottom-right';
        // DEPRECATED start
        this.isBlockDocumentActive = false;
        this.activeBreakpoint = new BehaviorSubject('');
        this.windowWidth$ = new BehaviorSubject(0);
        this.windowHeight = new BehaviorSubject(0);
        this.sidebarLinks = [];
        // DEPRECATED end
        this.activeModals = [];
        this.openModalId = new BehaviorSubject('');
        if (isPlatformBrowser(this.platformId)) {
            router.events
                .subscribe((event) => {
                if (event instanceof NavigationStart) {
                    this.navigationStartHandler(event);
                }
                if (event instanceof NavigationEnd) {
                    this.navigationEndHandler(event);
                }
            });
        }
    }
    /**
     * @return {?}
     */
    get appRouter() {
        return this.router;
    }
    /**
     * @param {?} querySelector
     * @return {?}
     */
    shadowDomQuery(querySelector) {
        return this.shadowDomRoot.nativeElement.querySelector(querySelector);
    }
    /**
     * @return {?}
     */
    uniqueId() {
        return Math.random().toString(36).substr(2, 9);
    }
    /**
     * @param {?} links
     * @return {?}
     */
    setSidebarLinks(links) {
        this.sidebarLinks = links;
    }
    /**
     * displays a growl UxMessage item, isStycky
     * @param {?} msg
     * @param {?=} isSticky
     * @param {?=} isMultiple
     * @param {?=} life
     * @param {?=} position
     * @return {?}
     */
    growl(msg, isSticky, isMultiple, life, position) {
        if (msg.severity !== 'info' && msg.severity !== 'warning' && msg.severity !== 'success' && msg.severity !== 'danger') {
            throw new Error('UxService.growl() ERROR : message severity must be either : success,warning,info,danger');
        }
        else {
            if (isMultiple === undefined || !isMultiple) {
                this.growlMessages = [];
            }
            this.growlMessages = this.growlMessages.concat(msg);
            if (life === undefined || isNaN(life)) {
                this.growlLife = 3000;
            }
            else {
                this.growlLife = life;
            }
            if (isSticky) {
                this.isGrowlSticky = isSticky;
            }
            else {
                this.isGrowlSticky = false;
            }
            if (position) {
                this.growlPosition = position;
            }
        }
    }
    /**
     * @return {?}
     */
    clearGrowl() {
        this.growlMessages = [];
    }
    /**
     * @param {?} msg
     * @param {?=} position
     * @return {?}
     */
    growlSuccess(msg, position) {
        this.growl({ severity: 'success', summary: 'SUCCESS', detail: msg }, false, false, undefined, position);
    }
    /**
     * @param {?} msg
     * @param {?=} position
     * @return {?}
     */
    growlError(msg, position) {
        this.growl({ severity: 'danger', summary: 'ERROR', detail: msg }, false, false, undefined, position);
    }
    /**
     * @param {?} msg
     * @param {?=} position
     * @return {?}
     */
    growlWarning(msg, position) {
        this.growl({ severity: 'warning', summary: 'WARNING', detail: msg }, false, false, undefined, position);
    }
    /**
     * @param {?} msg
     * @param {?=} position
     * @return {?}
     */
    growlInfo(msg, position) {
        this.growl({ severity: 'info', summary: 'INFO', detail: msg }, false, false, undefined, position);
    }
    /**
     * @return {?}
     */
    blockDocument() {
        console.warn(`
            ****** eUI 4 DEPRECATED WARNING ******
            uxService.blockDocument() will be deprecated and replaced by UxAppShellService.isBlockDocumentActive = true
        `);
        this.asService.isBlockDocumentActive = true;
        // setTimeout(() => this.isBlockDocumentActive = true);
    }
    /**
     * @return {?}
     */
    unblockDocument() {
        console.warn(`
            ****** eUI 4 DEPRECATED WARNING ******
            uxService.unblockDocument() will be deprecated and replaced by UxAppShellService.isBlockDocumentActive = false
        `);
        this.asService.isBlockDocumentActive = false;
        // setTimeout(() => this.isBlockDocumentActive = false);
    }
    /**
     * @param {?} width
     * @return {?}
     */
    setActiveBreakpoint(width) {
        this.windowWidth = width;
        this.windowWidth$.next(width);
        switch (true) {
            case (width >= 0 && width < 576):
                this.activeBreakpoint.next('xs');
                break;
            case (width >= 576 && width < 768):
                this.activeBreakpoint.next('sm');
                break;
            case (width >= 768 && width < 992):
                this.activeBreakpoint.next('md');
                break;
            case (width >= 992 && width < 1200):
                this.activeBreakpoint.next('lg');
                break;
            case (width >= 1200 && width < 1400):
                this.activeBreakpoint.next('xl');
                break;
            case (width >= 1400):
                this.activeBreakpoint.next('xxl');
                break;
        }
        return this.activeBreakpoint.value;
    }
    /**
     * @return {?}
     */
    isMobile() {
        return (this.activeBreakpoint.value === 'xs' || this.activeBreakpoint.value === 'sm');
    }
    /**
     * @return {?}
     */
    isTablet() {
        return this.activeBreakpoint.value === 'md';
    }
    /**
     * @return {?}
     */
    isLtDesktop() {
        return (this.activeBreakpoint.value === 'xs'
            || this.activeBreakpoint.value === 'sm'
            || this.activeBreakpoint.value === 'md');
    }
    /**
     * @return {?}
     */
    isDesktop() {
        return this.activeBreakpoint.value === 'lg';
    }
    /**
     * @return {?}
     */
    isLargeDesktop() {
        return (this.activeBreakpoint.value === 'xl');
    }
    /**
     * @return {?}
     */
    isExtraLargeDesktop() {
        return (this.activeBreakpoint.value === 'xxl');
    }
    /**
     * @param {?} height
     * @return {?}
     */
    setWindowHeight(height) {
        this.windowHeight.next(height);
    }
    /**
     * @param {?} width
     * @return {?}
     */
    setWindowWidth(width) {
        this.windowWidth$.next(width);
    }
    /**
     * @param {?} key
     * @param {?=} languageCode
     * @return {?}
     */
    translate(key, languageCode) {
        let /** @type {?} */ code = 'en';
        if (languageCode) {
            if (languageCode === 'en' || languageCode === 'fr') {
                code = languageCode;
            }
        }
        else {
            if (this.activeLanguage) {
                code = this.activeLanguage.code;
            }
        }
        return UX_I18N[code][key];
    }
    /**
     * @param {?} dateStart
     * @param {?} dateEnd
     * @return {?}
     */
    diffDays(dateStart, dateEnd) {
        return Math.round((dateEnd.getTime() - dateStart.getTime()) / 1000 / 60 / 60 / 24);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    diffDaysFromToday(date) {
        return this.diffDays(new Date(), date);
    }
    /**
     * @return {?}
     */
    toggleInnerSidebar() {
        console.warn(`
            ****** eUI 4 DEPRECATED WARNING ******
            uxService.toggleInnerSidebar() will be deprecated and replaced by UxAppShellService.sidebarToggle()
        `);
        this.asService.sidebarToggle();
    }
    /**
     * @return {?}
     */
    get isSidebarStateOpen() {
        console.warn(`
            ****** eUI 4 DEPRECATED WARNING ******
            uxService.isSidebarStateOpen() will be deprecated and replaced by UxAppShellService.state$.isSidebarOpen.getValue()
        `);
        return this.asService.isSidebarOpen;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    set isSidebarStateOpen(state) {
        console.warn(`
            ****** eUI 4 DEPRECATED WARNING ******
            uxService.isSidebarStateOpen() will be deprecated and replaced by UxAppShellService.isSidebarOpen = true | false
        `);
        this.asService.isSidebarOpen = state;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        let /** @type {?} */ errMsg = (error.message) ? error.message :
            error.status ? `${error.status} - ${error.statusText}` : 'Server error';
        // console.error(errMsg);
        return Observable.throw(errMsg);
    }
    /**
     * @param {?=} modalId
     * @return {?}
     */
    openModal(modalId) {
        document.body.classList.add('modal-open');
        if (!modalId) {
            modalId = 'single_modal';
        }
        this.activeModals.push(new UxModal({
            id: modalId,
            isOpen: true
        }));
        setTimeout(() => {
            const /** @type {?} */ el = document.getElementById(modalId + '-close-button');
            if (el) {
                el.focus();
            }
        }, 100);
    }
    /**
     * @param {?=} messageBoxId
     * @return {?}
     */
    openMessageBox(messageBoxId) {
        if (!messageBoxId) {
            messageBoxId = 'messagebox_modal';
        }
        this.openModal(messageBoxId);
    }
    /**
     * @param {?=} messageBoxId
     * @return {?}
     */
    closeMessageBox(messageBoxId) {
        if (!messageBoxId) {
            messageBoxId = 'messagebox_modal';
        }
        this.closeModal(messageBoxId);
    }
    /**
     * @param {?=} modalId
     * @return {?}
     */
    isModalOpen(modalId) {
        if (!modalId) {
            modalId = 'single_modal';
        }
        if (this.activeModals.length) {
            let /** @type {?} */ modalIndex = this.findModalIndex(modalId);
            if (modalIndex !== -1) {
                return this.activeModals[modalIndex].isOpen;
            }
        }
        return false;
    }
    /**
     * @param {?=} modalId
     * @return {?}
     */
    closeModal(modalId) {
        if (!modalId) {
            modalId = 'single_modal';
        }
        /**
         * Make sure we find the modal before splicing the activeModals array
         */
        const /** @type {?} */ index = this.findModalIndex(modalId);
        if (index >= 0) {
            this.activeModals.splice(index, 1);
        }
        if (this.activeModals && this.activeModals.length <= 0) {
            document.body.classList.remove('modal-open');
        }
        else {
            // If there is still another (parent) modal dialog open, ensure it is focused upon to be able to close is with the ESC key:
            const /** @type {?} */ lastModalId = this.activeModals[this.activeModals.length - 1].id;
            if (lastModalId) {
                setTimeout(() => {
                    const /** @type {?} */ el = document.getElementById(lastModalId + '-close-button');
                    if (el) {
                        el.focus();
                    }
                }, 100);
            }
        }
    }
    /**
     * @param {?} modalId
     * @return {?}
     */
    findModalIndex(modalId) {
        let /** @type {?} */ index = -1;
        if (this.activeModals.length) {
            for (let /** @type {?} */ i = 0; i < this.activeModals.length; i++) {
                if (this.activeModals[i].id === modalId) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    }
    /**
     * Provides read-only equivalent of jQuery's position function:
     * http://api.jquery.com/position/
     * @param {?} nativeEl
     * @return {?}
     */
    position(nativeEl) {
        let /** @type {?} */ elBCR = this.offset(nativeEl);
        let /** @type {?} */ offsetParentBCR = { top: 0, left: 0 };
        let /** @type {?} */ offsetParentEl = this.parentOffsetEl(nativeEl);
        if (offsetParentEl !== this.document) {
            offsetParentBCR = this.offset(offsetParentEl);
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        let /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
        };
    }
    /**
     * Provides read-only equivalent of jQuery's offset function:
     * http://api.jquery.com/offset/
     * @param {?} nativeEl
     * @return {?}
     */
    offset(nativeEl) {
        let /** @type {?} */ boundingClientRect = nativeEl.getBoundingClientRect();
        return {
            width: boundingClientRect.width || nativeEl.offsetWidth,
            height: boundingClientRect.height || nativeEl.offsetHeight,
            top: boundingClientRect.top + (this.window.pageYOffset || this.document.documentElement.scrollTop),
            left: boundingClientRect.left + (this.window.pageXOffset || this.document.documentElement.scrollLeft)
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    consumeEvent(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
            event.cancelBubble = true;
        }
        return false;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validateEmail(c) {
        /* tslint:disable */
        let /** @type {?} */ EMAIL_REGEXP = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        /* tslint:enable */
        return EMAIL_REGEXP.test(c.value) ? null : {
            validateEmail: {
                valid: false
            }
        };
    }
    /**
     * @param {?} FormControls
     * @return {?}
     */
    markFormGroupTouched(FormControls) {
        const /** @type {?} */ markFormGroupTouchedRecursive = (controls) => {
            this.forOwn(controls, (c, controlKey) => {
                if (c instanceof FormGroup || c instanceof FormArray) {
                    markFormGroupTouchedRecursive(c.controls);
                }
                else {
                    c.markAsTouched();
                    c.updateValueAndValidity();
                }
            });
        };
        markFormGroupTouchedRecursive(FormControls);
    }
    /**
     * @return {?}
     */
    getDecimalSeparator() {
        let /** @type {?} */ n = 1.1;
        n = n.toLocaleString().substring(1, 2);
        return n;
    }
    /**
     * @param {?} value
     * @param {?=} fractionSize
     * @param {?=} inDecimalSeparator
     * @param {?=} inThousandSeparator
     * @return {?}
     */
    formatNumber(value, fractionSize = 2, inDecimalSeparator = null, inThousandSeparator = null) {
        let /** @type {?} */ decimalSeparator;
        let /** @type {?} */ thousandsSeparator;
        if (value === null || value === undefined) {
            return null;
        }
        // console.log(inDecimalSeparator)
        // console.log(inThousandSeparator)
        if (inDecimalSeparator) {
            decimalSeparator = inDecimalSeparator;
            if (inDecimalSeparator === ',') {
                thousandsSeparator = ' ';
                inThousandSeparator = ' ';
            }
            else {
                thousandsSeparator = '';
            }
        }
        else {
            decimalSeparator = ',';
        }
        if (inThousandSeparator) {
            thousandsSeparator = inThousandSeparator;
            if (inThousandSeparator === ',') {
                decimalSeparator = '.';
            }
            else {
                decimalSeparator = !inDecimalSeparator || (inDecimalSeparator !== '.' && inDecimalSeparator !== ',') ?
                    ',' :
                    inDecimalSeparator;
            }
        }
        else {
            thousandsSeparator = '';
        }
        const /** @type {?} */ maxFractions = [];
        for (let /** @type {?} */ i = 0; i < fractionSize; i++) {
            maxFractions.push('0');
        }
        const /** @type {?} */ maxFraction = maxFractions.join('');
        let [integer, fraction = maxFraction] = (value || '0').toString().split('.');
        fraction = fractionSize > 0 ? (fraction + maxFraction).substring(0, fractionSize) : '';
        if (fraction === maxFraction) {
            fraction = '';
        }
        // console.log(decimalSeparator)
        // console.log(thousandsSeparator)
        integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSeparator);
        return integer + (fraction.length > 0 ? decimalSeparator + fraction : '');
    }
    /**
     * @param {?} object
     * @param {?} iteratee
     * @return {?}
     */
    forOwn(object, iteratee) {
        object = Object(object);
        Object.keys(object).forEach((key) => iteratee(object[key], key, object));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigationStartHandler(event) {
        /*
                if (this.isNavigationBlockDocumentActive) {
                    this.blockDocument();
                }
                */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigationEndHandler(event) {
        /*
                if (this.isNavigationBlockDocumentActive) {
                    this.unblockDocument();
                }
                */
        window.scrollTo(0, 0);
    }
    /**
     * @return {?}
     */
    get window() {
        return window;
    }
    /**
     * @return {?}
     */
    get document() {
        return window.document;
    }
    /**
     * @param {?} nativeEl
     * @param {?} cssProp
     * @return {?}
     */
    getStyle(nativeEl, cssProp) {
        // IE
        if (nativeEl.currentStyle) {
            return nativeEl.currentStyle[cssProp];
        }
        if (this.window.getComputedStyle) {
            return this.window.getComputedStyle(nativeEl)[cssProp];
        }
        // finally try and get inline style
        return nativeEl.style[cssProp];
    }
    /**
     * Checks if a given element is statically positioned
     * @param {?} nativeEl
     * @return {?}
     */
    isStaticPositioned(nativeEl) {
        return (this.getStyle(nativeEl, 'position') || 'static') === 'static';
    }
    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param {?} nativeEl
     * @return {?}
     */
    parentOffsetEl(nativeEl) {
        let /** @type {?} */ offsetParent = nativeEl.offsetParent || this.document;
        while (offsetParent && offsetParent !== this.document &&
            this.isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || this.document;
    }
}
UxService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxService.ctorParameters = () => [
    { type: Router, },
    { type: ComponentFactoryResolver, },
    { type: ApplicationRef, },
    { type: Injector, },
    { type: UxAppShellService, },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] },] },
];

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class AppEffects {
    /**
     * @param {?} actions
     * @param {?} store
     * @param {?} uxService
     */
    constructor(actions, store, uxService) {
        this.actions = actions;
        this.store = store;
        this.uxService = uxService;
        this.connectionUpdate = this.actions.ofType(APP_CONNECTION_UPDATE)
            .switchMap((action) => {
            if (action.payload === true) {
                return Observable.of({
                    type: APP_CONNECTION_UPDATE_CONFIRMED,
                    payload: true,
                })
                    .do(() => this.store.dispatch(new AppStatusUpdate('connecting')))
                    .delay(2500)
                    .do(() => this.store.dispatch(new AppStatusUpdate('idle')));
            }
            else {
                return Observable.of({
                    type: APP_CONNECTION_UPDATE_CONFIRMED,
                    payload: false,
                })
                    .do(() => this.store.dispatch(new AppStatusUpdate('idle')));
            }
        });
        this.connectionUpdateConfirmed = this.actions.ofType(APP_CONNECTION_UPDATE_CONFIRMED)
            .do((action) => {
            if (!action.payload) {
                this.uxService.growl({ severity: 'danger', summary: 'ERROR', detail: 'You are not connected' }, true, false);
            }
            else {
                this.uxService.growl({ severity: 'success', summary: 'MESSAGE', detail: 'You are connected' }, true, false);
            }
        });
    }
}
AppEffects.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AppEffects.ctorParameters = () => [
    { type: Actions, },
    { type: StoreService, },
    { type: UxService, },
];
__decorate([
    Effect(),
    __metadata("design:type", Object)
], AppEffects.prototype, "connectionUpdate", void 0);
__decorate([
    Effect({ dispatch: false }),
    __metadata("design:type", Object)
], AppEffects.prototype, "connectionUpdateConfirmed", void 0);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * @param {?} action
 * @return {?}
 */
function toPayload(action) {
    return (/** @type {?} */ (action)).payload;
}
class RoutesEffects {
    /**
     * @param {?} actions
     */
    constructor(actions) {
        this.actions = actions;
        this.routeUpdate = this.actions.ofType(UPDATE_ROUTE)
            .map(toPayload)
            .mergeMap((route) => {
            const /** @type {?} */ module = route.snapshot.data['module'] || 'undefined';
            return [
                new ChangeModuleAction(module),
            ];
        });
    }
}
RoutesEffects.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RoutesEffects.ctorParameters = () => [
    { type: Actions, },
];
__decorate$1([
    Effect(),
    __metadata$1("design:type", Observable)
], RoutesEffects.prototype, "routeUpdate", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ CoreModuleEffects = [AppEffects, RoutesEffects];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class OpenidConnectService {
    /**
     * @param {?} config
     * @param {?} http
     */
    constructor(config, http) {
        this.config = config;
        this.http = http;
        this.SESSION_STORAGE_KEY_ID_TOKEN = 'ux-openid-connect-id-token';
        this.SESSION_STORAGE_KEY_USER_DETAILS = 'ux-openid-connect-user-details';
        this.REQUEST_PARAMETER_ORIGINAL_URL = 'ux-openid-connect-original-url';
        this.DEFAULT_OPENID_SCOPE = 'openid email profile';
    }
    /**
     * @return {?}
     */
    getIdToken() {
        return sessionStorage.getItem(this.SESSION_STORAGE_KEY_ID_TOKEN);
    }
    /**
     * @return {?}
     */
    getUserDetails() {
        const /** @type {?} */ detailsString = sessionStorage.getItem(this.SESSION_STORAGE_KEY_USER_DETAILS);
        if (detailsString) {
            return JSON.parse(detailsString);
        }
        else {
            return null;
        }
    }
    /**
     * @return {?}
     */
    renewIdToken() {
        const /** @type {?} */ openIdConnectConfig = this.config.openIdConnect;
        sessionStorage.removeItem(this.SESSION_STORAGE_KEY_ID_TOKEN);
        let /** @type {?} */ redirectUrl = openIdConnectConfig.spaRedirectUrl;
        if (redirectUrl.indexOf(this.REQUEST_PARAMETER_ORIGINAL_URL) < 0) {
            const /** @type {?} */ delimiter = (redirectUrl.indexOf('?') >= 0 ? '&' : '?');
            redirectUrl += delimiter + this.REQUEST_PARAMETER_ORIGINAL_URL + '=' + encodeURIComponent(window.location.href);
        }
        const /** @type {?} */ nounce = new Date().getTime();
        window.location.href = openIdConnectConfig.authorizeUrl +
            '?client_id=' + openIdConnectConfig.spaClientId +
            '&response_type=id_token&scope=' + (openIdConnectConfig.scope || this.DEFAULT_OPENID_SCOPE) +
            '&redirect_uri=' + encodeURIComponent(redirectUrl) +
            '&nonce=' + nounce;
    }
    /**
     * @param {?} jwtToken
     * @return {?}
     */
    decodeJwtToken(jwtToken) {
        const /** @type {?} */ base64Url = jwtToken.split('.')[1];
        const /** @type {?} */ base64 = base64Url.replace('-', '+').replace('_', '/');
        return JSON.parse(window.atob(base64));
    }
}
OpenidConnectService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
OpenidConnectService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
    { type: HttpClient, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ GET = 'GET';
const /** @type {?} */ POST = 'POST';
const /** @type {?} */ PUT = 'PUT';
const /** @type {?} */ DELETE = 'DELETE';
const /** @type {?} */ requestOptions = (options) => {
    const /** @type {?} */ defaultOptions = {
        withCredentials: true,
        headers: new HttpHeaders({ 'X-Csrf-Request': 'X-Csrf-Request' }),
    };
    return options ? Object.assign({}, defaultOptions, options) : defaultOptions;
};
class HttpService {
    /**
     * @param {?} http
     * @param {?} translateService
     */
    constructor(http, translateService) {
        this.http = http;
        this.translateService = translateService;
        /**
         * The request initialized event emitter
         */
        this.requestInit = new EventEmitter();
        /**
         * The request resolved event emitter
         */
        this.requestResolved = new EventEmitter();
        /**
         * The request failed event emitter
         */
        this.requestFailed = new EventEmitter();
    }
    /**
     * @param {?} uri
     * @param {?=} options
     * @return {?}
     */
    get(uri, options) {
        options = requestOptions(options);
        if (options.addLang !== false) {
            uri = this.addLangToUri(uri);
        }
        this.emitRequestInitEvent(GET, uri, options);
        return this.http.get(uri, options)
            .do(response => this.emitRequestResolvedEvent(GET, uri, options, response))
            .catch((error) => {
            this.emitRequestFailedEvent(GET, uri, options);
            return Observable.throw(error);
        });
    }
    /**
     * @param {?} uri
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    post(uri, body, options) {
        options = requestOptions(options);
        if (options.addLang !== false) {
            uri = this.addLangToUri(uri);
        }
        this.emitRequestInitEvent(POST, uri, options);
        return this.http.post(uri, body, options)
            .do(response => this.emitRequestResolvedEvent(POST, uri, options, response))
            .catch((error) => {
            this.emitRequestFailedEvent(POST, uri, options);
            return Observable.throw(error);
        });
    }
    /**
     * @param {?} uri
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    put(uri, body, options) {
        options = requestOptions(options);
        if (options.addLang !== false) {
            uri = this.addLangToUri(uri);
        }
        this.emitRequestInitEvent(PUT, uri, options);
        return this.http.put(uri, body, options)
            .do(response => this.emitRequestResolvedEvent(PUT, uri, options, response))
            .catch((error) => {
            this.emitRequestFailedEvent(PUT, uri, options);
            return Observable.throw(error);
        });
    }
    /**
     * @param {?} uri
     * @param {?=} options
     * @return {?}
     */
    delete(uri, options) {
        options = requestOptions(options);
        this.emitRequestInitEvent(DELETE, uri, options);
        return this.http.delete(uri, options)
            .do(response => this.emitRequestResolvedEvent(DELETE, uri, options, response))
            .catch((error) => {
            this.emitRequestFailedEvent(DELETE, uri, options);
            return Observable.throw(error);
        });
    }
    /**
     * @param {?} verb
     * @param {?} uri
     * @param {?} options
     * @return {?}
     */
    emitRequestInitEvent(verb, uri, options) {
        this.requestInit.emit({
            verb,
            options,
            uri,
        });
    }
    /**
     * @param {?} verb
     * @param {?} uri
     * @param {?} options
     * @param {?} response
     * @return {?}
     */
    emitRequestResolvedEvent(verb, uri, options, response) {
        this.requestResolved.emit({
            verb,
            options,
            uri,
            response,
        });
    }
    /**
     * @param {?} verb
     * @param {?} uri
     * @param {?} options
     * @return {?}
     */
    emitRequestFailedEvent(verb, uri, options) {
        this.requestFailed.emit({
            verb,
            options,
            uri,
        });
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    addLangToUri(uri) {
        const /** @type {?} */ lang = this.translateService.currentLang;
        if (uri.indexOf('?') > 0) {
            return uri += `&lang=${lang}`;
        }
        return uri += `?lang=${lang}`;
    }
}
HttpService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
HttpService.ctorParameters = () => [
    { type: HttpClient, },
    { type: TranslateService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UserService {
    /**
     * @param {?} config
     * @param {?} store
     * @param {?} http
     */
    constructor(config, store, http) {
        this.config = config;
        this.store = store;
        this.http = http;
    }
    /**
     * @return {?}
     */
    loadUserDetail() {
        const /** @type {?} */ url = this.getEndPoint('detail');
        const /** @type {?} */ user = { userId: 'anonymous' };
        if (!url) {
            this.store.dispatch(new UpdateUserDetailAction(user));
            return of(/** @type {?} */ (user));
        }
        return this.http.get(url)
            .do((data) => {
            this.store.dispatch(new UpdateUserDetailAction(data));
        }).catch(e => of(/** @type {?} */ (user)));
    }
    /**
     * @return {?}
     */
    observePreferencesUpdate() {
        (/** @type {?} */ (this.store.select(getUserPrefsState)))
            .filter(prefs => Object.keys(prefs).length > 0)
            .switchMap(prefs => this.saveUserPreferences(prefs).catch(() => of(prefs)))
            .subscribe(prefs => {
            console.log('Prefs saved!', prefs);
        });
    }
    /**
     * @return {?}
     */
    loadUserPreferences() {
        const /** @type {?} */ url = this.getEndPoint('preferences');
        if (!url) {
            return of({});
        }
        const /** @type {?} */ userId = this.getUserId();
        return this.http.get(`${url}?userId=${userId}`)
            .switchMap(dbPrefs => this.userPreferences().map(localPrefs => Object.assign({}, localPrefs, dbPrefs)))
            .do((preferences) => {
            this.store.dispatch(new UpdateUserPreferencesAction(preferences));
        }).catch(e => of({}));
    }
    /**
     * @param {?} prefs
     * @return {?}
     */
    saveUserPreferences(prefs) {
        const /** @type {?} */ url = this.getEndPoint('preferences');
        if (!url) {
            return of({});
        }
        const /** @type {?} */ userId = this.getUserId();
        return this.http.put(`${url}?userId=${userId}`, prefs);
    }
    /**
     * @return {?}
     */
    userPreferences() {
        return this.store.select(getUserPrefsState).take(1);
    }
    /**
     * @return {?}
     */
    getUserId() {
        let /** @type {?} */ userId;
        this.store.select(getUserIdState)
            .take(1)
            .subscribe(id => {
            userId = id;
        });
        return userId;
    }
    /**
     * @return {?}
     */
    getCoreApiConfig() {
        return this.config.modules && this.config.modules.core && this.config.modules.core.api;
    }
    /**
     * @param {?=} target
     * @return {?}
     */
    getEndPoint(target = 'detail') {
        const /** @type {?} */ coreApiConfig = this.getCoreApiConfig();
        if (!coreApiConfig || !coreApiConfig.user || !coreApiConfig.user[target]) {
            return;
        }
        const /** @type {?} */ base = coreApiConfig.base || '';
        const /** @type {?} */ baseUser = coreApiConfig.user.base || '';
        if (coreApiConfig.user[target].indexOf('http') > -1) {
            return coreApiConfig.user[target];
        }
        else {
            return `${base + baseUser + coreApiConfig.user[target]}`;
        }
    }
}
UserService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UserService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
    { type: StoreService, },
    { type: HttpService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LocalizationService {
    /**
     * @param {?} translateService
     * @param {?} userService
     * @param {?} logger
     */
    constructor(translateService, userService, logger) {
        this.translateService = translateService;
        this.userService = userService;
        this.logger = logger;
        this.modulesTranslation = {};
    }
    /**
     * @param {?=} languages
     * @param {?=} defaultLanguage
     * @return {?}
     */
    init(languages = [], defaultLanguage = 'en') {
        return this.userService.userPreferences()
            .mergeMap((preferences) => {
            let /** @type {?} */ lang = preferences.lang;
            // This is not safe (depends on navigator)... should be wrapped in platform
            if (!lang) {
                lang = (/** @type {?} */ (navigator)).languages
                    && (/** @type {?} */ (navigator)).languages[0]
                    || navigator.language
                    || (/** @type {?} */ (navigator)).userLanguage;
                // SSR temp fix in case navigator does not exist
                if (!lang) {
                    lang = defaultLanguage;
                }
            }
            lang = lang.substr(0, 2);
            lang = languages.indexOf(lang) < 0 ? defaultLanguage : lang;
            if (languages.length === 0) {
                languages.push(lang);
            }
            this.logger.info(`App language set: ${lang}`);
            this.translateService.addLangs(languages);
            this.translateService.setDefaultLang(lang);
            return this.translateService.use(lang);
        });
    }
}
LocalizationService.decorators = [
    { type: Injectable },
];
// /**
//  * Deactivated for now (all translations are in the common file)
//  * @param module -- Angular module
//  */
// loadTranslationModule(module: string): Observable<any> {
//     this.logger.warning('loadTranslationModule() should not be used. Add translations to global translation file.');
//     return Observable.of({});
//     // const lang = this.translate.currentLang || 'en';
//     // if (this.modulesTranslation[module] && this.modulesTranslation[module][lang]) {
//     //     return Observable.of(this.modulesTranslation[module][lang]);
//     // }
//     // const uri = `assets/${module}/i18n/${lang}.json`;
//     // return this.http.get(uri)
//     //     .map(res => res.json())
//     //     .do((i18n: any) => {
//     //         if (!this.modulesTranslation[module]) {
//     //             this.modulesTranslation[module] = {};
//     //         }
//     //         this.modulesTranslation[module][lang] = i18n;
//     //         this.translate.setTranslation(lang, i18n, true);
//     //         console.log(`[Localization] lang (${lang}) loaded for module (${module})...`);
//     //     })
//     //     .catch((err: any) => {
//     //         console.log(`[Localization] lang (${lang}) not found for module (${module})`);
//     //         return Observable.of({});
//     //     });
// }
/** @nocollapse */
LocalizationService.ctorParameters = () => [
    { type: TranslateService, },
    { type: UserService, },
    { type: TraceService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ cacheTranslations = {};
class TranslateHttpLoader {
    /**
     * @param {?} http
     * @param {?=} prefix
     * @param {?=} suffix
     * @param {?=} queryParams
     */
    constructor(http, prefix = '/assets/i18n-compiled/', suffix = '.json', queryParams = false) {
        this.http = http;
        this.prefix = prefix;
        this.suffix = suffix;
        this.queryParams = queryParams;
    }
    /**
     * Gets the translations from the server
     * @param {?} lang
     * @return {?} any
     */
    getTranslation(lang) {
        if (cacheTranslations[lang]) {
            const /** @type {?} */ translation = Object.assign({}, cacheTranslations[lang]);
            return Observable.of(translation);
        }
        if (this.queryParams) {
            return this.http.get(`${this.prefix}?${this.queryParams}=${lang}`)
                .map((translation) => {
                cacheTranslations[lang] = translation;
                return translation;
            })
                .catch(() => {
                Observable.throw(new EuiError(errorCodes.ERR_TRANSLATION_FILE_MISSING, null, { lang }));
                return Observable.of({});
            });
        }
        return this.http.get(`${this.prefix}${lang}${this.suffix}`)
            .map((translation) => {
            cacheTranslations[lang] = translation;
            return translation;
        })
            .catch(() => {
            Observable.throw(new EuiError(errorCodes.ERR_TRANSLATION_FILE_MISSING, null, { lang }));
            return Observable.of({});
        });
    }
}
const /** @type {?} */ translateConfig = {
    loader: {
        provide: TranslateLoader,
        useFactory: translateStaticLoader,
        deps: [HttpClient, CONFIG_TOKEN],
    },
};
/**
 * @param {?} http
 * @param {?} config
 * @return {?}
 */
function translateStaticLoader(http, config) {
    if (config && config.global && config.global.i18nFolder) {
        const /** @type {?} */ i18nFolder = config.global.i18nFolder;
        return new TranslateHttpLoader(http, `assets/${i18nFolder}/`);
    }
    else if (config && config.global && config.global.i18nSource) {
        const /** @type {?} */ i18nSource = config.global.i18nSource;
        // checking query parameter if exists
        const /** @type {?} */ queryParams = config.global.i18nQueryParam ? config.global.i18nQueryParam : false;
        return new TranslateHttpLoader(http, `/${config.global.baseUrl}/${i18nSource}`, '', queryParams);
    }
    return new TranslateHttpLoader(http, 'assets/i18n-compiled/');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LocalstorageService {
    /**
     * @param {?} key
     * @param {?} data
     * @return {?}
     */
    set(key, data) {
        try {
            const /** @type {?} */ serialized = JSON.stringify(data);
            localStorage.setItem(key, serialized);
        }
        catch (/** @type {?} */ err) {
            return undefined;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        try {
            const /** @type {?} */ serialized = localStorage.getItem(key);
            if (serialized === null) {
                return undefined;
            }
            return JSON.parse(serialized);
        }
        catch (/** @type {?} */ err) {
            return undefined;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    delete(key) {
        localStorage.removeItem(key);
    }
}
LocalstorageService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class StorageService {
    /**
     * @param {?} localStorageService
     * @param {?} logger
     */
    constructor(localStorageService, logger) {
        this.localStorageService = localStorageService;
        this.logger = logger;
        this._storage = 'localStorage';
    }
    /**
     * @param {?} key
     * @param {?} data
     * @param {?=} storage
     * @return {?}
     */
    set(key, data, storage = this._storage) {
        if (storage === 'localStorage') {
            return this.localStorageService.set(key, data);
        }
        const /** @type {?} */ msg = '[Storage Service] Error setting data, storage must be be "localStorage"';
        this.logger.error(msg);
        throw new EuiError(undefined, msg);
    }
    /**
     * @param {?} key
     * @param {?=} storage
     * @return {?}
     */
    get(key, storage = this._storage) {
        if (storage === 'localStorage') {
            return this.localStorageService.get(key);
        }
        const /** @type {?} */ msg = '[Storage] Error getting data, storage has to be "localStorage"';
        this.logger.error(msg);
        throw new EuiError(undefined, msg);
    }
    /**
     * @param {?} key
     * @param {?=} storage
     * @return {?}
     */
    delete(key, storage = this._storage) {
        if (storage === 'localStorage') {
            return this.localStorageService.delete(key);
        }
        const /** @type {?} */ msg = '[Storage] Error deleting data, storage has to be "localStorage"';
        this.logger.error(msg);
        throw new EuiError(undefined, msg);
    }
    /**
     * @param {?} storage
     * @return {?}
     */
    set storage(storage) {
        this._storage = storage;
    }
}
StorageService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
StorageService.ctorParameters = () => [
    { type: LocalstorageService, },
    { type: TraceService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAuthService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        // default must be false, it should be update after login
        this.isLoggedIn = true;
        const /** @type {?} */ authExist = config && config.global && config.global.auth;
        this.redirectUrl = authExist && config.global.auth.redirectUrl ? config.global.auth.redirectUrl : '';
        this.isLoggedIn = authExist && config.global.auth.isLoggedIn ? config.global.auth.isLoggedIn : true;
        this.loginPageUrl = authExist && config.global.auth.loginPageUrl ? config.global.auth.loginPageUrl : '';
    }
    /**
     * @param {?} status
     * @return {?}
     */
    setLoggedIn(status) {
        this.isLoggedIn = status;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
}
UxAuthService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxAuthService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ getUserState$1 = (state) => state.user;
const /** @type {?} */ getRights = (state) => state.rights;
const /** @type {?} */ getUserRights = createSelector(getUserState$1, getRights);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPermissionService {
    /**
     * @param {?} store
     */
    constructor(store) {
        // Listening rights & links from State
        this.store = store;
        this.userRights = [];
        this.store.select(getUserRights).subscribe((rights) => {
            this.userRights = rights;
        });
    }
    /**
     * @return {?}
     */
    getRights() {
        return this.userRights;
    }
    /**
     * @param {?} routeId
     * @return {?}
     */
    checkRightToActivateRoute(routeId) {
        const /** @type {?} */ userRights = this.getRights();
        return this.checkRight(userRights, routeId);
    }
    /**
     * @param {?} permStr
     * @return {?}
     */
    checkAttributePermission(permStr) {
        const /** @type {?} */ userRights = this.getRights();
        const /** @type {?} */ permProps = permStr.split('.');
        if (permProps.length > 1) {
            const /** @type {?} */ right = permProps[0];
            const /** @type {?} */ permission = permProps[1];
            return this.checkPermission(userRights, right, permission);
        }
        else {
            const /** @type {?} */ rightId = permStr;
            return this.checkRight(userRights, rightId);
        }
    }
    /**
     * @param {?} rights
     * @param {?} rightId
     * @return {?}
     */
    checkRight(rights, rightId) {
        return rights.findIndex((right) => {
            return right.id === rightId;
        }) > -1;
    }
    /**
     * @param {?} rights
     * @param {?} rightId
     * @param {?} permissionId
     * @return {?}
     */
    checkPermission(rights, rightId, permissionId) {
        const /** @type {?} */ indexOfRight = rights.findIndex((right) => {
            return right.id === rightId;
        });
        if (indexOfRight > -1) {
            return rights[indexOfRight].permissions.includes(permissionId);
        }
        return false;
    }
}
UxPermissionService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxPermissionService.ctorParameters = () => [
    { type: Store, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAuthGuardService {
    /**
     * @param {?} authService
     * @param {?} permissionService
     */
    constructor(authService, permissionService) {
        this.authService = authService;
        this.permissionService = permissionService;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    checkLogin(url) {
        if (this.authService.isLoggedIn) {
            return true;
        }
        // Store the attempted URL for redirecting
        this.authService.redirectUrl = url;
        // Navigate to the login page with extras
        // this.router.navigate(['/login']);
        return false;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    checkRouteRight(id) {
        return this.permissionService.checkRightToActivateRoute(id);
    }
}
UxAuthGuardService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxAuthGuardService.ctorParameters = () => [
    { type: UxAuthService, },
    { type: UxPermissionService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicMenuService {
    /**
     * @param {?} config
     * @param {?} uxPermission
     * @param {?} store
     */
    constructor(config, uxPermission, store) {
        this.config = config;
        this.uxPermission = uxPermission;
        this.store = store;
        this.menuLinks = [];
        this.store.select(getUserState).subscribe((user) => {
            if (user.menuLinks) {
                this.menuLinks = user.menuLinks;
            }
        });
    }
    /**
     * @return {?}
     */
    getMenuLinks() {
        return this.menuLinks;
    }
    /**
     * @param {?} links
     * @return {?}
     */
    filterUxLinksWithRights(links) {
        const /** @type {?} */ userRights = this.uxPermission.getRights() ? this.uxPermission.getRights() : [];
        return links.filter((link) => {
            if (link.hasChildren) {
                link.children = this.filterUxLinksWithRights(link.children);
            }
            if (link.allowedRightId) {
                return userRights.findIndex((right) => {
                    return right.id === link.allowedRightId;
                }) > -1;
            }
            else {
                return true;
            }
        });
    }
}
UxDynamicMenuService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicMenuService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
    { type: UxPermissionService, },
    { type: StoreService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ mapTypeIdToRoute = {
    '31084141': 'financial-instrument',
    '31084142': 'mip',
    '31084143': 'action',
    '31084144': 'programme',
    '31084145': 'project',
    '31084146': 'contract',
    '31087247': 'component',
    '31084348': 'instrument-domain',
    '31084349': 'sub-project',
    '31084350': 'commission-decision',
    '31086952': 'operational-entity',
};
class RouteService {
    constructor() { }
    /**
     * @param {?} oe
     * @return {?}
     */
    urlOperationalEntity(oe) {
        if (!oe.typeId || !oe.key) {
            return;
        }
        if (oe.typeId in mapTypeIdToRoute) {
            return `${mapTypeIdToRoute[oe.typeId]}/${oe.key}`;
        }
    }
}
RouteService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RouteService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const ResponseErrorHandlerTypes = {
    Redirect: 1,
    Notify: 2,
    None: 3,
};
ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.Redirect] = "Redirect";
ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.Notify] = "Notify";
ResponseErrorHandlerTypes[ResponseErrorHandlerTypes.None] = "None";
/**
 * Search in the configuration if the Url that gave an error has a handler
 * @param url Url from the Router
 * @param configs Http Error Routes configuration
 */
const /** @type {?} */ getRouteConfig = (url, httpStatus, configs) => (configs.filter((conf) => {
    if (conf.match === '*') {
        return typeof conf[httpStatus] !== 'undefined';
    }
    const /** @type {?} */ re = new RegExp(conf.match);
    return re.exec(url) !== null && typeof conf[httpStatus] !== 'undefined';
})[0]);
const /** @type {?} */ defaultRouteRedirect = {
    '404': '/404',
    '401': '/401',
    '500': '/500',
};
class RequestErrorInterceptor {
    /**
     * @param {?} appConfig
     * @param {?} logger
     * @param {?} router
     * @param {?} uxService
     */
    constructor(appConfig, logger, router, uxService) {
        this.appConfig = appConfig;
        this.logger = logger;
        this.router = router;
        this.uxService = uxService;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        return next.handle(req)
            .do(() => { }, (err) => {
            this.logError(err);
            if (!this.appConfig.httpResponseHandlers) {
                return;
            }
            if (err instanceof HttpErrorResponse) {
                let { routesHandlers, routesRedirect } = this.appConfig.httpResponseHandlers;
                routesRedirect = Object.assign({}, defaultRouteRedirect, routesRedirect);
                const /** @type {?} */ config = getRouteConfig(err.url, err.status, routesHandlers);
                const /** @type {?} */ rule = config && config[err.status];
                if (typeof rule === 'function') {
                    rule.call(null, err);
                }
                else if (rule === ResponseErrorHandlerTypes.Notify) {
                    this.showNotificationError(err);
                }
                else if (rule !== ResponseErrorHandlerTypes.None) {
                    const /** @type {?} */ statusManaged = err.status === 404 || err.status === 401 || err.status === 500;
                    if (rule === ResponseErrorHandlerTypes.Redirect || (statusManaged && !rule)) {
                        this.router.navigate([routesRedirect[err.status]]);
                    }
                    else {
                        this.showNotificationError(err);
                    }
                }
            }
        });
    }
    /**
     * @param {?} err
     * @return {?}
     */
    showNotificationError(err) {
        this.uxService.growlError(err.statusText);
    }
    /**
     * @param {?} err
     * @return {?}
     */
    logError(err) {
        const /** @type {?} */ message = err.message ? err.message : err.toString();
        this.logger.error(message);
    }
}
RequestErrorInterceptor.decorators = [
    { type: Injectable },
];
/** @nocollapse */
RequestErrorInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
    { type: TraceService, },
    { type: Router, },
    { type: UxService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GlobalErrorHandler extends ErrorHandler {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        super();
        this.injector = injector;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        const /** @type {?} */ traceService = this.injector.get(TraceService);
        const /** @type {?} */ message = error.message ? error.message : error.toString();
        traceService.error(message);
        // throw error;
        super.handleError(error);
    }
}
GlobalErrorHandler.decorators = [
    { type: Injectable },
];
/** @nocollapse */
GlobalErrorHandler.ctorParameters = () => [
    { type: Injector, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class QueueApiService {
    /**
     * @param {?} store
     * @param {?} http
     * @param {?} logger
     */
    constructor(store, http, logger) {
        this.store = store;
        this.http = http;
        this.logger = logger;
    }
    /**
     * @param {?} queueId
     * @param {?} uri
     * @param {?} method
     * @param {?=} payload
     * @return {?}
     */
    queue(queueId, uri, method, payload) {
        const /** @type {?} */ allowedMethods = ['post', 'put', 'get'];
        if (allowedMethods.indexOf(method) < 0) {
            throw new EuiError(errorCodes.ERR_QUEUE_METHOD_NOT_ALLOWED, `[Queue Api] method "${method}" is not alllowed`);
        }
        const /** @type {?} */ data = {
            uri,
            method,
            payload,
        };
        this.store.dispatch(new ApiQueueAdd({ id: queueId, data }));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    removeQueue(id) {
        this.store.dispatch(new ApiQueueRemove(id));
    }
    /**
     * @param {?} queueId
     * @return {?}
     */
    processQueue(queueId) {
        return this.store.select(getApiQueueById(queueId))
            .take(1)
            .switchMap((queue) => {
            if (!queue) {
                this.logger.warning(`Queue with id "${queueId}" does not exist`);
                return Observable.of(null);
            }
            return this.http[queue.method](queue.uri, queue.payload)
                .do(() => this.removeQueue(queueId));
        });
    }
}
QueueApiService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
QueueApiService.ctorParameters = () => [
    { type: StoreService, },
    { type: HttpService, },
    { type: TraceService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AppService {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
    /**
     * Start listening for navigator disconnection
     * and updates the store
     * @return {?}
     */
    listenForConnectionUpdate() {
        window.addEventListener('offline', () => this.store.dispatch(new AppConnectionUpdate(false)));
        window.addEventListener('online', () => this.store.dispatch(new AppConnectionUpdate(true)));
    }
}
AppService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AppService.ctorParameters = () => [
    { type: StoreService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDomService {
    /**
     * @param {?} target
     * @param {?} className
     * @return {?}
     */
    closestMatchingParent(target, className) {
        let /** @type {?} */ element = target;
        while (element && element.nodeType === Node.ELEMENT_NODE) {
            if (element.classList.contains(className)) {
                return element;
            }
            element = element.parentElement;
        }
        return null;
    }
}
UxDomService.zIndex = 1045;
UxDomService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAssetsService {
    /**
     * @param {?} http
     * @param {?} uxService
     */
    constructor(http, uxService) {
        this.http = http;
        this.uxService = uxService;
    }
    /**
     * @param {?} assetId
     * @param {?} languageCode
     * @param {?=} remoteUrl
     * @return {?}
     */
    getAssetsContents(assetId, languageCode, remoteUrl) {
        if (assetId) {
            if (!languageCode && this.uxService.activeLanguage) {
                languageCode = this.uxService.activeLanguage.code;
            }
            if (languageCode) {
                let /** @type {?} */ url;
                if (!remoteUrl) {
                    url = `assets/${assetId}_${languageCode.toUpperCase()}.json`;
                }
                else {
                    url = `${remoteUrl}/${assetId}_${languageCode.toUpperCase()}.json`;
                }
                return this.http.get(url);
            }
        }
        return Observable.of(null);
    }
}
UxAssetsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxAssetsService.ctorParameters = () => [
    { type: HttpService, },
    { type: UxService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimezoneService {
    constructor() { }
    /**
     * Convert country ISO code to country name (in english)
     * @param {?} iso
     * @return {?}
     */
    iso2country(iso) {
        return UX_COUNTRIES[iso] ? UX_COUNTRIES[iso] : iso;
    }
    /**
     * Gets the list of ISO-codes for all countries
     * @return {?}
     */
    getCountries() {
        const /** @type {?} */ res = [];
        for (const /** @type {?} */ prop of Object.keys(UX_COUNTRIES)) {
            res.push(prop);
        }
        return res;
    }
    /**
     * @return {?}
     */
    getTimezones() {
        return UX_TIMEZONES;
    }
    /**
     * @param {?} tz
     * @return {?}
     */
    getTimezone(tz) {
        return UX_TIMEZONES.find((item) => {
            return item.name === tz;
        });
    }
}
UxTimezoneService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxTimezoneService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ extend$1 = (/** @type {?} */ (extendProxy)).default || extendProxy;
class EnvConfigService {
    /**
     * @param {?} http
     * @param {?} config
     */
    constructor(http, config) {
        this.http = http;
        this.config = config;
    }
    /**
     * @return {?}
     */
    loadEnvConfigFile() {
        return this.http.get(this.config.configFilePath);
    }
    /**
     * @param {?} fileConfig
     * @return {?}
     */
    loadEnvConfigService(fileConfig) {
        let /** @type {?} */ configServiceURI = 'configServiceURI';
        if (!fileConfig[configServiceURI]) {
            return of({});
        }
        return this.http.get(fileConfig[configServiceURI]);
    }
    /**
     * @return {?}
     */
    loadDynamicConfig() {
        if (!this.config.configFilePath) {
            // No config file in asset folder
            return of({});
        }
        return this.loadEnvConfigFile()
            .do((tsConfig) => {
            // PreMerge hook (if necessary add logic)
            extend$1(true, this.config, tsConfig);
            // PosMerge hook (if necessary add logic)
        })
            .switchMap(fileConfig => this.loadEnvConfigService(fileConfig))
            .do((wsconfig) => {
            // PreMerge hook (if necessary add logic)
            extend$1(true, this.config, wsconfig);
            // PosMerge hook (if necessary add logic)
        })
            .catch(error => {
            console.error(error);
            return of({});
        });
    }
}
EnvConfigService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
EnvConfigService.ctorParameters = () => [
    { type: HttpService, },
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxErrorOutput {
    /**
     * @param {?} info
     * @param {?} errorFeedback
     * @param {?=} subErrors
     */
    constructor(info, errorFeedback, subErrors) {
        this.severity = UxMessageSeverity.danger;
        if (!subErrors) {
            Object.assign(this, Object.assign({}, info), Object.assign({}, errorFeedback));
        }
        else {
            Object.assign(this, Object.assign({}, info), Object.assign({}, errorFeedback), { subErrors });
        }
    }
    /**
     * @param {?=} byKey
     * @return {?}
     */
    getFeedBacks(byKey) {
        if (this.subErrors) {
            return this.subErrors.filter((err) => {
                if (err instanceof UxValidationErrorClass) {
                    if (byKey && err.attributes) {
                        return this.checkAttribute(byKey, err.attributes);
                    }
                    else if (byKey && !err.attributes) {
                        return false;
                    }
                    else if (!byKey) {
                        return true;
                    }
                }
            }).map((err) => ({ msgId: err.msgId, defaultMsg: err.defaultMsg, severity: err.severity }));
        }
        else {
            if (!byKey) {
                return [{ msgId: this.msgId, defaultMsg: this.defaultMsg, severity: this.severity }];
            }
            else {
                return [];
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} attributes
     * @return {?}
     */
    checkAttribute(key, attributes) {
        return attributes.some((attr) => {
            return key === attr.key;
        });
    }
}
/** @enum {string} */
const UxMessageSeverity = {
    info: 'info',
    warning: 'warning',
    danger: 'danger',
    success: 'success',
};
class UxValidationErrorClass {
    /**
     * @param {?} data
     */
    constructor(data) {
        this.severity = UxMessageSeverity.danger;
        Object.assign(this, data);
    }
}
/**
 * @param {?} resp
 * @param {?} mapper
 * @return {?}
 */
function transformToUxHttpResponse(resp, mapper) {
    let /** @type {?} */ updatedErr = /** @type {?} */ (resp);
    updatedErr.uxHttpErrorOutput = mapper(resp.error);
    return updatedErr;
}
class UxPublishErrorFeedbackEvent {
    /**
     * @param {?} err
     * @param {?=} id
     */
    constructor(err, id) {
        this.err = err;
        this.id = id;
    }
}
class UxClearErrorFeedbackEvent {
    /**
     * @param {?=} id
     */
    constructor(id) {
        this.id = id;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxRequestErrorModelInterceptor {
    /**
     * @param {?} appConfig
     */
    constructor(appConfig) {
        this.appConfig = appConfig;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        return next.handle(req)
            .do((err) => {
        }, (err) => {
            if (this.appConfig.errorMappingHandler) {
                if (err instanceof HttpErrorResponse) {
                    err = /** @type {?} */ (transformToUxHttpResponse(err, this.appConfig.errorMappingHandler));
                }
            }
        });
    }
}
UxRequestErrorModelInterceptor.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxRequestErrorModelInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 * @param {?=} errorManager
 * @return {?}
 */
function withUxErrorManager(errorManager) {
    return function (source$) {
        return new Observable(observer => {
            const /** @type {?} */ wrapper = {
                next: value => {
                    errorManager.clearError();
                    observer.next(value);
                },
                error: (err) => {
                    errorManager.publishError(err.uxHttpErrorOutput);
                },
            };
            return source$.subscribe(wrapper);
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxErrorFeedbackService {
    constructor() {
        this.errors = new Subject();
    }
    /**
     * @param {?} err
     * @param {?=} id
     * @return {?}
     */
    publishError(err, id) {
        if (id) {
            this.errors.next(new UxPublishErrorFeedbackEvent(err, id));
        }
        else {
            this.errors.next(new UxPublishErrorFeedbackEvent(err));
        }
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    clearError(id) {
        this.errors.next(new UxClearErrorFeedbackEvent(id));
    }
    /**
     * @return {?}
     */
    createLocalErrorManager() {
        return new UxErrorManager(this);
    }
    /**
     * @return {?}
     */
    createGlobalErrorManager() {
        return new UxErrorManager(this, true);
    }
}
class UxErrorManager {
    /**
     * @param {?} uxErrorFeedbackService
     * @param {?=} isGlobal
     */
    constructor(uxErrorFeedbackService, isGlobal) {
        this.uxErrorFeedbackService = uxErrorFeedbackService;
        this.isGlobal = isGlobal;
        this.id = Math.random().toString();
        this.httpErrorOperator = withUxErrorManager(this);
    }
    /**
     * @param {?} err
     * @return {?}
     */
    publishError(err) {
        if (!this.isGlobal) {
            this.uxErrorFeedbackService.publishError(err, this.id);
        }
        else {
            this.uxErrorFeedbackService.publishError(err);
        }
    }
    /**
     * @return {?}
     */
    clearError() {
        if (!this.isGlobal) {
            this.uxErrorFeedbackService.clearError(this.id);
        }
        else {
            this.uxErrorFeedbackService.clearError();
        }
    }
    /**
     * @return {?}
     */
    errors() {
        if (!this.isGlobal) {
            return this.uxErrorFeedbackService.errors.pipe(filter((evt) => evt.id === this.id));
        }
        else {
            return this.uxErrorFeedbackService.errors.pipe(filter((evt) => !evt.id));
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ appConfigDefault = {
    global: {
        languages: ['en'],
        defaultLanguage: 'en',
    },
};
class OptionalDeps {
    /**
     * @param {?} store
     */
    constructor(store) {
        this.store = store;
    }
}
OptionalDeps.decorators = [
    { type: Injectable },
];
/** @nocollapse */
OptionalDeps.ctorParameters = () => [
    { type: Store, decorators: [{ type: Optional },] },
];
/**
 * @param {?} appConfig
 * @param {?=} environment
 * @return {?}
 */
function providersModule(appConfig, environment = {}) {
    return [
        StorageService,
        LocalstorageService,
        UserService,
        RouteService,
        HttpService,
        UxDomService,
        TraceService,
        UxService,
        UxAppShellService,
        UxAssetsService,
        UxTimezoneService,
        GlobalErrorHandler,
        QueueApiService,
        AppService,
        EnvConfigService,
        OptionalDeps,
        OpenidConnectService,
        { provide: APP_CONFIG_TOKEN, useValue: appConfig },
        { provide: ENVIRONMENT_TOKEN, useValue: environment },
        { provide: CONFIG_TOKEN, useFactory: getConfig, deps: [APP_CONFIG_TOKEN, ENVIRONMENT_TOKEN] },
        {
            provide: HTTP_INTERCEPTORS,
            useClass: UxRequestErrorModelInterceptor,
            multi: true
        },
        { provide: StoreService, useFactory: storeServiceFactory, deps: [OptionalDeps, TraceService] },
        { provide: UxAuthService, useFactory: uxAuthServiceFactory, deps: [CONFIG_TOKEN] },
        { provide: UxAuthGuardService, useFactory: uxAuthGuardServiceFactory, deps: [UxAuthService, UxPermissionService] },
        { provide: UxPermissionService, useFactory: uxPermissionsServiceFactory, deps: [OptionalDeps] },
        { provide: UxErrorFeedbackService, useFactory: errorFeedbackServiceFactory, deps: [OptionalDeps] },
        {
            provide: UxDynamicMenuService,
            useFactory: uxDynamicMenuServiceFactory,
            deps: [CONFIG_TOKEN, UxPermissionService, OptionalDeps]
        },
        { provide: LocalizationService, useFactory: localizationServiceFactory, deps: [TranslateService, UserService, TraceService] },
        {
            provide: APP_INITIALIZER,
            useFactory: initApp,
            deps: [CONFIG_TOKEN, StoreService, UserService, LocalizationService, Injector, AppService, EnvConfigService],
            multi: true,
        },
        {
            provide: ErrorHandler,
            useClass: GlobalErrorHandler,
        },
    ];
}
const ɵ0$6 = translateStaticLoader;
class CoreModule {
    /**
     * @param {?} parentModule
     */
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('CoreModule is already loaded. Import it in the AppModule only');
        }
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = { appConfig: appConfigDefault, environment: {} }) {
        return {
            ngModule: CoreModule,
            providers: providersModule(config.appConfig, config.environment),
        };
    }
}
CoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    EffectsModule.forRoot([AppEffects]),
                    TranslateModule.forChild({
                        loader: {
                            provide: TranslateLoader,
                            useFactory: ɵ0$6,
                            deps: [HttpClient],
                        },
                    }),
                ],
            },] },
];
/** @nocollapse */
CoreModule.ctorParameters = () => [
    { type: CoreModule, decorators: [{ type: Optional }, { type: SkipSelf },] },
];
/**
 * @param {?} optionalDeps
 * @param {?} logger
 * @return {?}
 */
function storeServiceFactory(optionalDeps, logger) {
    return new StoreService(optionalDeps.store, logger);
}
/**
 * @param {?} config
 * @return {?}
 */
function uxAuthServiceFactory(config) {
    return new UxAuthService(config);
}
/**
 * @param {?} uxAuthService
 * @param {?} uxPermissionService
 * @return {?}
 */
function uxAuthGuardServiceFactory(uxAuthService, uxPermissionService) {
    return new UxAuthGuardService(uxAuthService, uxPermissionService);
}
/**
 * @param {?} optionalDeps
 * @return {?}
 */
function uxPermissionsServiceFactory(optionalDeps) {
    return new UxPermissionService(optionalDeps.store);
}
/**
 * @param {?} config
 * @param {?} uxPermission
 * @param {?} optionalDeps
 * @return {?}
 */
function uxDynamicMenuServiceFactory(config, uxPermission, optionalDeps) {
    return new UxDynamicMenuService(config, uxPermission, optionalDeps.store);
}
/**
 * @param {?} translate
 * @param {?} userService
 * @param {?} logger
 * @return {?}
 */
function localizationServiceFactory(translate, userService, logger) {
    return new LocalizationService(translate, userService, logger);
}
/**
 * @return {?}
 */
function errorFeedbackServiceFactory() {
    return new UxErrorFeedbackService();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DYNAMIC_COMPONENT_CONFIG = new InjectionToken('DYNAMIC_COMPONENT_CONFIG');
class UxDynamicComponentService {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} injector
     * @param {?} appRef
     */
    constructor(componentFactoryResolver, injector, appRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.appRef = appRef;
    }
    /**
     * @param {?} component
     * @param {?=} el
     * @param {?=} config
     * @return {?}
     */
    add(component, el, config) {
        // this.portal = new ComponentPortal(component);
        // Create a portalHost from a DOM element
        this.portalHost = new DomPortalHost(el ? el.nativeElement : document.body, this.componentFactoryResolver, this.appRef, this.injector);
        // Locate the component factory for the ComponentToIncludeDynamicallyComponent
        this.portal = new ComponentPortal(component, null, config ? this.createInjector(config) : null);
        // Attach portal to host
        this.portalComponentInstance = this.portalHost.attach(this.portal);
        const /** @type {?} */ portalHost = this.portalHost;
        const /** @type {?} */ portal = this.portal;
        const /** @type {?} */ portalComponentInstance = this.portalComponentInstance;
        return { portalHost, portal, portalComponentInstance };
    }
    /**
     * @param {?} portalHostRef
     * @param {?} portalRef
     * @return {?}
     */
    remove(portalHostRef, portalRef) {
        portalHostRef.detach();
    }
    /**
     * @param {?} data
     * @return {?}
     */
    createInjector(data) {
        const /** @type {?} */ injectorTokens = new WeakMap();
        const /** @type {?} */ dataConfig = Object.assign(data, {
            portalHostRef: this.portalHost,
            portalRef: this.portal,
            portalComponentInstanceRef: this.portalComponentInstance,
        });
        injectorTokens.set(DYNAMIC_COMPONENT_CONFIG, data);
        return new PortalInjector(this.injector, injectorTokens);
    }
}
UxDynamicComponentService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicComponentService.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
    { type: Injector, },
    { type: ApplicationRef, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CachePreventionInterceptor {
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return next.handle(request.clone({
            headers: request.headers.set('Cache-Control', 'No-Cache'),
        }));
    }
}
CachePreventionInterceptor.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CorsSecurityInterceptor {
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return next.handle(request.clone({
            withCredentials: true
        }));
    }
}
CorsSecurityInterceptor.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CsrfPreventionInterceptor {
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return next.handle(request.clone({
            headers: request.headers.set('X-Requested-With', 'XMLHttpRequest'),
        }));
    }
}
CsrfPreventionInterceptor.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class EuLoginSessionTimeoutHandlingInterceptor {
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        return next.handle(request).do((event) => {
            this.checkRequestSuccessForEULoginSessionTimeout(request, event);
            return event;
        }, error => {
            this.checkRequestErrorForEULoginSessionTimeout(request, error);
        });
    }
    /**
     * @param {?} request
     * @param {?} event
     * @return {?}
     */
    checkRequestSuccessForEULoginSessionTimeout(request, event) {
        if (event instanceof HttpResponse) {
            if (this.isSsoResponse((/** @type {?} */ (event)).body)) {
                this.reauthenticate(request, /** @type {?} */ (event));
            }
        }
    }
    /**
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    checkRequestErrorForEULoginSessionTimeout(request, response) {
        // intentionally blank; meant for overriding
    }
    /**
     * @param {?} body
     * @return {?}
     */
    isSsoResponse(body) {
        if (body) {
            if (typeof body !== 'string') {
                return (body.success === false &&
                    body.status === 'ECAS_AUTHENTICATION_REQUIRED' &&
                    body.code === 303 &&
                    body.message === 'session expired');
            }
            else {
                const /** @type {?} */ html = body;
                return ((html.indexOf('<meta name="Keywords" content="EU Login, ECAS, Authentication, Security" />') >= 0 &&
                    html.indexOf('<meta name="Description" content="EU Login" />') >= 0) ||
                    html.indexOf('<meta name="Description" content="European Commission Authentication Service" />') >= 0 ||
                    html.indexOf('<title>Mock Login Form</title>') >= 0 ||
                    html.indexOf('<title>Redirecting To ECAS</title>') >= 0 ||
                    html === '{ success : false, status : "ECAS_AUTHENTICATION_REQUIRED", code : 303, message : "session expired" }' ||
                    html === '{ "success" : false, "status" : "ECAS_AUTHENTICATION_REQUIRED", "code" : 303, "message": "session expired" }');
            }
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    reauthenticate(request, response) {
        document.location.reload(true);
    }
}
EuLoginSessionTimeoutHandlingInterceptor.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class OpenidConnectInterceptor {
    /**
     * @param {?} config
     * @param {?} openidConnectService
     */
    constructor(config, openidConnectService) {
        this.config = config;
        this.openidConnectService = openidConnectService;
        // By default, the original request should at least be retries once in case the cached API Gateway token expires:
        this.maximumRequestRetries = 1;
        if (this.config && this.config.openIdConnect && this.config.openIdConnect.maximumRequestRetries) {
            this.maximumRequestRetries = this.config.openIdConnect.maximumRequestRetries;
        }
    }
    /**
     * @param {?} request
     * @param {?} next
     * @param {?=} retryCount
     * @return {?}
     */
    intercept(request, next, retryCount = 0) {
        if (this.config && this.config.openIdConnect && this.config.openIdConnect.enabled) {
            const /** @type {?} */ config = this.config.openIdConnect;
            if (config.apiGatewayServices) {
                const /** @type {?} */ service = this.getMatchingServiceFromConfiguration(request, config.apiGatewayServices);
                if (service && service.audienceId) {
                    return this.makeApiGatewayServiceCall(request, next, service.audienceId, retryCount);
                }
            }
            if (config.services) {
                const /** @type {?} */ service = this.getMatchingServiceFromConfiguration(request, config.services);
                if (service && service.audienceId) {
                    return this.makeServiceCall(request, next, service.audienceId, retryCount);
                }
            }
        }
        return next.handle(request);
    }
    /**
     * @param {?} request
     * @param {?} configuredServices
     * @return {?}
     */
    getMatchingServiceFromConfiguration(request, configuredServices) {
        if (configuredServices) {
            for (const /** @type {?} */ serviceId in configuredServices) {
                if (configuredServices.hasOwnProperty(serviceId)) {
                    const /** @type {?} */ service = configuredServices[serviceId];
                    if (this.urlMatches(request.url, service.endpoint)) {
                        return service;
                    }
                }
            }
        }
        return null;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @param {?} audienceId
     * @param {?=} retryCount
     * @return {?}
     */
    makeApiGatewayServiceCall(request, next, audienceId, retryCount = 0) {
        // Check if we already have an API Gateway access token cached in memory:
        if (this.cachedApiGatewayAccessTokenHasExpired()) {
            // Get an EU Login access token for the API Gateway and for the target service:
            const /** @type {?} */ apiGatewayAccessTokenAudienceId = this.config.openIdConnect.apiGatewayAccessTokenAudienceId;
            return Observable.zip(next.handle(this.getServiceAccessTokenRequest(apiGatewayAccessTokenAudienceId)).catch((response) => {
                return this.handleErrorResponse(response, request, next, retryCount);
            }), next.handle(this.getServiceAccessTokenRequest(audienceId)).catch((response) => {
                return this.handleErrorResponse(response, request, next, retryCount);
            })).flatMap(([apiGatewayServiceAccessTokenEvent, serviceAccessTokenEvent]) => {
                if (apiGatewayServiceAccessTokenEvent instanceof HttpResponse && serviceAccessTokenEvent instanceof HttpResponse) {
                    // We now have an EU Login access token for the API Gateway and the target service.
                    // Continue by asking an access token to the gateway itself. It requires the EU Login access token...
                    const /** @type {?} */ apiGatewayServiceAccessToken = (/** @type {?} */ (apiGatewayServiceAccessTokenEvent)).body;
                    const /** @type {?} */ apiGatewayConsumerKey = this.config.openIdConnect.apiGatewayConsumerKey;
                    let /** @type {?} */ apiGatewayHeaders = new HttpHeaders();
                    apiGatewayHeaders = apiGatewayHeaders.append('Authorization', 'Basic ' + apiGatewayConsumerKey);
                    apiGatewayHeaders = apiGatewayHeaders.append('Content-type', 'application/x-www-form-urlencoded');
                    const /** @type {?} */ body = 'grant_type=oauth2:eui&eul_access_token=' + apiGatewayServiceAccessToken.access_token;
                    return next.handle(new HttpRequest('POST', this.config.openIdConnect.apiGatewayAccessTokenUrl, body, {
                        headers: apiGatewayHeaders,
                        withCredentials: false,
                    })).flatMap((apiGatewayAccessTokenEvent) => {
                        if (apiGatewayAccessTokenEvent instanceof HttpResponse) {
                            // We now have access to the API Gateway.
                            // Continue by calling the gateway (using the API Gateway access token),
                            // and by propagating the EU Login access token for the target service...
                            const /** @type {?} */ apiGatewayAccessToken = (/** @type {?} */ (apiGatewayAccessTokenEvent)).body;
                            this.cachedApiGatewayAccessTokenResponseTimestamp = new Date();
                            this.cachedApiGatewayAccessToken = apiGatewayAccessToken;
                            const /** @type {?} */ serviceAccessToken = (/** @type {?} */ (serviceAccessTokenEvent)).body;
                            return this.callApiGatewayService(request, next, apiGatewayAccessToken, serviceAccessToken, retryCount);
                        }
                        else {
                            return Observable.of(null);
                        }
                    });
                }
                else {
                    return Observable.of(null);
                }
            });
        }
        else {
            // We already have an API Gateway access token.
            // Now request an EU Login access token for the target service.
            return next.handle(this.getServiceAccessTokenRequest(audienceId)).catch((response) => {
                return this.handleErrorResponse(response, request, next, retryCount);
            }).flatMap((serviceAccessTokenEvent) => {
                if (serviceAccessTokenEvent instanceof HttpResponse) {
                    // We have now both the API Gateway access token and a EU Login access token for the target service;
                    // we can call the API Gateway.
                    const /** @type {?} */ serviceAccessToken = (/** @type {?} */ (serviceAccessTokenEvent)).body;
                    return this.callApiGatewayService(request, next, this.cachedApiGatewayAccessToken, serviceAccessToken);
                }
                else {
                    return Observable.of(null);
                }
            });
        }
    }
    /**
     * @param {?} request
     * @param {?} next
     * @param {?} audienceId
     * @param {?=} retryCount
     * @return {?}
     */
    makeServiceCall(request, next, audienceId, retryCount = 0) {
        return next.handle(this.getServiceAccessTokenRequest(audienceId)).flatMap((httpEvent) => {
            if (httpEvent instanceof HttpResponse) {
                const /** @type {?} */ accessToken = (/** @type {?} */ (httpEvent)).body;
                return next.handle(request.clone({
                    headers: request.headers.set('Authorization', accessToken.token_type + ' ' + accessToken.access_token),
                }));
            }
            else {
                return Observable.of(httpEvent);
            }
        }).catch((response) => this.handleErrorResponse(response, request, next, retryCount));
    }
    /**
     * @param {?} audienceId
     * @return {?}
     */
    getServiceAccessTokenRequest(audienceId) {
        let /** @type {?} */ parameters = new HttpParams();
        parameters = parameters.append('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer');
        parameters = parameters.append('scope', (this.config.openIdConnect.scope || this.openidConnectService.DEFAULT_OPENID_SCOPE));
        parameters = parameters.append('assertion', this.openidConnectService.getIdToken());
        parameters = parameters.append('audience', audienceId);
        parameters = parameters.append('client_id', this.config.openIdConnect.spaClientId);
        return new HttpRequest('POST', this.config.openIdConnect.euLoginAccessTokenUrl, null, {
            headers: new HttpHeaders().set('Content-type', 'application/x-www-form-urlencoded'),
            params: parameters,
            withCredentials: true,
        });
    }
    /**
     * @param {?} originalRequest
     * @param {?} next
     * @param {?} apiGatewayAccessToken
     * @param {?} serviceAccessToken
     * @param {?=} retryCount
     * @return {?}
     */
    callApiGatewayService(originalRequest, next, apiGatewayAccessToken, serviceAccessToken, retryCount = 0) {
        let /** @type {?} */ authorizationHeaders = originalRequest.headers;
        authorizationHeaders = authorizationHeaders.set('Authorization', apiGatewayAccessToken.token_type + ' ' + apiGatewayAccessToken.access_token);
        authorizationHeaders = authorizationHeaders.set('Authorization-Propagation', serviceAccessToken.access_token);
        return next.handle(originalRequest.clone({
            withCredentials: false,
            headers: authorizationHeaders,
        })).catch((response) => {
            return this.handleErrorResponse(response, originalRequest, next, retryCount);
        });
    }
    /**
     * @param {?} requestUrl
     * @param {?} serviceUrl
     * @return {?}
     */
    urlMatches(requestUrl, serviceUrl) {
        return new RegExp('^' + serviceUrl.replace(/\*/g, '.*')).test(requestUrl);
    }
    /**
     * @return {?}
     */
    cachedApiGatewayAccessTokenHasExpired() {
        if (this.cachedApiGatewayAccessTokenResponseTimestamp &&
            this.cachedApiGatewayAccessToken &&
            this.cachedApiGatewayAccessToken.expires_in) {
            // OpenID access token expires_in field is in seconds:
            const /** @type {?} */ expiresInMilliseconds = 1000 * this.cachedApiGatewayAccessToken.expires_in;
            return new Date().getTime() >= this.cachedApiGatewayAccessTokenResponseTimestamp.getTime() + expiresInMilliseconds;
        }
        else {
            return true;
        }
    }
    /**
     * @param {?} response
     * @param {?} originalRequest
     * @param {?} next
     * @param {?=} retryCount
     * @return {?}
     */
    handleErrorResponse(response, originalRequest, next, retryCount = 0) {
        if (response) {
            if (response.error && response.error.error === 'invalid_request') {
                // The ID token is invalid or incorrect; retrieve another one:
                this.openidConnectService.renewIdToken();
            }
            else if (response.status === 401 || response.status === 403) {
                // Can be one of the following conditions:
                // * The client ID is invalid or incorrect; fail the request.
                //   Either the developer needs to use a valid client ID or the administrator should allow the client ID access.
                // * The API Gateway access token is invalid. (401)
                // * The EU Login access token is invalid. (403)
                if (retryCount < this.maximumRequestRetries) {
                    return this.retryRequest(originalRequest, next, retryCount);
                }
                else {
                    console.error('The OpenID Connect call may have issues:\n' +
                        '* the client ID could be invalid\n' +
                        '* the API Gateway access token could be invalid\n' +
                        '* the EU Login access token for the target service could be invalid.');
                }
            }
            else if (response.status === 0) {
                // One of the access token requests or the original request was not sent.
                // Most likely one of the CORS pre-flight requests failed, or the browser is offline.
                console.warn('The OpenID Connect call may have issues:\n' +
                    '* the CORS pre-flight requests for the OpenID Connect access tokens or for the REST call could be failing\n' +
                    '* the browser could be currently offline.');
            }
        }
        throw (response);
    }
    /**
     * @param {?} originalRequest
     * @param {?} next
     * @param {?=} retryCount
     * @return {?}
     */
    retryRequest(originalRequest, next, retryCount = 0) {
        // Clear cached tokens before retrying in case the API Gateway access token is invalid:
        this.cachedApiGatewayAccessToken = null;
        return this.intercept(originalRequest, next, retryCount + 1);
    }
}
OpenidConnectInterceptor.decorators = [
    { type: Injectable },
];
/** @nocollapse */
OpenidConnectInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_TOKEN,] },] },
    { type: OpenidConnectService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBadge {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        this.typeClass = 'secondary';
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLink {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        this.disabled = false;
        this.hasIconBg = false;
        this.active = false;
        this.visible = true;
        this.expanded = false;
        this.hasMarker = false;
        this.hasTag = false;
        this.badgeTypeClass = 'secondary';
        this.isHome = false;
        this.isSeparator = false;
        this.isScreenReaderClickable = false;
        this.selected = false;
        Object.assign(this, values);
    }
    /**
     * @return {?}
     */
    get hasChildren() {
        return this.children != null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxOrderByPipe {
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static _orderByComparator(a, b) {
        if ((isNaN(parseFloat(a)) || !isFinite(a)) || (isNaN(parseFloat(b)) || !isFinite(b))) {
            // Isn't a number so lowercase the string to properly compare
            if (a.toLowerCase() < b.toLowerCase()) {
                return -1;
            }
            if (a.toLowerCase() > b.toLowerCase()) {
                return 1;
            }
        }
        else {
            // Parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b)) {
                return -1;
            }
            if (parseFloat(a) > parseFloat(b)) {
                return 1;
            }
        }
        return 0; // equal each other
    }
    /**
     * @param {?} input
     * @param {?} __1
     * @return {?}
     */
    transform(input, [config = '+']) {
        if (!Array.isArray(input)) {
            return input;
        }
        if (!Array.isArray(config) || (Array.isArray(config) && config.length === 1)) {
            let /** @type {?} */ propertyToCheck = !Array.isArray(config) ? config : config[0];
            let /** @type {?} */ desc = propertyToCheck.substr(0, 1) === '-';
            // Basic array
            if (!propertyToCheck || propertyToCheck === '-' || propertyToCheck === '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                let /** @type {?} */ property = propertyToCheck.substr(0, 1) === '+' || propertyToCheck.substr(0, 1) === '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort(function (a, b) {
                    return !desc
                        ? UxOrderByPipe._orderByComparator(a[property], b[property])
                        : -UxOrderByPipe._orderByComparator(a[property], b[property]);
                });
            }
        }
        else {
            // Loop over property of the array in order and sort
            return input.sort(function (a, b) {
                for (let /** @type {?} */ i = 0; i < config.length; i++) {
                    let /** @type {?} */ desc = config[i].substr(0, 1) === '-';
                    let /** @type {?} */ property = config[i].substr(0, 1) === '+' || config[i].substr(0, 1) === '-'
                        ? config[i].substr(1)
                        : config[i];
                    let /** @type {?} */ comparison = !desc
                        ? UxOrderByPipe._orderByComparator(a[property], b[property])
                        : -UxOrderByPipe._orderByComparator(a[property], b[property]);
                    // Don't return 0 yet in case of needing to sort by next property
                    if (comparison !== 0) {
                        return comparison;
                    }
                }
                return 0; // equal each other
            });
        }
    }
}
UxOrderByPipe.decorators = [
    { type: Pipe, args: [{ name: 'uxOrderBy', pure: false },] },
];
class UxOrderByPipeModule {
}
UxOrderByPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxOrderByPipe],
                declarations: [UxOrderByPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFilterPipe {
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    transform(value, args) {
        if (!args[0]) {
            return value;
        }
        else if (value) {
            return value.filter((item) => {
                for (let /** @type {?} */ key in item) {
                    if ((typeof item[key] === 'string' || item[key] instanceof String)) {
                        if (item[key].indexOf(args) !== -1) {
                            return true;
                        }
                    }
                }
            });
        }
    }
}
UxFilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'uxFilter'
            },] },
];
class UxFilterPipeModule {
}
UxFilterPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxFilterPipe],
                declarations: [UxFilterPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTruncatePipe {
    /**
     * @param {?} value
     * @param {?=} limit
     * @param {?=} trail
     * @return {?}
     */
    transform(value, limit = 40, trail = '\u2026') {
        if (value) {
            if (limit < 0) {
                limit *= -1;
                return value.length > limit ? trail + value.substring(value.length - limit, value.length) : value;
            }
            else {
                return value.length > limit ? value.substring(0, limit) + trail : value;
            }
        }
        return;
    }
}
UxTruncatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'uxTruncate'
            },] },
];
class UxTruncatePipeModule {
}
UxTruncatePipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTruncatePipe],
                declarations: [UxTruncatePipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCurrencyPipe {
    constructor() {
        this.decimalSeparator = '.';
        this.thousandsSeparator = ',';
    }
    /**
     * @param {?} value
     * @param {?=} fractionSize
     * @return {?}
     */
    transform(value, fractionSize = 2) {
        const /** @type {?} */ maxFractions = [];
        for (let /** @type {?} */ i = 0; i < fractionSize; i++) {
            maxFractions.push('0');
        }
        const /** @type {?} */ maxFraction = maxFractions.join('');
        let [integer, fraction = maxFraction] = (value || '0').toString().split(this.decimalSeparator);
        fraction = fractionSize > 0 ? (fraction + maxFraction).substring(0, fractionSize) : '';
        if (fraction === maxFraction) {
            fraction = '';
        }
        integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
        return '€ ' + integer + (fraction.length > 0 ? this.decimalSeparator + fraction : '');
    }
}
UxCurrencyPipe.decorators = [
    { type: Pipe, args: [{ name: 'uxCurrency' },] },
];
class UxCurrencyPipeModule {
}
UxCurrencyPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxCurrencyPipe],
                declarations: [UxCurrencyPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxNumberFormatPipe {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
    }
    /**
     * @param {?} value
     * @param {?=} decimalSeparator
     * @param {?=} fractionSize
     * @param {?=} thousandSeparator
     * @return {?}
     */
    transform(value, decimalSeparator = ',', fractionSize = 2, thousandSeparator = '.') {
        return this.uxService.formatNumber(value, fractionSize, decimalSeparator, thousandSeparator);
    }
}
UxNumberFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'uxNumberFormat' },] },
];
/** @nocollapse */
UxNumberFormatPipe.ctorParameters = () => [
    { type: UxService, },
];
class UxNumberFormatPipeModule {
}
UxNumberFormatPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxNumberFormatPipe],
                declarations: [UxNumberFormatPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMomentTzPipe {
    /**
     * inspired by https://www.npmjs.com/package/angular-moment-timezone
     * @param {?} value
     * @param {?} tzdata
     * @param {?=} parseInZone
     * @return {?}
     */
    transform(value, tzdata, parseInZone = false) {
        if (parseInZone) {
            return moment.tz(value, tzdata);
        }
        return moment(value).tz(tzdata);
    }
}
UxMomentTzPipe.decorators = [
    { type: Pipe, args: [{
                name: 'uxMomentTz',
            },] },
];
class UxMomentTzPipeModule {
}
UxMomentTzPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxMomentTzPipe],
                declarations: [UxMomentTzPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Transforms any input value
 */
class UxIsoToCountryPipe {
    /**
     * @param {?} service
     */
    constructor(service) {
        this.service = service;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return this.service.iso2country(value);
    }
}
UxIsoToCountryPipe.decorators = [
    { type: Pipe, args: [{
                name: 'uxIsoToCountry'
            },] },
    { type: Injectable },
];
/** @nocollapse */
UxIsoToCountryPipe.ctorParameters = () => [
    { type: UxTimezoneService, },
];
class UxIsoToCountryPipeModule {
}
UxIsoToCountryPipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxIsoToCountryPipe],
                declarations: [UxIsoToCountryPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxScrollHandlerDirective {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.uxScrollHandler = false;
        this.navIsFixed = false;
        this.appHeaderHeight = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.appWrapper = this.document.getElementById('app-wrapper');
        this.appHeader = this.document.getElementById('app-header');
        if (this.appHeader) {
            this.appHeaderHeight = this.appHeader.scrollHeight;
        }
    }
    /**
     * @return {?}
     */
    onWindowScroll() {
        if (this.uxScrollHandler && this.appHeaderHeight !== 0) {
            let /** @type {?} */ number = this.document.body.scrollTop || this.document.documentElement.scrollTop; // Chrome || IE/FF
            if (number > this.appHeaderHeight) {
                this.navIsFixed = true;
                this.appWrapper.classList.add('shrink-header-active');
            }
            else if (this.navIsFixed && number < this.appHeaderHeight) {
                this.navIsFixed = false;
                this.appWrapper.classList.remove('shrink-header-active');
            }
        }
    }
}
UxScrollHandlerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxScrollHandler]'
            },] },
];
/** @nocollapse */
UxScrollHandlerDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
];
UxScrollHandlerDirective.propDecorators = {
    "uxScrollHandler": [{ type: Input },],
    "onWindowScroll": [{ type: HostListener, args: ['window:scroll', [],] },],
};
class UxScrollHandlerElementDirective {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.navIsFixed = false;
    }
    /**
     * @return {?}
     */
    onWindowScroll() {
        let /** @type {?} */ element = this.document.getElementById(this.uxScrollHandlerElement);
        let /** @type {?} */ number = this.document.body.scrollTop || this.document.documentElement.scrollTop; // Chrome || IE/FF
        if (number > this.toggleActiveHeight) {
            this.navIsFixed = true;
            element.classList.add(this.toggleClass);
        }
        else if (this.navIsFixed && number < this.toggleActiveHeight) {
            this.navIsFixed = false;
            element.classList.remove(this.toggleClass);
        }
    }
}
UxScrollHandlerElementDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxScrollHandlerElement]'
            },] },
];
/** @nocollapse */
UxScrollHandlerElementDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
];
UxScrollHandlerElementDirective.propDecorators = {
    "uxScrollHandlerElement": [{ type: Input },],
    "toggleClass": [{ type: Input },],
    "toggleActiveHeight": [{ type: Input },],
    "onWindowScroll": [{ type: HostListener, args: ['window:scroll', [],] },],
};
class UxScrollHandlerDirectiveModule {
}
UxScrollHandlerDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxScrollHandlerDirective, UxScrollHandlerElementDirective],
                declarations: [UxScrollHandlerDirective, UxScrollHandlerElementDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMaxlengthDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.validityChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._element) {
            const /** @type {?} */ parent = this._element.parentElement;
            parent.removeChild(this._element);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.length) {
            setTimeout(() => {
                this._element = document.createElement('span');
                this._element.classList.add('input-maxlength');
                this._element.innerHTML = this.length.toString();
                let /** @type {?} */ nativeElement = this.el.nativeElement;
                if (nativeElement != null) {
                    let /** @type {?} */ parent = nativeElement.parentNode;
                    let /** @type {?} */ wrapper = document.createElement('div');
                    if (parent != null) {
                        parent.replaceChild(wrapper, nativeElement);
                        wrapper.appendChild(nativeElement);
                        if (nativeElement.parentElement != null) {
                            nativeElement.parentElement.appendChild(this._element);
                            nativeElement.parentElement.classList.add('input-maxlength-wrapper');
                        }
                    }
                }
                this._refreshValue();
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        setTimeout(() => {
            this._refreshValue();
        }, 100);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInput(event) {
        this._refreshValue();
    }
    /**
     * @return {?}
     */
    _refreshValue() {
        let /** @type {?} */ input = /** @type {?} */ (this.el.nativeElement);
        let /** @type {?} */ remainingLength = this.length - input.value.length;
        if (remainingLength < 0) {
            this._element.classList.add('error');
            input.value = input.value.substr(0, this.length);
            this._element.innerHTML = "0";
            this.validityChange.emit(false);
        }
        else {
            if (remainingLength <= 0) {
                this._element.classList.add('error');
                this.validityChange.emit(false);
                if (remainingLength < 0) {
                    input.value = input.value.substr(0, input.value.length - 1);
                }
            }
            if (remainingLength >= 0) {
                this._element.innerHTML = (this.length - input.value.length).toString();
            }
            if (remainingLength > 0) {
                this._element.classList.remove('error');
                this.validityChange.emit(true);
            }
        }
    }
}
UxMaxlengthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxMaxlength]',
                host: { '(input)': 'onInput($event)' }
            },] },
];
/** @nocollapse */
UxMaxlengthDirective.ctorParameters = () => [
    { type: ElementRef, },
];
UxMaxlengthDirective.propDecorators = {
    "length": [{ type: Input, args: ['uxMaxlength',] },],
    "validityChange": [{ type: Output },],
    "onChange": [{ type: HostListener, args: ['change', ['$event'],] },],
};
class UxMaxlengthModule {
}
UxMaxlengthModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxMaxlengthDirective],
                declarations: [UxMaxlengthDirective]
            },] },
];
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTooltip {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.text = '';
        this.position = 'top';
        this.color = 'none';
        this.size = 'auto';
        this.rounded = false;
        this.always = false;
        this._el = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.always) {
            this._el.classList.add("hint--always");
            this.show();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (let /** @type {?} */ i = 0; i < this._el.classList.length; i++) {
            let /** @type {?} */ currentClass = this._el.classList[i];
            if (currentClass.indexOf("hint--") !== -1) {
                this._el.classList.remove(currentClass);
            }
        }
        if (this.always) {
            this._el.classList.add("hint--always");
            this.show();
        }
    }
    /**
     * @return {?}
     */
    show() {
        if (!this.text || this.text.length == 0)
            return;
        this.hide();
        this._el.setAttribute("data-hint", this.text);
        for (let /** @type {?} */ i = 0; i < this._el.classList.length; i++) {
            let /** @type {?} */ currentClass = this._el.classList[i];
            if (currentClass.indexOf("hint") !== -1)
                this._el.classList.remove(currentClass);
        }
        if (this.always) {
            this._el.classList.add("hint--always");
        }
        this._el.classList.add("hint--" + this.position);
        switch (this.color) {
            case "danger":
                this._el.classList.add("hint--error");
                break;
            case "warning":
                this._el.classList.add("hint--warning");
                break;
            case "info":
                this._el.classList.add("hint--info");
                break;
            case "success":
                this._el.classList.add("hint--success");
                break;
            default:
        }
        switch (this.size) {
            case "small":
                this._el.classList.add("hint--small");
                break;
            case "medium":
                this._el.classList.add("hint--medium");
                break;
            case "large":
                this._el.classList.add("hint--large");
                break;
            default:
        }
        if (this.rounded)
            this._el.classList.add("hint--rounded");
    }
    /**
     * @return {?}
     */
    hide() {
        if (this.always)
            return;
        this._el.removeAttribute("data-hint");
    }
}
UxTooltip.decorators = [
    { type: Directive, args: [{
                selector: '[uxTooltip]',
                host: {
                    '(mouseover)': 'show()',
                    '(mouseout)': 'hide()',
                    '(focus)': 'show()',
                    '(unfocus)': 'hide()'
                }
            },] },
];
/** @nocollapse */
UxTooltip.ctorParameters = () => [
    { type: ElementRef, },
];
UxTooltip.propDecorators = {
    "text": [{ type: Input, args: ['uxTooltip',] },],
    "position": [{ type: Input },],
    "color": [{ type: Input },],
    "size": [{ type: Input },],
    "rounded": [{ type: Input },],
    "always": [{ type: Input },],
};
class UxTooltipModule {
}
UxTooltipModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTooltip],
                declarations: [UxTooltip]
            },] },
];
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAutoResizeDirective {
    /**
     * @param {?} el
     * @param {?} uxService
     * @param {?} controlContainer
     */
    constructor(el, uxService, controlContainer) {
        this.el = el;
        this.uxService = uxService;
        this.controlContainer = controlContainer;
        this.defaultRows = 1;
        this.windowResizedSubscription = fromEvent(window, 'resize')
            .debounceTime(300)
            .subscribe((event) => {
            this.resize();
        });
    }
    /**
     * @param {?} minRows
     * @return {?}
     */
    set minRows(minRows) {
        this.defaultRows = minRows;
    }
    /**
     * @param {?} textArea
     * @return {?}
     */
    onInput(textArea) {
        if (!this.isUsingFormsApi()) {
            this.resize();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.el.nativeElement.rows = this.defaultRows;
        this.el.nativeElement.style.overflow = 'hidden';
        this.el.nativeElement.style.resize = 'none';
        if (this.isUsingFormsApi()) {
            this.handleFormControlChanges();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // In case auto-resize inputs are being used inside modal dialogs, we have to wait until the modal dialog is open before we resize:
        const /** @type {?} */ modalParent = this.findAncestorByClass(this.el.nativeElement, 'ux-modal');
        if (modalParent != null) {
            this.parentModalId = modalParent.id;
            this.openModalIdSubscription = this.uxService.openModalId.subscribe((modalId) => {
                if (modalId === this.parentModalId) {
                    setTimeout(() => {
                        this.resize();
                    }, 0);
                }
            });
        }
        this.resize();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.openModalIdSubscription) {
            this.openModalIdSubscription.unsubscribe();
        }
        if (this.windowResizedSubscription) {
            this.windowResizedSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    resize() {
        this.el.nativeElement.style.height = 'auto';
        let /** @type {?} */ offset = this.el.nativeElement.offsetHeight, /** @type {?} */
        scroll = this.el.nativeElement.scrollHeight;
        let /** @type {?} */ height = (offset > scroll ? offset : scroll);
        if (height <= 0) {
            height = 'auto';
        }
        else {
            height += 'px';
        }
        this.el.nativeElement.style.height = height;
    }
    /**
     * @param {?} el
     * @param {?} cls
     * @return {?}
     */
    findAncestorByClass(el, cls) {
        while ((el = el.parentElement) && !el.classList.contains(cls)) { }
        return el;
    }
    /**
     * @return {?}
     */
    handleFormControlChanges() {
        const /** @type {?} */ fg = this.getFormGroup();
        if (fg && fg.controls[this.formControlName]) {
            fg.controls[this.formControlName]
                .valueChanges
                .subscribe(v => {
                this.resize();
            });
        }
    }
    /**
     * @return {?}
     */
    isUsingFormsApi() {
        return !!this.getFormGroup();
    }
    /**
     * @return {?}
     */
    getFormGroup() {
        if (this.controlContainer && this.controlContainer.formDirective) {
            return (/** @type {?} */ (this.controlContainer.formDirective)).form;
        }
        return null;
    }
}
UxAutoResizeDirective.decorators = [
    { type: Directive, args: [{
                selector: 'textarea[uxAutoResize]'
            },] },
];
/** @nocollapse */
UxAutoResizeDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: UxService, },
    { type: ControlContainer, decorators: [{ type: Optional },] },
];
UxAutoResizeDirective.propDecorators = {
    "formControlName": [{ type: Input },],
    "minRows": [{ type: Input },],
    "onInput": [{ type: HostListener, args: ['input', ['$event.target'],] },],
};
class UxAutoResizeModule {
}
UxAutoResizeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxAutoResizeDirective],
                declarations: [UxAutoResizeDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCollapsibleDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.isFinishedMoving = true;
        this.isExpanded = true;
        this.isMoving = false;
        this.uxExpanded = true;
        this.uxCollapsed = false;
        this.transitionDuration = '0.35s';
        this.container = el.nativeElement;
        this.containerStyle = this.container.style;
        this.containerStyle.overflow = 'hidden';
        this.containerStyle.transform = 'translate3d(0, 0, 0)';
        let /** @type {?} */ display = this.containerStyle.display;
        if (display == null || display.length <= 0) {
            this.containerStyle.display = 'block';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        let /** @type {?} */ change = changes['uxCollapsed'];
        if (change != null && !change.isFirstChange()) {
            if (this.uxCollapsed) {
                this.collapse();
            }
            else {
                this.expand();
            }
        }
        change = changes['uxExpanded'];
        if (change != null && !change.isFirstChange()) {
            if (this.uxExpanded) {
                this.expand();
            }
            else {
                this.collapse();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.containerStyle.transitionDuration = '0';
        if (this.uxCollapsed || !this.uxExpanded || this.container.getAttribute('aria-expanded') === 'false') {
            this.isExpanded = false;
            this.containerStyle.height = '0';
        }
        else {
            this.containerStyle.height = 'auto'; // Set it to auto to ensure a working resizing.
        }
    }
    /**
     * @return {?}
     */
    collapse() {
        if (this.isExpanded) {
            if (this.animation != null) {
                this.animation.unsubscribe();
            }
            this.animation = Observable.concat(Observable.of(() => {
                this.disableFocus();
                this.isMoving = true;
                this.isFinishedMoving = false;
                // Temporarily disable the transition to ensure a transition from and actual height value.
                this.containerStyle.transitionDuration = '0';
            }), Observable.timer(20).switchMapTo(Observable.of(() => {
                // Set it to the current height first to ensure the animation on the 'height' property.
                this.containerStyle.height = this.container.offsetHeight + 'px';
                this.containerStyle.transitionDuration = this.transitionDuration;
            })), Observable.timer(20).switchMapTo(Observable.of(() => {
                this.containerStyle.opacity = '1.0';
                this.containerStyle.height = '0';
            })), Observable.timer(350).switchMapTo(Observable.of(() => {
                this.isExpanded = false;
                this.isFinishedMoving = true;
                this.isMoving = false;
                this.containerStyle.transitionDuration = '0';
            }))).subscribe(f => f());
        }
    }
    /**
     * @return {?}
     */
    expand() {
        if (!this.isExpanded) {
            if (this.animation != null) {
                this.animation.unsubscribe();
            }
            let /** @type {?} */ height = 0;
            this.animation = Observable.concat(Observable.of(() => {
                this.enableFocus();
                this.isMoving = false;
                this.isFinishedMoving = false;
                // Temporarily disable the transition to ensure a transition from an actual height value.
                this.containerStyle.transitionDuration = '0';
                // Also make the content invisible to know the actual current height.
                this.containerStyle.opacity = '0';
            }), Observable.timer(0).switchMapTo(Observable.of(() => {
                this.containerStyle.height = 'auto';
                height = this.container.offsetHeight;
                this.containerStyle.height = '0'; // Set it first back to 0 to ensure the animation on the 'height' property.
            })), Observable.timer(20).switchMapTo(Observable.of(() => {
                this.containerStyle.transitionDuration = this.transitionDuration;
                this.containerStyle.opacity = '1.0';
            })), Observable.timer(20).switchMapTo(Observable.of(() => {
                this.containerStyle.height = height + 'px';
            })), Observable.timer(350).switchMapTo(Observable.of(() => {
                this.isExpanded = true;
                this.isFinishedMoving = true;
                this.isMoving = false;
                this.containerStyle.height = 'auto'; // Set it to auto to ensure a working resizing.
                this.containerStyle.transitionDuration = '0';
            }))).subscribe(f => f());
        }
    }
    /**
     * @return {?}
     */
    disableFocus() {
        let /** @type {?} */ focusedElement = this.container.querySelector(':focus');
        if (focusedElement != null) {
            focusedElement.blur();
        }
        let /** @type {?} */ elements = this.container.querySelectorAll('*');
        for (let /** @type {?} */ i = 0; i < elements.length; i++) {
            let /** @type {?} */ element = elements[i];
            let /** @type {?} */ tabIndex = element.getAttribute('tabindex');
            if (tabIndex != null) {
                element.setAttribute('data-prev-tabindex', tabIndex);
            }
            element.setAttribute('tabindex', '-1');
        }
    }
    /**
     * @return {?}
     */
    enableFocus() {
        let /** @type {?} */ elements = this.container.querySelectorAll('*');
        for (let /** @type {?} */ i = 0; i < elements.length; i++) {
            let /** @type {?} */ element = elements[i];
            let /** @type {?} */ prevTabIndex = element.getAttribute('data-prev-tabindex');
            if (prevTabIndex != null) {
                element.setAttribute('tabindex', prevTabIndex);
            }
            else {
                element.removeAttribute('tabindex');
            }
        }
    }
}
UxCollapsibleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxCollapsible]',
                exportAs: 'uxCollapsible'
            },] },
];
/** @nocollapse */
UxCollapsibleDirective.ctorParameters = () => [
    { type: ElementRef, },
];
UxCollapsibleDirective.propDecorators = {
    "isFinishedMoving": [{ type: HostBinding, args: ['class.collapse',] },],
    "isExpanded": [{ type: HostBinding, args: ['class.in',] }, { type: HostBinding, args: ['attr.aria-expanded',] },],
    "isMoving": [{ type: HostBinding, args: ['class.collapsing',] },],
    "uxExpanded": [{ type: Input },],
    "uxCollapsed": [{ type: Input },],
};
class UxCollapsibleDirectiveModule {
}
UxCollapsibleDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxCollapsibleDirective],
                declarations: [UxCollapsibleDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* tslint:enable */
class UxHasPermissionDirective {
    /**
     * @param {?} element
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} permissionService
     */
    constructor(element, templateRef, viewContainer, permissionService) {
        this.element = element;
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.permissionService = permissionService;
        this.permissions = [];
        this.isHidden = true;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasPermission(val) {
        this.permissions = val;
        this.updateView();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateView();
    }
    /**
     * @return {?}
     */
    updateView() {
        if (this.checkPermission()) {
            if (this.isHidden) {
                this.viewContainer.createEmbeddedView(this.templateRef);
                this.isHidden = false;
            }
        }
        else {
            this.isHidden = true;
            this.viewContainer.clear();
        }
    }
    /**
     * @return {?}
     */
    checkPermission() {
        let /** @type {?} */ hasPermission = true;
        // for start it checks with and operator
        this.permissions.forEach((permission) => {
            hasPermission = this.permissionService.checkAttributePermission(permission) && hasPermission;
        });
        return hasPermission;
    }
}
UxHasPermissionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[hasPermission]'
            },] },
];
/** @nocollapse */
UxHasPermissionDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: TemplateRef, },
    { type: ViewContainerRef, },
    { type: UxPermissionService, },
];
UxHasPermissionDirective.propDecorators = {
    "hasPermission": [{ type: Input },],
};
class UxHasPermissionDirectiveModule {
}
UxHasPermissionDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxHasPermissionDirective],
                declarations: [UxHasPermissionDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxSmoothScrollToDirective {
    constructor() { }
    /**
     * @return {?}
     */
    onClick() {
        this.targetElement = document.getElementById(this.scrollTo);
        if (!this.targetElement) {
            return;
        }
        new SmoothScroll(this.targetElement, {
            duration: this.duration,
            offset: this.offset,
            easing: this.easing,
            callbackBefore: this.callbackBefore,
            callbackAfter: this.callbackAfter,
            containerId: this.containerId,
            middleAlign: this.middleAlign
        });
    }
    ;
}
UxSmoothScrollToDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxScrollTo]'
            },] },
];
/** @nocollapse */
UxSmoothScrollToDirective.ctorParameters = () => [];
UxSmoothScrollToDirective.propDecorators = {
    "scrollTo": [{ type: Input, args: ['uxScrollTo',] },],
    "duration": [{ type: Input, args: ['duration',] },],
    "offset": [{ type: Input, args: ['offset',] },],
    "easing": [{ type: Input, args: ['easing',] },],
    "callbackBefore": [{ type: Input, args: ['callbackBefore',] },],
    "callbackAfter": [{ type: Input, args: ['callbackAfter',] },],
    "containerId": [{ type: Input, args: ['containerId',] },],
    "middleAlign": [{ type: Input, args: ['middleAlign',] },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};
class UxSmoothScrollDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @param {?} target
     * @return {?}
     */
    onClick(target) {
        if (this.scrollOnClick) {
            this.scroll();
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        this.scroll();
    }
    /**
     * @return {?}
     */
    scroll() {
        if (typeof this.scrollIf === 'undefined' || this.scrollIf === true) {
            setTimeout(() => {
                new SmoothScroll(this.el.nativeElement, {
                    duration: this.duration,
                    offset: this.offset,
                    easing: this.easing,
                    callbackBefore: this.callbackBefore,
                    callbackAfter: this.callbackAfter,
                    containerId: this.containerId,
                    middleAlign: this.middleAlign
                });
            }, 0);
        }
    }
}
UxSmoothScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxSmoothScroll]'
            },] },
];
/** @nocollapse */
UxSmoothScrollDirective.ctorParameters = () => [
    { type: ElementRef, },
];
UxSmoothScrollDirective.propDecorators = {
    "scrollIf": [{ type: Input, args: ['scrollIf',] },],
    "duration": [{ type: Input, args: ['duration',] },],
    "offset": [{ type: Input, args: ['offset',] },],
    "easing": [{ type: Input, args: ['easing',] },],
    "callbackBefore": [{ type: Input, args: ['callbackBefore',] },],
    "callbackAfter": [{ type: Input, args: ['callbackAfter',] },],
    "containerId": [{ type: Input, args: ['containerId',] },],
    "scrollOnClick": [{ type: Input, args: ['scrollOnClick',] },],
    "middleAlign": [{ type: Input, args: ['middleAlign',] },],
    "onClick": [{ type: HostListener, args: ['click', ['$event.target'],] },],
};
class SmoothScroll {
    /**
     * @param {?} element
     * @param {?} options
     */
    constructor(element, options) {
        this.smoothScroll(element, options);
    }
    /**
     * @param {?} element
     * @param {?} options
     * @return {?}
     */
    smoothScroll(element, options) {
        options = options || {};
        // Options
        let /** @type {?} */ duration = options.duration || 800, /** @type {?} */
        offset = options.offset || 0, /** @type {?} */
        easing = options.easing || 'easeInOutQuart', /** @type {?} */
        callbackBefore = options.callbackBefore || function () { }, /** @type {?} */
        callbackAfter = options.callbackAfter || function () { }, /** @type {?} */
        container = document.getElementById(options.containerId) || null, /** @type {?} */
        containerPresent = (container != undefined && container != null), /** @type {?} */
        middleAlign = options.middleAlign || false;
        /**
         * Retrieve current location
         */
        let /** @type {?} */ getScrollLocation = function () {
            if (containerPresent) {
                return container.scrollTop;
            }
            else {
                if (window.pageYOffset) {
                    return window.pageYOffset;
                }
                else {
                    return document.documentElement.scrollTop;
                }
            }
        };
        /**
         * Calculate easing pattern.
         *
         * 20150713 edit - zephinzer
         * - changed if-else to switch
         * @see http://archive.oreilly.com/pub/a/server-administration/excerpts/even-faster-websites/writing-efficient-javascript.html
         */
        let /** @type {?} */ getEasingPattern = function (type, time) {
            switch (type) {
                case 'easeInQuad': return time * time; // accelerating from zero velocity
                case 'easeOutQuad': return time * (2 - time); // decelerating to zero velocity
                case 'easeInOutQuad': return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration
                case 'easeInCubic': return time * time * time; // accelerating from zero velocity
                case 'easeOutCubic': return (--time) * time * time + 1; // decelerating to zero velocity
                case 'easeInOutCubic': return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration
                case 'easeInQuart': return time * time * time * time; // accelerating from zero velocity
                case 'easeOutQuart': return 1 - (--time) * time * time * time; // decelerating to zero velocity
                case 'easeInOutQuart': return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time; // acceleration until halfway, then deceleration
                case 'easeInQuint': return time * time * time * time * time; // accelerating from zero velocity
                case 'easeOutQuint': return 1 + (--time) * time * time * time * time; // decelerating to zero velocity
                case 'easeInOutQuint': return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time; // acceleration until halfway, then deceleration
                default: return time;
            }
        };
        /**
         * Calculate how far to scroll
         */
        let /** @type {?} */ getEndLocation = function (element) {
            let /** @type {?} */ location = 0, /** @type {?} */
            elementRect = element.getBoundingClientRect(), /** @type {?} */
            absoluteElementTop = elementRect.top + window.pageYOffset;
            if (middleAlign) {
                location = (absoluteElementTop + (element.offsetHeight / 2)) - (window.innerHeight / 2);
            }
            else {
                location = absoluteElementTop;
            }
            if (offset) {
                location = location - offset;
            }
            return Math.max(location, 0);
        };
        // Initialize the whole thing
        setTimeout(function () {
            let /** @type {?} */ currentLocation = null, /** @type {?} */
            startLocation = getScrollLocation(), /** @type {?} */
            endLocation = getEndLocation(element), /** @type {?} */
            timeLapsed = 0, /** @type {?} */
            distance = endLocation - startLocation, /** @type {?} */
            percentage, /** @type {?} */
            position, /** @type {?} */
            scrollHeight, /** @type {?} */
            internalHeight;
            /**
             * Stop the scrolling animation when the anchor is reached (or at the top/bottom of the page)
             */
            let /** @type {?} */ stopAnimation = function () {
                currentLocation = getScrollLocation();
                if (containerPresent) {
                    scrollHeight = container.scrollHeight;
                    internalHeight = container.clientHeight + currentLocation;
                }
                else {
                    scrollHeight = document.body.scrollHeight;
                    internalHeight = window.innerHeight + currentLocation;
                }
                if ((
                // condition 1
                position == endLocation) ||
                    (
                    // condition 2
                    currentLocation == endLocation) ||
                    (
                    // condition 3
                    internalHeight > scrollHeight)) {
                    // stop
                    clearInterval(runAnimation);
                    callbackAfter(element);
                }
            };
            /**
             * Scroll the page by an increment, and check if it's time to stop
             */
            let /** @type {?} */ animateScroll = function () {
                timeLapsed += 16;
                percentage = (timeLapsed / duration);
                percentage = (percentage > 1) ? 1 : percentage;
                position = startLocation + (distance * getEasingPattern(easing, percentage));
                if (containerPresent) {
                    container.scrollTop = position;
                }
                else {
                    window.scrollTo(0, position);
                }
                stopAnimation();
            };
            callbackBefore(element);
            let /** @type {?} */ runAnimation = setInterval(animateScroll, 16);
        }, 0);
    }
}
class UxSmoothScrollDirectiveModule {
}
UxSmoothScrollDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxSmoothScrollToDirective, UxSmoothScrollDirective],
                declarations: [UxSmoothScrollToDirective, UxSmoothScrollDirective]
            },] },
];
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ availableTypes = [
    'creditCard',
    'phone',
    'date',
    'numeral'
];
class UxCleaveDirective {
    /**
     * @param {?} el
     * @param {?} uxService
     */
    constructor(el, uxService) {
        this.el = el;
        this.uxService = uxService;
        this.cleaveInstance = null;
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ cleaveOpts = null;
        // simple type (see availableTypes)
        if (typeof this.options === 'string' && availableTypes.indexOf(this.options) !== -1) {
            cleaveOpts = {};
            cleaveOpts[this.options] = true;
            let /** @type {?} */ numeralDecimalMark;
            let /** @type {?} */ delimiter;
            if (this.options === 'numeral') {
                if (this.decimalSeparator) {
                    numeralDecimalMark = this.decimalSeparator;
                    if (this.decimalSeparator === ',') {
                        delimiter = ' ';
                    }
                    else {
                        delimiter = '';
                    }
                }
                else {
                    numeralDecimalMark = ',';
                }
                if (this.thousandSeparator) {
                    delimiter = this.thousandSeparator;
                    if (this.thousandSeparator === ',') {
                        numeralDecimalMark = '.';
                    }
                    else {
                        numeralDecimalMark = !this.decimalSeparator || (this.decimalSeparator !== '.' && this.decimalSeparator !== ',') ?
                            ',' :
                            this.decimalSeparator;
                    }
                }
                else {
                    delimiter = '';
                }
                cleaveOpts = {
                    numeral: true,
                    numeralDecimalMark,
                    delimiter,
                };
            }
        }
        // literal options object
        if (typeof this.options === 'string' && this.options.match(/^\{/)) {
            try {
                cleaveOpts = JSON.parse(this.options);
            }
            catch (/** @type {?} */ e) {
                console.error('Angular2 Cleave : options object could not be parsed. Check that JSON syntax is correct.');
            }
        }
        // handle error if option is not available
        if (typeof this.options === 'string' && cleaveOpts === null) {
            console.error('Angular2 Cleave : option is not valid (%s).\n Available options : %s', this.options, availableTypes.join(', '));
        }
        // Cleave.js options object
        if (typeof this.options === 'object') {
            cleaveOpts = this.options;
        }
        // let's go !
        if (cleaveOpts !== null) {
            this.initCleave(cleaveOpts);
        }
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    initCleave(opts) {
        this.cleaveInstance = new Cleave(this.el.nativeElement, opts);
    }
}
UxCleaveDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxCleave]'
            },] },
];
/** @nocollapse */
UxCleaveDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: UxService, },
];
UxCleaveDirective.propDecorators = {
    "options": [{ type: Input, args: ['uxCleave',] },],
    "decimalSeparator": [{ type: Input },],
    "thousandSeparator": [{ type: Input },],
};
class UxCleaveModule {
}
UxCleaveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxCleaveDirective],
                declarations: [UxCleaveDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
    /**
     * @return {?}
     */
    getType() {
        return this.name;
    }
}
UxTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[uxTemplate]'
            },] },
];
/** @nocollapse */
UxTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, },
];
UxTemplateDirective.propDecorators = {
    "type": [{ type: Input },],
    "name": [{ type: Input, args: ['uxTemplate',] },],
};
class UxTemplateDirectiveModule {
}
UxTemplateDirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTemplateDirective],
                declarations: [UxTemplateDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NguiAutoCompleteDropdownButtonDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.hasDropdownButton = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.hasDropdownButton) {
            const /** @type {?} */ input = this.el.nativeElement;
            if (input && input.offsetParent) {
                this.inputParent = input.offsetParent;
                this.inputButton = document.createElement('div');
                this.inputButton.className = 'ngui-auto-complete-wrapper__button';
                input.style.paddingRight = '2rem';
                this.inputButton.addEventListener('click', this.onClickListener.bind(this));
                this.inputParent.appendChild(this.inputButton);
            }
        }
    }
    /**
     * @return {?}
     */
    onClickListener() {
        this.el.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.inputButton) {
            this.inputButton.removeEventListener('click', this.onClickListener);
            this.inputButton.remove();
        }
    }
}
NguiAutoCompleteDropdownButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[ngui-auto-complete]'
            },] },
];
/** @nocollapse */
NguiAutoCompleteDropdownButtonDirective.ctorParameters = () => [
    { type: ElementRef, },
];
NguiAutoCompleteDropdownButtonDirective.propDecorators = {
    "hasDropdownButton": [{ type: Input },],
};
class NguiAutoCompleteDropdownButtonModule {
}
NguiAutoCompleteDropdownButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [NguiAutoCompleteDropdownButtonDirective],
                declarations: [NguiAutoCompleteDropdownButtonDirective]
            },] },
];
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLanguage {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxGrowlComponent {
    /**
     * @param {?} el
     * @param {?} differs
     */
    constructor(el, differs) {
        this.el = el;
        this.sticky = false;
        this.life = 3000;
        this.differ = differs.find([]).create(undefined);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.container = /** @type {?} */ (this.containerViewChild.nativeElement);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        let /** @type {?} */ changes = this.differ.diff(this.value);
        if (changes && this.container) {
            if (this.stopDoCheckPropagation) {
                this.stopDoCheckPropagation = false;
            }
            else if (this.value && this.value.length) {
                if (!this.sticky) {
                    if (this.timeout) {
                        clearTimeout(this.timeout);
                    }
                    this.timeout = setTimeout(() => {
                        this.removeAll();
                    }, this.life);
                }
            }
        }
    }
    /**
     * @param {?} msg
     * @param {?} msgel
     * @return {?}
     */
    remove(msg, msgel) {
        this.stopDoCheckPropagation = true;
        setTimeout(() => {
            this.value.splice(this.findMessageIndex(msg), 1);
        }, 250);
    }
    /**
     * @return {?}
     */
    removeAll() {
        if (this.value && this.value.length) {
            this.stopDoCheckPropagation = true;
            setTimeout(() => {
                this.value.splice(0, this.value.length);
            }, 250);
        }
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    findMessageIndex(msg) {
        let /** @type {?} */ index = -1;
        if (this.value && this.value.length) {
            for (let /** @type {?} */ i = 0; i < this.value.length; i++) {
                if (this.value[i] === msg) {
                    index = i;
                    break;
                }
            }
        }
        return index;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (!this.sticky) {
            clearTimeout(this.timeout);
        }
    }
}
UxGrowlComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-growl',
                template: `
        <div #container class="ux-growl {{styleClass}} ux-growl--{{position}}">
            <div #msgel *ngFor="let msg of value"
                 class="ux-growl-item-container fx slideInUp" aria-live="polite"
                 [ngClass]="{'ux-growl-item-container--info':msg.severity == 'info',
                             'ux-growl-item-container--warning':msg.severity == 'warning',
                             'ux-growl-item-container--danger':msg.severity == 'danger',
                             'ux-growl-item-container--success':msg.severity == 'success'}">
                <div class="ux-growl-item">
                     <div class="ux-growl-item-close ux-icon ux-icon-close" (click)="remove(msg,msgel)"></div>
                     <span class="ux-growl-item-image ux-icon ux-icon-2x"
                        [ngClass]="{'ux-icon-info-circle':msg.severity == 'info',
                                    'ux-icon-exclamation-circle':msg.severity == 'warning',
                                    'ux-icon-times-circle':msg.severity == 'danger',
                                    'ux-icon-check-circle':msg.severity == 'success'}"></span>
                     <div class="ux-growl-item-message">
                        <span class="ux-growl-item-message-title">{{msg.summary}}</span>
                        <p class="ux-growl-item-message-detail" [innerHTML]="msg.detail"></p>
                     </div>
                </div>
            </div>
        </div>
    `
            },] },
];
/** @nocollapse */
UxGrowlComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: IterableDiffers, },
];
UxGrowlComponent.propDecorators = {
    "sticky": [{ type: Input },],
    "life": [{ type: Input },],
    "value": [{ type: Input },],
    "style": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "position": [{ type: Input },],
    "containerViewChild": [{ type: ViewChild, args: ['container',] },],
};
class UxGrowlComponentModule {
}
UxGrowlComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxGrowlComponent],
                declarations: [UxGrowlComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBlockDocumentComponent {
    constructor() { }
}
UxBlockDocumentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-block-document',
                template: "<div class=\"ux-block-document\" [ngStyle]=\"{display: isBlocked ? 'block' : 'none'}\"> <div class=\"ux-block-document-loading\"></div> </div> ",
            },] },
];
/** @nocollapse */
UxBlockDocumentComponent.ctorParameters = () => [];
UxBlockDocumentComponent.propDecorators = {
    "isBlocked": [{ type: Input },],
};
class UxBlockDocumentComponentModule {
}
UxBlockDocumentComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxBlockDocumentComponent],
                declarations: [UxBlockDocumentComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxEuLanguages {
    /**
     * @param {?=} codes
     * @return {?}
     */
    static getLanguages(codes) {
        if (codes == null || codes.length <= 0) {
            codes = this.defaultCodes;
        }
        let /** @type {?} */ languages = [];
        for (let /** @type {?} */ c = 0; c < codes.length; c++) {
            const /** @type {?} */ language = this.languagesByCode[codes[c]];
            if (language != null) {
                languages.push(language);
            }
        }
        return languages;
    }
}
UxEuLanguages.languagesByCode = {
    bg: {
        code: 'bg',
        label: 'български'
    },
    cs: {
        code: 'cs',
        label: 'čeština'
    },
    da: {
        code: 'da',
        label: 'dansk'
    },
    de: {
        code: 'de',
        label: 'Deutsch'
    },
    et: {
        code: 'et',
        label: 'eesti keel'
    },
    el: {
        code: 'el',
        label: 'ελληνικά'
    },
    en: {
        code: 'en',
        label: 'English'
    },
    es: {
        code: 'es',
        label: 'español'
    },
    fr: {
        code: 'fr',
        label: 'français'
    },
    ga: {
        code: 'ga',
        label: 'Gaeilge'
    },
    it: {
        code: 'it',
        label: 'italiano'
    },
    lv: {
        code: 'lv',
        label: 'latviešu valoda'
    },
    lt: {
        code: 'lt',
        label: 'lietuvių kalba'
    },
    hu: {
        code: 'hu',
        label: 'magyar'
    },
    mt: {
        code: 'mt',
        label: 'Malti'
    },
    nl: {
        code: 'nl',
        label: 'Nederlands'
    },
    pl: {
        code: 'pl',
        label: 'polski'
    },
    pt: {
        code: 'pt',
        label: 'português'
    },
    ro: {
        code: 'ro',
        label: 'română'
    },
    sk: {
        code: 'sk',
        label: 'slovenčina'
    },
    sl: {
        code: 'sl',
        label: 'slovenščina'
    },
    fi: {
        code: 'fi',
        label: 'suomi'
    },
    sv: {
        code: 'sv',
        label: 'svenska'
    },
    hr: {
        code: 'hr',
        label: 'hrvatski'
    },
    is: {
        code: 'is',
        label: 'íslenska'
    },
    mk: {
        code: 'mk',
        label: 'македонски'
    },
    no: {
        code: 'no',
        label: 'norsk'
    },
    tr: {
        code: 'tr',
        label: 'türkçe'
    }
};
UxEuLanguages.defaultCodes = [
    'bg', 'cs', 'da', 'de', 'et', 'el', 'en',
    'es', 'fr', 'ga', 'it', 'lv', 'lt', 'hu',
    'mt', 'nl', 'pl', 'pt', 'ro', 'sk', 'sl',
    'fi', 'sv', 'hr', 'is', 'mk', 'no', 'tr'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxModalComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.dismissActionLabel = 'Cancel';
        this.dismissActionDisabled = false;
        this.acceptActionLabel = 'OK';
        this.acceptActionDisabled = false;
        this.isFooterVisible = true;
        this.isVisible = false;
        this.isKeepBodyScroll = false;
        this.isSizeSmall = false;
        this.isSizeLarge = false;
        this.isSizeFullScreen = false;
        this.isSizeFullHeight = false;
        this.isSizeMediumHeight = false;
        this.isShowActionIcons = false;
        this.acceptIconClass = 'ux-icon ux-icon-check';
        this.dismissIconClass = 'ux-icon ux-icon-close';
        this.hasNoBodyPadding = false;
        this.isFooterCustomAlignment = false;
        this.isCloseModalOnEscape = true;
        this.isShowCloseButton = true;
        this.isMessageBox = false;
        this.isHandleCloseOnDismiss = true;
        this.isHandleCloseOnAccept = true;
        this.isHandleCloseOnClose = true;
        this.isOverflowVisible = false;
        this.isDismissActionVisible = true;
        this.isAcceptActionVisible = true;
        this.onDismiss = new EventEmitter();
        this.onAccept = new EventEmitter();
        this.onClose = new EventEmitter();
        // modal states
        this.stateClasses = '';
    }
    /**
     * @return {?}
     */
    get isModalOpen() {
        if (this.uxService.isModalOpen(this.id)) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.isVisible) {
            this.uxService.openModal(this.id);
        }
        // setting modal states
        if (this.isSizeSmall) {
            this.stateClasses = 'ux-modal--small';
        }
        if (this.isSizeLarge) {
            this.stateClasses = 'ux-modal--large';
        }
        if (this.isSizeFullScreen) {
            this.stateClasses = 'ux-modal--full-screen';
        }
        if (!this.isAcceptActionVisible && !this.isDismissActionVisible) {
            this.isFooterVisible = false;
        }
        // this.openModalIdSubscription = this.uxService.openModalId.subscribe((modalId) => {
        //     if (modalId === this.id) {
        //         this.vcCloseButton.nativeElement.focus();
        //     }
        // });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.openModalIdSubscription) {
            this.openModalIdSubscription.unsubscribe();
        }
        if (this.uxService.isModalOpen(this.id)) {
            this.close({});
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    close(event) {
        if (this.isHandleCloseOnClose) {
            this.uxService.closeModal(this.id);
        }
        this.onClose.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeModalOnEscape(event) {
        if (this.isCloseModalOnEscape) {
            if (event.keyCode === 27) {
                // 27 = escape
                this.close(event);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onAcceptActionClick(event) {
        if (this.isHandleCloseOnAccept) {
            this.uxService.closeModal(this.id);
        }
        this.onAccept.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDismissActionClick(event) {
        if (this.isHandleCloseOnDismiss) {
            this.uxService.closeModal(this.id);
        }
        this.onDismiss.emit(event);
    }
}
UxModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-modal',
                template: `
        <div id="{{id}}" cdkTrapFocus class="modal fx ux-modal {{styleClass}} {{stateClasses}}" [class.show]="isModalOpen"
                                         tabindex="-1"
                                         role="dialog"
                                         [class.slideInDown]="!isMessageBox"
                                         [class.flipInY]="isMessageBox"
                                         [class.ux-modal--full-height]="isSizeFullHeight"
                                         [class.ux-modal--medium-height]="isSizeMediumHeight"
                                         [attr.aria-hidden]="!isModalOpen"
                                         [style.display]="isModalOpen ? 'block' : 'none'"
                                         (keydown)="closeModalOnEscape($event)" tabIndex="-1">
            <div class="modal-dialog ux-modal__dialog" role="document" [style.max-width]="customWidth">
              <div class="modal-content ux-modal__content" [class.ux-u-overflow-visible]="isOverflowVisible">
                <div class="modal-header ux-modal__header">
                  <ng-template [ngIf]="customHeaderContent">
                      <ng-content select="uxModalHeader"></ng-content>
                  </ng-template>
                  <ng-template [ngIf]="!customHeaderContent">
                      <h5 class="modal-title ux-modal__header-title">{{titleLabel}}</h5>
                  </ng-template>
                  <button #closeButton type="button" id="{{id}}-close-button"
                          class="ux-modal__header-close close"
                          data-dismiss="modal" aria-label="Close"
                          (click)="close($event)" [class.ux-u-opacity-0]="!isShowCloseButton">
                    <span>&times;</span>
                  </button>
                </div>
                <div class="modal-body ux-modal__body {{bodyStyleClass}}"
                     [class.p-0]="hasNoBodyPadding" [class.ux-u-overflow-visible]="isOverflowVisible">
                  <ng-content select="uxModalBody"></ng-content>
                </div>
                <div *ngIf="isFooterVisible"
                        class="modal-footer ux-modal__footer {{footerStyleClass}}"
                        [class.ux-modal__footer--custom-alignment]="isFooterCustomAlignment">
                  <ng-template [ngIf]="customFooterContent">
                      <ng-content select="uxModalFooter"></ng-content>
                  </ng-template>
                  <ng-template [ngIf]="!customFooterContent">
                      <button type="button"
                              class="btn btn-secondary" *ngIf="isDismissActionVisible"
                              [disabled]="dismissActionDisabled" (click)="onDismissActionClick($event)" >
                        <i *ngIf="isShowActionIcons" class="{{dismissIconClass}}"></i>
                        {{dismissActionLabel}}
                      </button>
                      <button type="button"
                              class="btn btn-primary" *ngIf="isAcceptActionVisible"
                              [disabled]="acceptActionDisabled" (click)="onAcceptActionClick($event)">
                        <i *ngIf="isShowActionIcons" class="{{acceptIconClass}}"></i>
                        {{acceptActionLabel}}
                      </button>
                  </ng-template>
                </div>
              </div>
            </div>
        </div>
        <div class="modal-backdrop" [class.show]="isModalOpen"
                                    [ngClass]="{fade: isModalOpen, in: isModalOpen}"
                                    [style.display]="isModalOpen ? 'block' : 'none'" (focus)="close($event)"></div>
        `
            },] },
];
/** @nocollapse */
UxModalComponent.ctorParameters = () => [
    { type: UxService, },
];
UxModalComponent.propDecorators = {
    "id": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "titleLabel": [{ type: Input },],
    "dismissActionLabel": [{ type: Input },],
    "dismissActionDisabled": [{ type: Input },],
    "acceptActionLabel": [{ type: Input },],
    "acceptActionDisabled": [{ type: Input },],
    "isFooterVisible": [{ type: Input },],
    "isVisible": [{ type: Input },],
    "isKeepBodyScroll": [{ type: Input },],
    "isSizeSmall": [{ type: Input },],
    "isSizeLarge": [{ type: Input },],
    "isSizeFullScreen": [{ type: Input },],
    "isSizeFullHeight": [{ type: Input },],
    "isSizeMediumHeight": [{ type: Input },],
    "isShowActionIcons": [{ type: Input },],
    "acceptIconClass": [{ type: Input },],
    "dismissIconClass": [{ type: Input },],
    "hasNoBodyPadding": [{ type: Input },],
    "customWidth": [{ type: Input },],
    "isFooterCustomAlignment": [{ type: Input },],
    "isCloseModalOnEscape": [{ type: Input },],
    "isShowCloseButton": [{ type: Input },],
    "isMessageBox": [{ type: Input },],
    "isHandleCloseOnDismiss": [{ type: Input },],
    "isHandleCloseOnAccept": [{ type: Input },],
    "isHandleCloseOnClose": [{ type: Input },],
    "bodyStyleClass": [{ type: Input },],
    "footerStyleClass": [{ type: Input },],
    "isOverflowVisible": [{ type: Input },],
    "isDismissActionVisible": [{ type: Input },],
    "isAcceptActionVisible": [{ type: Input },],
    "onDismiss": [{ type: Output },],
    "onAccept": [{ type: Output },],
    "onClose": [{ type: Output },],
    "vcCloseButton": [{ type: ViewChild, args: ['closeButton',] },],
    "customFooterContent": [{ type: ContentChild, args: [forwardRef(() => UxModalFooterTagDirective),] },],
    "customHeaderContent": [{ type: ContentChild, args: [forwardRef(() => UxModalHeaderTagDirective),] },],
};
class UxModalBodyTagDirective {
}
UxModalBodyTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxModalBody' },] },
];
class UxModalFooterTagDirective {
}
UxModalFooterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxModalFooter' },] },
];
class UxModalHeaderTagDirective {
}
UxModalHeaderTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxModalHeader' },] },
];
class UxModalComponentModule {
}
UxModalComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, A11yModule],
                exports: [UxModalComponent, UxModalBodyTagDirective, UxModalFooterTagDirective, UxModalHeaderTagDirective],
                declarations: [UxModalComponent, UxModalBodyTagDirective, UxModalFooterTagDirective, UxModalHeaderTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLanguageSelectorComponent {
    /**
     * @param {?} shadowDomRoot
     * @param {?} uxService
     * @param {?} storageService
     * @param {?} translateService
     */
    constructor(shadowDomRoot, uxService, storageService, translateService) {
        this.shadowDomRoot = shadowDomRoot;
        this.uxService = uxService;
        this.storageService = storageService;
        this.translateService = translateService;
        this.isShowLabel = true;
        this.languageChanged = new EventEmitter();
        this.modalId = 'ux-language-selector-modal';
        this.dropDownIsOpen = false;
    }
    /**
     * @return {?}
     */
    get isShowDropDown() {
        return this.languages.length > 1 && this.languages.length < 4;
    }
    /**
     * @return {?}
     */
    get isShowModal() {
        return this.languages.length >= 4;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.languageCodes != null) {
            let /** @type {?} */ codes = this.languageCodes.split(/[ ,]+/g);
            this.languages = UxEuLanguages.getLanguages(codes);
        }
        else {
            this.languages = UxEuLanguages.getLanguages();
        }
        if (this.additionalLanguages) {
            for (const /** @type {?} */ additionalLanguage of this.additionalLanguages) {
                this.languages.push(additionalLanguage);
            }
        }
        this.languageRows = this.prepareLanguageRows();
        this.selectedLanguage = this.selectedLanguage || {
            code: this.translateService.currentLang,
            label: this.getLanguageLabel(this.translateService.currentLang)
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes && (changes['languageCodes'] || changes['additionalLanguages'])) {
            this.ngOnInit();
        }
    }
    /**
     * @param {?} querySelector
     * @return {?}
     */
    shadowDomQuery(querySelector) {
        return this.shadowDomRoot.nativeElement.querySelector(querySelector);
    }
    /**
     * @return {?}
     */
    prepareLanguageRows() {
        let /** @type {?} */ rows = [];
        let /** @type {?} */ row = [];
        for (let /** @type {?} */ i = 0; i < this.languages.length; i++) {
            if (i % 4 === 0) {
                if (row.length > 0) {
                    rows.push(row);
                    row = [];
                }
            }
            row.push(this.languages[i]);
        }
        if (row.length > 0) {
            rows.push(row);
        }
        return rows;
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    selectLanguage(languageCode) {
        if (this.selectedLanguage != null && this.selectedLanguage.code !== languageCode) {
            for (const /** @type {?} */ language of this.languages) {
                if (language.code === languageCode) {
                    this.selectedLanguage = language;
                    break;
                }
            }
            // Save the Language preference to local storage...
            let /** @type {?} */ state = this.storageService.get('state');
            if (!state) {
                state = { user: { preferences: {} } };
            }
            state.user.preferences.lang = this.selectedLanguage.code;
            this.storageService.set('state', state);
            this.languageChanged.emit(this.selectedLanguage);
        }
        this.close();
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    getLanguageLabel(languageCode) {
        for (const /** @type {?} */ language of this.languages) {
            if (language.code === languageCode) {
                return language.label;
            }
        }
        return;
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    toggleOutside(evt) {
        if (!this.shadowDomRoot.nativeElement.contains(evt.target)) {
            this.dropDownIsOpen = false;
        }
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    openKeyDown(keyCode) {
        if (keyCode === 13) {
            this.open();
        }
    }
    /**
     * @return {?}
     */
    open() {
        this.uxService.openModal(this.modalId);
        setTimeout(() => {
            this.shadowDomQuery('.btn-primary').focus();
        }, 0);
    }
    /**
     * @return {?}
     */
    close() {
        this.uxService.closeModal(this.modalId);
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    closeModalOnEscape(keyCode) {
        if (keyCode === 27) {
            // 27 = escape
            this.close();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    consumeEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        event.cancelBubble = true;
        return false;
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    toggleDropDownKeyDown(keyCode) {
        if (keyCode === 13) {
            this.toggleDropDown();
        }
    }
    /**
     * @return {?}
     */
    toggleDropDown() {
        this.dropDownIsOpen = !this.dropDownIsOpen;
        if (this.dropDownIsOpen) {
            let /** @type {?} */ selectedItem = this.shadowDomQuery('.dropdown-item[data-language-code=' + this.selectedLanguage.code + ']');
            if (selectedItem != null) {
                setTimeout(() => {
                    selectedItem.focus();
                }, 100);
            }
        }
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    selectDropdownLanguage(languageCode) {
        this.selectLanguage(languageCode);
        this.dropDownIsOpen = false;
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    closeDropDownOnEscape(keyCode) {
        if (keyCode === 27) {
            // 27 = escape
            this.dropDownIsOpen = false;
        }
    }
    /**
     * @return {?}
     */
    closeOnBlur() {
        setTimeout(() => {
            if (this.shadowDomQuery('.dropdown-item:focus') == null) {
                this.dropDownIsOpen = false;
            }
        }, 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateDropDownSelection(event) {
        let /** @type {?} */ keyCode = event.keyCode;
        /*
                 38 = arrow up
                 40 = arrow down
                 */
        let /** @type {?} */ focusedItem = this.shadowDomQuery('.dropdown-item:focus');
        if (focusedItem != null) {
            let /** @type {?} */ next;
            if (keyCode === 40) {
                // arrow down:
                next = (/** @type {?} */ (focusedItem)).nextElementSibling;
                if (!next) {
                    next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).firstElementChild;
                }
            }
            else if (keyCode === 38) {
                // arrow up:
                next = (/** @type {?} */ (focusedItem)).previousElementSibling;
                if (!next) {
                    next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).lastElementChild;
                }
            }
            if (next) {
                (/** @type {?} */ (next)).focus();
                this.consumeEvent(event);
            }
        }
    }
}
UxLanguageSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-language-selector',
                template: "<div class=\"ecl-typography ux-language-selector\"> <ng-container *ngIf=\"isShowDropDown\"> <div class=\"btn-group\"> <a class=\"ecl-lang-select-sites__link\" tabindex=\"1\" aria-haspopup=\"true\" (click)=\"toggleDropDown()\" (keydown)=\"toggleDropDownKeyDown($event.keyCode)\"> <span class=\"ecl-lang-select-sites__label\" *ngIf=\"isShowLabel\">{{selectedLanguage.label}}</span> <span class=\"ecl-lang-select-sites__code\"> <span class=\"ecl-icon ecl-icon--language ecl-lang-select-sites__icon\"></span> <span class=\"ecl-lang-select-sites__code-text\">{{selectedLanguage.code | uppercase}}</span> </span> </a> <div class=\"dropdown-menu\" [style.display]=\"dropDownIsOpen ? 'block' : 'none'\" style=\"left: initial;right: 0;\" (keydown)=\"closeDropDownOnEscape($event.keyCode)\"> <a *ngFor=\"let language of languages\" href=\"javascript:void(0);\" class=\"dropdown-item\" [attr.data-language-code]=\"language.code\" (click)=\"selectDropdownLanguage(language.code)\" (blur)=\"closeOnBlur()\" (keydown)=\"navigateDropDownSelection($event)\" > <label>{{language.label}} ({{language.code}})</label> </a> </div> </div> </ng-container> <ng-container *ngIf=\"isShowModal\"> <a class=\"ecl-lang-select-sites__link\" tabindex=\"1\" (click)=\"open()\" (keydown)=\"openKeyDown($event.keyCode)\"> <span class=\"ecl-lang-select-sites__label\" *ngIf=\"isShowLabel\">{{selectedLanguage.label}}</span> <span class=\"ecl-lang-select-sites__code\"> <span class=\"ecl-icon ecl-icon--language ecl-lang-select-sites__icon\"></span> <span class=\"ecl-lang-select-sites__code-text\">{{selectedLanguage.code | uppercase}}</span> </span> </a> <ux-modal id=\"{{modalId}}\" titleLabel=\"Select language\" [isFooterVisible]=\"false\" styleClass=\"ux-language-selector-modal\"> <uxModalBody> <div *ngFor=\"let row of languageRows\" class=\"row mt-2\"> <div *ngFor=\"let language of row\" class=\"col-md-3 col-sm-6\"> <button class=\"btn btn-block\" [class.btn-secondary]=\"language.code != selectedLanguage.code\" [class.btn-primary]=\"language.code == selectedLanguage.code\" (click)=\"selectLanguage(language.code)\"> <label>{{language.label}} ({{language.code}})</label> </button> </div> </div> </uxModalBody> </ux-modal> </ng-container> </div> "
            },] },
];
/** @nocollapse */
UxLanguageSelectorComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: UxService, },
    { type: StorageService, },
    { type: TranslateService, },
];
UxLanguageSelectorComponent.propDecorators = {
    "languageCodes": [{ type: Input },],
    "additionalLanguages": [{ type: Input },],
    "selectedLanguage": [{ type: Input },],
    "isShowLabel": [{ type: Input },],
    "languageChanged": [{ type: Output },],
    "toggleOutside": [{ type: HostListener, args: ['body:click', ['$event'],] },],
};
class UxLanguageSelectorComponentModule {
}
UxLanguageSelectorComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxModalComponentModule],
                exports: [UxLanguageSelectorComponent],
                declarations: [UxLanguageSelectorComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTagComponent {
    constructor() {
        this.isRounded = false;
        this.isSmall = false;
        this.tabindex = '0';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.stateClasses = '';
        if (!this.subLabel && this.isRounded) {
            this.stateClasses += 'ux-a-tag--rounded ';
        }
        if (this.isSmall) {
            this.stateClasses += 'ux-a-tag--small';
        }
    }
}
UxTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-tag',
                template: "<div *ngIf=\"label\" class=\"ux-a-tag {{stateClasses}} {{styleClass}}\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}}\"> <span class=\"ux-a-tag__label ux-u-bg-color-{{typeClass}}\"> {{label}} </span> <span *ngIf=\"subLabel\" class=\"ux-a-tag__sub-label ux-u-bg-color-{{typeClass}}-dark\"> {{subLabel}} </span> </div> ",
                styles: [":host{flex:0 1 auto !important}.ux-a-tag{color:white;display:flex;max-width:100% !important;padding:0;width:100%}.ux-a-tag__label{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#9e9e9e;padding:.66rem 1.25rem}.ux-a-tag__sub-label{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#757575;padding:.66rem 1.25rem}.ux-a-tag--small .ux-a-tag__label{padding:.33rem .66rem}.ux-a-tag--small .ux-a-tag__sub-label{padding:.33rem .66rem}.ux-a-tag--large .ux-a-tag__label{padding:1.25rem 1rem}.ux-a-tag--large .ux-a-tag__sub-label{padding:1.25rem 1rem}.ux-a-tag--rounded .ux-a-tag__label{border-radius:10rem} /*# sourceMappingURL=ux-a-tag.component.css.map */"],
            },] },
];
/** @nocollapse */
UxTagComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "isRounded": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "tabindex": [{ type: Input },],
};
class UxTagComponentModule {
}
UxTagComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTagComponent],
                declarations: [UxTagComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxIconComponent {
    constructor() {
        this.isRounded = true;
        this.isTiny = false;
        this.isSmall = false;
        this.isLarge = false;
        this.isHoverable = false;
        this.tagTypeClass = 'danger';
        this.tagSizeClass = 'tiny';
        this.isShowTag = true;
        this.isEmptyTag = false;
        this.tabindexValue = -1;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.iconStateClasses = '';
        if (this.iconClass) {
            if (this.isRounded) {
                if (this.isLarge) {
                    this.iconStateClasses += 'ux-a-icon--rounded-large ';
                }
                else if (this.isSmall) {
                    this.iconStateClasses += 'ux-a-icon--rounded-small ';
                }
                else if (this.isTiny) {
                    this.iconStateClasses += 'ux-a-icon--rounded-tiny ';
                }
                else {
                    this.iconStateClasses += 'ux-a-icon--rounded ';
                }
            }
            else {
                if (this.isTiny) {
                    this.iconStateClasses += 'ux-a-icon--tiny ';
                }
                if (this.isSmall) {
                    this.iconStateClasses += 'ux-a-icon--small ';
                }
                if (this.isLarge) {
                    this.iconStateClasses += 'ux-a-icon--large ';
                }
                if (this.isHoverable) {
                    this.iconStateClasses += 'ux-a-icon--hoverable';
                    this.tabindexValue = 0;
                }
            }
            if (this.typeClass) {
                this.iconStateClasses += 'ux-a-icon--' + this.typeClass;
            }
        }
    }
}
UxIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-icon',
                template: "<div *ngIf=\"iconClass\" class=\"ux-a-icon {{iconStateClasses}} {{styleClass}} ux-u-color-{{typeClass}}\" tabindex=\"{{tabindexValue}}\"> <span class=\"ux-icon-fw {{iconClass}} ux-a-icon__icon\"> <span *ngIf=\"(tagLabel || isEmptyTag) && isShowTag\" class=\"ux-a-icon__tag badge badge--{{tagSizeClass}} badge-pill badge-{{tagTypeClass}}\" [class.ux-a-icon__tag--empty]=\"isEmptyTag\"> <span *ngIf=\"!isEmptyTag\">{{tagLabel}}</span> </span> </span> </div> ",
                styles: [".ux-a-icon{position:relative;text-align:center}.ux-a-icon__icon{font-size:1.42857rem;position:relative}.ux-a-icon__tag{min-width:20px;position:absolute;right:-9px;top:-9px;z-index:1;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-icon__tag--empty{min-height:10px;min-width:10px;right:-4px;top:-4px}.ux-a-icon__label-wrapper{color:#333;margin-top:1.25rem}.ux-a-icon--hoverable{color:#757575}.ux-a-icon--hoverable:hover,.ux-a-icon--hoverable:focus{color:#004494;cursor:pointer}.ux-a-icon--hoverable .ux-a-icon__icon{padding:.33rem}.ux-a-icon--hoverable:focus .ux-a-icon__icon{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-a-icon--tiny .ux-a-icon__icon{font-size:.85714rem}.ux-a-icon--small .ux-a-icon__icon{font-size:1rem}.ux-a-icon--large .ux-a-icon__icon{font-size:2rem}.ux-a-icon--rounded{padding-top:0.5rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#757575}.ux-a-icon--rounded .ux-a-icon__icon{margin-top:0.25rem}.ux-a-icon--rounded-large{padding-top:0.75rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#757575}.ux-a-icon--rounded-small{padding-top:0.25rem;border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#757575}.ux-a-icon--rounded-large .ux-a-icon__icon{font-size:2rem;margin:0.3rem}.ux-a-icon--rounded.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#e0e9f2}.ux-a-icon--rounded.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#b3d4e9}.ux-a-icon--rounded.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#c8d7c4}.ux-a-icon--rounded.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#f9ca93}.ux-a-icon--rounded.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:3rem;width:3rem;background-color:#f4bcc1}.ux-a-icon--rounded-large.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#e0e9f2}.ux-a-icon--rounded-large.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#b3d4e9}.ux-a-icon--rounded-large.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#c8d7c4}.ux-a-icon--rounded-large.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#f9ca93}.ux-a-icon--rounded-large.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:4rem;width:4rem;background-color:#f4bcc1}.ux-a-icon--rounded-small.ux-a-icon--primary{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#e0e9f2}.ux-a-icon--rounded-small.ux-a-icon--info{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#b3d4e9}.ux-a-icon--rounded-small.ux-a-icon--success{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#c8d7c4}.ux-a-icon--rounded-small.ux-a-icon--warning{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#f9ca93}.ux-a-icon--rounded-small.ux-a-icon--danger{border-radius:100%;color:white;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);height:2rem;width:2rem;background-color:#f4bcc1}.ux-a-icon-toggle{cursor:pointer}.ux-a-icon-toggle:focus{outline:2px solid #ffd617;outline-offset:0;-moz-outline-radius:4px;position:relative;z-index:2} /*# sourceMappingURL=ux-a-icon.component.css.map */"],
            },] },
];
/** @nocollapse */
UxIconComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isRounded": [{ type: Input },],
    "isTiny": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isHoverable": [{ type: Input },],
    "tagLabel": [{ type: Input },],
    "tagTypeClass": [{ type: Input },],
    "tagSizeClass": [{ type: Input },],
    "isShowTag": [{ type: Input },],
    "isEmptyTag": [{ type: Input },],
};
class UxIconComponentModule {
}
UxIconComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxIconComponent],
                declarations: [UxIconComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMarkerComponent {
}
UxMarkerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-marker',
                template: "<div class=\"ux-a-marker {{styleClass}}\"> <span class=\"ux-icon ux-icon-circle ux-a-marker__icon ux-u-color-{{typeClass}}\"></span> </div> ",
                styles: [".ux-a-marker__icon{color:#757575;font-size:14px}.ux-a-marker--small{padding:.33rem}.ux-a-marker--large{padding:1.25rem} /*# sourceMappingURL=ux-a-marker.component.css.map */"],
            },] },
];
/** @nocollapse */
UxMarkerComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
};
class UxMarkerComponentModule {
}
UxMarkerComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxMarkerComponent],
                declarations: [UxMarkerComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBadgeComponent {
    constructor() {
        this.typeClass = 'default';
        this.isSmall = false;
        this.isLarge = false;
        this.isTiny = false;
        this.isPill = false;
        this.isOutline = false;
    }
}
UxBadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-badge',
                template: "<span class=\"badge ux-c-badge badge-{{typeClass}} ux-c-badge--{{typeClass}} {{styleClass}}\" [class.ux-c-badge--outline]=\"isOutline\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\" [class.badge--tiny]=\"isTiny\"> <ng-content></ng-content> </span> ",
            },] },
];
/** @nocollapse */
UxBadgeComponent.ctorParameters = () => [];
UxBadgeComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isTiny": [{ type: Input },],
    "isPill": [{ type: Input },],
    "isOutline": [{ type: Input },],
};
class UxBadgeComponentModule {
}
UxBadgeComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxBadgeComponent],
                declarations: [UxBadgeComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLabelComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.isIconRounded = false;
        this.isIconSmall = false;
        this.isIconTiny = false;
        this.isIconLarge = false;
        this.hasMarker = false;
        this.isClickable = false;
        this.badgeTypeClass = 'primary';
        this.isDisabled = false;
        this.isBoldLabel = false;
        this.isSmall = false;
        this.isLarge = false;
        this.isRenderHTML = false;
        this.tabindex = '0';
        this.labelClicked = new EventEmitter();
        this.stateClasses = '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.subLabel && !this.customSubLabel && !this.isBoldLabel) {
            this.stateClasses += 'ux-a-label--has-no-sub-label ';
        }
        if (this.isLarge) {
            this.stateClasses += 'ux-a-label--large';
        }
        if (this.isSmall) {
            this.stateClasses += 'ux-a-label--small';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ subLabelChange = changes && changes['subLabel'];
        if (subLabelChange) {
            const /** @type {?} */ subLabel = subLabelChange.currentValue;
            if (this.subLabelSizeLimit) {
                if (subLabel && subLabel.length > this.subLabelSizeLimit) {
                    this.subLabel = subLabel.substr(0, this.subLabelSizeLimit) + '...';
                }
                else {
                    this.subLabel = subLabel;
                }
            }
            else {
                this.subLabel = subLabel;
            }
        }
    }
    /**
     * @return {?}
     */
    onLabelClicked() {
        this.labelClicked.emit();
    }
}
UxLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-label',
                template: "<div class=\"ux-a-label {{styleClass}} ux-a-label--t-{{themeClass}} {{stateClasses}}\" [class.ux-a-label--disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.role]=\"ariaRole\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{infos}}\" [attr.aria-expanded]=\"ariaExpanded\" [attr.aria-controls]=\"ariaControls\"> <ux-a-marker *ngIf=\"hasMarker\" typeClass=\"{{markerTypeClass}}\" styleClass=\"mr-2\"> </ux-a-marker> <ux-a-icon *ngIf=\"iconClass\" typeClass=\"{{iconTypeClass}}\" iconClass=\"{{iconClass}}\" [isRounded]=\"isIconRounded\" [isSmall]=\"isIconSmall\" [isTiny]=\"isIconTiny\" [isLarge]=\"isIconLarge\" styleClass=\"mr-2\"> </ux-a-icon> <div class=\"ux-a-label__content\"> <div *ngIf=\"!customLabel\" class=\"ux-a-label__label {{labelStyleClass}}\" role=\"presentation\"> <ng-template [ngIf]=\"isClickable\"> <a class=\"ux-a-label__label--clickable\" [tabindex]=\"tabindex\" (click)=\"onLabelClicked()\"> {{label}} </a> </ng-template> <ng-template [ngIf]=\"!isClickable\"> <span *ngIf=\"isRenderHTML\" [innerHTML]=\"label\"></span> <span *ngIf=\"!isRenderHTML\"> {{label}} </span> </ng-template> </div> <div *ngIf=\"customLabel\" class=\"ux-a-label__custom-label\" role=\"presentation\"> <ng-content select=\"uxLabelContent\"></ng-content> </div> <ng-template [ngIf]=\"!customSubLabel\"> <div *ngIf=\"subLabel\" class=\"ux-a-label__sub-label\"> <span *ngIf=\"isRenderHTML\" [innerHTML]=\"subLabel\"></span> <span *ngIf=\"!isRenderHTML\"> {{subLabel}} </span> </div> </ng-template> <ng-template [ngIf]=\"customSubLabel\"> <div class=\"ux-a-label__sub-label\"> <ng-content select=\"uxLabelSubLabel\"></ng-content> </div> </ng-template> </div> <ux-badge *ngIf=\"badgeLabel\" typeClass=\"{{badgeTypeClass}}\" styleClass=\"ml-2\" [isSmall]=\"isSmall\" [isPill]=\"true\"> {{badgeLabel}} </ux-badge> <span *ngIf=\"infos\" class=\"ux-a-label__label-infos\"> {{infos}} </span> </div> ",
                styles: [":host{-ms-flex:0 1 100%;flex:0 1 auto}ux-a-label{flex:0 1 100% !important}.ux-a-label{align-items:center;display:flex}.ux-a-label__label{color:#616161;font-size:1.14286rem;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label__label--clickable:hover{color:#004494;text-decoration:underline}.ux-a-label__custom-label{color:#616161;font-size:1.14286rem;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label__label-infos{margin-left:.66rem}.ux-a-label__sub-label{color:#757575;margin-top:.33rem}.ux-a-label--disabled .ux-a-label__icon,.ux-a-label--disabled .ux-a-label__label,.ux-a-label--disabled .ux-a-label__sub-label{color:#bdbdbd !important}.ux-a-label--large{padding:.66rem}.ux-a-label--small .ux-a-label__label{font-size:1rem}.ux-a-label--small .ux-a-label__sub-label{font-size:.85714rem}.ux-a-label--small .ux-a-icon{margin-right:0.325rem !important}.ux-a-label--has-no-sub-label .ux-a-label__label{font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-label--t-white .ux-a-label__label,.ux-a-label--t-white .ux-a-label__sub-label{color:white} /*# sourceMappingURL=ux-a-label.component.css.map */"],
            },] },
];
/** @nocollapse */
UxLabelComponent.ctorParameters = () => [
    { type: UxService, },
];
UxLabelComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "labelStyleClass": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "isIconRounded": [{ type: Input },],
    "isIconSmall": [{ type: Input },],
    "isIconTiny": [{ type: Input },],
    "isIconLarge": [{ type: Input },],
    "hasMarker": [{ type: Input },],
    "markerTypeClass": [{ type: Input },],
    "isClickable": [{ type: Input },],
    "badgeLabel": [{ type: Input },],
    "badgeTypeClass": [{ type: Input },],
    "infos": [{ type: Input },],
    "themeClass": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "isBoldLabel": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "subLabelSizeLimit": [{ type: Input },],
    "isRenderHTML": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "ariaRole": [{ type: Input },],
    "ariaExpanded": [{ type: Input },],
    "ariaControls": [{ type: Input },],
    "labelClicked": [{ type: Output },],
    "customLabel": [{ type: ContentChild, args: [forwardRef(() => UxLabelContentTagDirective),] },],
    "customSubLabel": [{ type: ContentChild, args: [forwardRef(() => UxLabelSubLabelTagDirective),] },],
};
class UxLabelContentTagDirective {
}
UxLabelContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLabelContent' },] },
];
class UxLabelSubLabelTagDirective {
}
UxLabelSubLabelTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLabelSubLabel' },] },
];
class UxLabelComponentModule {
}
UxLabelComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxBadgeComponentModule, UxMarkerComponentModule, UxIconComponentModule],
                exports: [UxLabelComponent, UxLabelContentTagDirective, UxLabelSubLabelTagDirective],
                declarations: [UxLabelComponent, UxLabelContentTagDirective, UxLabelSubLabelTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxItemConfig {
    constructor() {
        this.hasBorder = true;
    }
}
UxItemConfig.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxItemComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.isIconRounded = false;
        this.hasMarker = false;
        this.isTagRounded = false;
        this.isLarge = false;
        this.isSmall = false;
        this.hasBorder = true;
        this.isExpanded = true;
        this.isLeftPositioned = false;
        this.isDisabled = false;
        this.isActive = false;
        this.isHoverable = true;
        this.isScreenReaderClickable = false;
        this.listItemClick = new EventEmitter();
        this.isHovered = false;
        Object.assign(this, config);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.item) {
            this.id = this.item.id;
            this.label = this.item.label;
            this.subLabel = this.item.subLabel;
            this.iconClass = this.item.iconClass;
            this.iconTypeClass = this.item.iconTypeClass;
            this.typeClass = this.item.typeClass;
            this.isDisabled = this.item.disabled;
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        this.listItemClick.next(this.item);
    }
    /**
     * @return {?}
     */
    onMouseenter() {
        this.isHovered = true;
    }
    /**
     * @return {?}
     */
    onMouseleave() {
        this.isHovered = false;
    }
}
UxItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-item',
                template: '<div></div>'
            },] },
];
/** @nocollapse */
UxItemComponent.ctorParameters = () => [
    { type: UxItemConfig, },
];
UxItemComponent.propDecorators = {
    "item": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "isIconRounded": [{ type: Input },],
    "hasMarker": [{ type: Input },],
    "markerTypeClass": [{ type: Input },],
    "tagTypeClass": [{ type: Input },],
    "tagLabel": [{ type: Input },],
    "tagCount": [{ type: Input },],
    "isTagRounded": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "hasBorder": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "isLeftPositioned": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "isActive": [{ type: Input },],
    "isHoverable": [{ type: Input },],
    "isScreenReaderClickable": [{ type: Input },],
    "listItemClick": [{ type: Output },],
};
class UxItemComponentModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: UxItemComponentModule, providers: [UxItemConfig] }; }
}
UxItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxTagComponentModule,
                    UxIconComponentModule,
                    UxMarkerComponentModule,
                    UxLabelComponentModule
                ],
                exports: [
                    UxItemComponent,
                    UxTagComponentModule,
                    UxIconComponentModule,
                    UxMarkerComponentModule,
                    UxLabelComponentModule
                ],
                declarations: [UxItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxListItemConfig extends UxItemConfig {
    constructor() {
        super(...arguments);
        this.hasBorder = true;
    }
}
UxListItemConfig.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxListItemComponent extends UxItemComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        super(config);
    }
}
UxListItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-list-item',
                template: "<div class=\"ux-list-item-wrapper\" [class.ux-list-item-wrapper--hovered]=\"isHovered && !isExpanded\" [attr.role]=\"! isScreenReaderClickable ? 'presentation' : ''\" (click)=\"onClick()\" (mouseenter)=\"onMouseenter()\" (mouseleave)=\"onMouseleave()\"> <div *ngIf=\"isHovered && !isExpanded\" class=\"ux-list-item-hover-content\" [class.ux-list-item-hover-content--left-positioned]=\"isLeftPositioned\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" tabindex=\"-1\"></ux-a-label> </div> <div class=\"ux-list-item ux-list-item--{{typeClass}} {{styleClass}}\" [class.ux-list-item--small]=\"isSmall\" [class.ux-list-item--large]=\"isLarge\" [class.ux-list-item--hovered]=\"isHovered && !isExpanded\" [class.ux-list-item--not-hoverable]=\"!isHoverable\" [class.ux-list-item--bordered]=\"hasBorder\" [class.ux-list-item--collapsed]=\"!isExpanded\" [class.ux-list-item--active]=\"isActive\" [class.ux-list-item--seperator]=\"!label && !subLabel && !customContent\" [class.ux-list-item--disabled]=\"isDisabled\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxListItemContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isDisabled]=\"isDisabled\" tabindex=\"-1\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-list-item__right-content\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\" [isRounded]=\"isTagRounded\" tabindex=\"-1\"> </ux-a-tag> </div> </ng-template> </div> </div> "
            },] },
];
/** @nocollapse */
UxListItemComponent.ctorParameters = () => [
    { type: UxListItemConfig, },
];
UxListItemComponent.propDecorators = {
    "customContent": [{ type: ContentChild, args: [forwardRef(() => UxListtemContentTagDirective),] },],
    "customSubLabel": [{ type: ContentChild, args: [forwardRef(() => UxListItemSubLabelTagDirective),] },],
};
class UxListItemSubLabelTagDirective {
}
UxListItemSubLabelTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxListItemSubLabel' },] },
];
class UxListtemContentTagDirective {
}
UxListtemContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxListItemContent' },] },
];
class UxListItemComponentModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: UxItemComponentModule, providers: [UxListItemConfig] }; }
}
UxListItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxItemComponentModule],
                exports: [UxListItemComponent, UxListItemSubLabelTagDirective, UxListtemContentTagDirective],
                declarations: [
                    UxListItemComponent,
                    UxListItemSubLabelTagDirective,
                    UxListtemContentTagDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDropdownButtonItemComponent {
    /**
     * @param {?} uxDropdownButtonComponent
     */
    constructor(uxDropdownButtonComponent) {
        this.isDisabled = false;
        this.isActive = false;
        this.uxDropdownButtonComponent = uxDropdownButtonComponent;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        this.uxDropdownButtonComponent.navigateDropDownSelection(event);
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.uxDropdownButtonComponent.closeOnBlur();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.uxDropdownButtonComponent) {
            this.uxDropdownButtonComponent.closeOnBlur();
        }
    }
}
UxDropdownButtonItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dropdown-button-item',
                template: `
    <ux-list-item id="{{id}}"
                  [isActive]="isActive"
                  (blur)="onBlur()"
                  (keydown)="onKeydown($event)"
                  iconClass="{{iconClass}}"
                  label="{{label}}"
                  [isDisabled]="isDisabled"
                  styleClass="ux-dropdown-button-item {{stateClass}}"
                  (click)="onClick()">
    </ux-list-item>
    `
            },] },
];
/** @nocollapse */
UxDropdownButtonItemComponent.ctorParameters = () => [
    { type: UxDropdownButtonComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [forwardRef(() => UxDropdownButtonComponent),] },] },
];
UxDropdownButtonItemComponent.propDecorators = {
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "isActive": [{ type: Input },],
};
class UxDropdownButtonItemComponentModule {
}
UxDropdownButtonItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxListItemComponentModule],
                exports: [UxDropdownButtonItemComponent],
                declarations: [UxDropdownButtonItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ UX_DROPDOWNBUTTON_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UxDropdownButtonComponent),
    multi: true,
};
class UxDropdownButtonComponent {
    /**
     * @param {?} uxService
     * @param {?} shadowDomRoot
     */
    constructor(uxService, shadowDomRoot) {
        this.uxService = uxService;
        this.shadowDomRoot = shadowDomRoot;
        this.links = [];
        this.typeClass = 'secondary';
        this.isSplitButtonToggle = false;
        this.isDropDownRightAligned = false;
        this.isLinkToggle = false;
        this.isUpdateLabelFromSelectedItem = false;
        this.isOutline = false;
        this.isShowDropdownToggle = true;
        this.hasItems = false;
        this.isDisabled = false;
        this.width = '10rem';
        this.dropdownMaxHeight = '200px';
        this.isSmall = false;
        this.isLarge = false;
        this.linkSelected = new EventEmitter();
        this.isShown = true;
        this.dropDownIsOpen = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.label && !this.iconClass && !this.isSplitButtonToggle) {
            this.iconClass = 'ux-icon ux-icon-bars';
        }
        if (this.isSmall) {
            this.btnSizeClass = 'btn-sm';
        }
        if (this.isLarge) {
            this.btnSizeClass = 'btn-lg';
        }
    }
    /**
     * @return {?}
     */
    get toggleClass() {
        if (this.isLinkToggle) {
            return 'ux-dropdown-button__toggle--link-toggle';
        }
        else {
            if (this.label || this.isSplitButtonToggle) {
                if (!this.isSplitButtonToggle) {
                    if (this.isOutline) {
                        return 'btn btn-outline-' + this.typeClass;
                    }
                    else {
                        return 'btn btn-' + this.typeClass;
                    }
                }
                else {
                    if (this.isOutline) {
                        return 'btn btn-outline-' + this.typeClass + ' ux-dropdown-button__toggle--split-toggle-outline';
                    }
                    else {
                        return 'btn btn-' + this.typeClass + ' ux-dropdown-button__toggle--split-toggle';
                    }
                }
            }
            else if (this.iconClass && !this.label && !this.isSplitButtonToggle) {
                return 'ux-dropdown-button__toggle--icon-toggle';
            }
        }
        return '';
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    toggleOutside(evt) {
        if (!this.shadowDomRoot.nativeElement.contains(evt.target)) {
            this.dropDownIsOpen = false;
        }
    }
    /**
     * @param {?} querySelector
     * @return {?}
     */
    shadowDomQuery(querySelector) {
        return this.shadowDomRoot.nativeElement.querySelector(querySelector);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleDropDownKeyDown(event) {
        if (event.keyCode === 13) {
            this.toggleDropDown(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleDropDown(event) {
        this.dropDownIsOpen = !this.dropDownIsOpen;
        let /** @type {?} */ selectedItem;
        if (this.dropDownIsOpen) {
            if (this.activeLink) {
                selectedItem = this.shadowDomQuery('.dropdown-item[data-link-id=' + this.activeLink.id + ']');
            }
            else {
                selectedItem = this.shadowDomQuery('.dropdown-item');
            }
            if (selectedItem) {
                setTimeout(() => {
                    if (selectedItem != null) {
                        selectedItem.focus();
                    }
                }, 0);
            }
        }
    }
    /**
     * @param {?} event
     * @param {?} link
     * @return {?}
     */
    selectDropdownItemKeydown(event, link) {
        if (event.keyCode === 13) {
            this.selectDropdownItem(event, link);
        }
    }
    /**
     * @param {?} event
     * @param {?} link
     * @return {?}
     */
    selectDropdownItem(event, link) {
        this.uxService.consumeEvent(event);
        if (!link.disabled) {
            this.linkSelected.emit(link);
            if (link && link.command) {
                link.command();
            }
            if (this.isUpdateLabelFromSelectedItem && link) {
                this.label = link.label;
            }
            if (this.isUpdateLabelFromSelectedItem) {
                this.links.forEach((lnk) => {
                    lnk.active = false;
                });
                link.active = true;
            }
        }
        this.dropDownIsOpen = false;
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    closeDropDownOnEscape(keyCode) {
        if (keyCode === 27) {
            // 27 = escape
            this.dropDownIsOpen = false;
        }
    }
    /**
     * @return {?}
     */
    closeOnBlur() {
        setTimeout(() => {
            if (this.shadowDomQuery('.dropdown-item:focus') == null) {
                this.dropDownIsOpen = false;
            }
        }, 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateDropDownSelection(event) {
        let /** @type {?} */ keyCode = event.keyCode;
        /*
                 38 = arrow up
                 40 = arrow down
                 */
        let /** @type {?} */ focusedItem = this.shadowDomQuery('.dropdown-item:focus');
        if (focusedItem != null) {
            let /** @type {?} */ next;
            if (keyCode === 40) {
                // arrow down:
                next = (/** @type {?} */ (focusedItem)).nextElementSibling;
                if (!next) {
                    next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).firstElementChild;
                }
            }
            else if (keyCode === 38) {
                // arrow up:
                next = (/** @type {?} */ (focusedItem)).previousElementSibling;
                if (!next) {
                    next = (/** @type {?} */ ((/** @type {?} */ (focusedItem)).parentNode)).lastElementChild;
                }
            }
            if (next) {
                (/** @type {?} */ (next)).focus();
                this.uxService.consumeEvent(event);
            }
        }
    }
    /**
     * @param {?} links
     * @return {?}
     */
    writeValue(links) {
        this.links = links;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
    }
}
UxDropdownButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dropdown-button',
                template: `
    <div class="ux-dropdown-button {{styleClass}} {{btnSizeClass}}" [class.ux-o-disabled]="isDisabled">
        <div class="btn-group">
            <a class="ux-dropdown-button__toggle {{btnSizeClass}} {{toggleClass}}" tabindex="0"
                [class.dropdown-toggle]="isShowDropdownToggle"
                aria-haspopup="true" data-toggle="dropdown"
                [attr.aria-expanded]="!dropDownIsOpen"
                (click)="toggleDropDown($event)"
                (keydown)="toggleDropDownKeyDown($event)">
                <span *ngIf="iconClass" class="ux-dropdown-button__toggle-icon {{iconClass}}"></span>
                <span *ngIf="label" class="ux-dropdown-button__toggle-label ux-button__content"
                    [class.ux-dropdown-button__toggle-label--with-icon]="iconClass">
                    {{label}}
                </span>
            </a>
            <div class="ux-dropdown-button__menu dropdown-menu"
                [style.min-width]="width"
                [style.max-height]="dropdownMaxHeight"
                [style.display]="dropDownIsOpen ? 'block' : 'none'"
                [class.ux-dropdown-button__menu--right-aligned]="isDropDownRightAligned"
                [class.ux-dropdown-button__menu--link-toggle]="isLinkToggle"
                (keydown)="closeDropDownOnEscape($event.keyCode)"
                (click)="closeOnBlur()" *ngIf="(items && items.length > 0) || (links && links.length > 0) || hasItems">

                <ng-template [ngIf]="items.length === 0 && !hasItems">
                    <ux-dropdown-button-item *ngFor="let link of links"
                        id="{{link.id}}"
                        label="{{link.label}}"
                        iconClass="{{link.iconClass}}"
                        [isDisabled]="link.disabled"
                        [isActive]="link.active"
                        (click)="selectDropdownItem($event, link)"
                        (keydown)="selectDropdownItemKeydown($event, link)"
                        (click)="closeOnBlur()">
                    </ux-dropdown-button-item>
                </ng-template>

                <ng-template [ngIf]="items.length !== 0 || hasItems">
                    <ng-content></ng-content>
                </ng-template>

            </div>
        </div>
    </div>
    `,
                providers: [UX_DROPDOWNBUTTON_VALUE_ACCESSOR],
            },] },
];
/** @nocollapse */
UxDropdownButtonComponent.ctorParameters = () => [
    { type: UxService, },
    { type: ElementRef, },
];
UxDropdownButtonComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "label": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "links": [{ type: Input },],
    "activeLink": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "isSplitButtonToggle": [{ type: Input },],
    "isDropDownRightAligned": [{ type: Input },],
    "isLinkToggle": [{ type: Input },],
    "isUpdateLabelFromSelectedItem": [{ type: Input },],
    "isOutline": [{ type: Input },],
    "isShowDropdownToggle": [{ type: Input },],
    "hasItems": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "width": [{ type: Input },],
    "dropdownMaxHeight": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "linkSelected": [{ type: Output },],
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxDropdownButtonItemComponent),] },],
    "toggleOutside": [{ type: HostListener, args: ['body:click', ['$event'],] },],
};
class UxDropdownButtonComponentModule {
}
UxDropdownButtonComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxDropdownButtonItemComponentModule],
                exports: [UxDropdownButtonComponent],
                declarations: [UxDropdownButtonComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutHeaderComponent {
    /**
     * @param {?} translateService
     * @param {?} cd
     */
    constructor(translateService, cd) {
        this.translateService = translateService;
        this.cd = cd;
        this.appFullName = '';
        this.appShortName = '';
        this.appSubtitle = '';
        this.envLabel = '';
        this.languageCodes = '';
        this.isCustomRightContent = false;
        this.isCustomTitleContent = false;
        this.isShowExtraButtonAction = false;
        this.isShowLanguageSelector = true;
        this.homeUrl = '/screen/home';
        this.isHideLogo = false;
        this.isHomeUrlActive = true;
        this.isErrorState = false;
        this.languageChanged = new EventEmitter();
        this.userProfileLinkSelected = new EventEmitter();
        translateService.onLangChange.subscribe(() => this.cd.detectChanges());
    }
    /**
     * @return {?}
     */
    get hasSubtitle() {
        return this.appSubtitle !== '';
    }
    /**
     * @return {?}
     */
    get activeLanguageCode() {
        return this.selectedLanguage && this.selectedLanguage.code || this.translateService.currentLang;
    }
    /**
     * @return {?}
     */
    get appShortNameGen() {
        if (this.appShortName === '') {
            return this.appFullName;
        }
        else {
            return this.appShortName;
        }
    }
    /**
     * @param {?} language
     * @return {?}
     */
    onLanguageChanged(language) {
        this.languageChanged.emit(language);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onUserProfileLinkSelected(uxLink) {
        this.userProfileLinkSelected.emit(uxLink);
    }
}
UxLayoutHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-header',
                template: "<div id=\"app-header\"> <ng-template [ngIf]=\"isHomeUrlActive\"> <a [routerLink]=\"homeUrl\" *ngIf=\"!isHideLogo\"> <div class=\"logo logo--{{activeLanguageCode}}\"> <div *ngIf=\"envLabel\" class=\"env\">{{envLabel}}</div> </div> </a> </ng-template> <ng-template [ngIf]=\"!isHomeUrlActive\"> <a href=\"javascript:void(0)\" *ngIf=\"!isHideLogo\"> <div class=\"logo logo--{{activeLanguageCode}}\"> <div *ngIf=\"envLabel\" class=\"env\">{{envLabel}}</div> </div> </a> </ng-template> <div *ngIf=\"isCustomTitleContent\" class=\"title\"> <ng-content select=\"uxLayoutHeaderTitleContent\"></ng-content> </div> <div *ngIf=\"!isCustomTitleContent\" class=\"title\"> <h1 [class.with-subtitle]=\"hasSubtitle\" [class.no-margin-left]=\"isHideLogo\" class=\"full\" [ngClass]=\"appFullNameStyleClass\">{{appFullName}}</h1> <h1 class=\"short\">{{appShortNameGen}}</h1> <h2 *ngIf=\"appSubtitle\"> {{appSubtitle}} </h2> </div> <div *ngIf=\"!isCustomRightContent && !isErrorState\" class=\"right-links\"> <div *ngIf=\"isShowLanguageSelector\" class=\"links\"> <ul> <li> <ux-language-selector *ngIf=\"languageCodes && !additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [languageCodes]=\"languageCodes\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes && !additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes && additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [additionalLanguages]=\"additionalLanguages\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"languageCodes && additionalLanguages\" (languageChanged)=\"onLanguageChanged($event)\" [languageCodes]=\"languageCodes\" [additionalLanguages]=\"additionalLanguages\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> </li> </ul> </div> <div class=\"user-infos\" *ngIf=\"userInfos\"> <ng-template [ngIf]=\"userProfileLinks\"> <ux-dropdown-button label=\"{{userInfos}}\" [iconClass]=\"userInfosIcon\" [isLinkToggle]=\"true\" [isDropDownRightAligned]=\"true\" [links]=\"userProfileLinks\" (linkSelected)=\"onUserProfileLinkSelected($event)\"> </ux-dropdown-button> </ng-template> <ng-template [ngIf]=\"!userProfileLinks\"> {{userInfos}} </ng-template> </div> </div> <div *ngIf=\"isCustomRightContent && !isErrorState\" class=\"right-content\"> <ng-content select=\"uxLayoutHeaderRightContent\"></ng-content> </div> </div> ",
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutHeaderComponent.ctorParameters = () => [
    { type: TranslateService, },
    { type: ChangeDetectorRef, },
];
UxLayoutHeaderComponent.propDecorators = {
    "appFullName": [{ type: Input },],
    "appFullNameStyleClass": [{ type: Input },],
    "appShortName": [{ type: Input },],
    "appSubtitle": [{ type: Input },],
    "envLabel": [{ type: Input },],
    "userInfos": [{ type: Input },],
    "userInfosIcon": [{ type: Input },],
    "languageCodes": [{ type: Input },],
    "additionalLanguages": [{ type: Input },],
    "isCustomRightContent": [{ type: Input },],
    "isCustomTitleContent": [{ type: Input },],
    "isShowExtraButtonAction": [{ type: Input },],
    "isShowLanguageSelector": [{ type: Input },],
    "homeUrl": [{ type: Input },],
    "isHideLogo": [{ type: Input },],
    "userProfileLinks": [{ type: Input },],
    "selectedLanguage": [{ type: Input },],
    "isHomeUrlActive": [{ type: Input },],
    "isErrorState": [{ type: Input },],
    "languageChanged": [{ type: Output },],
    "userProfileLinkSelected": [{ type: Output },],
};
class UxLayoutHeaderRightContentTagDirective {
}
UxLayoutHeaderRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderRightContent' },] },
];
class UxLayoutHeaderUserProfileLinksTagDirective {
}
UxLayoutHeaderUserProfileLinksTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderUserProfileLinks' },] },
];
class UxLayoutHeaderTitleContentTagDirective {
}
UxLayoutHeaderTitleContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderTitleContent' },] },
];
class UxLayoutHeaderComponentModule {
}
UxLayoutHeaderComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, UxLanguageSelectorComponentModule,
                    UxDropdownButtonComponentModule, UxDropdownButtonItemComponentModule],
                exports: [UxLayoutHeaderComponent, UxLayoutHeaderRightContentTagDirective, UxLayoutHeaderTitleContentTagDirective,
                    UxLayoutHeaderUserProfileLinksTagDirective],
                declarations: [UxLayoutHeaderComponent, UxLayoutHeaderRightContentTagDirective, UxLayoutHeaderTitleContentTagDirective,
                    UxLayoutHeaderUserProfileLinksTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutFooterComponent {
    constructor() {
        this.isStyleInverse = false;
        this.isCompact = false;
    }
}
UxLayoutFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-footer',
                template: `
        <ng-template [ngIf]="isCompact">
            <div id="app-footer" class="compact" [class.inverse]="isStyleInverse">
                <ng-content></ng-content>
            </div>
        </ng-template>

        <ng-template [ngIf]="!isCompact">
            <div id="app-footer" [class.inverse]="isStyleInverse">
                <div class="links">
                    <ng-content select="uxLayoutFooterLinks"></ng-content>
                </div>
                <div class="app-infos">
                    <ng-content select="uxLayoutFooterAppInfos"></ng-content>
                </div>
            </div>
        </ng-template>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutFooterComponent.propDecorators = {
    "isStyleInverse": [{ type: Input },],
    "isCompact": [{ type: Input },],
};
class UxLayoutFooterAppInfosTagDirective {
}
UxLayoutFooterAppInfosTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutFooterAppInfos' },] },
];
class UxLayoutFooterLinksTagDirective {
}
UxLayoutFooterLinksTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutFooterLinks' },] },
];
class UxLayoutFooterComponentModule {
}
UxLayoutFooterComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    UxLayoutFooterComponent, UxLayoutFooterAppInfosTagDirective,
                    UxLayoutFooterLinksTagDirective
                ],
                declarations: [
                    UxLayoutFooterComponent, UxLayoutFooterAppInfosTagDirective,
                    UxLayoutFooterLinksTagDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarComponent {
    constructor() {
        this.isMuted = false;
    }
}
UxLayoutNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar',
                template: `
        <div id="nav-bar" class="ux-layout-nav-bar {{styleClass}}"
             [class.ux-layout-nav-bar--muted]="isMuted">
            <ng-content select="uxLayoutNavBarLeftActionsContent"></ng-content>
            <ng-content select="uxLayoutNavBarElementsContent"></ng-content>
            <ng-content></ng-content>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutNavBarComponent.propDecorators = {
    "isMuted": [{ type: Input },],
    "styleClass": [{ type: Input },],
};
class UxLayoutNavBarElementsContentTagDirective {
}
UxLayoutNavBarElementsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutNavBarElementsContent' },] },
];
class UxLayoutNavBarLeftActionsContentTagDirective {
}
UxLayoutNavBarLeftActionsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutNavBarLeftActionsContent' },] },
];
class UxLayoutNavBarComponentModule {
}
UxLayoutNavBarComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutNavBarComponent, UxLayoutNavBarElementsContentTagDirective, UxLayoutNavBarLeftActionsContentTagDirective],
                declarations: [UxLayoutNavBarComponent, UxLayoutNavBarElementsContentTagDirective, UxLayoutNavBarLeftActionsContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutSidebarItemComponent {
    /**
     * @param {?} uxService
     * @param {?} router
     * @param {?} activatedRoute
     * @param {?} asService
     */
    constructor(uxService, router, activatedRoute, asService) {
        this.uxService = uxService;
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.asService = asService;
        this.isLarge = false;
        this.isActive = false;
        this.isExpanded = false;
        this.isSeparator = false;
        this.isHome = false;
        this.isItemTogglingSubitems = true;
        this.isInnerSidebarItem = false;
        this.clicked = new EventEmitter();
        this.toggled = new EventEmitter();
        this.crlf = String.fromCharCode(10, 13);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.isInnerSidebarItem && !this.iconClass) {
            this.iconClass = 'ux-icon ux-icon-circle-o ux-u-font-size-h7';
        }
    }
    /**
     * @return {?}
     */
    get hasSub() {
        //  to prevent self inclusion : https://github.com/angular/angular/issues/10098#issuecomment-235157642
        if (this.subItems.length > 1) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isCurrentRouteActive() {
        if (this.url) {
            if (this.router.isActive(this.router.createUrlTree([this.url], { relativeTo: this.activatedRoute }), this.isHome)) {
                return true;
            }
        }
        else if (this.id && this.isActive) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event.keyCode === 13) {
            this.navigateTo();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        this.isExpanded = !this.isExpanded;
        this.toggled.next(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        this.clicked.emit(this.id);
        if (this.url) {
            this.navigateTo();
        }
        if (this.urlExternal) {
            window.open(this.urlExternal, '_blank');
        }
        if (this.hasSub && this.isItemTogglingSubitems) {
            this.toggle(event);
        }
        if (typeof (this.command) === 'function') {
            this.command();
        }
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    navigateTo() {
        if (this.url) {
            this.router.navigate([this.url], { relativeTo: this.activatedRoute });
            window.scrollTo(0, 0);
        }
    }
}
UxLayoutSidebarItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-sidebar-item',
                template: `
    <div *ngIf="!isSeparator" class="sidebar-item"
                              (keydown)="onKeyDown($event)"
                              (click)="onClick($event)"
                              [pTooltip]="!(asService.state$ | async).isSidebarOpen &&
                                          !(asService.breakpoints$ | async).isMobile &&
                                          !isExpanded ? subLabel ? label + crlf + subLabel : label : ''">

        <a [routerLink]="[url]" *ngIf="url">
            <div class="sidebar-item__header" (click)="onClick($event)"
                                            [class.sidebar-item__header--title]="!(url || id || command || urlExternal)"
                                            [class.sidebar-item__header--large]="isLarge"
                                            [class.sidebar-item__header--active]="isCurrentRouteActive"
                                            [class.sidebar-item__header--is-toggling-subitems]="isItemTogglingSubitems"
                                            tabindex="0">
                <div *ngIf="iconClass" class="sidebar-item__header-icon-wrapper">
                    <span class="sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw"></span>
                </div>
                <div class="sidebar-item__header-label-wrapper">
                    <div class="sidebar-item__header-label-wrapper-label">
                        {{label}}
                    </div>
                    <div *ngIf="subLabel" class="sidebar-item__header-label-wrapper-sub-label">
                        {{subLabel}}
                    </div>
                </div>
                <span *ngIf="hasSub" class="sidebar-item__header-expand-toggle" (click)="toggle($event)">
                    <span class="ux-icon" [ngClass]="{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}"></span>
                </span>
            </div>
        </a>

        <a href="{{ urlExternal }}" *ngIf="urlExternal">
            <div class="sidebar-item__header" (click)="onClick($event)"
                                            [class.sidebar-item__header--title]="!(url || id || command || urlExternal)"
                                            [class.sidebar-item__header--large]="isLarge"
                                            [class.sidebar-item__header--active]="isCurrentRouteActive"
                                            [class.sidebar-item__header--is-toggling-subitems]="isItemTogglingSubitems"
                                            tabindex="0">
                <div *ngIf="iconClass" class="sidebar-item__header-icon-wrapper">
                    <span class="sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw"></span>
                </div>
                <div class="sidebar-item__header-label-wrapper">
                    <div class="sidebar-item__header-label-wrapper-label">
                        {{label}}
                    </div>
                    <div *ngIf="subLabel" class="sidebar-item__header-label-wrapper-sub-label">
                        {{subLabel}}
                    </div>
                </div>
                <span *ngIf="hasSub" class="sidebar-item__header-expand-toggle" (click)="toggle($event)">
                    <span class="ux-icon" [ngClass]="{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}"></span>
                </span>
            </div>
        </a>

        <div class="sidebar-item__header" *ngIf="!url && !urlExternal" (click)="onClick($event)"
                                        [class.sidebar-item__header--title]="!(url || id || command || urlExternal)"
                                        [class.sidebar-item__header--large]="isLarge"
                                        [class.sidebar-item__header--active]="isCurrentRouteActive"
                                        [class.sidebar-item__header--is-toggling-subitems]="isItemTogglingSubitems"
                                        tabindex="0">
            <div *ngIf="iconClass" class="sidebar-item__header-icon-wrapper">
                <span class="sidebar-item__header-icon-wrapper-icon {{iconClass}} ux-icon-fw"></span>
            </div>
            <div class="sidebar-item__header-label-wrapper">
                <div class="sidebar-item__header-label-wrapper-label">
                    {{label}}
                </div>
                <div *ngIf="subLabel" class="sidebar-item__header-label-wrapper-sub-label">
                    {{subLabel}}
                </div>
            </div>
            <span *ngIf="hasSub" class="sidebar-item__header-expand-toggle" (click)="toggle($event)">
                <span class="ux-icon" [ngClass]="{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}"></span>
            </span>
        </div>

        <ng-template [ngIf]="isExpanded">
            <div class="sidebar-item__sub">
                <ng-content></ng-content>
            </div>
        </ng-template>
    </div>
    <div *ngIf="isSeparator" class="sidebar-item">
        <div class="sidebar-item-separator"></div>
    </div>
    `,
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutSidebarItemComponent.ctorParameters = () => [
    { type: UxService, },
    { type: Router, },
    { type: ActivatedRoute, },
    { type: UxAppShellService, },
];
UxLayoutSidebarItemComponent.propDecorators = {
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "url": [{ type: Input },],
    "urlExternal": [{ type: Input },],
    "command": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isActive": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "isSeparator": [{ type: Input },],
    "isHome": [{ type: Input },],
    "isItemTogglingSubitems": [{ type: Input },],
    "isInnerSidebarItem": [{ type: Input },],
    "clicked": [{ type: Output },],
    "toggled": [{ type: Output },],
    "subItems": [{ type: ContentChildren, args: [forwardRef(() => UxLayoutSidebarItemComponent),] },],
};
class UxLayoutSidebarItemComponentModule {
}
UxLayoutSidebarItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, TooltipModule],
                exports: [UxLayoutSidebarItemComponent],
                declarations: [UxLayoutSidebarItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutSidebarItemsComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.links = [];
        this.isLargeItems = false;
        this.isInnerNavigationSidebar = false;
        this.isInnerSidebar = false;
        this.toggled = new EventEmitter();
        this.clicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.sidebarItems && this.sidebarItems.length > 0) {
            this.sidebarItems.forEach(item => {
                item.isLarge = this.isLargeItems;
            });
        }
    }
    /**
     * @return {?}
     */
    get hasLinks() {
        if (this.links) {
            return this.links.length !== 0;
        }
        return false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onSidebarItemToggle(item) {
        this.toggled.emit(item);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    onClick(id) {
        this.clicked.emit(id);
    }
}
UxLayoutSidebarItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-sidebar-items',
                template: `
        <div class="sidebar-items"
             [class.sidebar-items--inner-navigation-sidebar]="isInnerNavigationSidebar">

            <ng-template [ngIf]="!hasLinks">
                <ng-content></ng-content>
            </ng-template>

            <ng-template [ngIf]="hasLinks">
                <ux-layout-sidebar-item *ngFor="let link of links"
                                        id="{{link.id}}"
                                        label="{{link.label}}"
                                        subLabel="{{link.subLabel}}"
                                        url="{{link.url}}"
                                        urlExternal="{{link.urlExternal}}"
                                        [hidden]="!link.visible"
                                        [command]="link.command"
                                        [isActive]="link.active"
                                        [isLarge]="isLargeItems"
                                        iconClass="{{link.iconClass}}"
                                        [isHome]="link.isHome"
                                        [isSeparator]="link.isSeparator"
                                        [isExpanded]="link.expanded"
                                        (toggled)="onSidebarItemToggle($event)"
                                        (clicked)="onClick($event)"
                                        [isInnerSidebarItem]="isInnerSidebar">
                    <ux-layout-sidebar-item *ngFor="let childLink of link.children"
                                            id="{{childLink.id}}"
                                            label="{{childLink.label}}"
                                            subLabel="{{childLink.subLabel}}"
                                            url="{{childLink.url}}"
                                            urlExternal="{{childLink.urlExternal}}"
                                            [hidden]="!childLink.visible"
                                            [command]="childLink.command"
                                            [isActive]="childLink.active"
                                            [isLarge]="isLargeItems"
                                            iconClass="{{childLink.iconClass}}"
                                            [isSeparator]="childLink.isSeparator"
                                            [isExpanded]="childLink.expanded"
                                            (toggled)="onSidebarItemToggle($event)"
                                            (clicked)="onClick($event)"
                                            [isInnerSidebarItem]="isInnerSidebar">
                        <ux-layout-sidebar-item *ngFor="let childLinkSub of childLink.children"
                                                id="{{childLinkSub.id}}"
                                                label="{{childLinkSub.label}}"
                                                subLabel="{{childLinkSub.subLabel}}"
                                                url="{{childLinkSub.url}}"
                                                urlExternal="{{childLinkSub.urlExternal}}"
                                                [hidden]="!childLinkSub.visible"
                                                [command]="childLinkSub.command"
                                                [isActive]="childLinkSub.active"
                                                [isLarge]="isLargeItems"
                                                iconClass="{{childLinkSub.iconClass}}"
                                                [isSeparator]="childLinkSub.isSeparator"
                                                [isExpanded]="childLinkSub.expanded"
                                                (toggled)="onSidebarItemToggle($event)"
                                                (clicked)="onClick($event)"
                                                [isInnerSidebarItem]="isInnerSidebar">
                        </ux-layout-sidebar-item>
                    </ux-layout-sidebar-item>
                </ux-layout-sidebar-item>
            </ng-template>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutSidebarItemsComponent.ctorParameters = () => [
    { type: UxService, },
];
UxLayoutSidebarItemsComponent.propDecorators = {
    "links": [{ type: Input },],
    "isLargeItems": [{ type: Input },],
    "isInnerNavigationSidebar": [{ type: Input },],
    "isInnerSidebar": [{ type: Input },],
    "sidebarItems": [{ type: ContentChildren, args: [UxLayoutSidebarItemComponent,] },],
    "toggled": [{ type: Output },],
    "clicked": [{ type: Output },],
};
class UxLayoutSidebarItemsComponentModule {
}
UxLayoutSidebarItemsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, UxLayoutSidebarItemComponentModule
                ],
                exports: [
                    UxLayoutSidebarItemsComponent,
                ],
                declarations: [
                    UxLayoutSidebarItemsComponent,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutOverlayPanelComponent {
    constructor() {
        this.isActive = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        this.isActive = !this.isActive;
    }
}
UxLayoutOverlayPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-overlay-panel',
                template: `
        <div class="overlay-panel" [class.active]="isActive" (click)="onClick($event)">
            <ng-content></ng-content>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutOverlayPanelComponent.propDecorators = {
    "isActive": [{ type: Input },],
};
class UxLayoutOverlayPanelComponentModule {
}
UxLayoutOverlayPanelComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    UxLayoutOverlayPanelComponent
                ],
                declarations: [
                    UxLayoutOverlayPanelComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarActionItemComponent {
    /**
     * @param {?} uxService
     * @param {?} asService
     */
    constructor(uxService, asService) {
        this.uxService = uxService;
        this.asService = asService;
        this.isToggleContent = true;
        this.isOverlayPanel = false;
        this.isOverlayPanelCustomContent = false;
        this.isOverlayPanelBg = false;
        this.links = [];
        this.isShowHome = true;
        this.homeUrl = '/screen/home';
        this.isIconLarge = false;
        this.itemClass = '';
        this.contentClass = '';
        this.tagCount = 0;
        this.isShowTagAsBullet = false;
        this.isHiddenMobile = false;
        this.isMobileOnly = false;
        this.isHiddenDesktop = false;
        this.isUseSidebarTemplateAsLinks = false;
        this.isActive = false;
        this.isContentFixedHeight = false;
        this.isShowLanguageSelector = true;
        this.isShowBadge = false;
        this.hideBagdeOnClick = false;
        this.languageChanged = new EventEmitter();
        this.clicked = new EventEmitter();
        this.toggled = new EventEmitter();
        this.userProfileLinkSelected = new EventEmitter();
        this.genIconClass = '';
    }
    /**
     * @return {?}
     */
    unToggleAll() {
        this.isActive = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.genIconClass = this.iconClass;
        if (this.isIconLarge) {
            this.genIconClass += ' ux-a-icon--large';
        }
    }
    /**
     * @param {?} language
     * @return {?}
     */
    onLanguageChanged(language) {
        this.languageChanged.emit(language);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onUserProfileLinkSelected(link) {
        this.userProfileLinkSelected.next(link);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        if (this.isToggleContent) {
            this.isActive = !this.isActive;
            event.stopImmediatePropagation();
            event.preventDefault();
            if (this.isActive) {
                this.toggled.emit(this);
            }
        }
        else {
            this.clicked.emit(this);
        }
        if (this.hideBagdeOnClick) {
            this.isShowBadge = false;
            this.clicked.emit(this);
        }
    }
    /**
     * @return {?}
     */
    showBadge() {
        this.isShowBadge = true;
    }
    /**
     * @return {?}
     */
    hideBadge() {
        this.isShowBadge = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.stopImmediatePropagation();
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSidebarItemClick(event) {
        this.isActive = !this.isActive;
    }
    /**
     * @return {?}
     */
    getResponsiveClasses() {
        let /** @type {?} */ classes = '';
        if (this.isHiddenMobile) {
            classes = 'd-sm-none d-md-block';
        }
        if (this.isMobileOnly) {
            classes = 'd-none d-sm-block d-md-none';
        }
        if (this.isHiddenDesktop) {
            classes = 'd-lg-none';
        }
        return classes;
    }
}
UxLayoutNavBarActionItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-action-item',
                template: `
        <div class="ux-layout-nav-bar__action-item {{itemClass}} {{getResponsiveClasses()}}" (click)="toggle($event)"
            [class.selected]="isActive"
            [class.not-hoverable]="customItemContent">
            <ng-template [ngIf]="customItemContent">
                <ng-content select="uxLayoutNavBarItemContent"></ng-content>
            </ng-template>
            <ng-template [ngIf]="!customItemContent">
                <ux-a-icon styleClass="ux-layout-nav-bar__action-item-icon"
                           iconClass="{{genIconClass}}"
                           [isShowTag]="tagCount && tagCount != 0 && isShowBadge"
                           [isEmptyTag]="isShowTagAsBullet"
                           tagLabel="{{tagCount}}"
                           tagSizeClass="tinier"
                           [isRounded]="false">
                </ux-a-icon>
            </ng-template>
        </div>

        <ng-template [ngIf]="isOverlayPanel">
            <ng-template [ngIf]="isOverlayPanelCustomContent">
                <ux-layout-overlay-panel [isActive]="isActive">
                    <ng-content select="uxLayoutNavBarOverlayPanelContent"></ng-content>
                </ux-layout-overlay-panel>
            </ng-template>

            <ng-template [ngIf]="!isOverlayPanelCustomContent">
                <div class="overlay-panel" [class.active]="isActive" (click)="onClick($event)">
                    <div class="overlay-panel__header">
                        <div class="overlay-panel__header-profile">
                            <span *ngIf="isShowLanguageSelector">
                                <ux-language-selector
                                    (languageChanged)="onLanguageChanged($event)"
                                    [languageCodes]="languageCodes"
                                    [selectedLanguage]="selectedLanguage">
                                </ux-language-selector>
                            </span>

                            <div class="overlay-panel__header-custom-content">
                                <ng-content select="uxLayoutNavBarOverlayPanelHeaderContent"></ng-content>
                            </div>

                            <span class="overlay-panel__header-profile-infos">
                                <ng-template [ngIf]="headerUserProfileLinks">
                                    <ux-dropdown-button label="{{userInfos}}"
                                                        styleClass="mobile"
                                                        [isLinkToggle]="true"
                                                        [isDropDownRightAligned]="true"
                                                        [links]="headerUserProfileLinks"
                                                        (linkSelected)="onUserProfileLinkSelected($event)">
                                    </ux-dropdown-button>
                                </ng-template>
                                <ng-template [ngIf]="!headerUserProfileLinks">
                                    {{userInfos}}
                                </ng-template>
                            </span>
                        </div>
                    </div>

                    <div class="overlay-panel__inner">
                        <ux-layout-sidebar-items [links]="(asService.state$ | async).combinedLinks"
                                                 (clicked)="onSidebarItemClick($event)">
                        </ux-layout-sidebar-items>
                    </div>
                </div>
            </ng-template>
        </ng-template>

        <ng-template [ngIf]="!isOverlayPanel">
            <aside class="inner-content {{contentClass}}"
                [class.hidden]="!isActive"
                [class.fixed-height]="isContentFixedHeight">
                <ng-content></ng-content>
            </aside>
        </ng-template>
    `,
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutNavBarActionItemComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxAppShellService, },
];
UxLayoutNavBarActionItemComponent.propDecorators = {
    "id": [{ type: Input },],
    "isToggleContent": [{ type: Input },],
    "isOverlayPanel": [{ type: Input },],
    "isOverlayPanelCustomContent": [{ type: Input },],
    "isOverlayPanelBg": [{ type: Input },],
    "links": [{ type: Input },],
    "isShowHome": [{ type: Input },],
    "homeUrl": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isIconLarge": [{ type: Input },],
    "itemClass": [{ type: Input },],
    "contentClass": [{ type: Input },],
    "tagCount": [{ type: Input },],
    "isShowTagAsBullet": [{ type: Input },],
    "userInfos": [{ type: Input },],
    "userInfosIconClass": [{ type: Input },],
    "isHiddenMobile": [{ type: Input },],
    "isMobileOnly": [{ type: Input },],
    "isHiddenDesktop": [{ type: Input },],
    "isUseSidebarTemplateAsLinks": [{ type: Input },],
    "isActive": [{ type: Input },],
    "isContentFixedHeight": [{ type: Input },],
    "headerUserProfileLinks": [{ type: Input },],
    "languageCodes": [{ type: Input },],
    "additionalLanguages": [{ type: Input },],
    "selectedLanguage": [{ type: Input },],
    "isShowLanguageSelector": [{ type: Input },],
    "isShowBadge": [{ type: Input },],
    "hideBagdeOnClick": [{ type: Input },],
    "languageChanged": [{ type: Output },],
    "clicked": [{ type: Output },],
    "toggled": [{ type: Output },],
    "userProfileLinkSelected": [{ type: Output },],
    "customItemContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutNavBarItemContentTagDirective),] },],
    "unToggleAll": [{ type: HostListener, args: ['body:click',] },],
};
class UxLayoutNavBarOverlayPanelContentTagDirective {
}
UxLayoutNavBarOverlayPanelContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutNavBarOverlayPanelContent' },] },
];
class UxLayoutNavBarOverlayHeaderPanelContentTagDirective {
}
UxLayoutNavBarOverlayHeaderPanelContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutNavBarOverlayPanelHeaderContent' },] },
];
class UxLayoutNavBarItemContentTagDirective {
}
UxLayoutNavBarItemContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutNavBarItemContent' },] },
];
class UxLayoutNavBarActionItemComponentModule {
}
UxLayoutNavBarActionItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    UxLanguageSelectorComponentModule,
                    UxLayoutSidebarItemsComponentModule,
                    UxLayoutOverlayPanelComponentModule,
                    UxDropdownButtonComponentModule,
                    UxDropdownButtonItemComponentModule,
                    UxIconComponentModule,
                ],
                exports: [
                    UxLayoutNavBarActionItemComponent,
                    UxLayoutNavBarOverlayPanelContentTagDirective,
                    UxLayoutNavBarItemContentTagDirective,
                    UxLayoutNavBarOverlayHeaderPanelContentTagDirective,
                ],
                declarations: [
                    UxLayoutNavBarActionItemComponent,
                    UxLayoutNavBarOverlayPanelContentTagDirective,
                    UxLayoutNavBarItemContentTagDirective,
                    UxLayoutNavBarOverlayHeaderPanelContentTagDirective,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarActionsComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
    }
    /**
     * @return {?}
     */
    unToggleAll() {
        this.items.toArray().forEach(function (i) {
            i.isActive = false;
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    hideAll(item) {
        this.items.toArray().forEach(function (i) {
            if (i !== item) {
                i.isActive = false;
            }
        });
    }
}
UxLayoutNavBarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-actions',
                template: `
        <div class="ux-layout-nav-bar__right-actions">
            <ng-content></ng-content>
        </div>
    `,
                // IE11 icons overlapping issue (cfr. EUI-1115)
                // styles: [`
                //     :host {
                //         display: flex;
                //         margin-left: auto;
                //     }
                // `],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutNavBarActionsComponent.ctorParameters = () => [
    { type: UxService, },
];
UxLayoutNavBarActionsComponent.propDecorators = {
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxLayoutNavBarActionItemComponent), { descendants: true },] },],
    "unToggleAll": [{ type: HostListener, args: ['body:click',] },],
};
class UxLayoutNavBarActionsComponentModule {
}
UxLayoutNavBarActionsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutNavBarActionsComponent],
                declarations: [UxLayoutNavBarActionsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxListItemsComponent {
    /**
     * @param {?} elementRef
     * @param {?} uxService
     */
    constructor(elementRef, uxService) {
        this.elementRef = elementRef;
        this.uxService = uxService;
        this.expanded = false;
        this.isSmall = false;
        this.isLarge = false;
        this.hasBorder = false;
        this.isLeftPositioned = false;
        this.isAccessible = false;
        this.tabindex = '0';
        this.listItemClick = new EventEmitter();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onListItemClick(item) {
        this.listItemClick.emit(item);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        if (this.isAccessible) {
            const /** @type {?} */ focusableElements = this.getFocusableElements();
            if (focusableElements.length > 0) {
                for (let /** @type {?} */ i = 0; i < focusableElements.length; i++) {
                    focusableElements[i].setAttribute('tabindex', '-1');
                }
                this.focusElement(focusableElements[0]);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.isAccessible) {
            let /** @type {?} */ next = false;
            switch (event.keyCode) {
                case 38:
                    // ARROW UP
                    break;
                case 40:
                    // ARROW DOWN
                    next = true;
                    break;
                case 9:
                    // TAB
                    if (event.shiftKey) {
                        const /** @type {?} */ oldTabindex = this.tabindex;
                        this.tabindex = '-1';
                        setTimeout(() => {
                            this.tabindex = oldTabindex;
                        }, 0);
                    }
                    return;
                default:
                    return;
            }
            // Focus on the next/previous list item label, making sure only that item is focusable:
            const /** @type {?} */ focusableElements = this.getFocusableElements();
            if (focusableElements.length > 0) {
                for (let /** @type {?} */ i = 0; i < focusableElements.length; i++) {
                    if (focusableElements[i] === document.activeElement) {
                        focusableElements[i].setAttribute('tabindex', '-1');
                        if (next) {
                            if (i + 1 < focusableElements.length) {
                                this.focusElement(focusableElements[i + 1]);
                            }
                            else {
                                this.focusElement(focusableElements[0]);
                            }
                        }
                        else {
                            if (i - 1 >= 0) {
                                this.focusElement(focusableElements[i - 1]);
                            }
                            else {
                                this.focusElement(focusableElements[focusableElements.length - 1]);
                            }
                        }
                        break;
                    }
                }
            }
            this.uxService.consumeEvent(event);
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    focusElement(element) {
        element.setAttribute('tabindex', '0');
        element.focus();
    }
    /**
     * @return {?}
     */
    getFocusableElements() {
        return this.elementRef.nativeElement.querySelectorAll('.ux-a-label,.ux-a-tag');
    }
}
UxListItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-list-items',
                template: `
    <div *ngIf="titleLabel" class="ux-list-items-title {{titleLabelClass}}">{{titleLabel}}</div>
    <ul class="ux-list-items" [tabindex]="tabindex" aria-orientation="vertical" (focus)="onFocus($event)" (keydown)="onKeyDown($event)">
        <ng-template [ngIf]="links">
            <ux-list-item *ngFor="let link of links"
                           [item]="link"
                           (listItemClick)="onListItemClick($event)"
                           [isExpanded]="expanded"
                           [isSmall]="isSmall"
                           [hasBorder]="hasBorder"
                           [isLarge]="isLarge"
                           [isLeftPositioned]="isLeftPositioned"
                           [isScreenReaderClickable]="link.isScreenReaderClickable">
            </ux-list-item>
        </ng-template>
        <ng-template [ngIf]="!links">
            <ng-content></ng-content>
        </ng-template>
    </ul>
  `
            },] },
];
/** @nocollapse */
UxListItemsComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: UxService, },
];
UxListItemsComponent.propDecorators = {
    "titleLabel": [{ type: Input },],
    "titleLabelClass": [{ type: Input },],
    "expanded": [{ type: Input },],
    "links": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "hasBorder": [{ type: Input },],
    "isLeftPositioned": [{ type: Input },],
    "isAccessible": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "listItemClick": [{ type: Output },],
};
class UxListItemsComponentModule {
}
UxListItemsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxListItemComponentModule],
                exports: [UxListItemsComponent],
                declarations: [
                    UxListItemsComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDateTagComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.dateFormat = 'DD/MM/YYYY';
        this.isVerticalLayout = true;
        this.isHandleOverdue = false;
        this.isDisplayDaysLeft = false;
        this.isMuted = false;
        this.tabindex = 0;
        this.stateClass = '';
        this.languageCode = uxService.activeLanguage.code;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        const /** @type {?} */ prefix = 'ux-a-date-tag';
        if (this.isMuted) {
            this.isVerticalLayout = false;
        }
        if (this.isVerticalLayout) {
            this.stateClass += prefix + '--vertical ';
            if (this.typeClass) {
                this.stateClass += prefix + '--vertical--' + this.typeClass + ' ';
            }
            else {
                if (this.isHandleOverdue) {
                    this.stateClass += prefix + '--vertical--' + this.getOverdueState();
                }
            }
        }
        else {
            if (this.typeClass) {
                this.stateClass += prefix + '--' + this.typeClass;
            }
            else {
                if (this.isHandleOverdue) {
                    this.stateClass += prefix + '--' + this.getOverdueState();
                }
            }
            if (this.isMuted) {
                this.stateClass += ' ' + prefix + '--muted';
            }
        }
    }
    /**
     * @return {?}
     */
    get daysLeftValue() {
        if (typeof this.date !== 'string') {
            let /** @type {?} */ diffDays = this.uxService.diffDaysFromToday(this.date);
            let /** @type {?} */ label = '';
            switch (true) {
                case (diffDays < -1):
                    label = this.uxService.translate('xDaysAgo', this.languageCode).replace('%PARAM%', Math.abs(diffDays).toString());
                    break;
                case (diffDays === -1):
                    label = this.uxService.translate('oneDayAgo', this.languageCode);
                    break;
                case (diffDays === 0):
                    label = this.uxService.translate('today', this.languageCode);
                    break;
                case (diffDays === 1):
                    label = this.uxService.translate('inOneDay', this.languageCode);
                    break;
                case (diffDays > 1):
                    label = this.uxService.translate('inXDays', this.languageCode).replace('%PARAM%', diffDays.toString());
                    break;
            }
            return label;
        }
        else {
            return '';
        }
    }
    /**
     * @return {?}
     */
    getOverdueState() {
        const /** @type {?} */ now = new Date();
        if (this.date.toDateString() === now.toDateString()) {
            return 'warning';
        }
        else if (now > this.date) {
            return 'danger';
        }
        return 'primary';
    }
}
UxDateTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-date-tag',
                template: "<span *ngIf=\"isVerticalLayout\" class=\"ux-a-date-tag-container\" [tabindex]=\"tabindex\" attr.aria-label=\"{{ date | amLocal | amDateFormat: 'DD' }} {{ date | amLocal | amDateFormat: 'MMM' }} {{ date | amLocal | amDateFormat: 'YYYY' }} {{ daysLeftValue }}\"> <div class=\"ux-a-date-tag {{ stateClass }} {{ styleClass }}\"> <div class=\"ux-a-date-tag__d\">{{ date | amLocal | amDateFormat: 'DD' }}</div> <div class=\"ux-a-date-tag__m\">{{ date | amLocal | amDateFormat: 'MMM' }}</div> <div class=\"ux-a-date-tag__y\">{{ date | amLocal | amDateFormat: 'YYYY' }}</div> </div> <div *ngIf=\"isDisplayDaysLeft\" class=\"ux-a-date-tag__sub-label\"> {{ daysLeftValue }} </div> </span> <span *ngIf=\"!isVerticalLayout\" class=\"ux-a-date-tag-container\" [tabindex]=\"tabindex\" attr.aria-label=\"{{ date | amLocal | amDateFormat: dateFormat }} {{ daysLeftValue }}\"> <div class=\"ux-a-date-tag {{ stateClass }} {{ styleClass }}\"> {{ date | amLocal | amDateFormat: dateFormat }} </div> <div *ngIf=\"isDisplayDaysLeft\" class=\"ux-a-date-tag__sub-label\"> {{ daysLeftValue }} </div> </span> ",
                styles: [".ux-a-date-tag-container .ux-a-date-tag{background-color:white;padding:.66rem;text-align:center;width:100px;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag__sub-label{font-size:.71429rem;font-style:italic;margin-top:.33rem;text-align:center}.ux-a-date-tag-container .ux-a-date-tag--vertical{background:#d2d2d2;border-bottom:4px solid #ffd114}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__d{font-size:1.14286rem;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__m{font-size:1rem;text-transform:uppercase;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-a-date-tag-container .ux-a-date-tag--vertical .ux-a-date-tag-container .ux-a-date-tag__y{font-size:.85714rem}.ux-a-date-tag-container .ux-a-date-tag--tiny{padding:.33rem}.ux-a-date-tag-container .ux-a-date-tag--big{padding:1.25rem}.ux-a-date-tag-container .ux-a-date-tag--primary{color:#003e8c}.ux-a-date-tag-container .ux-a-date-tag--info{color:#0067ad}.ux-a-date-tag-container .ux-a-date-tag--success{color:#3f7233}.ux-a-date-tag-container .ux-a-date-tag--warning{color:#ee821d}.ux-a-date-tag-container .ux-a-date-tag--danger{color:#d61d2b}.ux-a-date-tag-container .ux-a-date-tag--vertical--primary{background:#003e8c;border-bottom-color:#001f65;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--info{background:#0067ad;border-bottom-color:#00408c;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--success{background:#3f7233;border-bottom-color:#204a17;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--warning{background:#f08d23;border-bottom-color:#e8670e;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--vertical--danger{background:#d61d2b;border-bottom-color:#c20b13;color:#fff}.ux-a-date-tag-container .ux-a-date-tag--muted{margin-bottom:0;box-shadow:none;font-family:\"eui-default\",Arial,\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal} /*# sourceMappingURL=ux-a-date-tag.component.css.map */"],
            },] },
];
/** @nocollapse */
UxDateTagComponent.ctorParameters = () => [
    { type: UxService, },
];
UxDateTagComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "date": [{ type: Input },],
    "dateFormat": [{ type: Input },],
    "isVerticalLayout": [{ type: Input },],
    "isHandleOverdue": [{ type: Input },],
    "isDisplayDaysLeft": [{ type: Input },],
    "languageCode": [{ type: Input },],
    "isMuted": [{ type: Input },],
    "tabindex": [{ type: Input },],
};
class UxDateTagComponentModule {
}
UxDateTagComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, MomentModule],
                exports: [UxDateTagComponent],
                declarations: [UxDateTagComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxNotificationItemComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.dateFormat = 'DD/MM/YYYY';
        this.isRenderHTML = false;
        this.isShowPriority = false;
        this.itemClick = new EventEmitter();
        this.itemMarkAsRead = new EventEmitter();
        this.itemMarkAsUnRead = new EventEmitter();
        this.tooltipSize = 'auto';
        if (!this.markAsReadLabel) {
            this.markAsReadLabel = uxService.translate('notificationMarkAsRead');
        }
        if (!this.markAsUnReadLabel) {
            this.markAsUnReadLabel = uxService.translate('notificationMarkAsUnRead');
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onItemClick(event) {
        this.itemClick.emit(this.notificationLink);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onItemMarkAsRead(event) {
        if (this.notificationLink.metadata) {
            this.notificationLink.metadata.read = true;
        }
        this.itemMarkAsRead.emit(this.notificationLink);
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onItemMarkAsUnRead(event) {
        if (this.notificationLink.metadata) {
            this.notificationLink.metadata.read = false;
        }
        this.itemMarkAsUnRead.emit(this.notificationLink);
        this.uxService.consumeEvent(event);
    }
    /**
     * @return {?}
     */
    get notificationTypeClass() {
        if (!this.notificationLink.typeClass) {
            return 'primary';
        }
        else {
            return this.notificationLink.typeClass;
        }
    }
}
UxNotificationItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-notification-item',
                template: "<div class=\"ux-notification__item\"> <div class=\"ux-notification__item-content\" [ngClass]=\"isShowPriority && notificationLink.metadata.typeClass ? 'ux-notification__item-content--' + notificationLink.metadata.typeClass : 'ux-notification__item-content--secondary'\" (click)=\"onItemClick($event)\" [class.ux-notification__item-content--type]=\"notificationLink.metadata && ( notificationLink.metadata.type || notificationLink.metadata.date )\"> <div *ngIf=\"notificationLink.metadata && ( notificationLink.metadata.type || notificationLink.metadata.date )\" class=\"ux-notification__item-content-col--left\"> <ux-badge *ngIf=\"notificationLink.metadata && notificationLink.metadata.type\" [isPill]=\"false\" [isSmall]=\"true\" [typeClass]=\"isShowPriority && notificationLink.metadata.typeClass ? notificationLink.metadata.typeClass : 'primary'\"> {{ notificationLink.metadata.type }} </ux-badge> <ux-badge *ngIf=\"notificationLink.metadata && !notificationLink.metadata.type\" [isPill]=\"false\" [isSmall]=\"true\" [typeClass]=\"isShowPriority && notificationLink.metadata.typeClass ? notificationLink.metadata.typeClass : 'primary'\"> <span class=\"ux-icon ux-icon-envelope-o\"></span> </ux-badge> <ux-a-date-tag *ngIf=\"notificationLink.metadata && notificationLink.metadata.date\" [date]=\"notificationLink.metadata.date\" [isMuted]=\"true\" [isDisplayDaysLeft]=\"true\" dateFormat=\"{{dateFormat}}\"> </ux-a-date-tag> </div> <div class=\"ux-notification__item-content-col--center\"> <ng-template [ngIf]=\"notificationLink.metadata?.url\"> <a href=\"{{ notificationLink.metadata.url }}\" target=\"_blank\">{{ notificationLink.label | uxTruncate : 200 }}</a> </ng-template> <ng-template [ngIf]=\"!notificationLink.metadata?.url\"> {{ notificationLink.label | uxTruncate : 200 }} </ng-template> </div> <div class=\"ux-notification__item-content-col--right\"> <button class=\"ux-notification__item-close\" type=\"button\" [attr.aria-label]=\"markAsReadLabel\" title=\"{{ markAsReadLabel }}\" (click)=\"onItemMarkAsRead($event)\"> <span class=\"ion ion-ios-close-empty\"></span> </button> </div> </div> </div> ",
            },] },
];
/** @nocollapse */
UxNotificationItemComponent.ctorParameters = () => [
    { type: UxService, },
];
UxNotificationItemComponent.propDecorators = {
    "notificationLink": [{ type: Input },],
    "dateFormat": [{ type: Input },],
    "isRenderHTML": [{ type: Input },],
    "markAsReadLabel": [{ type: Input },],
    "markAsUnReadLabel": [{ type: Input },],
    "isShowPriority": [{ type: Input },],
    "itemClick": [{ type: Output },],
    "itemMarkAsRead": [{ type: Output },],
    "itemMarkAsUnRead": [{ type: Output },],
};
class UxNotificationItemComponentModule {
}
UxNotificationItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxIconComponentModule,
                    UxLabelComponentModule,
                    UxBadgeComponentModule,
                    UxDateTagComponentModule,
                    UxTooltipModule,
                    UxTruncatePipeModule,
                ],
                exports: [UxNotificationItemComponent],
                declarations: [UxNotificationItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxButtonComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.type = 'button';
        this.isOutline = false;
        this.isSecondary = false;
        this.isSmall = false;
        this.isLarge = false;
        this.isBlock = false;
        this.isFlat = false;
        this.isLineWrap = false;
        this.tabindex = '0';
        this.isDisabled = false;
        this.stateClass = 'ux-button--with-label';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setClasses();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ innerText = this.uxContentPlaceholder.nativeElement.innerText;
        if (!innerText.trim()) {
            this.stateClass = 'ux-button--icon-only';
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    setClasses() {
        this.btnTypeClass = '';
        let /** @type {?} */ prefix = 'btn-';
        if (!this.isFlat && !this.typeClass) {
            this.typeClass = 'primary';
        }
        if (this.isFlat && !this.typeClass) {
            this.typeClass = 'default';
        }
        if (this.isSecondary) {
            this.typeClass = 'secondary';
        }
        if (this.isOutline) {
            prefix += 'outline-';
        }
        if (this.isFlat) {
            prefix = 'btn-flat btn-flat-';
        }
        this.btnTypeClass = prefix + this.typeClass;
        this.btnSizeClass = '';
        if (this.isSmall) {
            this.btnSizeClass = 'btn-sm';
        }
        if (this.isLarge) {
            this.btnSizeClass = 'btn-lg';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setClasses();
    }
}
UxButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-button',
                template: "<button type=\"{{type}}\" class=\"btn ux-button {{btnTypeClass}} {{btnSizeClass}} {{styleClass}} {{stateClass}}\" [class.btn-block]=\"isBlock\" [class.ux-button--line-wrap]=\"isLineWrap\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-disabled]=\"isDisabled\"> <span *ngIf=\"iconClass\" class=\"ux-button__icon {{iconClass}}\"></span> <span class=\"ux-button__content\" #uxContentPlaceholder> <ng-content></ng-content> </span> </button> ",
                styles: ["﻿:host(.ux-button—host-disabled){pointer-events:none} /*# sourceMappingURL=ux-button.component.css.map */"],
            },] },
];
/** @nocollapse */
UxButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
UxButtonComponent.propDecorators = {
    "type": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isOutline": [{ type: Input },],
    "isSecondary": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isBlock": [{ type: Input },],
    "isFlat": [{ type: Input },],
    "isLineWrap": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "isDisabled": [{ type: Input }, { type: HostBinding, args: ['class.ux-button—host-disabled',] },],
    "uxContentPlaceholder": [{ type: ViewChild, args: ['uxContentPlaceholder',] },],
};
class UxButtonComponentModule {
}
UxButtonComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxButtonComponent],
                declarations: [UxButtonComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxNotificationsPanelComponent {
    /**
     * @param {?} uxLayoutNavBarActionsComponent
     * @param {?} uxLayoutOverlayPanelComponent
     * @param {?} uxService
     */
    constructor(uxLayoutNavBarActionsComponent, uxLayoutOverlayPanelComponent, uxService) {
        this.uxService = uxService;
        this.notificationLinks = [];
        this.viewAllNotificationsLabel = null;
        this.headerTitleLabel = null;
        this.noNotificationFoundLabel = null;
        this.todaysSeparatorLabel = null;
        this.oldestSeparatorLabel = null;
        this.unreadLabel = null;
        this.totalLabel = null;
        this.markAsReadLabel = null;
        this.markAsUnReadLabel = null;
        this.markAllAsReadLabel = null;
        this.settingsLabel = null;
        this.isShowViewAllAction = true;
        this.isSeparateCurrentDayNotifications = false;
        this.isHidePanelOnViewAllAction = true;
        this.isRenderHTML = false;
        this.isShowTotalNotifications = true;
        this.isShowRefreshButton = true;
        this.customUnreadCount = false;
        this.nbUnreadCount = null;
        this.isShowPriority = false;
        this.refreshClick = new EventEmitter();
        this.viewAllClick = new EventEmitter();
        this.itemClick = new EventEmitter();
        this.itemMarkAsRead = new EventEmitter();
        this.itemMarkAsUnRead = new EventEmitter();
        this.markAllAsRead = new EventEmitter();
        this.notificationSettings = new EventEmitter();
        this.currentDayNotifications = [];
        this.oldestNotifications = [];
        this.unreadNotifications = [];
        this.today = new Date();
        this.uxLayoutNavBarActionsComponent = uxLayoutNavBarActionsComponent;
        this.uxLayoutOverlayPanelComponent = uxLayoutOverlayPanelComponent;
        if (!this.viewAllNotificationsLabel) {
            this.viewAllNotificationsLabel = uxService.translate('viewAllNotifications');
        }
        if (!this.headerTitleLabel) {
            this.headerTitleLabel = uxService.translate('myNotifications');
        }
        if (!this.noNotificationFoundLabel) {
            this.noNotificationFoundLabel = uxService.translate('noNotificationFound');
        }
        if (!this.todaysSeparatorLabel) {
            this.todaysSeparatorLabel = uxService.translate('notificationsToday');
        }
        if (!this.oldestSeparatorLabel) {
            this.oldestSeparatorLabel = uxService.translate('notificationsOldest');
        }
        if (!this.unreadLabel) {
            this.unreadLabel = uxService.translate('notificationsUnread');
        }
        if (!this.totalLabel) {
            this.totalLabel = uxService.translate('notificationsTotal');
        }
        if (!this.markAsReadLabel) {
            this.markAsReadLabel = uxService.translate('notificationMarkAsRead');
        }
        if (!this.markAsUnReadLabel) {
            this.markAsUnReadLabel = uxService.translate('notificationMarkAsUnRead');
        }
    }
    /**
     * @return {?}
     */
    get unreadCount() {
        let /** @type {?} */ unreadNotifications = this.notificationLinks.filter((link) => {
            if (link.metadata) {
                return link.metadata.read === false;
            }
            return false;
        });
        return unreadNotifications.length;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isSeparateCurrentDayNotifications) {
            this.currentDayNotifications = this.notificationLinks.filter((link) => {
                if (link.metadata) {
                    return new Date(link.metadata.date).toDateString() === new Date().toDateString();
                }
                return false;
            });
            this.oldestNotifications = this.notificationLinks.filter((link) => {
                if (link.metadata) {
                    return new Date(link.metadata.date).toDateString() !== new Date().toDateString();
                }
                return false;
            });
        }
        if (!this.customUnreadCount) {
            this.nbUnreadCount = this.unreadCount;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.customUnreadCount) {
            this.nbUnreadCount = this.unreadCount;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRefresh(event) {
        this.refreshClick.emit();
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onItemClick(link) {
        this.itemClick.emit(link);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onViewAllClick(event) {
        this.viewAllClick.emit();
        if (!this.isHidePanelOnViewAllAction) {
            this.uxService.consumeEvent(event);
        }
        else {
            if (this.uxLayoutNavBarActionsComponent && !this.uxLayoutOverlayPanelComponent) {
                this.uxLayoutNavBarActionsComponent.hideAll(null);
            }
        }
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onItemMarkAsRead(link) {
        this.itemMarkAsRead.emit(link);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onItemMarkAsUnRead(link) {
        this.itemMarkAsUnRead.emit(link);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMarkAllAsRead(e) {
        this.markAllAsRead.emit(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onNotificationSettings(e) {
        this.notificationSettings.emit(e);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    getNotificationStateClass(link) {
        if (link.metadata) {
            if (link.metadata.read) {
                return 'ux-list-item--muted';
            }
        }
        return '';
    }
}
UxNotificationsPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-notifications-panel',
                template: "<div class=\"ux-notifications-panel\"> <div class=\"ux-notifications-panel__header\"> <div class=\"ux-notifications-panel__header-title\"> <div class=\"ux-notifications-panel__header-title-label\"> {{ headerTitleLabel }} <span *ngIf=\"notificationLinks\" class=\"ux-u-cursor-help ml-2\" [attr.aria-label]=\"unreadLabel\" title=\"{{ unreadLabel }}\"> <ux-badge [isPill]=\"true\" [isSmall]=\"true\" typeClass=\"primary\">{{ notificationLinks.length }}</ux-badge> </span> </div> </div> <div *ngIf=\"notificationLinks\" class=\"ux-notifications-panel__header-actions\"> <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-checkbox-outline\" [attr.aria-label]=\"markAllAsReadLabel\" title=\"{{ markAllAsReadLabel }}\" (click)=\"onMarkAllAsRead($event)\"></ux-button> <!-- <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-settings\" [attr.aria-label]=\"settingsLabel\" title=\"{{ settingsLabel }}\" (click)=\"onNotificationSettings($event)\"></ux-button> --> <ux-button [isFlat]=\"true\" typeClass=\"primary\" iconClass=\"ion ion-android-refresh\" (click)=\"onRefresh($event)\" *ngIf=\"isShowRefreshButton\"></ux-button> </div> </div> <div class=\"ux-notifications-panel__content\"> <ux-notification-item *ngFor=\"let notificationLink of notificationLinks\" [notificationLink]=\"notificationLink\" [isShowPriority]=\"isShowPriority\" [isRenderHTML]=\"isRenderHTML\" dateFormat=\"hh:mm\" (itemClick)=\"onItemClick($event)\" (itemMarkAsRead)=\"onItemMarkAsRead($event)\" (itemMarkAsUnRead)=\"onItemMarkAsUnRead($event)\"></ux-notification-item> </div> <div class=\"ux-notifications-panel__footer\"> <ng-template [ngIf]=\"notificationLinks?.length > 0\"> <strong><a (click)=\"onViewAllClick($event)\">{{ viewAllNotificationsLabel }}</a></strong> </ng-template> <ng-template [ngIf]=\"notificationLinks?.length === 0\"> <div class=\"ux-notification__item-content\">{{ noNotificationFoundLabel }}</div> </ng-template> </div> </div> ",
            },] },
];
/** @nocollapse */
UxNotificationsPanelComponent.ctorParameters = () => [
    { type: UxLayoutNavBarActionsComponent, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [forwardRef(() => UxLayoutNavBarActionsComponent),] },] },
    { type: UxLayoutOverlayPanelComponent, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [forwardRef(() => UxLayoutOverlayPanelComponent),] },] },
    { type: UxService, },
];
UxNotificationsPanelComponent.propDecorators = {
    "notificationLinks": [{ type: Input },],
    "viewAllNotificationsLabel": [{ type: Input },],
    "headerTitleLabel": [{ type: Input },],
    "noNotificationFoundLabel": [{ type: Input },],
    "todaysSeparatorLabel": [{ type: Input },],
    "oldestSeparatorLabel": [{ type: Input },],
    "unreadLabel": [{ type: Input },],
    "totalLabel": [{ type: Input },],
    "markAsReadLabel": [{ type: Input },],
    "markAsUnReadLabel": [{ type: Input },],
    "markAllAsReadLabel": [{ type: Input },],
    "settingsLabel": [{ type: Input },],
    "isShowViewAllAction": [{ type: Input },],
    "isSeparateCurrentDayNotifications": [{ type: Input },],
    "isHidePanelOnViewAllAction": [{ type: Input },],
    "isRenderHTML": [{ type: Input },],
    "isShowTotalNotifications": [{ type: Input },],
    "isShowRefreshButton": [{ type: Input },],
    "customUnreadCount": [{ type: Input },],
    "nbUnreadCount": [{ type: Input },],
    "isShowPriority": [{ type: Input },],
    "refreshClick": [{ type: Output },],
    "viewAllClick": [{ type: Output },],
    "itemClick": [{ type: Output },],
    "itemMarkAsRead": [{ type: Output },],
    "itemMarkAsUnRead": [{ type: Output },],
    "markAllAsRead": [{ type: Output },],
    "notificationSettings": [{ type: Output },],
};
class UxNotificationsPanelComponentModule {
}
UxNotificationsPanelComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxListItemComponentModule,
                    UxListItemsComponentModule,
                    UxNotificationItemComponentModule,
                    UxBadgeComponentModule,
                    MomentModule,
                    UxDateTagComponentModule,
                    UxTruncatePipeModule,
                    UxButtonComponentModule,
                ],
                exports: [UxNotificationsPanelComponent],
                declarations: [UxNotificationsPanelComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarActionItemNotificationsComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.notificationLinks = [];
        this.isRenderHTML = false;
        this.isShowViewAllAction = true;
        this.isShowUnreadNotificationsCountAsBullet = false;
        this.isShowTotalNotifications = true;
        this.isShowRefreshButton = true;
        this.isHidePanelOnViewAllAction = false;
        this.isShowBadge = true;
        this.hideBagdeOnClick = false;
        this.customUnreadCount = false;
        this.nbUnreadCount = null;
        this.viewAllNotificationsLabel = null;
        this.headerTitleLabel = null;
        this.noNotificationFoundLabel = null;
        this.todaysSeparatorLabel = null;
        this.oldestSeparatorLabel = null;
        this.unreadLabel = null;
        this.totalLabel = null;
        this.markAsReadLabel = null;
        this.markAsUnReadLabel = null;
        this.markAllAsReadLabel = null;
        this.settingsLabel = null;
        this.isShowPriority = false;
        this.notificationsRefreshClick = new EventEmitter();
        this.notificationsViewAllClick = new EventEmitter();
        this.notificationsItemClick = new EventEmitter();
        this.notificationsItemMarkAsRead = new EventEmitter();
        this.notificationsItemMarkAsUnRead = new EventEmitter();
        this.iconClick = new EventEmitter();
        this.notificationsMarkAllAsRead = new EventEmitter();
        this.notificationsSettings = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.viewAllNotificationsLabel) {
            this.viewAllNotificationsLabel = this.uxService.translate('viewAllNotifications');
        }
        if (!this.headerTitleLabel) {
            this.headerTitleLabel = this.uxService.translate('myNotifications');
        }
        if (!this.noNotificationFoundLabel) {
            this.noNotificationFoundLabel = this.uxService.translate('noNotificationFound');
        }
        if (!this.todaysSeparatorLabel) {
            this.todaysSeparatorLabel = this.uxService.translate('notificationsToday');
        }
        if (!this.oldestSeparatorLabel) {
            this.oldestSeparatorLabel = this.uxService.translate('notificationsOldest');
        }
        if (!this.unreadLabel) {
            this.unreadLabel = this.uxService.translate('notificationsUnread');
        }
        if (!this.totalLabel) {
            this.totalLabel = this.uxService.translate('notificationsTotal');
        }
        if (!this.markAsReadLabel) {
            this.markAsReadLabel = this.uxService.translate('notificationMarkAsRead');
        }
        if (!this.markAsUnReadLabel) {
            this.markAsUnReadLabel = this.uxService.translate('notificationMarkAsUnRead');
        }
    }
    /**
     * @return {?}
     */
    showBadge() {
        this.uxLayoutNavBarActionItemComponent.showBadge();
    }
    /**
     * @return {?}
     */
    hideBadge() {
        this.uxLayoutNavBarActionItemComponent.hideBadge();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onIconClick(e) {
        this.iconClick.emit(e);
    }
    /**
     * @return {?}
     */
    get unreadNotificationsCountGenerated() {
        if (this.unreadNotificationsCount) {
            return this.unreadNotificationsCount;
        }
        else {
            return this.notificationLinks.length;
        }
    }
}
UxLayoutNavBarActionItemNotificationsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-action-item-notifications',
                template: `
        <!-- WITHIN OVERLAY -->
        <ux-layout-nav-bar-action-item  iconClass="ux-icon ux-icon-bell"
                                        tagCount="{{unreadNotificationsCountGenerated}}"
                                        [isShowTagAsBullet]="isShowUnreadNotificationsCountAsBullet"
                                        [isOverlayPanel]="true"
                                        [isOverlayPanelCustomContent]="true"
                                        [isShowBadge]="isShowBadge"
                                        [hideBagdeOnClick]="hideBagdeOnClick"
                                        (clicked)="onIconClick($event)">
            <uxLayoutNavBarOverlayPanelContent>
                <ux-notifications-panel [notificationLinks]="notificationLinks"
                                        [isSeparateCurrentDayNotifications]="false"
                                        [isHidePanelOnViewAllAction]="isHidePanelOnViewAllAction"
                                        (refreshClick)="notificationsRefreshClick.emit($event)"
                                        (viewAllClick)="notificationsViewAllClick.emit($event)"
                                        (itemMarkAsRead)="notificationsItemMarkAsRead.emit($event)"
                                        (itemMarkAsUnRead)="notificationsItemMarkAsUnRead.emit($event)"
                                        (itemClick)="notificationsItemClick.emit($event)"
                                        (markAllAsRead)="notificationsMarkAllAsRead.emit($event)"
                                        (notificationSettings)="notificationsSettings.emit($event)"
                                        [isRenderHTML]="isRenderHTML"
                                        [isShowViewAllAction]="isShowViewAllAction"
                                        [isShowTotalNotifications]="isShowTotalNotifications"
                                        [isShowRefreshButton]="isShowRefreshButton"
                                        [customUnreadCount]="customUnreadCount"
                                        [nbUnreadCount]="nbUnreadCount"
                                        [viewAllNotificationsLabel]="viewAllNotificationsLabel"
                                        [headerTitleLabel]="headerTitleLabel"
                                        [noNotificationFoundLabel]="noNotificationFoundLabel"
                                        [todaysSeparatorLabel]="todaysSeparatorLabel"
                                        [oldestSeparatorLabel]="oldestSeparatorLabel"
                                        [unreadLabel]="unreadLabel"
                                        [totalLabel]="totalLabel"
                                        [markAsReadLabel]="markAsReadLabel"
                                        [markAsUnReadLabel]="markAsUnReadLabel"
                                        [markAllAsReadLabel]="markAllAsReadLabel"
                                        [settingsLabel]="settingsLabel"
                                        [isShowPriority]="isShowPriority">
                </ux-notifications-panel>
            </uxLayoutNavBarOverlayPanelContent>
        </ux-layout-nav-bar-action-item>
    `,
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutNavBarActionItemNotificationsComponent.ctorParameters = () => [
    { type: UxService, },
];
UxLayoutNavBarActionItemNotificationsComponent.propDecorators = {
    "notificationLinks": [{ type: Input },],
    "unreadNotificationsCount": [{ type: Input },],
    "isRenderHTML": [{ type: Input },],
    "isShowViewAllAction": [{ type: Input },],
    "isShowUnreadNotificationsCountAsBullet": [{ type: Input },],
    "isShowTotalNotifications": [{ type: Input },],
    "isShowRefreshButton": [{ type: Input },],
    "isHidePanelOnViewAllAction": [{ type: Input },],
    "isShowBadge": [{ type: Input },],
    "hideBagdeOnClick": [{ type: Input },],
    "customUnreadCount": [{ type: Input },],
    "nbUnreadCount": [{ type: Input },],
    "viewAllNotificationsLabel": [{ type: Input },],
    "headerTitleLabel": [{ type: Input },],
    "noNotificationFoundLabel": [{ type: Input },],
    "todaysSeparatorLabel": [{ type: Input },],
    "oldestSeparatorLabel": [{ type: Input },],
    "unreadLabel": [{ type: Input },],
    "totalLabel": [{ type: Input },],
    "markAsReadLabel": [{ type: Input },],
    "markAsUnReadLabel": [{ type: Input },],
    "markAllAsReadLabel": [{ type: Input },],
    "settingsLabel": [{ type: Input },],
    "isShowPriority": [{ type: Input },],
    "notificationsRefreshClick": [{ type: Output },],
    "notificationsViewAllClick": [{ type: Output },],
    "notificationsItemClick": [{ type: Output },],
    "notificationsItemMarkAsRead": [{ type: Output },],
    "notificationsItemMarkAsUnRead": [{ type: Output },],
    "iconClick": [{ type: Output },],
    "notificationsMarkAllAsRead": [{ type: Output },],
    "notificationsSettings": [{ type: Output },],
    "uxLayoutNavBarActionItemComponent": [{ type: ViewChild, args: [UxLayoutNavBarActionItemComponent,] },],
};
class UxLayoutNavBarActionItemNotificationsComponentModule {
}
UxLayoutNavBarActionItemNotificationsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxLayoutNavBarActionItemComponentModule, UxNotificationsPanelComponentModule],
                exports: [UxLayoutNavBarActionItemNotificationsComponent],
                declarations: [UxLayoutNavBarActionItemNotificationsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarTopMenuComponent {
    /**
     * @param {?} asService
     */
    constructor(asService) {
        this.asService = asService;
        this.homeUrl = '/screen/home';
        this.isShowHome = true;
        this.menuItemClicked = new EventEmitter();
        this.links = [];
        this.linksSubscription = asService.state$.subscribe((state) => {
            this.links = state.menuLinks;
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.linksSubscription) {
            this.linksSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    onHomeClick() {
        let /** @type {?} */ link = new UxLink({ id: 'home', url: this.homeUrl });
        this.onLinkClick(link);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onLinkClick(link) {
        if (link.url) {
            window.scrollTo(0, 0);
        }
        if (!link.disabled) {
            this.menuItemClicked.emit(link);
        }
        if (link.urlExternal) {
            window.open(link.urlExternal, '_blank');
        }
        if (link.command) {
            link.command();
        }
    }
}
UxLayoutNavBarTopMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-top-menu',
                template: `
        <nav id="top-menu" *ngIf="links && links.length !== 0">
            <ul>
                <li *ngIf="isShowHome" class="icon-menu-item"
                    routerLinkActive="selected" [routerLinkActiveOptions]="{exact:true}">
                    <a [routerLink]="homeUrl" (click)="onHomeClick()" class="icon-home-link">
                        <span class="ux-icon ux-icon-2x ux-icon-home"></span>
                    </a>
                </li>

                <li *ngFor="let link of links" [class.has-sub]="link.hasChildren" routerLinkActive="selected">
                    <ng-template [ngIf]="link.visible && !link.isHome">
                        <a *ngIf="!link.url" (click)="onLinkClick(link)">
                            <i *ngIf="link.iconClass" class="{{ link.iconClass }} ux-icon-fw"></i> {{link.label}}
                        </a>
                        <a *ngIf="link.url" [routerLink]="link.url" (click)="onLinkClick(link)">
                            <i *ngIf="link.iconClass" class="{{ link.iconClass }} ux-icon-fw"></i> {{link.label}}
                        </a>
                        <ul *ngIf="link.hasChildren">
                            <li class="child" *ngFor="let childLink of link.children"
                                [class.has-sub]="childLink.hasChildren" [class.hidden]="!childLink.visible">
                                <ng-template [ngIf]="childLink.visible">
                                    <a *ngIf="!childLink.url"
                                        [class.disabled]="childLink.disabled"
                                        (click)="onLinkClick(childLink)">
                                        <i *ngIf="childLink.iconClass" class="{{ childLink.iconClass }} ux-icon-fw"></i>
                                        {{childLink.label}}
                                    </a>
                                    <a *ngIf="childLink.url"
                                        [class.disabled]="childLink.disabled"
                                        [routerLink]="childLink.url"
                                        (click)="onLinkClick(childLink)">
                                        <i *ngIf="childLink.iconClass" class="{{ childLink.iconClass }} ux-icon-fw"></i>
                                        {{childLink.label}}
                                    </a>
                                    <ul *ngIf="childLink.hasChildren">
                                        <li class="child" *ngFor="let childSubLink of childLink.children">
                                            <ng-template [ngIf]="childSubLink.visible">
                                                <a *ngIf="childSubLink.url"
                                                    [class.disabled]="childSubLink.disabled"
                                                    [routerLink]="childSubLink.url"
                                                    (click)="onLinkClick(childSubLink)">
                                                    <i *ngIf="childSubLink.iconClass"
                                                        class="{{ childSubLink.iconClass }} ux-icon-fw"></i>
                                                    {{childSubLink.label}}
                                                    </a>
                                                <a *ngIf="!childSubLink.url"
                                                    [class.disabled]="childSubLink.disabled"
                                                    (click)="onLinkClick(childSubLink)">
                                                    <i *ngIf="childSubLink.iconClass"
                                                        class="{{ childSubLink.iconClass }} ux-icon-fw"></i>
                                                    {{childSubLink.label}}
                                                    </a>
                                            </ng-template>
                                        </li>
                                    </ul>
                                </ng-template>
                            </li>
                        </ul>
                    </ng-template>
                </li>
            </ul>
        </nav>
    `,
                styles: [`
        :host {
            display: block;
            width: 100%;
        }
    `],
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutNavBarTopMenuComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxLayoutNavBarTopMenuComponent.propDecorators = {
    "homeUrl": [{ type: Input },],
    "isShowHome": [{ type: Input },],
    "menuItemClicked": [{ type: Output },],
};
class UxLayoutNavBarTopMenuComponentModule {
}
UxLayoutNavBarTopMenuComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [UxLayoutNavBarTopMenuComponent],
                declarations: [UxLayoutNavBarTopMenuComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarLeftActionItemComponent {
    constructor() {
        this.itemClass = '';
        this.isStatic = false;
    }
}
UxLayoutNavBarLeftActionItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-left-action-item',
                template: `
        <div class="ux-layout-nav-bar__action-item {{itemClass}}"
            [class.d-none.d-lg-block]="isHiddenMobile" [class.not-hoverable]="isStatic">
            <ng-content></ng-content>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutNavBarLeftActionItemComponent.propDecorators = {
    "itemClass": [{ type: Input },],
    "isHiddenMobile": [{ type: Input },],
    "isStatic": [{ type: Input },],
};
class UxLayoutNavBarLeftActionItemComponentModule {
}
UxLayoutNavBarLeftActionItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutNavBarLeftActionItemComponent],
                declarations: [UxLayoutNavBarLeftActionItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarLeftActionsComponent {
}
UxLayoutNavBarLeftActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-left-actions',
                template: `
        <div class="ux-layout-nav-bar__left-actions">
            <ng-content></ng-content>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
class UxLayoutNavBarLeftActionsComponentModule {
}
UxLayoutNavBarLeftActionsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutNavBarLeftActionsComponent],
                declarations: [UxLayoutNavBarLeftActionsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutNavBarLeftActionItemSidebarToggleComponent {
    /**
     * @param {?} uxAppShellService
     */
    constructor(uxAppShellService) {
        this.uxAppShellService = uxAppShellService;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggleSidebar(event) {
        this.uxAppShellService.setState(Object.assign({}, this.uxAppShellService.state, { isSidebarOpen: !this.uxAppShellService.state.isSidebarOpen }));
    }
}
UxLayoutNavBarLeftActionItemSidebarToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-nav-bar-left-action-item-sidebar-toggle',
                template: `
        <div class="ux-layout-nav-bar__action-item d-none d-lg-block" (click)="onToggleSidebar($event)">
            <a href="javascript:void(0);" class="ux-layout-nav-bar__action-item-icon-toggle">
                <span class="ux-layout-nav-bar__action-item-icon-toggle-icon ux-icon ux-icon-bars"></span>
            </a>
        </div>
        <div *ngIf="label"
             class="ux-layout-nav-bar__action-item ux-layout-nav-bar__action-item-label d-none d-lg-block"
             (click)="onToggleSidebar($event)">
                {{label}}
        </div>
    `,
                styles: [`
        :host {
            display: flex;
        }
    `],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutNavBarLeftActionItemSidebarToggleComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxLayoutNavBarLeftActionItemSidebarToggleComponent.propDecorators = {
    "label": [{ type: Input },],
};
class UxLayoutNavBarLeftActionItemSidebarToggleComponentModule {
}
UxLayoutNavBarLeftActionItemSidebarToggleComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutNavBarLeftActionItemSidebarToggleComponent],
                declarations: [UxLayoutNavBarLeftActionItemSidebarToggleComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutSidebarComponent {
    /**
     * @param {?} uxService
     * @param {?} asService
     * @param {?} document
     */
    constructor(uxService, asService, document) {
        this.uxService = uxService;
        this.asService = asService;
        this.document = document;
        this.homeUrl = '/screen/home';
        this.isShowLogo = false;
        this.isLargeItems = false;
        this.hasFilter = false;
        this.filterPlaceholderLabel = 'Filter';
        this.isInnerSidebar = false;
        // as sub-transclusion contentChildren does not work : https://github.com/angular/angular/issues/16299
        // @Input() items: QueryList<UxLayoutSidebarItemComponent>;
        this.toggled = new EventEmitter();
        this.clicked = new EventEmitter();
        this.topPosition = 0;
        this.subscription = this.uxService.windowWidth$.subscribe(width => {
            this.calculatePosition();
        });
    }
    /**
     * @return {?}
     */
    onWindowScroll() {
        this.calculatePosition();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.theme) {
            this.themeClass = 'sidebar--t-' + this.theme;
        }
        if (this.isInnerSidebar) {
            this.isLargeItems = true;
        }
        this.calculatePosition();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @param {?} id
     * @return {?}
     */
    onClick(id) {
        if (id) {
            this.clicked.emit(id);
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onSidebarItemToggle(item) {
        if (!this.uxService.isSidebarStateOpen) {
            this.uxService.isSidebarStateOpen = true;
        }
        this.toggled.next(item);
    }
    /**
     * @return {?}
     */
    calculatePosition() {
        if (!this.isInnerSidebar) {
            this.topPosition = 0;
        }
        else {
            let /** @type {?} */ position = 0;
            const /** @type {?} */ navBar = this.document.getElementById('nav-bar');
            if (navBar) {
                position = navBar.getBoundingClientRect().bottom;
            }
            if (position >= 0) {
                this.topPosition = position;
            }
            else {
                this.topPosition = 0;
            }
        }
    }
}
UxLayoutSidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-sidebar',
                template: `
        <div class="sidebar {{themeClass}}"
            [class.inner-sidebar]="isInnerSidebar"
            [class.sidebar--large-items]="isLargeItems"
            [style.top.px]="topPosition">

            <div class="logo-wrapper" *ngIf="isShowLogo">
                <a [routerLink]="homeUrl">
                    <div class="logo"></div>
                </a>
            </div>

            <div class="sidebar-inner">

                <ng-template [ngIf]="customContent">
                    <ng-content select="uxLayoutSidebarContent"></ng-content>
                </ng-template>

                <ng-template [ngIf]="!customContent">

                    <div *ngIf="titleLabel" class="title">{{titleLabel}}</div>

                    <div class="header" *ngIf="customHeaderContent">
                        <ng-content select="uxLayoutSidebarHeader"></ng-content>
                    </div>

                    <div class="filter" *ngIf="hasFilter">
                        <input type="text" #sidebarFilter placeholder="{{filterPlaceholderLabel}}"/>
                        <span class="ux-icon ux-icon-search"></span>
                    </div>

                    <ux-layout-sidebar-items [links]="(asService.state$ | async).sidebarLinks"
                                             [isLargeItems]="isLargeItems"
                                             [isInnerSidebar]="isInnerSidebar"
                                             (toggled)="onSidebarItemToggle($event)">
                    </ux-layout-sidebar-items>

                </ng-template>
            </div>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutSidebarComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxAppShellService, },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
];
UxLayoutSidebarComponent.propDecorators = {
    "homeUrl": [{ type: Input },],
    "titleLabel": [{ type: Input },],
    "isShowLogo": [{ type: Input },],
    "isLargeItems": [{ type: Input },],
    "hasFilter": [{ type: Input },],
    "filterPlaceholderLabel": [{ type: Input },],
    "isInnerSidebar": [{ type: Input },],
    "theme": [{ type: Input },],
    "toggled": [{ type: Output },],
    "clicked": [{ type: Output },],
    "customHeaderContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutSidebarHeaderTagDirective),] },],
    "customContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutSidebarContentTagDirective),] },],
    "onWindowScroll": [{ type: HostListener, args: ['window:scroll', [],] },],
};
class UxLayoutSidebarHeaderTagDirective {
}
UxLayoutSidebarHeaderTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutSidebarHeader' },] },
];
class UxLayoutSidebarContentTagDirective {
}
UxLayoutSidebarContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutSidebarContent' },] },
];
class UxLayoutSidebarComponentModule {
}
UxLayoutSidebarComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, RouterModule,
                    UxLayoutSidebarItemComponentModule, UxLayoutSidebarItemsComponentModule,
                ],
                exports: [
                    UxLayoutSidebarComponent,
                    UxLayoutSidebarHeaderTagDirective,
                    UxLayoutSidebarContentTagDirective,
                ],
                declarations: [
                    UxLayoutSidebarComponent,
                    UxLayoutSidebarHeaderTagDirective,
                    UxLayoutSidebarContentTagDirective,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutAppShellComponent {
    /**
     * @param {?} uxService
     * @param {?} uxAppShellService
     */
    constructor(uxService, uxAppShellService) {
        this.uxService = uxService;
        this.uxAppShellService = uxAppShellService;
        // GLOBAL
        this.appHomeUrl = '/screen/home';
        this.isContract = false;
        this.isContractMedium = false;
        this.isContractSmall = false;
        this.isScrollHandlerActive = true;
        this.isErrorState = false;
        // HEADER
        this.hasHeader = true;
        this.hasHeaderUserProfile = false;
        this.hasHeaderProfileAvatar = false;
        this.isHeaderHideLogo = false;
        this.isHeaderShowLanguageSelector = true;
        this.isHeaderHomeUrlActive = true;
        this.headerLanguageChanged = new EventEmitter();
        this.headerUserProfileLinkSelected = new EventEmitter();
        // NAV BAR
        this.hasNavBar = true;
        this.navBarTopMenuLinks = [];
        this.navBarTopMenuHomeUrl = '/screen/home';
        this.isNavBarTopMenuShowHome = true;
        this.isNavBarMuted = false;
        this.navBarNotificationLinks = [];
        this.isNavBarMobileSidebarTemplateLinks = false;
        this.navBarTopMenuItemClicked = new EventEmitter();
        this.navBarNotificationsRefreshClick = new EventEmitter();
        this.navBarNotificationsViewAllClick = new EventEmitter();
        this.navBarNotificationsItemClick = new EventEmitter();
        this.navBarNotificationsItemMarkAsRead = new EventEmitter();
        this.navBarNotificationsItemMarkAsUnRead = new EventEmitter();
        // FOOTER
        this.isFooterCompact = true;
        this.footerAppVersion = '@app.version@';
        this.footerAppReleaseDate = '@app.release.date@';
        this.isFooterStyleInverse = false;
        this.hasFooter = true;
        // SIDEBAR
        this.hasSidebar = false;
        this.isSidebarInner = false;
        this.sidebarLinks = [];
        this.isSidebarShowLogo = false;
        this.isSidebarLargeItems = false;
        this.isSidebarStateCloseWithIcons = true;
        this.isSidebarMobileVisible = false;
        this.hasSidebarFilter = false;
        this.isSidebarOpen = true;
        this.isDebugState = false;
        this.sidebarItemToggle = new EventEmitter();
        this.isMobile = false;
        this.isTablet = false;
        this.mobileMenuLinks = [];
        this.appShellStateSubscription = uxAppShellService.state$.subscribe((state) => {
            if (this.isDebugState) {
                console.log('ux-layout-app-shell : state subscription : ', state);
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ cSidebarLinks = changes['sidebarLinks'];
        const /** @type {?} */ cMenuLinks = changes['navBarTopMenuLinks'];
        let /** @type {?} */ hasChanged = false;
        if (cSidebarLinks) {
            if (cSidebarLinks.previousValue && cSidebarLinks.currentValue) {
                if (cSidebarLinks.previousValue.join() !== cSidebarLinks.currentValue.join()) {
                    hasChanged = true;
                }
            }
        }
        if (cMenuLinks) {
            if (cMenuLinks.previousValue && cMenuLinks.currentValue) {
                if (cMenuLinks.previousValue.join() !== cMenuLinks.currentValue.join()) {
                    hasChanged = true;
                }
            }
        }
        if (hasChanged) {
            this.uxAppShellService.setState(Object.assign({}, this.uxAppShellService.state, { sidebarLinks: this.sidebarLinks, menuLinks: this.navBarTopMenuLinks }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        console.log('ux-layout-app-shell : init application state');
        this.uxAppShellService.setState(Object.assign({}, this.uxAppShellService.state, { isSidebarOpen: this.isSidebarOpen, isSidebarActive: this.hasSidebar && !this.isSidebarInner, isSidebarInnerActive: this.isSidebarInner, isSidebarStateCloseWithIcons: this.isSidebarStateCloseWithIcons, windowHeight: window.innerHeight, windowWidth: window.innerWidth, menuLinks: this.navBarTopMenuLinks, sidebarLinks: this.sidebarLinks }));
        // DEPRECATED start
        this.uxService.setActiveBreakpoint(window.innerWidth);
        this.uxService.setWindowHeight(window.innerHeight);
        // DEPRECATED end
        this.windowResizedSubscription = fromEvent(window, 'resize')
            .debounceTime(300)
            .subscribe((event) => {
            this.uxAppShellService.setState(Object.assign({}, this.uxAppShellService.state, { windowHeight: window.innerHeight, windowWidth: window.innerWidth }));
            // DEPRECATED start
            this.uxService.setActiveBreakpoint(window.innerWidth);
            this.uxService.setWindowHeight(window.innerHeight);
            // DEPRECATED end
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.appClasses = '';
        if (this.styleClass) {
            this.appClasses += ' ' + this.styleClass;
        }
        if (this.themeClass) {
            this.appClasses += ' ' + this.themeClass;
        }
        if (this.isContract) {
            this.appClasses += ' contract';
        }
        if (this.isContractMedium) {
            this.appClasses += ' contract-half';
        }
        if (this.isContractSmall) {
            this.appClasses += ' contract-quarter';
        }
        if (this.isSidebarShowLogo) {
            this.isHeaderHideLogo = true;
        }
    }
    /**
     * @param {?} uxLanguage
     * @return {?}
     */
    onHeaderLanguageChanged(uxLanguage) {
        this.headerSelectedLanguage = uxLanguage;
        this.headerLanguageChanged.emit(uxLanguage);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onHeaderUserProfileLinkSelected(uxLink) {
        this.headerUserProfileLinkSelected.emit(uxLink);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onTopMenuItemClicked(uxLink) {
        this.navBarTopMenuItemClicked.emit(uxLink);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onSidebarItemToggle(item) {
        this.sidebarItemToggle.next(item);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.windowResizedSubscription) {
            this.windowResizedSubscription.unsubscribe();
        }
        if (this.appShellStateSubscription) {
            this.appShellStateSubscription.unsubscribe();
        }
    }
}
UxLayoutAppShellComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-app-shell',
                template: "<div id=\"app-wrapper\" [uxScrollHandler]=\"isScrollHandlerActive\" class=\"{{appClasses}} {{(uxAppShellService.state$ | async).wrapperClasses}}\"> <ux-layout-sidebar *ngIf=\"hasSidebar && !isSidebarInner\" titleLabel=\"{{sidebarTitle}}\" [isShowLogo]=\"isSidebarShowLogo\" [isLargeItems]=\"isSidebarLargeItems\" [isInnerSidebar]=\"isSidebarInner\" [hasFilter]=\"hasSidebarFilter\" theme=\"{{sidebarTheme}}\" (toggled)=\"onSidebarItemToggle($event)\"> <uxLayoutSidebarHeader *ngIf=\"customSidebarHeaderContent.length !== 0\"> <ng-content select=\"uxAppShellSidebarHeaderContent\"></ng-content> </uxLayoutSidebarHeader> </ux-layout-sidebar> <div id=\"main\" role=\"main\"> <ng-template [ngIf]=\"customTopMessage.length !== 0\"> <uxLayoutSidebarHeader> <ng-content select=\"uxAppShellTopMessageContent\"></ng-content> </uxLayoutSidebarHeader> </ng-template> <ux-layout-header *ngIf=\"hasHeader\" appFullName=\"{{headerAppFullName}}\" appShortName=\"{{headerAppShortName}}\" appSubtitle=\"{{headerAppSubtitle}}\" [userInfos]=\"headerUserInfos\" [userInfosIcon]=\"headerUserInfosIcon\" homeUrl=\"{{appHomeUrl}}\" [userProfileLinks]=\"headerUserProfileLinks\" [isHideLogo]=\"isHeaderHideLogo\" [isShowLanguageSelector]=\"isHeaderShowLanguageSelector\" [isCustomTitleContent]=\"customHeaderTitleContent.length !== 0\" [isCustomRightContent]=\"customHeaderRightContent.length !== 0\" envLabel=\"{{headerEnvLabel}}\" [languageCodes]=\"headerLanguageCodes\" [additionalLanguages]=\"headerAdditionalLanguages\" [selectedLanguage]=\"headerSelectedLanguage\" (languageChanged)=\"onHeaderLanguageChanged($event)\" [isHomeUrlActive]=\"isHeaderHomeUrlActive\" (userProfileLinkSelected)=\"onHeaderUserProfileLinkSelected($event)\" [isErrorState]=\"isErrorState\"> <uxLayoutHeaderTitleContent *ngIf=\"customHeaderTitleContent.length !== 0\"> <ng-content select=\"uxAppShellHeaderTitleContent\"></ng-content> </uxLayoutHeaderTitleContent> <uxLayoutHeaderRightContent *ngIf=\"customHeaderRightContent.length !== 0\"> <ng-content select=\"uxAppShellHeaderRightContent\"></ng-content> </uxLayoutHeaderRightContent> </ux-layout-header> <ng-template [ngIf]=\"hasNavBar\"> <ng-template [ngIf]=\"isNavBarMuted || isErrorState\"> <ux-layout-nav-bar [isMuted]=\"true\"></ux-layout-nav-bar> </ng-template> <ng-template [ngIf]=\"!isNavBarMuted && !isErrorState\"> <ux-layout-nav-bar styleClass=\"navBarStyleClass\"> <uxLayoutNavBarLeftActionsContent> <ux-layout-nav-bar-left-actions> <ux-layout-nav-bar-left-action-item-sidebar-toggle *ngIf=\"isSidebarInner && hasSidebar\" label=\"{{navBarSidebarToggleLabel}}\"> </ux-layout-nav-bar-left-action-item-sidebar-toggle> <ng-template [ngIf]=\"customNavBarLeftItemsContent.length !== 0\"> <ng-content select=\"uxAppShellNavBarLeftItemsContent\"></ng-content> </ng-template> </ux-layout-nav-bar-left-actions> </uxLayoutNavBarLeftActionsContent> <ux-layout-nav-bar-top-menu homeUrl=\"{{navBarTopMenuHomeUrl}}\" [isShowHome]=\"isNavBarTopMenuShowHome\" (menuItemClicked)=\"onTopMenuItemClicked($event)\"> </ux-layout-nav-bar-top-menu> <ux-layout-nav-bar-actions> <ng-template [ngIf]=\"customNavBarItemsContent.length !== 0\"> <ng-content select=\"uxAppShellNavBarItemsContent\"></ng-content> </ng-template> <ux-layout-nav-bar-action-item-notifications *ngIf=\"navBarNotificationLinks.length !== 0\" [notificationLinks]=\"navBarNotificationLinks\" (notificationsRefreshClick)=\"navBarNotificationsRefreshClick.emit($event)\" (notificationsViewAllClick)=\"navBarNotificationsViewAllClick.emit($event)\" (notificationsItemClick)=\"navBarNotificationsItemClick.emit($event)\" (notificationsItemMarkAsRead)=\"navBarNotificationsItemMarkAsRead.emit($event)\" (notificationsItemMarkAsUnRead)=\"navBarNotificationsItemMarkAsUnRead.emit($event)\"> </ux-layout-nav-bar-action-item-notifications> <ux-layout-nav-bar-action-item iconClass=\"ux-icon ux-icon-bars\" [isHiddenDesktop]=\"true\" [isOverlayPanel]=\"true\" [isUseSidebarTemplateAsLinks]=\"isNavBarMobileSidebarTemplateLinks\" [userInfos]=\"headerUserInfos\" [headerUserProfileLinks]=\"headerUserProfileLinks\" [languageCodes]=\"headerLanguageCodes\" [additionalLanguages]=\"headerAdditionalLanguages\" [selectedLanguage]=\"headerSelectedLanguage\" (languageChanged)=\"onHeaderLanguageChanged($event)\" [isShowLanguageSelector]=\"isHeaderShowLanguageSelector\" (userProfileLinkSelected)=\"onHeaderUserProfileLinkSelected($event)\"> <uxLayoutNavBarOverlayPanelHeaderContent> <ng-content select=\"uxAppShellOverlayPanelHeaderContent\"></ng-content> </uxLayoutNavBarOverlayPanelHeaderContent> </ux-layout-nav-bar-action-item> </ux-layout-nav-bar-actions> </ux-layout-nav-bar> </ng-template> </ng-template> <div id=\"main-content\"> <ux-layout-sidebar *ngIf=\"hasSidebar && isSidebarInner\" titleLabel=\"{{sidebarTitle}}\" [isInnerSidebar]=\"isSidebarInner\" [isShowLogo]=\"isSidebarShowLogo\" [isLargeItems]=\"isSidebarLargeItems\" theme=\"{{sidebarTheme}}\" (toggled)=\"onSidebarItemToggle($event)\"> </ux-layout-sidebar> <ng-template [ngIf]=\"customMainContent.length === 0 && !isErrorState\"> <router-outlet></router-outlet> </ng-template> <ng-template [ngIf]=\"customMainContent.length !== 0\"> <ng-content select=\"uxAppShellMainContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"isErrorState && customErrorStateContent.length !== 0\"> <ng-content select=\"uxAppShellErrorStateContent\"></ng-content> </ng-template> </div> <!-- #main-content end --> <ux-layout-footer *ngIf=\"hasFooter\" [isCompact]=\"isFooterCompact\" [isStyleInverse]=\"isFooterStyleInverse\"> <ng-template [ngIf]=\"customFooterContent.length === 0\"> version <strong [ngClass]=\"isFooterStyleInverse ? 'ux-u-color-accent' : 'ux-u-color-primary'\"> {{footerAppVersion}}</strong> - {{footerAppReleaseDate}} </ng-template> <ng-template [ngIf]=\"customFooterContent.length !== 0\"> <ng-content select=\"uxAppShellFooterContent\"></ng-content> </ng-template> </ux-layout-footer> </div> <!-- #main end --> <ux-growl [value]=\"uxService.growlMessages\" [sticky]=\"uxService.isGrowlSticky\" [life]=\"uxService.growlLife\" [position]=\"uxService.growlPosition\"></ux-growl> <ux-block-document [isBlocked]=\"(uxAppShellService.state$ | async).isBlockDocumentActive\"></ux-block-document> </div> ",
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutAppShellComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxAppShellService, },
];
UxLayoutAppShellComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "appHomeUrl": [{ type: Input },],
    "themeClass": [{ type: Input },],
    "isContract": [{ type: Input },],
    "isContractMedium": [{ type: Input },],
    "isContractSmall": [{ type: Input },],
    "isScrollHandlerActive": [{ type: Input },],
    "isErrorState": [{ type: Input },],
    "hasHeader": [{ type: Input },],
    "headerAppFullName": [{ type: Input },],
    "headerAppShortName": [{ type: Input },],
    "headerAppSubtitle": [{ type: Input },],
    "headerUserInfos": [{ type: Input },],
    "headerUserInfosIcon": [{ type: Input },],
    "hasHeaderUserProfile": [{ type: Input },],
    "hasHeaderProfileAvatar": [{ type: Input },],
    "headerUserProfileLinks": [{ type: Input },],
    "isHeaderHideLogo": [{ type: Input },],
    "isHeaderShowLanguageSelector": [{ type: Input },],
    "languageCodes": [{ type: Input },],
    "headerEnvLabel": [{ type: Input },],
    "headerLanguageCodes": [{ type: Input },],
    "headerAdditionalLanguages": [{ type: Input },],
    "headerSelectedLanguage": [{ type: Input },],
    "isHeaderHomeUrlActive": [{ type: Input },],
    "headerLanguageChanged": [{ type: Output },],
    "headerUserProfileLinkSelected": [{ type: Output },],
    "hasNavBar": [{ type: Input },],
    "navBarTopMenuLinks": [{ type: Input },],
    "navBarTopMenuHomeUrl": [{ type: Input },],
    "isNavBarTopMenuShowHome": [{ type: Input },],
    "isNavBarMuted": [{ type: Input },],
    "navBarStyleClass": [{ type: Input },],
    "navBarSidebarToggleLabel": [{ type: Input },],
    "navBarNotificationLinks": [{ type: Input },],
    "isNavBarMobileSidebarTemplateLinks": [{ type: Input },],
    "navBarTopMenuItemClicked": [{ type: Output },],
    "navBarNotificationsRefreshClick": [{ type: Output },],
    "navBarNotificationsViewAllClick": [{ type: Output },],
    "navBarNotificationsItemClick": [{ type: Output },],
    "navBarNotificationsItemMarkAsRead": [{ type: Output },],
    "navBarNotificationsItemMarkAsUnRead": [{ type: Output },],
    "isFooterCompact": [{ type: Input },],
    "footerAppVersion": [{ type: Input },],
    "footerAppReleaseDate": [{ type: Input },],
    "isFooterStyleInverse": [{ type: Input },],
    "hasFooter": [{ type: Input },],
    "hasSidebar": [{ type: Input },],
    "isSidebarInner": [{ type: Input },],
    "sidebarLinks": [{ type: Input },],
    "sidebarTitle": [{ type: Input },],
    "isSidebarShowLogo": [{ type: Input },],
    "isSidebarLargeItems": [{ type: Input },],
    "isSidebarStateCloseWithIcons": [{ type: Input },],
    "isSidebarMobileVisible": [{ type: Input },],
    "hasSidebarFilter": [{ type: Input },],
    "sidebarTheme": [{ type: Input },],
    "isSidebarOpen": [{ type: Input },],
    "isDebugState": [{ type: Input },],
    "sidebarItemToggle": [{ type: Output },],
    "customSidebarContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellSidebarContentTagDirective),] },],
    "customSidebarHeaderContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellSidebarHeaderContentTagDirective),] },],
    "customHeaderRightContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellHeaderRightContentTagDirective),] },],
    "customHeaderTitleContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellHeaderTitleContentTagDirective),] },],
    "customMainContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellMainContentTagDirective),] },],
    "customNavBarItemsContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellNavBarItemsContentTagDirective),] },],
    "customNavBarLeftItemsContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellNavBarLeftItemsContentTagDirective),] },],
    "customFooterContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellFooterContentTagDirective),] },],
    "sidebarItems": [{ type: ContentChildren, args: [forwardRef(() => UxLayoutSidebarItemComponent), { descendants: true },] },],
    "customTopMessage": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellTopMessageContentTagDirective),] },],
    "customErrorStateContent": [{ type: ContentChildren, args: [forwardRef(() => UxAppShellErrorStateContentTagDirective),] },],
};
class UxAppShellSidebarContentTagDirective {
}
UxAppShellSidebarContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellSidebarContent' },] },
];
class UxAppShellSidebarHeaderContentTagDirective {
}
UxAppShellSidebarHeaderContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellSidebarHeaderContent' },] },
];
class UxAppShellHeaderRightContentTagDirective {
}
UxAppShellHeaderRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellHeaderRightContent' },] },
];
class UxAppShellHeaderTitleContentTagDirective {
}
UxAppShellHeaderTitleContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellHeaderTitleContent' },] },
];
class UxAppShellMainContentTagDirective {
}
UxAppShellMainContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellMainContent' },] },
];
class UxAppShellNavBarItemsContentTagDirective {
}
UxAppShellNavBarItemsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellNavBarItemsContent' },] },
];
class UxAppShellNavBarLeftItemsContentTagDirective {
}
UxAppShellNavBarLeftItemsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellNavBarLeftItemsContent' },] },
];
class UxAppShellFooterContentTagDirective {
}
UxAppShellFooterContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellFooterContent' },] },
];
class UxAppShellOverlayPanelHeaderTagDirective {
}
UxAppShellOverlayPanelHeaderTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellOverlayPanelHeaderContent' },] },
];
class UxAppShellTopMessageContentTagDirective {
}
UxAppShellTopMessageContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellTopMessageContent' },] },
];
class UxAppShellErrorStateContentTagDirective {
}
UxAppShellErrorStateContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxAppShellErrorStateContent' },] },
];
class UxLayoutAppShellComponentModule {
}
UxLayoutAppShellComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    UxGrowlComponentModule,
                    UxBlockDocumentComponentModule,
                    UxScrollHandlerDirectiveModule,
                    UxLayoutHeaderComponentModule,
                    UxLayoutFooterComponentModule,
                    UxLayoutNavBarComponentModule,
                    UxLayoutNavBarActionsComponentModule,
                    UxLayoutNavBarActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemSidebarToggleComponentModule,
                    UxLayoutNavBarLeftActionsComponentModule,
                    UxLayoutNavBarActionItemNotificationsComponentModule,
                    UxLayoutNavBarTopMenuComponentModule,
                    UxLayoutSidebarComponentModule,
                ],
                exports: [
                    UxLayoutAppShellComponent,
                    UxAppShellSidebarContentTagDirective,
                    UxAppShellSidebarHeaderContentTagDirective,
                    UxAppShellHeaderRightContentTagDirective,
                    UxAppShellHeaderTitleContentTagDirective,
                    UxAppShellMainContentTagDirective,
                    UxAppShellNavBarItemsContentTagDirective,
                    UxAppShellNavBarLeftItemsContentTagDirective,
                    UxAppShellFooterContentTagDirective,
                    UxAppShellOverlayPanelHeaderTagDirective,
                    UxAppShellTopMessageContentTagDirective,
                    UxAppShellErrorStateContentTagDirective,
                ],
                declarations: [
                    UxLayoutAppShellComponent,
                    UxAppShellSidebarContentTagDirective,
                    UxAppShellSidebarHeaderContentTagDirective,
                    UxAppShellHeaderRightContentTagDirective,
                    UxAppShellHeaderTitleContentTagDirective,
                    UxAppShellMainContentTagDirective,
                    UxAppShellNavBarItemsContentTagDirective,
                    UxAppShellNavBarLeftItemsContentTagDirective,
                    UxAppShellFooterContentTagDirective,
                    UxAppShellOverlayPanelHeaderTagDirective,
                    UxAppShellTopMessageContentTagDirective,
                    UxAppShellErrorStateContentTagDirective,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimezones {
    constructor() {
        this.primary = 'Europe/Brussels';
        this.secondary = 'Europe/Brussels';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutHeaderProfileComponent {
    /**
     * @param {?} uxService
     * @param {?} tzService
     */
    constructor(uxService, tzService) {
        this.uxService = uxService;
        this.tzService = tzService;
        this.languageCodes = '';
        this.isConnected = false;
        this.isOnline = false;
        this.isShowTimeWrapper = false;
        this.isUserLoggedIn = true;
        this.welcomeLabel = 'Welcome';
        this.isAvailableUserStateBullet = true;
        // deprecated start
        this.utcLocalCityName = 'Brussels';
        this.utcLocalCityTooltip = 'My local time';
        this.utcLocalOffset = +1;
        this.utcForeignCityName = 'Addis-Abeba';
        this.utcForeignCityTooltip = 'Foreign time';
        this.utcForeignOffset = +2;
        // deprecated end
        this.timezones = new UxTimezones();
        this.languageChanged = new EventEmitter();
        this.formattedDateTimeSeparatorPattern = /\s\W\s/g;
        this.isProfileDropdownVisible = false;
        this.localTime = new Date();
    }
    /**
     * @return {?}
     */
    closeProfileDropdown() {
        this.isProfileDropdownVisible = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        let /** @type {?} */ ttimer = timer(0, 60000);
        ttimer.subscribe(t => {
            this.localTime = new Date();
        });
    }
    /**
     * @param {?} language
     * @return {?}
     */
    onLanguageChanged(language) {
        this.languageChanged.emit(language);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggleProfileDropdown(event) {
        this.isProfileDropdownVisible = !this.isProfileDropdownVisible;
        this.uxService.consumeEvent(event);
    }
}
UxLayoutHeaderProfileComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-header-profile',
                template: "<div class=\"profile-wrapper\"> <div class=\"left-panel\"> <div class=\"user-infos\"> <ng-template [ngIf]=\"isUserLoggedIn\"> {{welcomeLabel}} <strong class=\"ux-u-color-primary\">{{userInfos}}</strong> </ng-template> </div> <div *ngIf=\"isShowTimeWrapper\" class=\"time-wrapper\"> <div class=\"current-time\"> <span class=\"ux-icon ion-ios-clock-outline\"></span> <span> {{localTime | uxMomentTz: timezones?.primary | amDateFormat: 'HH:mm'}} </span> <span class=\"utc-time\"> <span class=\"ux-icon ion-location mr-1\"></span> {{tzService.getTimezone(timezones?.primary)?.desc}} </span> </div> <div class=\"utc-time\"> <span class=\"ux-icon ion-location mr-1\"></span> {{tzService.getTimezone(timezones?.secondary)?.desc}} <span> {{localTime | uxMomentTz: timezones?.secondary | amDateFormat: 'HH:mm'}} </span> </div> </div> <div *ngIf=\"!isShowTimeWrapper\" class=\"sub-content-wrapper\"> <ng-content select=\"uxLayoutHeaderProfileSubContent\"></ng-content> </div> </div> <div *ngIf=\"isUserLoggedIn\" class=\"right-panel\" (click)=\"onToggleProfileDropdown($event)\"> <div class=\"picture\"> <div class=\"connected-state\"> <span class=\"pulse-ring connect red\"></span> <span *ngIf=\"isConnected\" class=\"icon ion ion-social-rss ux-u-color-success\" title=\"Sucessfully connected to remote Opsys Server\"> </span> <span *ngIf=\"!isConnected\" class=\"icon ion ion-social-rss ux-u-color-danger\" title=\"Connection to remote Opsys Server failed!\"> </span> </div> <div class=\"available-state\" *ngIf=\"isAvailableUserStateBullet\"> <span *ngIf=\"isOnline\" class=\"icon ux-icon ux-icon-circle ux-u-color-success-light\" title=\"Online - Available for chat discussion\"> </span> <span *ngIf=\"!isOnline\" class=\"icon ux-icon ux-icon-circle ux-u-color-danger-light\" title=\"Offline - Unavailable for chat discussion\"> </span> </div> </div> <div class=\"profile-toggle\"> <span class=\"ux-icon\" [ngClass]=\"isProfileDropdownVisible ? 'ux-icon-angle-up' : 'ux-icon-angle-down'\"></span> </div> </div> <div class=\"language-selector-panel\"> <ux-language-selector *ngIf=\"languageCodes\" (languageChanged)=\"onLanguageChanged($event)\" languageCodes=\"{{languageCodes}}\" [isShowLabel]=\"!isUserLoggedIn\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> <ux-language-selector *ngIf=\"!languageCodes\" (languageChanged)=\"onLanguageChanged($event)\" [isShowLabel]=\"!isUserLoggedIn\" [selectedLanguage]=\"selectedLanguage\"> </ux-language-selector> </div> <div *ngIf=\"isProfileDropdownVisible && customProfileMenuContent\" class=\"profile-dropdown fx flipInY\"> <ng-content select=\"uxLayoutHeaderProfileMenuContent\"></ng-content> </div> </div> <ng-template [ngIf]=\"!isUserLoggedIn\"> <div> <ng-content select=\"uxLayoutHeaderProfileNotLoggedInContent\"></ng-content> </div> </ng-template> ",
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutHeaderProfileComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxTimezoneService, },
];
UxLayoutHeaderProfileComponent.propDecorators = {
    "userInfos": [{ type: Input },],
    "languageCodes": [{ type: Input },],
    "isConnected": [{ type: Input },],
    "isOnline": [{ type: Input },],
    "isShowTimeWrapper": [{ type: Input },],
    "isUserLoggedIn": [{ type: Input },],
    "selectedLanguage": [{ type: Input },],
    "welcomeLabel": [{ type: Input },],
    "isAvailableUserStateBullet": [{ type: Input },],
    "utcLocalCityName": [{ type: Input },],
    "utcLocalCityTooltip": [{ type: Input },],
    "utcLocalOffset": [{ type: Input },],
    "utcForeignCityName": [{ type: Input },],
    "utcForeignCityTooltip": [{ type: Input },],
    "utcForeignOffset": [{ type: Input },],
    "timezones": [{ type: Input },],
    "languageChanged": [{ type: Output },],
    "customProfileMenuContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutHeaderProfileMenuContentTagDirective),] },],
    "customProfileSubContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutHeaderProfileSubContentTagDirective),] },],
    "closeProfileDropdown": [{ type: HostListener, args: ['body:click',] },],
};
class UxLayoutHeaderProfileMenuContentTagDirective {
}
UxLayoutHeaderProfileMenuContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderProfileMenuContent' },] },
];
class UxLayoutHeaderProfileNotLoggedInContentTagDirective {
}
UxLayoutHeaderProfileNotLoggedInContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderProfileNotLoggedInContent' },] },
];
class UxLayoutHeaderProfileSubContentTagDirective {
}
UxLayoutHeaderProfileSubContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHeaderProfileSubContent' },] },
];
class UxLayoutHeaderProfileComponentModule {
}
UxLayoutHeaderProfileComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                    MomentModule,
                    UxLanguageSelectorComponentModule,
                    UxDropdownButtonComponentModule,
                    UxDropdownButtonItemComponentModule,
                    UxMomentTzPipeModule,
                ],
                exports: [
                    UxLayoutHeaderProfileComponent,
                    UxLayoutHeaderProfileMenuContentTagDirective,
                    UxLayoutHeaderProfileNotLoggedInContentTagDirective,
                    UxLayoutHeaderProfileSubContentTagDirective,
                ],
                declarations: [
                    UxLayoutHeaderProfileComponent,
                    UxLayoutHeaderProfileMenuContentTagDirective,
                    UxLayoutHeaderProfileNotLoggedInContentTagDirective,
                    UxLayoutHeaderProfileSubContentTagDirective,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAppComponent {
    constructor() {
        this.homeUrl = '/screen/home';
        this.notificationLinks = [];
        this.activeLanguageCode = 'en';
    }
}
UxAppComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-app',
                template: "<div class=\"ux-app {{styleClass}}\"> <div class=\"ux-app__main\" role=\"main\"> <div class=\"ux-app__header\"> <a class=\"ux-app__header-logo\" [routerLink]=\"homeUrl\"></a> <h1 class=\"ux-app__header-title\">{{appTitle}}</h1> <span class=\"ux-app__header-actions\"> <ng-content></ng-content> </span> </div> <div class=\"ux-app__main-content\"> <router-outlet></router-outlet> </div> </div> </div> ",
            },] },
];
/** @nocollapse */
UxAppComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "appTitle": [{ type: Input },],
    "homeUrl": [{ type: Input },],
    "notificationLinks": [{ type: Input },],
};
class UxAppModule {
}
UxAppModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, RouterModule,
                ],
                exports: [UxAppComponent],
                declarations: [UxAppComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBreadcrumbsService {
    /**
     * @param {?} translateService
     */
    constructor(translateService) {
        this.translateService = translateService;
        this.labels = new Map();
    }
    /**
     * @param {?} route
     * @return {?}
     */
    buildUrl(route) {
        let /** @type {?} */ url = '';
        route.pathFromRoot.forEach((parentRoute) => {
            if (parentRoute.snapshot.url.length > 0) {
                url += '/' + parentRoute.snapshot.url.map(segment => segment.path).join('/');
            }
        });
        return url;
    }
    /**
     * @param {?} route
     * @param {?} label
     * @return {?}
     */
    setLabel(route, label) {
        this.labels.set(this.buildUrl(route), label);
    }
    /**
     * @param {?} route
     * @return {?}
     */
    getLabel(route) {
        let /** @type {?} */ label = this.labels.get(this.buildUrl(route));
        if (!label) {
            label = route.snapshot.data['breadcrumb'].label ?
                this.translateService.instant(route.snapshot.data['breadcrumb'].label) :
                'unknown';
        }
        return label;
    }
}
UxBreadcrumbsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxBreadcrumbsService.ctorParameters = () => [
    { type: TranslateService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutBreadcrumbsComponent {
    /**
     * @param {?} router
     * @param {?} activatedRoute
     * @param {?} breadcrumbsService
     */
    constructor(router, activatedRoute, breadcrumbsService) {
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.breadcrumbsService = breadcrumbsService;
        this.homeUrl = '';
        this.homeUrlLabel = 'Home';
        this.truncateSize = 20;
        this.isECL = false;
        this.segments = [];
        this.isShowMore = false;
        this.isShowBreadcrumbsMenu = false;
        this.previousSegments = [];
    }
    /**
     * @return {?}
     */
    closeBreadcrumbsMenu() {
        this.isShowBreadcrumbsMenu = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.routeChange(this.activatedRoute);
        this.router.events
            .subscribe((event) => {
            if (event instanceof NavigationEnd) {
                this.routeChange(this.activatedRoute);
                this.buildBreadcrumb();
            }
        });
        this.buildBreadcrumb();
    }
    /**
     * @param {?} route
     * @return {?}
     */
    routeChange(route) {
        this.previousSegments = [...this.segments];
        this.segments = [];
        addBreadcrumb.call(this);
        while (route.firstChild) {
            route = route.firstChild;
            addBreadcrumb.call(this);
        }
        this.segments = concatToPreviousRoute.call(this);
        /**
         * @return {?}
         */
        function addBreadcrumb() {
            const /** @type {?} */ breadcrumb = route.snapshot.data['breadcrumb'];
            if (typeof breadcrumb !== 'undefined' && breadcrumb !== null) {
                this.segments.push(route);
            }
        }
        /**
         * @return {?}
         */
        function concatToPreviousRoute() {
            const /** @type {?} */ currentRoute = this.segments.slice(-1)[0];
            const /** @type {?} */ previousAllowed = currentRoute &&
                currentRoute.snapshot.data.breadcrumb &&
                currentRoute.snapshot.data.breadcrumb.previousAllowed;
            if (!previousAllowed) {
                return this.segments;
            }
            let /** @type {?} */ concatFromLastRoute = false;
            let /** @type {?} */ index = -1;
            let /** @type {?} */ goingBack = false;
            this.previousSegments.forEach((lastRoute, i) => {
                if (!concatFromLastRoute && lastRoute && lastRoute.snapshot.data.pageId) {
                    concatFromLastRoute = previousAllowed.indexOf(lastRoute.snapshot.data.pageId) >= 0;
                }
                if (currentRoute.snapshot.data.pageId && currentRoute.snapshot.data.pageId === lastRoute.snapshot.data.pageId) {
                    goingBack = true;
                    index = i;
                }
            });
            if (goingBack) {
                return this.previousSegments.slice(0, index + 1);
            }
            else if (concatFromLastRoute) {
                return [...this.previousSegments, currentRoute];
            }
            return this.segments;
        }
    }
    /**
     * @param {?} segment
     * @return {?}
     */
    buildUrl(segment) {
        return this.breadcrumbsService.buildUrl(segment);
    }
    /**
     * @param {?} segment
     * @return {?}
     */
    getLabel(segment) {
        return this.breadcrumbsService.getLabel(segment);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleIsShowMore(event) {
        this.isShowBreadcrumbsMenu = !this.isShowBreadcrumbsMenu;
        if (event) {
            event.preventDefault();
            event.stopPropagation();
            event.cancelBubble = true;
        }
    }
    /**
     * @return {?}
     */
    buildBreadcrumb() {
        /*  2DO
                    Calculate the total width of ux-breadcrumbs__item.
                    If max-width > ux-layout-nav-bar width then show the more (...) element.
                    Use this.isShowMore variable for this.
                */
    }
}
UxLayoutBreadcrumbsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-breadcrumbs',
                template: "<ng-container *ngIf=\"!isECL\"> <div class=\"ux-layout-breadcrumbs\"> <!-- Home --> <span class=\"ux-layout-breadcrumbs__item\"> <a *ngIf=\"segments.length > 0\" [routerLink]=\"homeUrl\" title=\"{{ homeUrlLabel }}\"><span>{{ homeUrlLabel }}</span></a> <span *ngIf=\"segments.length === 0\">{{ homeUrlLabel }}</span> </span> <!-- Items --> <span class=\"ux-layout-breadcrumbs__item\" *ngFor=\"let segment of segments; let last = last; let index = i;\"> <ng-template [ngIf]=\"!last\"> <a [routerLink]=\"buildUrl(segment)\" title=\"{{ getLabel(segment) }}\">{{ getLabel(segment) | uxTruncate : truncateSize }}</a> </ng-template> <!-- Last item --> <ng-template [ngIf]=\"last\"> <!-- More... (for future release) --> <!-- <a *ngIf=\"isShowMore\" href=\"javascript:void(0);\" (click)=\"toggleIsShowMore($event);\">...</a> --> <span title=\"{{ getLabel(segment) }}\">{{ getLabel(segment) }}</span> </ng-template> </span> </div> <!-- Called by More...: populated with \"hidden\" breadcrumbs items (for future release) <div class=\"ux-layout-breadcrumbs__menu dropdown-menu\" *ngIf=\"isShowBreadcrumbsMenu\"> <span class=\"ux-layout-breadcrumbs__item\" *ngFor=\"let number of [0,1,2,3,4,5,6,7,8,9]\"> <a href=\"javascript:void(0);\" title=\"Segment link n-{{number}}\">Segment link with long label n-{{number}}</a> </span> </div> --> </ng-container> <ng-container *ngIf=\"isECL\"> <nav class=\"ecl-breadcrumb\" aria-label=\"breadcrumb\"> <span class=\"ecl-u-sr-only\">You are here:</span> <ol class=\"ecl-breadcrumb__segments-wrapper\"> <li class=\"ecl-breadcrumb__segment ecl-breadcrumb__segment--first\"> <a *ngIf=\"segments.length > 0\" class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\" [routerLink]=\"homeUrl\" title=\"{{ homeUrlLabel }}\"> {{ homeUrlLabel }} </a> <span *ngIf=\"segments.length === 0\">{{ homeUrlLabel }}</span> </li> <ng-container *ngFor=\"let segment of segments; let last = last; let index = i;\"> <li *ngIf=\"!last\" class=\"ecl-breadcrumb__segment\"> <a class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\" [routerLink]=\"buildUrl(segment)\" title=\"{{ getLabel(segment) }}\"> {{ getLabel(segment) | uxTruncate : truncateSize }} </a> </li> <li *ngIf=\"last\" class=\"ecl-breadcrumb__segment ecl-breadcrumb__segment--last\"> <span class=\"ecl-link ecl-link--inverted ecl-link--standalone ecl-breadcrumb__link\"> {{ getLabel(segment) | uxTruncate : truncateSize }} </span> </li> </ng-container> </ol> </nav> </ng-container> ",
                changeDetection: ChangeDetectionStrategy.Default,
            },] },
];
/** @nocollapse */
UxLayoutBreadcrumbsComponent.ctorParameters = () => [
    { type: Router, },
    { type: ActivatedRoute, },
    { type: UxBreadcrumbsService, },
];
UxLayoutBreadcrumbsComponent.propDecorators = {
    "homeUrl": [{ type: Input },],
    "homeUrlLabel": [{ type: Input },],
    "truncateSize": [{ type: Input },],
    "isECL": [{ type: Input },],
    "closeBreadcrumbsMenu": [{ type: HostListener, args: ['body:click',] },],
};
class UxLayoutBreadcrumbsComponentModule {
}
UxLayoutBreadcrumbsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, UxTruncatePipeModule],
                exports: [UxLayoutBreadcrumbsComponent],
                declarations: [UxLayoutBreadcrumbsComponent],
                providers: [TranslateService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutTopMessageComponent {
}
UxLayoutTopMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-top-message',
                template: `
        <div class="ux-top-message {{styleClass}} ux-top-message--{{typeClass}}">
            <ng-content></ng-content>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutTopMessageComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
};
class UxLayoutTopMessageComponentModule {
}
UxLayoutTopMessageComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutTopMessageComponent],
                declarations: [UxLayoutTopMessageComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutBannerComponent {
}
UxLayoutBannerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-banner',
                template: `
        <div class="ux-layout-banner {{styleClass}}">
            <div class="ux-layout-banner__content">
                <ng-content></ng-content>
             </div>
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutBannerComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
};
class UxLayoutBannerComponentModule {
}
UxLayoutBannerComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutBannerComponent],
                declarations: [UxLayoutBannerComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutHorizontalComponent {
}
UxLayoutHorizontalComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-horizontal',
                template: "<div class=\"ux-o-layout-horizontal {{styleClass}}\"> <div class=\"ux-o-layout-horizontal__left\"><ng-content select=\"uxLayoutHorizontalLeft\"></ng-content></div> <div class=\"ux-o-layout-horizontal__center\"><ng-content select=\"uxLayoutHorizontalCenter\"></ng-content></div> <div class=\"ux-o-layout-horizontal__right\"><ng-content select=\"uxLayoutHorizontalRight\"></ng-content></div> </div> ",
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutHorizontalComponent.propDecorators = {
    "styleClass": [{ type: Input },],
};
class UxLayoutHorizontalLeftTagDirective {
}
UxLayoutHorizontalLeftTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHorizontalLeft' },] },
];
class UxLayoutHorizontalRightTagDirective {
}
UxLayoutHorizontalRightTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHorizontalRight' },] },
];
class UxLayoutHorizontalCenterTagDirective {
}
UxLayoutHorizontalCenterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutHorizontalCenter' },] },
];
class UxLayoutHorizontalModule {
}
UxLayoutHorizontalModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    UxLayoutHorizontalComponent,
                    UxLayoutHorizontalLeftTagDirective,
                    UxLayoutHorizontalRightTagDirective,
                    UxLayoutHorizontalCenterTagDirective
                ],
                declarations: [
                    UxLayoutHorizontalComponent,
                    UxLayoutHorizontalLeftTagDirective,
                    UxLayoutHorizontalRightTagDirective,
                    UxLayoutHorizontalCenterTagDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutPageHeaderComponent {
    /**
     * @param {?} asService
     */
    constructor(asService) {
        this.asService = asService;
        this.isLarge = false;
        this.isHighlighted = false;
        this.isECL = false;
        this.hasECLBreadcrumb = false;
        this.highlightedClasses = 'ux-u-z-highlighted ux-u-p-relative ux-u-color-white';
        this.pageTitleStateClass = '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.pageSubtitle) {
            this.pageTitleStateClass = 'ux-layout-page-header__title--no-subtitle ';
        }
        if (this.isLarge) {
            this.pageTitleStateClass += 'page-title--large';
        }
    }
}
UxLayoutPageHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-page-header',
                template: "<ng-container *ngIf=\"!isECL\"> <div *ngIf=\"!(asService.breakpoints$ | async).isMobile\"> <div class=\"ux-layout-page-header-wrapper\"> <div class=\"ux-layout-page-header\"> <div class=\"ux-layout-page-header__title page-title {{pageTitleStateClass}}\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageTitle}} </div> <ng-container *ngTemplateOutlet=\"actions\"></ng-container> </div> <div *ngIf=\"pageSubtitle\" class=\"ux-layout-page-header__sub-title\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\" title=\"{{pageSubtitle}}\"> <span class=\"page-sub-title\">{{pageSubtitle}}</span> </div> </div> </div> <div *ngIf=\"(asService.breakpoints$ | async).isMobile\"> <div class=\"ux-layout-page-header-wrapper ux-layout-page-header-wrapper--mobile\"> <ng-container *ngTemplateOutlet=\"actions\"></ng-container> <div class=\"ux-layout-page-header mt-2\"> <div class=\"ux-layout-page-header__title page-title {{pageTitleStateClass}}\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageTitle}} </div> </div> <div *ngIf=\"pageSubtitle\" class=\"ux-layout-page-header__sub-title page-sub-title\" [ngClass]=\"isHighlighted ? highlightedClasses : ''\"> {{pageSubtitle}} </div> </div> </div> <ng-template #actions> <div class=\"ux-layout-page-header__actions\" [class.ml-auto]=\"!(asService.breakpoints$ | async).isMobile\"> <div *ngIf=\"customActionsContent\" class=\"ux-layout-page-header__actions-content\"> <ng-content select=\"uxLayoutPageHeaderActionsContent\"></ng-content> </div> <ul *ngIf=\"customActionIconsContent\" class=\"ux-layout-page-header__actions-icons\"> <ng-content select=\"uxLayoutPageHeaderActionIconsContent\"></ng-content> </ul> </div> </ng-template> </ng-container> <ng-container *ngIf=\"isECL\"> <div class=\"ecl-page-header\"> <div class=\"ecl-container\"> <ux-layout-breadcrumbs [isECL]=\"true\" *ngIf=\"hasECLBreadcrumb\"></ux-layout-breadcrumbs> <div class=\"ecl-page-header__body\"> <div class=\"ecl-page-header__identity\"> {{pageTitle}} </div> </div> </div> </div> </ng-container> ",
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutPageHeaderComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxLayoutPageHeaderComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "pageTitle": [{ type: Input },],
    "pageSubtitle": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isHighlighted": [{ type: Input },],
    "isECL": [{ type: Input },],
    "hasECLBreadcrumb": [{ type: Input },],
    "customActionsContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutPageHeaderActionsContentTagDirective),] },],
    "customActionIconsContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutPageHeaderActionIconsContentTagDirective),] },],
};
class UxLayoutPageHeaderActionsContentTagDirective {
}
UxLayoutPageHeaderActionsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutPageHeaderActionsContent' },] },
];
class UxLayoutPageHeaderActionIconsContentTagDirective {
}
UxLayoutPageHeaderActionIconsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutPageHeaderActionIconsContent' },] },
];
class UxLayoutPageHeaderComponentModule {
}
UxLayoutPageHeaderComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxLayoutBreadcrumbsComponentModule,
                ],
                exports: [
                    UxLayoutPageHeaderComponent,
                    UxLayoutPageHeaderActionsContentTagDirective,
                    UxLayoutPageHeaderActionIconsContentTagDirective,
                ],
                declarations: [
                    UxLayoutPageHeaderComponent,
                    UxLayoutPageHeaderActionsContentTagDirective,
                    UxLayoutPageHeaderActionIconsContentTagDirective,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutPageHeaderActionIconItemComponent {
}
UxLayoutPageHeaderActionIconItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-page-header-action-icon-item',
                template: `
        <li class="ux-layout-page-header__actions-icons__item">
            <span class="{{iconClass}}"></span>
        </li>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
UxLayoutPageHeaderActionIconItemComponent.propDecorators = {
    "iconClass": [{ type: Input },],
};
class UxLayoutPageHeaderActionIconItemComponentModule {
}
UxLayoutPageHeaderActionIconItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    UxLayoutPageHeaderActionIconItemComponent,
                ],
                declarations: [
                    UxLayoutPageHeaderActionIconItemComponent,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutFooterActionBarComponent {
    constructor() {
        this.dismissActionLabel = 'Cancel';
        this.dismissActionDisabled = false;
        this.acceptActionLabel = 'OK';
        this.acceptActionDisabled = false;
        this.onDismiss = new EventEmitter();
        this.onAccept = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDismissClicked(event) {
        this.onDismiss.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onAcceptClicked(event) {
        this.onAccept.emit(event);
    }
}
UxLayoutFooterActionBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-layout-footer-action-bar',
                template: "<div class=\"ux-layout-footer-action-bar-wrapper\"> <div class=\"ux-layout-footer-action-bar {{styleClass}}\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxLayoutFooterActionBarContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <div class=\"row\"> <div class=\"col\"> <button class=\"btn btn-secondary btn-block\" [disabled]=\"dismissActionDisabled\" (click)=\"onDismissClicked($event)\"> {{dismissActionLabel}} </button> </div> <div class=\"col\"> <button class=\"btn btn-primary btn-block\" [disabled]=\"acceptActionDisabled\" (click)=\"onAcceptClicked($event)\"> {{acceptActionLabel}} </button> </div> </div> </ng-template> </div> </div> ",
            },] },
];
/** @nocollapse */
UxLayoutFooterActionBarComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "dismissActionLabel": [{ type: Input },],
    "dismissActionDisabled": [{ type: Input },],
    "acceptActionLabel": [{ type: Input },],
    "acceptActionDisabled": [{ type: Input },],
    "onDismiss": [{ type: Output },],
    "onAccept": [{ type: Output },],
    "customContent": [{ type: ContentChild, args: [forwardRef(() => UxLayoutFooterActionBarContentTagDirective),] },],
};
class UxLayoutFooterActionBarContentTagDirective {
}
UxLayoutFooterActionBarContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxLayoutFooterActionBarContent' },] },
];
class UxLayoutFooterActionBarComponentModule {
}
UxLayoutFooterActionBarComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLayoutFooterActionBarComponent, UxLayoutFooterActionBarContentTagDirective],
                declarations: [UxLayoutFooterActionBarComponent, UxLayoutFooterActionBarContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxToolbarFilterComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.isVisible = false;
        this.isFilterVisible = true;
        this.isToggleVisible = true;
        this.isToggleExpanded = false;
        this.filter = new EventEmitter();
        this.expandAll = new EventEmitter();
        this.collapseAll = new EventEmitter();
        this.filterValue = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.filterLabel) {
            this.translatedFilterLabel = this.uxService.translate('filter');
        }
        else {
            this.translatedFilterLabel = this.filterLabel;
        }
        if (!this.expandAllLabel) {
            this.translatedExpandAllLabel = this.uxService.translate('expandAll');
        }
        else {
            this.translatedExpandAllLabel = this.expandAllLabel;
        }
        if (!this.collapseAllLabel) {
            this.translatedCollapseAllLabel = this.uxService.translate('collapseAll');
        }
        else {
            this.translatedCollapseAllLabel = this.collapseAllLabel;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFilter(event) {
        if (this.filterValue === '') {
            if (!this.isToggleExpanded) {
                this.collapseAll.emit(null);
            }
        }
        this.filter.emit(this.filterValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExpandAll(event) {
        this.isToggleExpanded = !this.isToggleExpanded;
        this.expandAll.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCollapseAll(event) {
        this.isToggleExpanded = !this.isToggleExpanded;
        this.collapseAll.emit(event);
    }
}
UxToolbarFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-toolbar-filter',
                template: "<div *ngIf=\"isVisible\" class=\"ux-a-toolbar-filter\"> <div class=\"ux-a-toolbar-filter-content\"> <div *ngIf=\"isFilterVisible\" class=\"ux-a-toolbar-filter-filter\"> <div class=\"input-group\"> <span class=\"input-group-prepend\"> <span class=\"input-group-text\"> <span class=\"ux-icon ux-icon-search\"></span> </span> </span> <input type=\"text\" class=\"form-control ux-a-toolbar-filter-filter-input\" placeholder=\"{{translatedFilterLabel}}\" [(ngModel)]=\"filterValue\" (keyup)=\"onFilter($event)\"/> </div> </div> <div *ngIf=\"isToggleVisible\" class=\"ux-a-toolbar-filter-trigger-wrapper\"> <button type=\"button\" *ngIf=\"!isToggleExpanded\" class=\"ux-a-toolbar-filter-trigger btn btn-secondary\" (click)=\"onExpandAll($event)\"> <span class=\"ux-icon ux-icon-level-down ux-a-toolbar-filter-trigger-icon\"></span> {{translatedExpandAllLabel}} </button> <button type=\"button\" *ngIf=\"isToggleExpanded\" class=\"ux-a-toolbar-filter-trigger btn btn-secondary\" (click)=\"onCollapseAll($event)\"> <span class=\"ux-icon ux-icon-level-up ux-a-toolbar-filter-trigger-icon\"></span> {{translatedCollapseAllLabel}} </button> <ng-content select=\"uxToolbarFilterButtons\"></ng-content> </div> <div class=\"ml-auto d-flex-none\"> <ng-content></ng-content> </div> </div> </div> ",
                styles: [".ux-a-toolbar-filter{padding:.66rem}.ux-a-toolbar-filter-content{align-items:center;display:flex;flex-shrink:0}.ux-a-toolbar-filter-trigger-wrapper{display:flex;flex-shrink:0}.ux-a-toolbar-filter-trigger{margin-right:.33rem}.ux-a-toolbar-filter-filter{margin-right:.33rem;position:relative;width:100%}.ux-a-toolbar-filter-filter-input{width:100%}.ux-a-toolbar-filter-filter-input-search-icon{position:absolute;right:.66rem;top:.66rem} /*# sourceMappingURL=ux-a-toolbar-filter.component.css.map */"],
            },] },
];
/** @nocollapse */
UxToolbarFilterComponent.ctorParameters = () => [
    { type: UxService, },
];
UxToolbarFilterComponent.propDecorators = {
    "isVisible": [{ type: Input },],
    "filterLabel": [{ type: Input },],
    "expandAllLabel": [{ type: Input },],
    "collapseAllLabel": [{ type: Input },],
    "isFilterVisible": [{ type: Input },],
    "isToggleVisible": [{ type: Input },],
    "isToggleExpanded": [{ type: Input },],
    "filter": [{ type: Output },],
    "expandAll": [{ type: Output },],
    "collapseAll": [{ type: Output },],
};
class UxToolbarFilterButtonsTagDirective {
}
UxToolbarFilterButtonsTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxToolbarFilterButtons' },] },
];
class UxToolbarFilterComponentModule {
}
UxToolbarFilterComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [UxToolbarFilterComponent, UxToolbarFilterButtonsTagDirective],
                declarations: [UxToolbarFilterComponent, UxToolbarFilterButtonsTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPanelsComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.isShowToolbar = false;
        this.isShowToolbarExtendedPanelsToggle = false;
        this.openAllPanelsLabel = 'Open all panels';
        this.closeAllPanelsLabel = 'Close all panels';
        this.filterLabel = 'Filter panels';
        this.goToPanelsLabel = 'Go to panel';
        this.isMultipleExpanded = true;
        this.isAllPanelsExpandable = false;
        this.isDebug = false;
        this.isFilterVisible = true;
        this.isShowInvalidPanelsOnly = false;
        this.isAccordionPanels = false;
        this.isAllPanelsExpanded = false;
        this.panelExpanded = new EventEmitter();
        this.panelsFilter = '';
        this.extendedPanelsLinks = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ isAccordionPanels = this.isAccordionPanels;
        if (isAccordionPanels) {
            this.isMultipleExpanded = false;
            this.isAllPanelsExpandable = true;
        }
        setTimeout(() => {
            if (this.isAllPanelsExpandable) {
                this.panels.forEach(function (i) {
                    i.isExpandable = true;
                    if (!i.isExpandedInitialState) {
                        i.isExpanded = false;
                    }
                    if (isAccordionPanels) {
                        i.isAccordionPanel = true;
                    }
                });
            }
            if (this.isAllPanelsExpanded) {
                this.openAllPanels(null);
            }
        });
        this.panels.forEach((panel, i) => {
            this.extendedPanelsLinks.push(new UxLink({
                label: panel.label, iconClass: panel.iconClass,
                command: () => this.selectPanel(i)
            }));
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ isShowInvalidPanelsOnly = this.isShowInvalidPanelsOnly;
        const /** @type {?} */ customStateFilterValue = this.customStateFilterValue;
        if (this.panelsChildren) {
            if (changes['isShowInvalidPanelsOnly']) {
                this.panelsChildren.forEach(function (i) {
                    if (!i.hasStatusIndicator && i.statusIndicatorTypeClass !== 'info') {
                        // i.isVisible = !isShowInvalidPanelsOnly;
                        i.showOnlyInvalid = isShowInvalidPanelsOnly;
                    }
                    else {
                        i.isExpanded = true;
                    }
                });
            }
            if (changes['customStateFilterValue']) {
                this.panels.forEach(function (i) {
                    if (customStateFilterValue && customStateFilterValue !== '') {
                        i.isVisible = (i.customState === customStateFilterValue);
                    }
                    else {
                        i.isVisible = true;
                    }
                });
            }
        }
    }
    /**
     * @param {?} filterValue
     * @return {?}
     */
    onFilter(filterValue) {
        this.panelsFilter = filterValue;
        this.filterPanels();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    selectPanel(index) {
        const /** @type {?} */ selectedPanel = this.panels.toArray()[index];
        this.closeAllPanels(null);
        selectedPanel.isExpanded = true;
        window.scrollTo(0, selectedPanel.HTMLElement.getBoundingClientRect().top - 150);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    collapseAll(item) {
        this.panels.forEach(function (i) {
            if (i !== item) {
                i.isExpanded = false;
            }
        });
        this.panelExpanded.emit(item.id);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openAllPanels(event) {
        this.panels.forEach(function (i) {
            i.isExpanded = true;
        });
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeAllPanels(event) {
        this.panels.forEach(function (i) {
            i.isExpanded = false;
        });
        this.uxService.consumeEvent(event);
    }
    /**
     * @return {?}
     */
    filterPanels() {
        if (!this.customPanelsFilter) {
            if (this.panelsFilter !== '') {
                this.panels.forEach(function (i) {
                    i.isVisible = false;
                });
                this.panels.forEach((i) => {
                    if (i.filterInput) {
                        if (i.filterInput.toUpperCase().indexOf(this.panelsFilter.toUpperCase()) !== -1) {
                            i.isVisible = true;
                        }
                    }
                    else {
                        if (i.label.toUpperCase().indexOf(this.panelsFilter.toUpperCase()) !== -1) {
                            i.isVisible = true;
                        }
                    }
                });
            }
            else {
                this.panels.forEach(function (i) {
                    i.isVisible = true;
                });
            }
        }
        else {
            this.customPanelsFilter.filter(this.panels, this.panelsFilter);
        }
    }
}
UxPanelsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-panels',
                template: `

        <div *ngIf="isShowToolbar" class="ux-panel-toolbar">
            <ux-a-toolbar-filter [isVisible]="true"
                                [filterLabel]="filterLabel"
                                [expandAllLabel]="openAllPanelsLabel"
                                [collapseAllLabel]="closeAllPanelsLabel"
                                [isFilterVisible]="isFilterVisible"
                                [isToggleExpanded]="isAllPanelsExpanded"
                                (filter)="onFilter($event)"
                                (expandAll)="openAllPanels($event)"
                                (collapseAll)="closeAllPanels($event)">
                <uxToolbarFilterButtons>
                    <ux-dropdown-button *ngIf="isShowToolbarExtendedPanelsToggle"
                        label="{{goToPanelsLabel}}" iconClass="ux-icon ux-icon-bars"
                        [links]="extendedPanelsLinks">
                    </ux-dropdown-button>
                </uxToolbarFilterButtons>
            </ux-a-toolbar-filter>
        </div>

        <ul class="panels">
            <ng-content></ng-content>
        </ul>`
            },] },
];
/** @nocollapse */
UxPanelsComponent.ctorParameters = () => [
    { type: UxService, },
];
UxPanelsComponent.propDecorators = {
    "isShowToolbar": [{ type: Input },],
    "isShowToolbarExtendedPanelsToggle": [{ type: Input },],
    "openAllPanelsLabel": [{ type: Input },],
    "closeAllPanelsLabel": [{ type: Input },],
    "filterLabel": [{ type: Input },],
    "goToPanelsLabel": [{ type: Input },],
    "isMultipleExpanded": [{ type: Input },],
    "isAllPanelsExpandable": [{ type: Input },],
    "isDebug": [{ type: Input },],
    "isFilterVisible": [{ type: Input },],
    "isShowInvalidPanelsOnly": [{ type: Input },],
    "isAccordionPanels": [{ type: Input },],
    "customStateFilterValue": [{ type: Input },],
    "customPanelsFilter": [{ type: Input },],
    "isAllPanelsExpanded": [{ type: Input },],
    "panelExpanded": [{ type: Output },],
    "panels": [{ type: ContentChildren, args: [forwardRef(() => UxPanelComponent), { descendants: true },] },],
    "panelsChildren": [{ type: ContentChildren, args: [forwardRef(() => UxPanelComponent), { descendants: false },] },],
};
class UxPanelsComponentModule {
}
UxPanelsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, UxDropdownButtonComponentModule, UxToolbarFilterComponentModule],
                exports: [UxPanelsComponent],
                declarations: [UxPanelsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPanelComponent {
    /**
     * @param {?} uxPanelsComponent
     * @param {?} el
     * @param {?} render
     * @param {?} uxService
     * @param {?} uxDomService
     */
    constructor(uxPanelsComponent, el, render, uxService, uxDomService) {
        this.render = render;
        this.uxService = uxService;
        this.uxDomService = uxDomService;
        this.isIconRounded = false;
        this.isExpandable = false;
        this.isExpanded = false;
        this.isVisible = true;
        this.isSelected = false;
        this.isCollapsible = false;
        this.isCollapsed = false;
        this.badgeTypeClass = 'primary';
        this.hasTabs = false;
        this.hasNoHeader = false;
        this.hasNoContentPadding = false;
        this.isBlocked = false;
        this.isBlockedAriaLabel = 'loading';
        this.maxHeight = 'none';
        this.contentHeight = 'none';
        this.isFlat = false;
        this.isLargeHeader = false;
        this.isLargeFooter = false;
        this.isSmallHeader = false;
        this.hasStatusIndicator = false;
        this.statusIndicatorTypeClass = 'warning';
        this.statusIndicatorMessageLabel = 'Status indicator default message';
        this.isTogglableStatusIndicatorContent = true;
        this.isStatusIndicatorContentExpanded = false;
        this.hasStatusIndicatorHeaderBg = false;
        this.hasStatusIndicatorHeaderIcon = false;
        this.isEditModeActive = false;
        this.isContainerOnly = false;
        this.isClickable = false;
        this.isHighlighted = false;
        this.isAccordionPanel = false;
        this.tabindex = '0';
        this.isSticky = false;
        this.panelExpanded = new EventEmitter();
        this.panelCollapsed = new EventEmitter();
        this.showOnlyInvalid = false;
        this.statusIndicatorIconClass = '';
        this.labelThemeClass = '';
        this.isExpandedInitialState = false;
        // panel states
        this.hasMaxHeight = false;
        this.hasContentHeight = false;
        this.stateExpandableClass = '';
        this.stateTabsClass = '';
        this.statePanelItemClasses = '';
        this.statePanelHeaderClasses = '';
        this.statePanelContentClasses = '';
        this.stickyContentYOffset = 14;
        this.onScrollBind = this.onScroll.bind(this);
        this.onResizeBind = this.onResize.bind(this);
        this.sticked = true;
        this.selectedOffset = 0;
        this.windowOffsetTop = 0;
        this.offSet = 0;
        this.addClass = 'fixed';
        this.uxPanelsComponent = uxPanelsComponent;
        this.HTMLElement = el.nativeElement;
        this.selectedOffset = this.HTMLElement.offsetTop;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isSticky) {
            window.addEventListener('scroll', this.onScrollBind);
            window.addEventListener('resize', this.onResizeBind);
        }
    }
    /**
     * @return {?}
     */
    onScroll() {
        this.onWindowScroll();
        this.handleStickyPanel();
    }
    /**
     * @return {?}
     */
    onResize() {
        this.handleStickyPanel();
    }
    /**
     * @return {?}
     */
    onWindowScroll() {
        let /** @type {?} */ offset = this.HTMLElement.offsetTop;
        this.windowOffsetTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        if (this.selectedOffset === 0) {
            this.selectedOffset = offset;
        }
        if (this.sticked === false) {
            this.selectedOffset = offset;
        }
        if ((this.windowOffsetTop + this.offSet) > this.selectedOffset) {
            this.addSticky();
        }
        else {
            this.removeSticky();
        }
    }
    /**
     * @return {?}
     */
    handleStickyPanel() {
        if (this.stickyContentElementRef) {
            let /** @type {?} */ effectiveTopOffset = '';
            const /** @type {?} */ stickyContentTopOffset = this.stickyContainerElementRef.nativeElement.getBoundingClientRect().top;
            if (stickyContentTopOffset < 0) {
                effectiveTopOffset = -stickyContentTopOffset + this.stickyContentYOffset + 'px';
            }
            this.stickyContentElementRef.nativeElement.style.top = effectiveTopOffset;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Bugfix: prevent "flashing" of content being visible, then suddenly being invisible again.
        // This side-effect is caused by the parent <ux-panels> tag that sets the panels as accordion with a setTimeout().
        // That means: panels are visible by default, are rendered, then hidden again after becoming an accordion...
        if (this.uxPanelsComponent && this.uxPanelsComponent.isAccordionPanels) {
            this.isExpandable = true;
        }
        // end bugfix
        if (!this.contentId) {
            this.contentId = this.uxService.uniqueId();
        }
        this.isExpandedInitialState = this.isExpanded;
        if (!this.isExpandable) {
            this.isExpanded = true;
        }
        this.actualMaxHeight = this.maxHeight;
        // setting panel states
        if (this.maxHeight !== 'none') {
            this.hasMaxHeight = true;
        }
        if (this.contentHeight !== 'none') {
            this.hasContentHeight = true;
            this.actualMaxHeight = this.contentHeight;
        }
        if (this.hasTabs) {
            this.stateTabsClass = 'ux-panel-item--has-tabs';
        }
        if (this.isContainerOnly) {
            this.hasNoHeader = true;
            this.hasNoContentPadding = true;
        }
        if (this.hasNoHeader) {
            this.statePanelItemClasses += 'ux-panel-item--no-header ';
        }
        if (this.hasTabs) {
            this.statePanelItemClasses += 'ux-panel-item--has-tabs ';
        }
        if (this.isFlat) {
            this.statePanelItemClasses += 'ux-panel-item--flat ';
        }
        if (this.isClickable) {
            this.statePanelItemClasses += 'ux-panel-item--clickable ';
        }
        if (this.isLargeHeader) {
            this.statePanelHeaderClasses += 'ux-panel-header--large ';
        }
        if (this.isSmallHeader) {
            this.statePanelHeaderClasses += 'ux-panel-header--small ';
        }
        if (this.hasStatusIndicator && this.hasStatusIndicatorHeaderBg && !this.hasStatusIndicatorHeaderIcon) {
            this.statePanelItemClasses += 'ux-panel-item--' + this.statusIndicatorTypeClass;
            this.labelThemeClass = 'white';
        }
        // Cfr. EUI-1097
        // if (this.hasStatusIndicator && !this.hasStatusIndicatorHeaderBg && !this.hasStatusIndicatorHeaderIcon) {
        //     this.statePanelHeaderClasses += 'ux-u-border-l-' + this.statusIndicatorTypeClass;
        // }
        if (!this.isTogglableStatusIndicatorContent) {
            this.isStatusIndicatorContentExpanded = true;
        }
        if (this.hasNoContentPadding) {
            this.statePanelContentClasses += 'ux-panel-content--no-padding ';
        }
        if (this.isBlocked) {
            this.statePanelContentClasses += 'ux-panel-content--blocked';
        }
        // status indicator icon class
        if (this.statusIndicatorTypeClass === 'warning') {
            this.statusIndicatorIconClass = 'exclamation';
        }
        else if (this.statusIndicatorTypeClass === 'danger') {
            this.statusIndicatorIconClass = 'times';
        }
        else if (this.statusIndicatorTypeClass === 'info') {
            this.statusIndicatorIconClass = 'info';
        }
        else if (this.statusIndicatorTypeClass === 'success') {
            this.statusIndicatorIconClass = 'check';
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        window.removeEventListener('scroll', this.onScrollBind);
        window.removeEventListener('resize', this.onResizeBind);
    }
    /**
     * @return {?}
     */
    get statePanelItemClassesDynamic() {
        let /** @type {?} */ panelItemClasses = '';
        if (this.isSelected) {
            panelItemClasses += 'ux-panel-item--selected ';
        }
        if (this.isHighlighted) {
            panelItemClasses += 'ux-panel-item--highlighted ';
        }
        return panelItemClasses;
    }
    /**
     * @return {?}
     */
    get statePanelContentClassesDynamic() {
        if (this.isEditModeActive) {
            return 'ux-panel-content--edit-mode-active';
        }
        return '';
    }
    /**
     * @return {?}
     */
    get hasCustomPanelHeader() {
        return this.customPanelHeader.length !== 0;
    }
    /**
     * @return {?}
     */
    get hasCustomPanelFooter() {
        return this.customPanelFooter.length !== 0;
    }
    /**
     * @return {?}
     */
    get hasCustomPanelHeaderRightContent() {
        return this.customPanelHeaderRightContent.length !== 0;
    }
    /**
     * @return {?}
     */
    get hasCustomPanelHeaderWithDescendants() {
        return this.customPanelHeaderWithDescendants.length !== 0;
    }
    /**
     * @return {?}
     */
    get hasCustomPanelFooterWithDescendants() {
        return this.customPanelFooterWithDescendants.length !== 0;
    }
    /**
     * @return {?}
     */
    get hasCustomPanelHeaderRightContentWithDescendants() {
        return this.customPanelHeaderRightContentWithDescendants.length !== 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        let /** @type {?} */ el;
        if (event) {
            el = /** @type {?} */ (event.target);
        }
        if (!event ||
            el.classList.contains('ux-panel-header') ||
            el.classList.contains('ux-a-label__label') ||
            el.classList.contains('ux-panel-header__expand-toggle') ||
            el.parentElement && el.parentElement.classList.contains('ux-a-label__label')) {
            if (this.isExpandable) {
                if (this.uxPanelsComponent) {
                    if (!this.uxPanelsComponent.isMultipleExpanded) {
                        this.uxPanelsComponent.collapseAll(this);
                    }
                }
                this.isExpanded = !this.isExpanded;
                this.panelExpanded.emit(this.id);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleMaxHeight(event) {
        if (this.maxHeight !== this.actualMaxHeight) {
            this.actualMaxHeight = this.maxHeight;
        }
        else {
            this.actualMaxHeight = 'none';
        }
    }
    /**
     * @return {?}
     */
    get isMaxHeightExpanded() {
        return this.actualMaxHeight === 'none';
    }
    /**
     * @return {?}
     */
    onToggleStatusIndicatorContent() {
        this.isStatusIndicatorContentExpanded = !this.isStatusIndicatorContentExpanded;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCollapsibleButtonClick(event) {
        this.isCollapsed = !this.isCollapsed;
        this.panelCollapsed.emit(this.isCollapsed);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        switch (event.keyCode) {
            case 13: // ENTER
            case 32:
                // SPACE
                const /** @type {?} */ target = /** @type {?} */ (event.target);
                if (!this.uxDomService.closestMatchingParent(target, 'ux-panel-header__right-content')) {
                    this.toggle(null);
                    this.uxService.consumeEvent(event);
                }
                break;
        }
    }
    /**
     * @return {?}
     */
    addSticky() {
        this.sticked = true;
        this.HTMLElement.style.position = 'fixed';
        this.HTMLElement.style.top = this.offSet + 'px';
        this.render.addClass(this.HTMLElement, this.addClass);
        if (this.isHighlighted) {
            this.render.addClass(this.HTMLElement, 'ux-panel-item--highlighted');
        }
    }
    /**
     * @return {?}
     */
    removeSticky() {
        this.sticked = false;
        this.HTMLElement.style.position = '';
        this.render.removeClass(this.HTMLElement, this.addClass);
        if (this.isHighlighted) {
            this.render.removeClass(this.HTMLElement, 'ux-panel-item--highlighted');
        }
    }
}
UxPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-panel',
                template: "<div #stickyContainer></div> <div class=\"ux-panel\" [class.ux-panel--is-collapsible]=\"isCollapsible\"> <ng-template [ngIf]=\"isCollapsible\"> <div class=\"ux-panel__collapsible-button\" [class.ux-panel__collapsible-button--collapsed]=\"isCollapsed\" (click)=\"onCollapsibleButtonClick($event)\"> <i class=\"ux-icon\" [ngClass]=\"isCollapsed ? 'ux-icon-caret-right' : 'ux-icon-caret-left'\"></i> </div> </ng-template> <div *ngIf=\"isVisible && !showOnlyInvalid && !isCollapsed\" class=\"ux-panel-item {{styleClass}} {{statePanelItemClasses}} {{statePanelItemClassesDynamic}}\" #stickyContent> <span *ngIf=\"hasStatusIndicator && hasStatusIndicatorHeaderIcon\" class=\"ux-panel-item__status-indicator-icon-wrapper ux-u-bg-color-{{statusIndicatorTypeClass}}-dark\"> <span class=\"ux-panel-item__status-indicator-icon-wrapper-icon ux-icon ux-icon-{{statusIndicatorIconClass}}\"></span> </span> <ng-template [ngIf]=\"hasCustomPanelHeader\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ng-content select=\"uxPanelHeader\"></ng-content> <span *ngIf=\"isExpandable\" class=\"ux-panel-header__expand-toggle ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span> </div> </ng-template> <ng-template [ngIf]=\"hasCustomPanelHeaderWithDescendants\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ng-content select=\"uxPanelHeaderWithDescendants\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"!hasCustomPanelHeader && !hasCustomPanelHeaderWithDescendants\"> <div class=\"ux-panel-header {{headerStyleClass}} {{statePanelHeaderClasses}}\" [ngClass]=\"hasStatusIndicator && !hasStatusIndicatorHeaderBg && !hasStatusIndicatorHeaderIcon ? 'ux-u-border-l-'+statusIndicatorTypeClass : ''\" [class.ux-panel-header--accordion-expanded]=\"isExpanded && isAccordionPanel\" [class.ux-panel-header--expandable]=\"isExpandable\" (click)=\"toggle($event)\" [attr.role]=\"isExpandable ? 'button' : 'presentation'\" [tabindex]=\"tabindex\" attr.aria-label=\"{{label}} {{subLabel}} {{badgeLabel}} {{labelInfos}}\" [attr.aria-controls]=\"contentId\" [attr.aria-expanded]=\"isExpandable && isExpanded\" (keydown)=\"onKeyDown($event)\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" badgeLabel=\"{{badgeLabel}}\" badgeTypeClass=\"{{badgeTypeClass}}\" infos=\"{{labelInfos}}\" iconClass=\"{{iconClass}}\" iconTypeClass=\"{{iconTypeClass}}\" themeClass=\"{{labelThemeClass}}\" [isIconRounded]=\"isIconRounded\" subLabelSizeLimit=\"{{subLabelSizeLimit}}\" [isBoldLabel]=\"true\" tabindex=\"-1\"> </ux-a-label> <div [id]=\"contentId\" class=\"ux-panel-header__right-content\"> <ng-template [ngIf]=\"hasCustomPanelHeaderRightContent\"> <ng-content select=\"uxPanelHeaderRightContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"hasCustomPanelHeaderRightContentWithDescendants\"> <ng-content select=\"uxPanelHeaderRightContentWithDescendants\"></ng-content> </ng-template> <ng-template [ngIf]=\"!hasCustomPanelHeaderRightContent && !hasCustomPanelHeaderRightContentWithDescendants\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\"></ux-a-tag> </ng-template> <span *ngIf=\"isExpandable\" class=\"ux-panel-header__expand-toggle ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}\"></span> </div> </div> </ng-template> <ng-template [ngIf]=\"customSubHeaderContent\"> <div class=\"ux-panel-header__sub-header\"> <ng-content select=\"uxPanelSubHeaderContent\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"hasStatusIndicator && customStatusIndicatorContent\"> <div class=\"ux-panel-header__status-indicator-wrapper\"> <span class=\"ux-panel-header__status-indicator-wrapper-label ux-u-color-{{statusIndicatorTypeClass}}-darkest\"> {{statusIndicatorMessageLabel}} </span> <a *ngIf=\"isTogglableStatusIndicatorContent\" (click)=\"onToggleStatusIndicatorContent()\" class=\"ux-panel-header__status-indicator-wrapper-toggle\" tabindex=\"1\"> <span class=\"ux-icon\" [class.ux-icon-angle-down]=\"isStatusIndicatorContentExpanded\" [class.ux-icon-angle-right]=\"!isStatusIndicatorContentExpanded\"> </span> </a> </div> <div *ngIf=\"isStatusIndicatorContentExpanded\" class=\"ux-panel-header__status-indicator-content\"> <ng-content select=\"uxPanelHeaderStatusIndicatorContent\"></ng-content> </div> </ng-template> <div class=\"ux-panel-content {{statePanelContentClasses}} {{contentStyleClass}} {{statePanelContentClassesDynamic}}\" [class.ux-panel-content--fixed-height]=\"hasMaxHeight\" [style.max-height]=\"actualMaxHeight\" [hidden]=\"!isExpanded\" [style.height]=\"contentHeight\" [class.ux-panel-content--fixed-height-scrollable]=\"hasContentHeight\" aria-live=\"polite\"> <ng-content></ng-content> <div *ngIf=\"isBlocked\" class=\"ux-panel-content__blocked-overlay\" role=\"status\" [attr.aria-busy]=\"isBlocked\" [attr.aria-label]=\"isBlockedAriaLabel\"></div> </div> <div *ngIf=\"hasCustomPanelFooter\" class=\"ux-panel-footer\" [class.ux-panel-footer--large]=\"isLargeFooter\"> <ng-content select=\"uxPanelFooter\"></ng-content> </div> <div *ngIf=\"hasCustomPanelFooterWithDescendants\" class=\"ux-panel-footer\" [class.ux-panel-footer--large]=\"isLargeFooter\"> <ng-content select=\"uxPanelFooterWithDescendants\"></ng-content> </div> <div *ngIf=\"hasMaxHeight\" class=\"ux-panel-footer text-center\"> <button type=\"button\" class=\"btn btn-sm btn-secondary\" (click)=\"toggleMaxHeight($event)\"> <span *ngIf=\"isMaxHeightExpanded\">show less...</span> <span *ngIf=\"!isMaxHeightExpanded\">show more...</span> </button> </div> </div> </div> "
            },] },
];
/** @nocollapse */
UxPanelComponent.ctorParameters = () => [
    { type: UxPanelsComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [forwardRef(() => UxPanelsComponent),] },] },
    { type: ElementRef, },
    { type: Renderer2, },
    { type: UxService, },
    { type: UxDomService, },
];
UxPanelComponent.propDecorators = {
    "id": [{ type: Input },],
    "contentId": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "contentStyleClass": [{ type: Input },],
    "headerStyleClass": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "labelInfos": [{ type: Input },],
    "filterInput": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "isIconRounded": [{ type: Input },],
    "isExpandable": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "isVisible": [{ type: Input },],
    "isSelected": [{ type: Input },],
    "isCollapsible": [{ type: Input },],
    "isCollapsed": [{ type: Input },],
    "tagLabel": [{ type: Input },],
    "tagTypeClass": [{ type: Input },],
    "tagCount": [{ type: Input },],
    "badgeLabel": [{ type: Input },],
    "badgeTypeClass": [{ type: Input },],
    "hasTabs": [{ type: Input },],
    "hasNoHeader": [{ type: Input },],
    "hasNoContentPadding": [{ type: Input },],
    "isBlocked": [{ type: Input },],
    "isBlockedAriaLabel": [{ type: Input },],
    "maxHeight": [{ type: Input },],
    "contentHeight": [{ type: Input },],
    "isFlat": [{ type: Input },],
    "isLargeHeader": [{ type: Input },],
    "isLargeFooter": [{ type: Input },],
    "isSmallHeader": [{ type: Input },],
    "hasStatusIndicator": [{ type: Input },],
    "statusIndicatorTypeClass": [{ type: Input },],
    "statusIndicatorMessageLabel": [{ type: Input },],
    "isTogglableStatusIndicatorContent": [{ type: Input },],
    "isStatusIndicatorContentExpanded": [{ type: Input },],
    "hasStatusIndicatorHeaderBg": [{ type: Input },],
    "hasStatusIndicatorHeaderIcon": [{ type: Input },],
    "isEditModeActive": [{ type: Input },],
    "isContainerOnly": [{ type: Input },],
    "isClickable": [{ type: Input },],
    "isHighlighted": [{ type: Input },],
    "isAccordionPanel": [{ type: Input },],
    "customState": [{ type: Input },],
    "subLabelSizeLimit": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "isSticky": [{ type: Input },],
    "panelExpanded": [{ type: Output },],
    "panelCollapsed": [{ type: Output },],
    "customPanelHeader": [{ type: ContentChildren, args: [forwardRef(() => UxPanelHeaderTagDirective), { descendants: false },] },],
    "customPanelFooter": [{ type: ContentChildren, args: [forwardRef(() => UxPanelFooterTagDirective), { descendants: false },] },],
    "customPanelHeaderRightContent": [{ type: ContentChildren, args: [forwardRef(() => UxPanelHeaderRightContentTagDirective), { descendants: false },] },],
    "customPanelHeaderWithDescendants": [{ type: ContentChildren, args: [forwardRef(() => UxPanelHeaderWithDescendantsTagDirective), { descendants: true },] },],
    "customPanelFooterWithDescendants": [{ type: ContentChildren, args: [forwardRef(() => UxPanelFooterWithDescendantsTagDirective), { descendants: true },] },],
    "customPanelHeaderRightContentWithDescendants": [{ type: ContentChildren, args: [forwardRef(() => UxPanelHeaderRightContentWithDescendantsTagDirective), { descendants: true },] },],
    "customStatusIndicatorContent": [{ type: ContentChild, args: [forwardRef(() => UxPanelHeaderStatusIndicatorContentTagDirective),] },],
    "customSubHeaderContent": [{ type: ContentChild, args: [forwardRef(() => UxPanelSubHeaderContentTagDirective),] },],
    "stickyContainerElementRef": [{ type: ViewChild, args: ['stickyContainer',] },],
    "stickyContentElementRef": [{ type: ViewChild, args: ['stickyContent',] },],
};
class UxPanelHeaderTagDirective {
}
UxPanelHeaderTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelHeader' },] },
];
class UxPanelFooterTagDirective {
}
UxPanelFooterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelFooter' },] },
];
class UxPanelHeaderRightContentTagDirective {
}
UxPanelHeaderRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelHeaderRightContent' },] },
];
class UxPanelHeaderWithDescendantsTagDirective {
}
UxPanelHeaderWithDescendantsTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelHeaderWithDescendants' },] },
];
class UxPanelFooterWithDescendantsTagDirective {
}
UxPanelFooterWithDescendantsTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelFooterWithDescendants' },] },
];
class UxPanelHeaderRightContentWithDescendantsTagDirective {
}
UxPanelHeaderRightContentWithDescendantsTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelHeaderRightContentWithDescendants' },] },
];
class UxPanelHeaderStatusIndicatorContentTagDirective {
}
UxPanelHeaderStatusIndicatorContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelHeaderStatusIndicatorContent' },] },
];
class UxPanelSubHeaderContentTagDirective {
}
UxPanelSubHeaderContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPanelSubHeaderContent' },] },
];
class UxPanelComponentModule {
}
UxPanelComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxTagComponentModule, UxIconComponentModule, UxLabelComponentModule],
                exports: [
                    UxPanelComponent, UxPanelHeaderTagDirective, UxPanelFooterTagDirective,
                    UxPanelHeaderRightContentTagDirective, UxPanelHeaderStatusIndicatorContentTagDirective,
                    UxPanelHeaderWithDescendantsTagDirective,
                    UxPanelFooterWithDescendantsTagDirective,
                    UxPanelHeaderRightContentWithDescendantsTagDirective,
                    UxPanelSubHeaderContentTagDirective
                ],
                declarations: [
                    UxPanelComponent, UxPanelHeaderTagDirective, UxPanelFooterTagDirective,
                    UxPanelHeaderRightContentTagDirective, UxPanelHeaderStatusIndicatorContentTagDirective,
                    UxPanelHeaderWithDescendantsTagDirective,
                    UxPanelFooterWithDescendantsTagDirective,
                    UxPanelHeaderRightContentWithDescendantsTagDirective,
                    UxPanelSubHeaderContentTagDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLayoutFlexContentComponent {
    constructor() {
        this.isCollapsible = true;
        this.isCollapsed = false;
        this.isFlat = false;
        this.leftPanelSize = '20';
        // 2DO: Option feature to review: only applies for mobile & tablet modes when content is driven by router outlet
        // @Input() isAutoCollapsedOnClick: boolean = false;
        this.panelCollapsed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            if (item.getType() === 'left') {
                this.leftTemplate = item.template;
            }
            if (item.getType() === 'right') {
                this.rightTemplate = item.template;
            }
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCollapsibleButtonClick(event) {
        this.isCollapsed = !this.isCollapsed;
        this.panelCollapsed.emit(this.isCollapsed);
    }
}
UxLayoutFlexContentComponent.decorators = [
    { type: Component, args: [{
                /* tslint:disable-next-line */
                selector: 'ux-layout-flex-content',
                template: "<div class=\"ux-layout-flex-content {{styleClass}}\" [class.ux-layout-flex-content--not-collapsible]=\"!isCollapsible\"> <div class=\"ux-layout-flex-content__left\" [ngClass]=\"!isCollapsed ? 'ux-layout-flex-content__left--size-' + leftPanelSize : ''\" [class.ux-layout-flex-content__left--collapsed]=\"isCollapsed\" [class.ux-layout-flex-content__left--not-collapsible]=\"!isCollapsible\"> <div class=\"ux-layout-flex-content__left-container\" [class.ux-layout-flex-content__left-container--no-borders]=\"isFlat\"> <ng-template [ngIf]=\"leftTemplate\" [ngTemplateOutlet]=\"leftTemplate\"> </ng-template> </div> </div> <ng-template [ngIf]=\"isCollapsible\"> <div class=\"ux-layout-flex-content__collapsible-button\" [class.ux-layout-flex-content__collapsible-button--collapsed]=\"isCollapsed\" (click)=\"onCollapsibleButtonClick($event)\"> <i class=\"ux-icon\" [ngClass]=\"isCollapsed ? 'ux-icon-caret-right' : 'ux-icon-caret-left'\"></i> </div> </ng-template> <div class=\"ux-layout-flex-content__right\" [class.ux-layout-flex-content__right--overlay]=\"isCollapsible && !isCollapsed\"> <ng-template [ngIf]=\"rightTemplate\" [ngTemplateOutlet]=\"rightTemplate\"> </ng-template> </div> </div> ",
                styles: ["ux-layout-flex-content{flex-basis:0;flex-grow:1;max-width:100%}.ux-layout-flex-content{align-items:flex-start;-webkit-box-flex:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex !important;-ms-flex:1 1 auto;-webkit-flex:1 1 auto;flex:1 1 auto;-ms-flex-align:start;width:100%}.ux-layout-flex-content__left{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto}.ux-layout-flex-content__left--size-20{max-width:20%;width:20%}.ux-layout-flex-content__left--size-25{max-width:25%;width:25%}.ux-layout-flex-content__left--size-30{max-width:30%;width:30%}.ux-layout-flex-content__left--size-40{max-width:40%;width:40%}.ux-layout-flex-content__left--size-50{max-width:50%;width:50%}.ux-layout-flex-content__left--size-60{max-width:60%;width:60%}.ux-layout-flex-content__left--size-70{max-width:70%;width:70%}.ux-layout-flex-content__left--size-75{max-width:75%;width:75%}.ux-layout-flex-content__left--size-80{max-width:80%;width:80%}.ux-layout-flex-content__left--size-90{max-width:90%;width:90%}.ux-layout-flex-content__left--size-auto{max-width:100%;width:100%}.ux-layout-flex-content__left--collapsed{display:none}.ux-layout-flex-content__left--not-collapsible{margin-right:.89rem}.ux-layout-flex-content__left-container{background-color:white;border-radius:3px;border-top:1px solid #ddd;margin-bottom:1.25rem;position:relative;width:100%;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-layout-flex-content__left-container::after{clear:both;content:\"\";display:table}.ux-layout-flex-content__left-container--no-borders{background-color:transparent;border:none;box-shadow:none}.ux-layout-flex-content__left-container .ux-panel{margin-bottom:0}.ux-layout-flex-content__collapsible-button{align-items:center;background-color:white;border:1px solid #ddd;color:#004494;cursor:pointer;display:flex;font-size:1.5rem;height:3.5rem;margin-right:.89rem;padding:.89rem;position:relative;text-align:center}.ux-layout-flex-content__collapsible-button--collapsed{align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center}.ux-layout-flex-content__collapsible-button:hover{background-color:#4d7cb4;color:white}.ux-layout-flex-content__right{-webkit-flex:1 1 0%;-ms-flex:1 0 auto;overflow:visible}.ux-layout-flex-content__right-container{background-color:white;border-radius:3px;margin-bottom:1.25rem;padding:1.25rem;width:100%;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24)}.ux-layout-flex-content__right-container--clickable{cursor:pointer}.ux-layout-flex-content__right-container--clickable:focus,.ux-layout-flex-content__right-container--clickable:hover{background:#eee;outline:0;cursor:pointer;box-shadow:0 3px 6px rgba(0,0,0,0.16),0 3px 6px rgba(0,0,0,0.23)}.ux-layout-flex-content__right-container .col:not(:first-child),.ux-layout-flex-content__right-container .ux-col:not(:first-child){padding-top:2rem}@media screen and (max-width: 991px){.ux-layout-flex-content__left{min-width:60%;position:absolute;z-index:2}.ux-layout-flex-content__left--not-collapsible{display:flex;margin-right:1.25rem;position:relative !important}.ux-layout-flex-content__collapsible-button{left:60%;margin-left:1.25rem;padding:.66rem;position:absolute;text-align:center;z-index:1}.ux-layout-flex-content__collapsible-button:hover{background-color:#4d7cb4;color:white}.ux-layout-flex-content__collapsible-button--collapsed{align-items:center;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-ms-flex-align:center;left:0;margin-left:0;position:relative}.ux-layout-flex-content__right--overlay{opacity:0.4}.ux-layout-flex-content__right--overlay>*{cursor:not-allowed}.ux-layout-flex-content__right .content{align-items:center;display:flex;flex-direction:row;text-align:center;width:100% !important}}@media screen and (min-width: 0) and (max-width: 575px){.ux-layout-flex-content{display:block !important;max-width:100%;position:relative;width:100%}.ux-layout-flex-content__left{display:block;position:relative}.ux-layout-flex-content__left--not-collapsible{display:block;max-width:100%;position:relative !important;width:100%}.ux-layout-flex-content__collapsible-button{display:none}.ux-layout-flex-content__right{display:block;position:relative}.ux-layout-flex-content__right--overlay{opacity:1}.ux-layout-flex-content__right--overlay>*{cursor:pointer}} /*# sourceMappingURL=ux-layout-flex-content.component.css.map */"],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
UxLayoutFlexContentComponent.ctorParameters = () => [];
UxLayoutFlexContentComponent.propDecorators = {
    "isCollapsible": [{ type: Input },],
    "isCollapsed": [{ type: Input },],
    "isFlat": [{ type: Input },],
    "leftPanelSize": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "panelCollapsed": [{ type: Output },],
    "templates": [{ type: ContentChildren, args: [UxTemplateDirective,] },],
};
class UxLayoutFlexContentModule {
}
UxLayoutFlexContentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxPanelComponentModule],
                exports: [
                    UxLayoutFlexContentComponent
                ],
                declarations: [
                    UxLayoutFlexContentComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxSearchInputComponent {
    /**
     * @param {?} shadowDomRoot
     * @param {?} uxService
     */
    constructor(shadowDomRoot, uxService) {
        this.shadowDomRoot = shadowDomRoot;
        this.uxService = uxService;
        this.minCharacters = 3;
        this.maxHistoryEntries = 3;
        this.keyboardDebounceTime = 200;
        this.historicalSearches = [];
        this.suggestionsService = {
            /**
             * @param {?} query
             * @return {?}
             */
            getSuggestions(query) {
                return new Observable((observer) => {
                    observer.next([]);
                    observer.complete();
                });
            }
        };
        this.search = new EventEmitter();
        this.query = '';
        this.autocompleteLoading = false;
        this.historicalSearchesVisible = true;
        this.suggestionsVisible = false;
        this.noSuggestionsFound = false;
        this.ignoreInputBlur = false;
        this.control = new FormControl();
        this.control.valueChanges.debounceTime(this.keyboardDebounceTime).subscribe((query) => {
            this.query = query;
            this.getSuggestions();
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.searchInput = /** @type {?} */ (this.shadowDomQuery('input'));
    }
    /**
     * @return {?}
     */
    getQuery() {
        return this.query;
    }
    /**
     * @param {?} query
     * @return {?}
     */
    setQuery(query) {
        this.query = query;
    }
    /**
     * @return {?}
     */
    focus() {
        this.searchInput.focus();
    }
    /**
     * @return {?}
     */
    focusAndSelect() {
        this.focus();
        this.searchInput.select();
    }
    /**
     * @return {?}
     */
    hideSuggestions() {
        this.suggestionsVisible = false;
    }
    /**
     * @return {?}
     */
    showSuggestions() {
        let /** @type {?} */ show = true;
        // The suggestions should not be shown when:
        // 1. There are no visible suggestions.
        let /** @type {?} */ firstVisibleSuggestion = this.shadowDomQuery('.dropdown-item:not([hidden])');
        show = show && (firstVisibleSuggestion != null);
        // 2. The focus is no longer on the input field.
        show = show && (this.searchInput === this.shadowDomQuery(':focus'));
        if (show) {
            this.suggestionsVisible = true;
        }
        this.inactivateActiveSuggestion();
    }
    /**
     * @return {?}
     */
    startSearch() {
        this.storeHistoricalSearch();
        this.search.emit(this.query);
    }
    /**
     * @return {?}
     */
    showHistoricalSearches() {
        this.suggestions = [];
        this.historicalSearchesVisible = true;
        this.noSuggestionsFound = this.historicalSearches.length <= 0;
        this.showSuggestions();
    }
    /**
     * @return {?}
     */
    searchInputBlur() {
        if (!this.ignoreInputBlur) {
            this.hideSuggestions();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchInputKeydown(event) {
        let /** @type {?} */ keyCode = event.keyCode;
        if (keyCode === 40 || keyCode === 38) {
            // 40 = arrow down, 38 = arrow up
            this.focusNextSuggestion(event);
        }
        else if (keyCode === 13) {
            // 13 = enter
            // Wait for field value to update:
            setTimeout(() => {
                this.startSearch();
            }, this.keyboardDebounceTime);
        }
        else {
            this.hideSuggestionOnEscape(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    searchInputClick(event) {
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    suggestionKeydown(event) {
        let /** @type {?} */ keyCode = event.keyCode;
        if (keyCode === 40) {
            // 40 = arrow down
            this.focusNextSuggestion(event);
        }
        else if (keyCode === 38) {
            // 38 = arrow up
            this.focusPreviousSuggestion(event);
        }
        else if (keyCode === 13) {
            // 13 = enter
            this.selectActiveSuggestion();
        }
        else if (keyCode === 8) {
            // 8 = backspace
            this.consumeEvent(event);
        }
        this.hideSuggestionOnEscape(event);
    }
    /**
     * @return {?}
     */
    suggestionBlur() {
        if (!this.ignoreInputBlur) {
            this.hideSuggestions();
        }
    }
    /**
     * @return {?}
     */
    selectActiveSuggestion() {
        let /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
        if (activeSuggestion != null) {
            let /** @type {?} */ suggestion = activeSuggestion.textContent;
            // Wait for input event to finish:
            setTimeout(() => {
                this.hideSuggestions();
                this.focus();
                this.query = /** @type {?} */ (suggestion);
                this.startSearch();
            }, 0);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    suggestionClicked(event) {
        let /** @type {?} */ clickedSuggestion = /** @type {?} */ (event.currentTarget);
        if (clickedSuggestion != null) {
            this.inactivateActiveSuggestion();
            clickedSuggestion.classList.add('active');
            // Wait for input event to finish:
            setTimeout(() => {
                this.hideSuggestions();
                this.focus();
                this.query = /** @type {?} */ (clickedSuggestion.textContent);
                this.startSearch();
            }, 0);
        }
    }
    /**
     * @return {?}
     */
    getActiveSuggestion() {
        return this.shadowDomQuery('.dropdown-item.active');
    }
    /**
     * @param {?} querySelector
     * @return {?}
     */
    shadowDomQuery(querySelector) {
        return this.shadowDomRoot.nativeElement.querySelector(querySelector);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    consumeEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        event.cancelBubble = true;
        return false;
    }
    /**
     * @return {?}
     */
    ignoreBlur() {
        this.ignoreInputBlur = true;
    }
    /**
     * @return {?}
     */
    allowBlur() {
        // IE issue: let the focus() on an element first be completed before the blur() can be triggered.
        setTimeout(() => {
            this.ignoreInputBlur = false;
        }, 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    hideSuggestionOnEscape(event) {
        let /** @type {?} */ keyCode = event.keyCode;
        if (keyCode === 27) {
            // 27 = escape
            this.hideSuggestions();
            this.focus();
            this.consumeEvent(event);
        }
    }
    /**
     * @param {?} menuItem
     * @return {?}
     */
    focusOnMenuItem(menuItem) {
        this.ignoreBlur();
        menuItem.focus();
        this.allowBlur();
    }
    /**
     * @param {?} activeSuggestion
     * @return {?}
     */
    focusFirstSuggestion(activeSuggestion) {
        if (!this.noSuggestionsFound) {
            if (activeSuggestion == null) {
                let /** @type {?} */ firstSuggestion = this.shadowDomQuery('.dropdown-item:not([hidden])');
                if (firstSuggestion != null && !firstSuggestion.classList.contains('empty')) {
                    firstSuggestion.classList.add('active');
                    this.focusOnMenuItem(firstSuggestion);
                }
            }
            else {
                setTimeout(() => {
                    this.focusOnMenuItem(activeSuggestion);
                }, 0);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusNextSuggestion(event) {
        let /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
        if (!this.suggestionsVisible) {
            this.showSuggestions();
            this.focusFirstSuggestion(activeSuggestion);
        }
        else {
            if (activeSuggestion != null) {
                // focus next suggestion:
                let /** @type {?} */ nextSuggestion = /** @type {?} */ (activeSuggestion.nextElementSibling);
                if (nextSuggestion != null && !nextSuggestion.classList.contains('empty')) {
                    activeSuggestion.classList.remove('active');
                    nextSuggestion.classList.add('active');
                    this.ignoreBlur();
                    nextSuggestion.focus();
                    this.allowBlur();
                }
            }
            else {
                this.focusFirstSuggestion(activeSuggestion);
            }
        }
        this.consumeEvent(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusPreviousSuggestion(event) {
        let /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
        if (!this.suggestionsVisible) {
            this.showSuggestions();
            this.focusFirstSuggestion(activeSuggestion);
        }
        else {
            if (activeSuggestion != null) {
                // focus next suggestion:
                let /** @type {?} */ previousSuggestion = /** @type {?} */ (activeSuggestion.previousElementSibling);
                if (previousSuggestion != null && !previousSuggestion.classList.contains('empty')) {
                    activeSuggestion.classList.remove('active');
                    previousSuggestion.classList.add('active');
                    this.ignoreBlur();
                    previousSuggestion.focus();
                    this.allowBlur();
                }
            }
            else {
                this.focusFirstSuggestion(activeSuggestion);
            }
        }
        this.consumeEvent(event);
    }
    /**
     * @return {?}
     */
    inactivateActiveSuggestion() {
        let /** @type {?} */ activeSuggestion = this.getActiveSuggestion();
        if (activeSuggestion != null) {
            activeSuggestion.classList.remove('active');
        }
    }
    /**
     * @return {?}
     */
    storeHistoricalSearch() {
        // Remove existing entry:
        let /** @type {?} */ search = this.query;
        if (search !== null && search.trim().length > 0) {
            let /** @type {?} */ index = this.historicalSearches.indexOf(search, 0);
            if (index > -1) {
                this.historicalSearches.splice(index, 1);
            }
            this.historicalSearches.unshift(search);
            if (this.historicalSearches.length > this.maxHistoryEntries) {
                this.historicalSearches.splice(this.maxHistoryEntries);
            }
        }
    }
    /**
     * @return {?}
     */
    getSuggestions() {
        if (this.query.length >= this.minCharacters) {
            this.hideSuggestions();
            this.noSuggestionsFound = false;
            this.autocompleteLoading = true;
            this.suggestions = [];
            this.suggestionsService.getSuggestions(this.query).subscribe((suggestions) => {
                this.suggestions = suggestions;
                this.noSuggestionsFound = (this.suggestions == null || this.suggestions.length <= 0);
                this.autocompleteLoading = false;
                this.historicalSearchesVisible = false;
                setTimeout(() => {
                    this.showSuggestions();
                }, 0);
            });
        }
        else if (this.query.trim().length <= 0) {
            this.showHistoricalSearches();
        }
    }
}
UxSearchInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-search-input',
                template: `

        <div class="ux-search-input-container">
            <input #input type="search" class="form-control" [value]="query"
                   [formControl]="control" (blur)="searchInputBlur()"
                   (keydown)="searchInputKeydown($event)"
                   (click)="searchInputClick($event)"/>
            <div class="dropdown-menu-container">
                <div class="dropdown-menu" [hidden]="! suggestionsVisible">
                    <div *ngFor="let historicalSearch of historicalSearches"
                         class="dropdown-item historical" tabindex="0"
                         [hidden]="! historicalSearchesVisible"
                         (keydown)="suggestionKeydown($event)"
                         (mousedown)="suggestionClicked($event)"
                         (blur)="suggestionBlur()">
                         {{historicalSearch}}
                   </div>
                    <div *ngFor="let suggestion of suggestions" class="dropdown-item" tabindex="0"
                         (keydown)="suggestionKeydown($event)"
                         (mousedown)="suggestionClicked($event)"
                         (blur)="suggestionBlur()">
                         {{suggestion}}
                    </div>
                    <div class="dropdown-item empty" [hidden]="! noSuggestionsFound">
                        No suggestions found.
                    </div>
                </div>
            </div>
            <div class="spinner" [hidden]="! autocompleteLoading">
                <div class="spinner-item1"></div>
                <div class="spinner-item2"></div>
                <div class="spinner-item3"></div>
            </div>
        </div>


    `
            },] },
];
/** @nocollapse */
UxSearchInputComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: UxService, },
];
UxSearchInputComponent.propDecorators = {
    "minCharacters": [{ type: Input },],
    "maxHistoryEntries": [{ type: Input },],
    "keyboardDebounceTime": [{ type: Input },],
    "historicalSearches": [{ type: Input },],
    "suggestionsService": [{ type: Input },],
    "search": [{ type: Output },],
};
class UxSearchInputComponentModule {
}
UxSearchInputComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ReactiveFormsModule],
                exports: [UxSearchInputComponent],
                declarations: [UxSearchInputComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxIconToggleComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.styleClassOn = 'ux-u-color-accent-dark';
        this.styleClassOff = 'ux-u-color-grey-dark';
        this.isChecked = false;
        this.isReadOnly = false;
        this.tabindex = 0;
        this.toggle = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setIconClass();
        if (!this.ariaLabel || this.ariaLabel === '') {
            this.ariaLabel = (this.iconClass ? this.iconClass : '');
        }
    }
    /**
     * @return {?}
     */
    onToggle() {
        if (!this.isReadOnly) {
            this.isChecked = !this.isChecked;
            this.setIconClass();
            this.toggle.emit(this.isChecked);
        }
        this.focusElement.nativeElement.focus();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        switch (event.keyCode) {
            case 13: // ENTER
            case 32:
                // SPACE
                this.uxService.consumeEvent(event);
                this.onToggle();
                break;
        }
    }
    /**
     * @return {?}
     */
    setIconClass() {
        if (this.isChecked) {
            this.iconClass = this.iconClassOn;
            this.stateClass = this.styleClassOn;
        }
        else {
            this.iconClass = this.iconClassOff;
            this.stateClass = this.styleClassOff;
        }
    }
}
UxIconToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-icon-toggle',
                template: "<span #focusElement class=\"ux-a-icon-toggle {{stateClass}} {{styleClass}}\" tabindex=\"{{!isReadOnly ? tabindex: '-1'}}\" role=\"switch\" [attr.aria-label]=\"ariaLabel\" [attr.aria-checked]=\"isChecked\" [attr.accesskey]=\"keyboardAccessKey\" (click)=\"onToggle()\" (keydown)=\"onKeyDown($event)\"> <span class=\"{{iconClass}} ux-a-icon__icon\" [class.ux-u-cursor-pointer]=\"!isReadOnly\"></span> </span> ",
                styles: [".ux-a-icon-toggle .ux-a-icon__icon{font-size:1.42857rem} /*# sourceMappingURL=ux-a-icon-toggle.component.css.map */"],
            },] },
];
/** @nocollapse */
UxIconToggleComponent.ctorParameters = () => [
    { type: UxService, },
];
UxIconToggleComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "styleClassOn": [{ type: Input },],
    "styleClassOff": [{ type: Input },],
    "iconClassOff": [{ type: Input },],
    "iconClassOn": [{ type: Input },],
    "isChecked": [{ type: Input },],
    "isReadOnly": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "ariaLabel": [{ type: Input },],
    "keyboardAccessKey": [{ type: Input },],
    "toggle": [{ type: Output },],
    "focusElement": [{ type: ViewChild, args: ['focusElement',] },],
};
class UxIconToggleComponentModule {
}
UxIconToggleComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxIconToggleComponent],
                declarations: [UxIconToggleComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxIconBoxComponent {
    constructor() {
        this.tabindex = 0;
    }
}
UxIconBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-a-icon-box',
                template: "<div class=\"ux-a-icon-box {{styleClass}}\" [tabindex]=\"tabindex\" [attr.aria-label]=\"label\"> <div class=\"ux-a-icon-box__icon\"> <span class=\"ux-a-icon-box__icon-element {{iconClass}}\"></span> </div> <div class=\"ux-a-icon-box__label\"> {{label}} </div> </div> ",
                styles: [".ux-a-icon-box{box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);background-color:#004494;color:white;flex:0 0 8rem;height:9rem;margin-right:1.25rem;padding:.66rem;text-align:center}.ux-a-icon-box__icon{font-size:4rem}.ux-a-icon-box__label{font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal;text-transform:uppercase} /*# sourceMappingURL=ux-a-icon-box.component.css.map */"],
            },] },
];
/** @nocollapse */
UxIconBoxComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "label": [{ type: Input },],
    "tabindex": [{ type: Input },],
};
class UxIconBoxComponentModule {
}
UxIconBoxComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxIconBoxComponent],
                declarations: [UxIconBoxComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBlockContentComponent {
    /**
     * @param {?} elRef
     * @param {?} renderer
     */
    constructor(elRef, renderer) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.lastActiveElement = null;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ activeElement = this.getActiveElement();
        const /** @type {?} */ isBlocking = this.isAboutToBlock(changes);
        if (isBlocking) {
            this.desactivateElement(activeElement);
        }
        else {
            this.reactivateElement(activeElement);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    isAboutToBlock(changes) {
        const /** @type {?} */ isBlockedChange = changes['isBlocked'];
        return isBlockedChange &&
            isBlockedChange.currentValue &&
            !isBlockedChange.previousValue;
    }
    /**
     * @param {?} activeElement
     * @return {?}
     */
    desactivateElement(activeElement) {
        if (activeElement) {
            this.renderer.invokeElementMethod(activeElement, 'blur');
            this.lastActiveElement = activeElement;
        }
        else {
            this.lastActiveElement = null;
        }
    }
    /**
     * @param {?} activeElement
     * @return {?}
     */
    reactivateElement(activeElement) {
        if (this.lastActiveElement) {
            this.renderer.invokeElementMethod(this.lastActiveElement, 'focus');
        }
    }
    /**
     * @return {?}
     */
    getActiveElement() {
        return this.elRef.nativeElement.querySelector(':focus');
    }
}
UxBlockContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-block-content',
                template: "<div class=\"ux-c-block-content\" [class.ux-is-active]=\"isBlocked\"> <ng-content></ng-content> </div> ",
            },] },
];
/** @nocollapse */
UxBlockContentComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
];
UxBlockContentComponent.propDecorators = {
    "isBlocked": [{ type: Input },],
};
class UxBlockContentComponentModule {
}
UxBlockContentComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxBlockContentComponent],
                declarations: [UxBlockContentComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDisableContentComponent {
    /**
     * @param {?} elRef
     * @param {?} renderer
     * @param {?} uxService
     */
    constructor(elRef, renderer, uxService) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.uxService = uxService;
        this.disabledText = '';
        this.lastActiveElement = null;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ activeElement = this.getActiveElement();
        const /** @type {?} */ isBlocking = this.isAboutToBlock(changes);
        if (isBlocking) {
            this.desactivateElement(activeElement);
        }
        else {
            this.reactivateElement(activeElement);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    isAboutToBlock(changes) {
        const /** @type {?} */ isBlockedChange = changes['isDisabled'];
        return isBlockedChange &&
            isBlockedChange.currentValue &&
            !isBlockedChange.previousValue;
    }
    /**
     * @param {?} activeElement
     * @return {?}
     */
    desactivateElement(activeElement) {
        if (activeElement) {
            this.renderer.invokeElementMethod(activeElement, 'blur');
            this.lastActiveElement = activeElement;
        }
        else {
            this.lastActiveElement = null;
        }
    }
    /**
     * @param {?} activeElement
     * @return {?}
     */
    reactivateElement(activeElement) {
        if (this.lastActiveElement) {
            this.renderer.invokeElementMethod(this.lastActiveElement, 'focus');
        }
    }
    /**
     * @return {?}
     */
    getActiveElement() {
        return this.elRef.nativeElement.querySelector(':focus');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.isDisabled && this.disabledText) {
            this.uxService.growlInfo(this.disabledText);
        }
    }
}
UxDisableContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-disable-content',
                template: "<div class=\"ux-c-disable-content\" [class.ux-is-active]=\"isDisabled\" (click)=\"onClick($event)\"> <ng-content></ng-content> </div> ",
            },] },
];
/** @nocollapse */
UxDisableContentComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
    { type: UxService, },
];
UxDisableContentComponent.propDecorators = {
    "isDisabled": [{ type: Input },],
    "disabledText": [{ type: Input },],
};
class UxDisableContentComponentModule {
}
UxDisableContentComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxDisableContentComponent],
                declarations: [UxDisableContentComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxProgressCircleComponent {
    constructor() {
        this.emptyLabel = 'N/A';
        this.isDefaultColorSteps = true;
        this.isSmall = false;
        this.isLarge = false;
        this.tabindex = '0';
        this.ariaLabel = '';
        this.stateColorNumberClass = '';
        this.labelValue = '';
        this.percentValue = '';
        this.isLongLabel = false;
        this.offsetWidth = 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        const /** @type {?} */ prefix = 'ux-progress-circle--';
        let /** @type {?} */ colorStepsArray = [];
        this.roundedValue = Math.round(this.value);
        if (this.colorSteps) {
            colorStepsArray = this.colorSteps.split(/[ ,]+/g);
        }
        else {
            colorStepsArray = ['33', '66'];
        }
        if (this.colorType) {
            this.stateColorNumberClass = prefix + this.colorType;
        }
        else {
            if (this.isDefaultColorSteps) {
                if (this.value <= Number.parseInt(colorStepsArray[0], 10)) {
                    this.stateColorNumberClass = prefix + 'success';
                }
                if (this.value > Number.parseInt(colorStepsArray[0], 10) && this.value <= Number.parseInt(colorStepsArray[1], 10)) {
                    this.stateColorNumberClass = prefix + 'warning';
                }
                if (this.value > Number.parseInt(colorStepsArray[1], 10)) {
                    this.stateColorNumberClass = prefix + 'danger';
                }
            }
        }
        if (this.value === 0) {
            this.labelValue = this.emptyLabel;
        }
        else {
            if (this.valueLabel) {
                this.labelValue = this.valueLabel;
            }
            else {
                this.labelValue = this.value + '%';
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        if (this.labelValueEl) {
            this.offsetWidth = this.labelValueEl.nativeElement.offsetWidth;
            if (this.offsetWidth > 60) {
                this.isLongLabel = true;
            }
        }
    }
}
UxProgressCircleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-progress-circle',
                template: `
        <div class="ux-progress-circle-wrapper" [tabindex]="tabindex" [attr.aria-label]="ariaLabel">
            <div class="ux-progress-circle p{{roundedValue}} {{stateColorNumberClass}}"
                [class.ux-progress-circle--over50]="roundedValue > 50"
                [class.ux-progress-circle--small]="isSmall"
                [class.ux-progress-circle--large]="isLarge">

                <span class="ux-progress-circle__label" *ngIf="!isLongLabel">
                    <span #labelValueEl>{{labelValue}}</span>
                </span>
                <div class="ux-progress-circle__left-half-clipper">
                    <div class="ux-progress-circle__first50-bar"></div>
                    <div class="ux-progress-circle__value-bar"></div>
                </div>

                <div class="ux-progress-circle__bottom-label" *ngIf="isLongLabel"
                    [class.ux-progress-circle--small]="isSmall"
                    [class.ux-progress-circle--large]="isLarge">
                    <span class="label">{{labelValue}}</span>
                </div>
            </div>
            <div *ngIf="iconLabelClass"
                 [class.ux-progress-circle__icon-label]="!isLarge && !isSmall"
                 [class.ux-progress-circle__icon-label--small]="isSmall"
                 [class.ux-progress-circle__icon-label--large]="isLarge">
                <span class="{{iconLabelClass}} {{iconLabelStyleClass}}"></span>
            </div>
        </div>
        `
            },] },
];
/** @nocollapse */
UxProgressCircleComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "value": [{ type: Input },],
    "emptyLabel": [{ type: Input },],
    "valueLabel": [{ type: Input },],
    "isDefaultColorSteps": [{ type: Input },],
    "colorSteps": [{ type: Input },],
    "colorType": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "iconLabelClass": [{ type: Input },],
    "iconLabelStyleClass": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "ariaLabel": [{ type: Input },],
    "labelValueEl": [{ type: ViewChild, args: ['labelValueEl',] },],
};
class UxProgressCircleComponentModule {
}
UxProgressCircleComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxProgressCircleComponent],
                declarations: [UxProgressCircleComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxActionBoxComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.items = [];
        this.isCollapsible = true;
        this.isExpanded = true;
        this.isLeftPositioned = false;
        this.isSticky = false;
        this.tabindex = '0';
        this.actionsYOffset = 14;
        this.onScrollBind = this.onScroll.bind(this);
        this.onResizeBind = this.onResize.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isSticky) {
            window.addEventListener('scroll', this.onScrollBind);
            window.addEventListener('resize', this.onResizeBind);
        }
        this.generatedId = this.uxService.uniqueId();
    }
    /**
     * @return {?}
     */
    onScroll() {
        this.handleStickyActionsBox();
    }
    /**
     * @return {?}
     */
    onResize() {
        this.handleStickyActionsBox();
    }
    /**
     * @return {?}
     */
    handleStickyActionsBox() {
        if (this.actionsElementRef) {
            let /** @type {?} */ effectiveTopOffset = '';
            const /** @type {?} */ actionsTopOffset = this.containerElementRef.nativeElement.getBoundingClientRect().top;
            if (actionsTopOffset < 0) {
                effectiveTopOffset = -actionsTopOffset + this.actionsYOffset + 'px';
            }
            this.actionsElementRef.nativeElement.style.top = effectiveTopOffset;
        }
    }
    /**
     * @return {?}
     */
    get stateCollapsedClass() {
        if (!this.isExpanded) {
            return 'ux-action-box--collapsed';
        }
        return '';
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onItemClick(link) {
        if (link && link.command) {
            link.command();
        }
    }
    /**
     * @return {?}
     */
    onToggle() {
        if (this.isCollapsible) {
            this.isExpanded = !this.isExpanded;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        switch (event.keyCode) {
            case 13: // ENTER
            case 32:
                // SPACE
                this.uxService.consumeEvent(event);
                this.onToggle();
                break;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        window.removeEventListener('scroll', this.onScrollBind);
        window.removeEventListener('resize', this.onResizeBind);
    }
}
UxActionBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-action-box',
                template: "<div *ngIf=\"isLeftPositioned\" #container class=\"flex-container flex-container--align-top\"> <div #actions class=\"ux-action-box__actions\" [class.ux-action-box__actions--collapsed]=\"!isExpanded\" [class.ux-action-box__actions--left-positioned]=\"true\"> <ux-panel [id]=\"generatedId\" styleClass=\"{{stateCollapsedClass}}\" [tabindex]=\"tabindex\"> <uxPanelHeader> <ux-a-label *ngIf=\"isExpanded\" label=\"{{titleLabel}}\" styleClass=\"ux-action-box__label\" tabindex=\"-1\"></ux-a-label> <div class=\"ux-panel-header__right-content\"> <span *ngIf=\"isCollapsible\" class=\"ux-icon ux-action-box__icon-toggle\" [class.ux-icon-indent]=\"isExpanded\" [class.ux-icon-dedent]=\"!isExpanded\" role=\"button\" [attr.aria-controls]=\"generatedId\" [attr.aria-expanded]=\"isExpanded\" [tabindex]=\"tabindex\" (keydown)=\"onKeyDown($event)\" (click)=\"onToggle()\"></span> </div> </uxPanelHeader> <ng-template ngFor let-item [ngForOf]=\"items\"> <ux-list-items *ngIf=\"item.actions\" titleLabel=\"{{item.label}}\" [links]=\"item.actions\" [expanded]=\"isExpanded\" [isSmall]=\"true\" (listItemClick)=\"onItemClick($event)\" [isLeftPositioned]=\"true\" [isAccessible]=\"true\"> </ux-list-items> </ng-template> </ux-panel> </div> <ng-container *ngTemplateOutlet=\"content\"></ng-container> </div> <div *ngIf=\"!isLeftPositioned\" #container class=\"flex-container flex-container--align-top\"> <ng-container *ngTemplateOutlet=\"content\"></ng-container> <div #actions  class=\"ux-action-box__actions\" [class.ux-action-box__actions--collapsed]=\"!isExpanded\" [class.ux-action-box__actions--left-positioned]=\"false\"> <ux-panel [id]=\"generatedId\" styleClass=\"{{stateCollapsedClass}}\" [tabindex]=\"tabindex\"> <uxPanelHeader> <ux-a-label *ngIf=\"isExpanded\" label=\"{{titleLabel}}\" styleClass=\"ux-action-box__label\" tabindex=\"-1\"></ux-a-label> <div class=\"ux-panel-header__right-content\"> <span *ngIf=\"isCollapsible\" class=\"ux-icon ux-action-box__icon-toggle\" [class.ux-icon-indent]=\"isExpanded\" [class.ux-icon-dedent]=\"!isExpanded\" role=\"button\" [tabindex]=\"tabindex\" [attr.aria-controls]=\"generatedId\" [attr.aria-expanded]=\"isExpanded\" (keydown)=\"onKeyDown($event)\" (click)=\"onToggle()\"></span> </div> </uxPanelHeader> <ng-template ngFor let-item [ngForOf]=\"items\"> <ux-list-items *ngIf=\"item.actions\" titleLabel=\"{{item.label}}\" [links]=\"item.actions\" [expanded]=\"isExpanded\" [isSmall]=\"true\" (listItemClick)=\"onItemClick($event)\" [isLeftPositioned]=\"false\" [isAccessible]=\"true\"> </ux-list-items> </ng-template> </ux-panel> </div> </div> <ng-template #content> <div class=\"ux-action-box__content\"> <ng-content></ng-content> </div> <ng-template> ",
            },] },
];
/** @nocollapse */
UxActionBoxComponent.ctorParameters = () => [
    { type: UxService, },
];
UxActionBoxComponent.propDecorators = {
    "titleLabel": [{ type: Input },],
    "items": [{ type: Input },],
    "isCollapsible": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "isLeftPositioned": [{ type: Input },],
    "isSticky": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "containerElementRef": [{ type: ViewChild, args: ['container',] },],
    "actionsElementRef": [{ type: ViewChild, args: ['actions',] },],
};
class UxActionBoxComponentModule {
}
UxActionBoxComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxListItemsComponentModule, UxPanelComponentModule, UxLabelComponentModule],
                exports: [UxActionBoxComponent],
                declarations: [UxActionBoxComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxActionBoxItem {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAlertComponent {
    constructor() {
        this.typeClass = 'info';
        this.isMuted = false;
        this.isCloseable = false;
        this.close = new EventEmitter();
        this.isVisible = true;
        this.contentClass = '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.iconClass) {
            this.isMuted = true;
            this.contentClass = 'text with-icon';
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onCloseClick(evt) {
        this.isVisible = false;
        this.close.next();
    }
}
UxAlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-alert',
                template: "<div *ngIf=\"isVisible\" class=\"alert alert-{{typeClass}} ux-alert {{styleClass}}\" [class.muted]=\"isMuted\"> <div class=\"ux-alert__content-container {{contentClass}}\"> <div *ngIf=\"iconClass\" class=\"{{iconClass}} icon\"></div> <div> <ng-content></ng-content> </div> <div *ngIf=\"isCloseable\" (click)=\"onCloseClick($event)\" class=\"ux-alert__close\">×</div> </div> </div> ",
            },] },
];
/** @nocollapse */
UxAlertComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isMuted": [{ type: Input },],
    "isCloseable": [{ type: Input },],
    "close": [{ type: Output },],
};
class UxAlertComponentModule {
}
UxAlertComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxAlertComponent],
                declarations: [UxAlertComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDashboardCardComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.imageWidth = '64';
        this.imageHeight = '64';
        this.isIconCompact = true;
        this.buttonStyleClass = 'btn-info';
        this.isClickable = false;
        this.isHorizontalLayout = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    get stateTypeClass() {
        let /** @type {?} */ classes = '';
        if (this.typeClass) {
            classes = 'ux-dashboard-card--' + this.typeClass;
        }
        return classes;
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    onKeyDown(keyCode) {
        if (this.isClickable && keyCode === 13) {
            this.openLink();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.isClickable) {
            this.openLink();
        }
    }
    /**
     * @return {?}
     */
    openLink() {
        if (this.url) {
            this.uxService.appRouter.navigate([this.url]);
        }
        if (this.urlExternal) {
            window.open(this.urlExternal, '_blank');
        }
    }
}
UxDashboardCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dashboard-card',
                template: `
      <div class="ux-dashboard-card {{styleClass}} {{stateTypeClass}}" tabindex="1" [class.row]="isHorizontalLayout"
                 [class.ux-dashboard-card--clickable]="isClickable"
                 [class.ux-dashboard-card--icon-compact]="isIconCompact"
                 [class.ux-dashboard-card--horizontal]="isHorizontalLayout"
                 [class.ux-dashboard-card--horizontal--icon-compact]="isIconCompact && isHorizontalLayout"
                 (click)="onClick($event)"
                 (keydown)="onKeyDown($event.keyCode)">

          <div *ngIf="iconClass" [class.col-4]="isHorizontalLayout" class="ux-dashboard-card__icon-container">
              <div class="ux-dashboard-card__icon-wrapper ux-dashboard-card__icon-wrapper--{{iconTypeClass}}">
                  <span class="{{iconClass}} ux-icon-fw ux-dashboard-card__icon-wrapper-icon"></span>
              </div>
          </div>

          <div *ngIf="imageUrl" [class.col-4]="isHorizontalLayout" class="ux-dashboard-card__image-container">
              <div class="ux-dashboard-card__image-wrapper">
                  <img [style.height.px]="imageHeight" [style.width.px]="imageWidth"
                       src="{{imageUrl}}" alt="{{imageUrl}}"/>
              </div>
          </div>

          <div class="ux-dashboard-card__content-wrapper" [class.col-8]="isHorizontalLayout">
              <div class="ux-dashboard-card__content">
                  <div class="ux-dashboard-card__content-label">{{label}}</div>
                  <div class="ux-dashboard-card__content-sub-label">{{subLabel}}</div>
                  <div *ngIf="!isClickable" class="ux-dashboard-card__content-link">
                    <a *ngIf="urlExternal" href="{{urlExternal}}" target="_blank"
                       class="btn {{buttonStyleClass}}" tabindex="1">{{buttonLinkLabel}}</a>
                    <a *ngIf="url" [routerLink]="[url]" class="btn {{buttonStyleClass}}" tabindex="1">{{buttonLinkLabel}}</a>
                  </div>
              </div>
          </div>
      </div>
  `
            },] },
];
/** @nocollapse */
UxDashboardCardComponent.ctorParameters = () => [
    { type: UxService, },
];
UxDashboardCardComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "imageUrl": [{ type: Input },],
    "imageWidth": [{ type: Input },],
    "imageHeight": [{ type: Input },],
    "isIconCompact": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "urlExternal": [{ type: Input },],
    "url": [{ type: Input },],
    "buttonLinkLabel": [{ type: Input },],
    "buttonStyleClass": [{ type: Input },],
    "isClickable": [{ type: Input },],
    "isHorizontalLayout": [{ type: Input },],
};
class UxDashboardCardComponentModule {
}
UxDashboardCardComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [UxDashboardCardComponent],
                declarations: [UxDashboardCardComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxControlFeedbackComponent {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const /** @type {?} */ typeClassChanges = changes['typeClass'];
        if (typeClassChanges) {
            this.stateClass = typeClassChanges.currentValue ? `ux-u-color-${typeClassChanges.currentValue}` : void 0;
        }
    }
}
UxControlFeedbackComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-control-feedback',
                template: "<div role=\"alert\" class=\"ux-c-control-feedback form-control-feedback {{stateClass}} {{styleClass}}\"> <small class=\"ux-c-control-feedback__message\"><ng-content></ng-content></small> </div> ",
            },] },
];
/** @nocollapse */
UxControlFeedbackComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
};
class UxControlFeedbackComponentModule {
}
UxControlFeedbackComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxControlFeedbackComponent],
                declarations: [UxControlFeedbackComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDropdownComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.isActive = false;
        this.isRightAligned = true;
        this.width = '10rem';
        this.height = 'auto';
        this.clickedOutside = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} keyCode
     * @return {?}
     */
    closeDropDownOnEscape(keyCode) {
        if (keyCode === 27) {
            // 27 = escape
            this.isActive = false;
        }
    }
}
UxDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dropdown',
                template: `
        <div class="ux-dropdown dropdown-menu" [style.min-width]="width" [style.max-height]="height"
                [class.d-block]="isActive"
                [class.dropdown-menu-right]="isRightAligned"
                (keydown)="closeDropDownOnEscape($event.keyCode)">
                <ng-content></ng-content>
        </div>
    `
            },] },
];
/** @nocollapse */
UxDropdownComponent.ctorParameters = () => [
    { type: UxService, },
];
UxDropdownComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "isActive": [{ type: Input },],
    "isRightAligned": [{ type: Input },],
    "width": [{ type: Input },],
    "height": [{ type: Input },],
    "clickedOutside": [{ type: Output },],
};
class UxDropdownComponentModule {
}
UxDropdownComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxDropdownComponent],
                declarations: [UxDropdownComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFieldSearchComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.inputPlaceholderLabel = 'Search...';
        this.searchButtonAsIcon = false;
        this.isFilterButtonTrigger = false;
        this.isDropdownFilter = false;
        this.isAutofocus = false;
        this.suggestions = false;
        this.suggestionsData = [];
        this.dropdownFilterLabel = 'Advanced search';
        this.dropdownFilterTypeClass = 'secondary';
        this.dropdownFilterIsSplitButtonToggle = false;
        this.dropdownFilterIsDropDownRightAligned = false;
        this.dropdownFilterIsUpdateLabelFromSelectedItem = false;
        this.dropdownFilterIsOutline = false;
        this.dropdownFilterIsDisabled = false;
        this.dropdownFilterWidth = 'auto';
        this.dropdownFilterMaxHeight = '200px';
        this.dropdownFilterLinks = [];
        this.search = new EventEmitter();
        this.isFilterActive = false;
        this.data = '';
        this.dropdownFilterHasItems = true;
        this.translatedSearchButtonLabel = '';
        this.searchField = new FormControl();
        this.propagateChange = (_) => { };
        this.propagateTouched = () => { };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dropdownFilterLinks && this.dropdownFilterLinks.length > 0) {
            this.dropdownFilterHasItems = false;
        }
        if (!this.searchButtonLabel) {
            this.translatedSearchButtonLabel = this.uxService.translate('search');
        }
        else {
            this.translatedSearchButtonLabel = this.searchButtonLabel;
        }
        this.filteredOptions = this.searchField.valueChanges.pipe(startWith(''), map((value) => {
            this.data = value;
            return this._filter(value);
        }));
        if (this.defaultValue) {
            this.searchField.patchValue(this.defaultValue);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.isAutofocus) {
            this.focus();
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    _filter(name) {
        return this.suggestionsData.filter(option => option.toLowerCase().indexOf(name.toLowerCase()) > -1);
    }
    /**
     * @return {?}
     */
    onClearClick() {
        this.searchField.patchValue('');
        this.propagateChange('');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== undefined) {
            this.data = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.propagateTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        let /** @type {?} */ newValue = event.target.value;
        this.data = newValue;
        this.propagateChange(this.data);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyup(event) {
        this.onChange(event);
        if (event.keyCode === 13) {
            this.search.emit(event.target.value);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSearch(event) {
        this.search.emit(this.data);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouched(event) {
        this.propagateTouched();
    }
    /**
     * @return {?}
     */
    focus() {
        if (this.inputElementRef) {
            this.inputElementRef.nativeElement.focus();
        }
    }
}
UxFieldSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-field-search',
                template: "<div class=\"ux-field-search {{styleClass}}\"> <div class=\"input-group\"> <span class=\"input-group-prepend\"> <span class=\"input-group-text\"> <span class=\"ux-icon ux-icon-search\"></span> </span> </span> <div class=\"ux-clearable-input-wrapper\"> <input type=\"text\" matInput [matAutocomplete]=\"auto\" [formControl]=\"searchField\" class=\"form-control\" placeholder=\"{{inputPlaceholderLabel}}\" [value]=\"defaultValue\" (change)=\"onChange($event)\" (keyup)=\"onKeyup($event)\" (blur)=\"onTouched($event)\"/> <i class=\"ux-clearable-input-wrapper__clear\" *ngIf=\"data\" (click)=\"onClearClick()\">&times;</i> <mat-autocomplete #auto=\"matAutocomplete\"> <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option\"> {{ option }} </mat-option> </mat-autocomplete> </div> <span class=\"input-group-append\"> <ng-template [ngIf]=\"isDropdownFilter\"> <ux-dropdown-button [hasItems]=\"dropdownFilterHasItems\" [links]=\"dropdownFilterLinks\" [styleClass]=\"'ux-dropdown-button-search ' + dropdownFilterStyleClass\" [label]=\"dropdownFilterLabel\" [typeClass]=\"dropdownFilterTypeClass\" [iconClass]=\"dropdownFilterIconClass\" [isSplitButtonToggle]=\"dropdownFilterIsSplitButtonToggle\" [isDropDownRightAligned]=\"dropdownFilterIsDropDownRightAligned\" [isUpdateLabelFromSelectedItem]=\"dropdownFilterIsUpdateLabelFromSelectedItem\" [isOutline]=\"dropdownFilterIsOutline\" [isDisabled]=\"dropdownFilterIsDisabled\" [width]=\"dropdownFilterWidth\" [dropdownMaxHeight]=\"dropdownFilterMaxHeight\"> <div class=\"p-2\"> <ng-container *ngTemplateOutlet=\"filterContent\"></ng-container> </div> </ux-dropdown-button> </ng-template> </span> <span class=\"input-group-append\"> <button class=\"btn btn-primary\" type=\"button\" (click)=\"onSearch($event)\"> <span *ngIf=\"!searchButtonAsIcon\">{{translatedSearchButtonLabel}}</span> <span *ngIf=\"searchButtonAsIcon\"><i class=\"ux-icon ux-icon-search\"></i></span> </button> </span> <span *ngIf=\"customFilterContent && isFilterButtonTrigger\" class=\"input-group-append\"> <button class=\"btn btn-secondary\" type=\"button\" (click)=\"isFilterActive = !isFilterActive\"> <span class=\"ux-icon\" [ngClass]=\"!isFilterActive ? 'ux-icon-filter' : 'ux-icon-times'\"></span> </button> </span> </div> <ng-template [ngIf]=\"!isDropdownFilter && isFilterActive\"> <ng-container *ngTemplateOutlet=\"filterContent\"></ng-container> </ng-template> </div> <ng-template #filterContent> <div class=\"mt-2\"> <ng-content select=\"uxFieldSearchFilterContent\"></ng-content> </div> <ng-template> ",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => UxFieldSearchComponent),
                        multi: true,
                    }]
            },] },
];
/** @nocollapse */
UxFieldSearchComponent.ctorParameters = () => [
    { type: UxService, },
];
UxFieldSearchComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "inputPlaceholderLabel": [{ type: Input },],
    "searchButtonLabel": [{ type: Input },],
    "searchButtonAsIcon": [{ type: Input },],
    "filterContentWidth": [{ type: Input },],
    "filterContentHeight": [{ type: Input },],
    "isFilterButtonTrigger": [{ type: Input },],
    "isDropdownFilter": [{ type: Input },],
    "isAutofocus": [{ type: Input },],
    "suggestions": [{ type: Input },],
    "suggestionsData": [{ type: Input },],
    "defaultValue": [{ type: Input },],
    "dropdownFilterStyleClass": [{ type: Input },],
    "dropdownFilterLabel": [{ type: Input },],
    "dropdownFilterIconClass": [{ type: Input },],
    "dropdownFilterTypeClass": [{ type: Input },],
    "dropdownFilterIsSplitButtonToggle": [{ type: Input },],
    "dropdownFilterIsDropDownRightAligned": [{ type: Input },],
    "dropdownFilterIsUpdateLabelFromSelectedItem": [{ type: Input },],
    "dropdownFilterIsOutline": [{ type: Input },],
    "dropdownFilterIsDisabled": [{ type: Input },],
    "dropdownFilterWidth": [{ type: Input },],
    "dropdownFilterMaxHeight": [{ type: Input },],
    "dropdownFilterLinks": [{ type: Input },],
    "search": [{ type: Output },],
    "inputElementRef": [{ type: ViewChild, args: ['input',] },],
    "customFilterContent": [{ type: ContentChild, args: [forwardRef(() => UxFieldSearchFilterContentTagDirective),] },],
};
class UxFieldSearchFilterContentTagDirective {
}
UxFieldSearchFilterContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFieldSearchFilterContent' },] },
];
class UxFieldSearchComponentModule {
}
UxFieldSearchComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxDropdownComponentModule,
                    UxDropdownButtonComponentModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MatAutocompleteModule,
                ],
                exports: [
                    UxFieldSearchComponent,
                    UxFieldSearchFilterContentTagDirective,
                ],
                declarations: [
                    UxFieldSearchComponent,
                    UxFieldSearchFilterContentTagDirective,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxOverlayComponent {
    constructor() {
        this.isActive = false;
    }
}
UxOverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-overlay',
                template: `
      <div class="ux-overlay {{styleClass}}" [class.ux-overlay--is-active]="isActive"></div>
    `
            },] },
];
/** @nocollapse */
UxOverlayComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "isActive": [{ type: Input },],
};
class UxOverlayComponentModule {
}
UxOverlayComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxOverlayComponent],
                declarations: [UxOverlayComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFieldsetComponent {
    constructor() {
        this.typeClass = 'default';
        this.isFirst = false;
        this.isLarge = false;
        this.isCompactFields = false;
        this.isVerticalFields = false;
        this.isHighlighted = false;
        this.isExpandable = false;
        this.isExpanded = true;
        this.expanded = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ stateClass = '';
        let /** @type {?} */ headerStateClass = '';
        if (this.isFirst) {
            stateClass += 'ux-fieldset--first ';
        }
        if (this.isLarge) {
            stateClass += 'ux-fieldset--large ';
        }
        if (this.isExpandable) {
            headerStateClass += 'ux-fieldset__header--expandable';
        }
        this.stateClass = stateClass;
        this.headerStateClass = headerStateClass;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggle(event) {
        if (this.isExpandable) {
            this.isExpanded = !this.isExpanded;
            this.expanded.emit(this.id);
        }
    }
}
UxFieldsetComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-fieldset',
                template: `
   <div id="{{id}}" class="ux-fieldset {{styleClass}} {{stateClass}}" [class.ux-fieldset--highlighted]="isHighlighted">
       <div *ngIf="label" class="ux-fieldset__header {{headerStateClass}}" (click)="onToggle($event)">
           <div class="ux-fieldset__header-label ux-u-color-{{ typeClass }}">
               <i *ngIf="iconClass" class="{{ iconClass }} mr-1"></i>
               {{ label }}
           </div>
           <div class="ux-fieldset__header-right-content">
               <ng-template [ngIf]="customLabelRightContent">
                   <ng-content select="uxFieldsetLabelRightContent"></ng-content>
               </ng-template>
               <span *ngIf="isExpandable" class="ux-fieldset__header-expand-toggle ux-icon"
                     [ngClass]="{'ux-icon-angle-right': !isExpanded, 'ux-icon-angle-down': isExpanded}">
               </span>
           </div>
       </div>
       <div *ngIf="isExpanded" class="ux-fieldset__content">
           <ng-content></ng-content>
       </div>
   </div>
   <ux-overlay [isActive]="isHighlighted"></ux-overlay>
`
            },] },
];
/** @nocollapse */
UxFieldsetComponent.propDecorators = {
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "labelWidthClass": [{ type: Input },],
    "inputWidthClass": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "isFirst": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isCompactFields": [{ type: Input },],
    "isVerticalFields": [{ type: Input },],
    "isHighlighted": [{ type: Input },],
    "isExpandable": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "expanded": [{ type: Output },],
    "customLabelRightContent": [{ type: ContentChild, args: [forwardRef(() => UxFieldsetLabelRightContentTagDirective),] },],
};
class UxFieldsetLabelRightContentTagDirective {
}
UxFieldsetLabelRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFieldsetLabelRightContent' },] },
];
class UxFieldsetComponentModule {
}
UxFieldsetComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxOverlayComponentModule],
                exports: [UxFieldsetComponent, UxFieldsetLabelRightContentTagDirective],
                declarations: [UxFieldsetComponent, UxFieldsetLabelRightContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ noop = () => { };
const /** @type {?} */ UX_SWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UxSwitchComponent),
    multi: true,
};
class UxSwitchComponent {
    constructor() {
        this.isChecked = false;
        this.isDisabled = false;
        this.isSmall = false;
        this.isLarge = false;
        this.tabindex = '0';
        this.toggle = new EventEmitter();
        this.onChange = noop;
        this.onTouched = noop;
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    handleKey(evt) {
        if (evt.which === SPACE) {
            this.handleClicked();
        }
    }
    /**
     * @return {?}
     */
    handleClicked() {
        if (this.isDisabled) {
            return;
        }
        this.isChecked = !this.isChecked;
        this.onChange(this.isChecked);
        this.onTouched(this.isChecked);
        this.toggle.emit(this.isChecked);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        this.isChecked = obj;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
    }
}
UxSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-switch',
                template: `
        <span
          class="ux-c-switch {{styleClass}}"
          [class.ux-c-switch--small]="isSmall"
          [class.ux-c-switch--large]="isLarge"
          [class.ux-c-switch--checked]="isChecked"
          [class.ux-c-switch--disabled]="isDisabled"
          role="switch"
          [tabindex]="tabindex"
          [attr.aria-label]="label"
          [attr.aria-checked]="isChecked"
          [attr.aria-disabled]="isDisabled">
          <small class="ux-c-switch__handle"></small>
        </span>
  `,
                providers: [UX_SWITCH_VALUE_ACCESSOR],
            },] },
];
/** @nocollapse */
UxSwitchComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "isChecked": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "label": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "toggle": [{ type: Output },],
    "handleKey": [{ type: HostListener, args: ['keyup', ['$event'],] },],
    "handleClicked": [{ type: HostListener, args: ['click',] },],
};
class UxSwitchComponentModule {
}
UxSwitchComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxSwitchComponent],
                declarations: [UxSwitchComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxBadgeGroupComponent {
    constructor() {
        this.typeClass = 'default';
        this.isSmall = false;
        this.isLarge = false;
        this.isPill = false;
    }
}
UxBadgeGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-badge-group',
                template: "<span class=\"ux-badge-group ux-badge-group-{{typeClass}} {{styleClass}}\"> <span class=\"badge badge-{{typeClass}} ux-badge-group__badge-left\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\"> {{label}} </span> <span class=\"badge badge-secondary ux-badge-group__badge-right ux-badge-group__badge-right--{{typeClass}}\" [class.badge-pill]=\"isPill\" [class.badge--small]=\"isSmall\" [class.badge--large]=\"isLarge\"> {{subLabel}} </span> </span> ",
            },] },
];
/** @nocollapse */
UxBadgeGroupComponent.ctorParameters = () => [];
UxBadgeGroupComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isPill": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
};
class UxBadgeGroupComponentModule {
}
UxBadgeGroupComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxBadgeGroupComponent],
                declarations: [UxBadgeGroupComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDashboardButtonComponent {
    constructor() {
        this.isRounded = true;
        this.isLarge = false;
        this.isFullWidth = false;
        this.cmpPrefix = 'ux-dashboard-button';
    }
    /**
     * @return {?}
     */
    get stateRoundedClass() {
        if (this.isRounded) {
            return this.cmpPrefix + '--rounded';
        }
        return '';
    }
    /**
     * @return {?}
     */
    get stateTypeClass() {
        if (this.typeClass) {
            return this.cmpPrefix + '--' + this.typeClass;
        }
        return '';
    }
    /**
     * @return {?}
     */
    get stateLargeClass() {
        if (this.isLarge) {
            return this.cmpPrefix + '--large';
        }
        return '';
    }
    /**
     * @return {?}
     */
    get stateFullWidthClass() {
        if (this.isFullWidth) {
            return this.cmpPrefix + '--full-width';
        }
        return '';
    }
}
UxDashboardButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dashboard-button',
                template: `
        <div class="ux-dashboard-button {{stateRoundedClass}} {{stateTypeClass}} {{stateLargeClass}} {{stateFullWidthClass}}" tabindex="1">
            <div class="ux-dashboard-button__content">
                <div *ngIf="iconClass" class="ux-dashboard-button__content-main-icon">
                    <span class="ux-dashboard-button__icon-element {{iconClass}}"></span>
                </div>
                <div *ngIf="!iconClass" class="ux-dashboard-button__content-main-label">
                    {{mainLabel}}
                </div>
                <div class="ux-dashboard-button__content-title">
                    {{label}}
                </div>
                <div class="ux-dashboard-button__content-sub-title">
                    {{subLabel}}
                </div>
            </div>
        </div>
  `
            },] },
];
/** @nocollapse */
UxDashboardButtonComponent.propDecorators = {
    "mainLabel": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "url": [{ type: Input },],
    "isRounded": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "isFullWidth": [{ type: Input },],
};
class UxDashboardButtonComponentModule {
}
UxDashboardButtonComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule],
                exports: [UxDashboardButtonComponent],
                declarations: [UxDashboardButtonComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDashboardButtonsComponent {
    constructor() {
        this.isRounded = true;
        this.isLarge = false;
        this.isExtendedPanelsViewActive = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // console.log(this.buttons)
        if (this.isRounded) {
            this.buttons.forEach(function (i) {
                i.isRounded = true;
            });
        }
        else {
            this.buttons.forEach(function (i) {
                i.isRounded = false;
            });
        }
        if (this.isLarge) {
            this.buttons.forEach(function (i) {
                i.isLarge = true;
            });
        }
        else {
            this.buttons.forEach(function (i) {
                i.isLarge = false;
            });
        }
    }
}
UxDashboardButtonsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dashboard-buttons',
                template: `
    <ul class="ux-dashboard-buttons {{styleClass}}">
        <ng-content></ng-content>
    </ul>
  `
            },] },
];
/** @nocollapse */
UxDashboardButtonsComponent.propDecorators = {
    "isRounded": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "buttons": [{ type: ContentChildren, args: [forwardRef(() => UxDashboardButtonComponent),] },],
};
class UxDashboardButtonsComponentModule {
}
UxDashboardButtonsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxDashboardButtonsComponent],
                declarations: [UxDashboardButtonsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTabComponent {
    constructor() {
        this.isClosable = false;
        this.isDisabled = false;
        this.isActive = false;
        this.isVisible = true;
        this.hasValidationErrors = false;
        this.isVisibleOnScreen = true;
    }
}
UxTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tab',
                template: `
    <div [hidden]="!isActive || !isVisible">
        <ng-content></ng-content>
    </div>
  `
            },] },
];
/** @nocollapse */
UxTabComponent.propDecorators = {
    "id": [{ type: Input },],
    "index": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "isClosable": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "tag": [{ type: Input },],
    "tagTypeClass": [{ type: Input },],
    "hasMarker": [{ type: Input },],
    "markerTypeClass": [{ type: Input },],
    "isActive": [{ type: Input },],
    "url": [{ type: Input },],
    "isVisible": [{ type: Input },],
    "hasValidationErrors": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "labelStyleClass": [{ type: Input },],
};
class UxTabComponentModule {
}
UxTabComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTabComponent],
                declarations: [UxTabComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTabService {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.activeTabIndex = 1;
        this.tabs = [];
        console.log('UxTabService initiated');
    }
    /**
     * @param {?} tabs
     * @param {?} route
     * @return {?}
     */
    init(tabs, route) {
        this.tabs = tabs;
        this.route = route;
        const /** @type {?} */ currentRoute = this.uxService.appRouter.url;
        const /** @type {?} */ currentTabUrl = currentRoute.substr(currentRoute.lastIndexOf('/') + 1);
        for (let /** @type {?} */ i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].url === currentTabUrl) {
                this.activeTabIndex = i + 1;
            }
        }
    }
    /**
     * @param {?} increment
     * @return {?}
     */
    navigationIncrement(increment) {
        const /** @type {?} */ newIndex = this.activeTabIndex + increment;
        if (newIndex >= 1 && newIndex <= this.tabs.length) {
            this.activeTabIndex = newIndex;
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    selectTab(tab) {
        this.activeTabIndex = tab.index;
        if (tab.url) {
            this._navigateToTab(tab.url);
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    _navigateToTab(url) {
        this.uxService.appRouter.navigate([url], { relativeTo: this.route });
    }
}
UxTabService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxTabService.ctorParameters = () => [
    { type: UxService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTabsComponent {
    /**
     * @param {?} uxService
     * @param {?} el
     */
    constructor(uxService, el) {
        this.uxService = uxService;
        this.el = el;
        this.tabs = [];
        this.isMainNavigation = false;
        this.isSubTabs = false;
        this.tabSelected = new EventEmitter();
        this.tabClosed = new EventEmitter();
        this.activeTabIndexChange = new EventEmitter();
        this.subscription = this.uxService.activeBreakpoint.subscribe(bkp => {
            this.checkTabsWidthHandler();
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.childrenTabs.forEach((tab) => {
            this.tabs.push(tab);
        });
        const /** @type {?} */ activeTabs = this.tabs.filter((tab) => tab.isActive);
        if (activeTabs.length === 0 && !this.activeTabIndex) {
            this._selectTab(this.tabs[0], 1);
        }
        else {
            if (this.activeTabIndex) {
                this._selectTab(this._getTab(this.activeTabIndex - 1), this.activeTabIndex);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    checkTabsWidthHandler() {
        if (this.el.nativeElement.children[0]) {
            let /** @type {?} */ lastVisibleOnScreenTab = this.el.nativeElement.children[0].lastElementChild;
            if (lastVisibleOnScreenTab) {
                let /** @type {?} */ right = lastVisibleOnScreenTab.offsetLeft + lastVisibleOnScreenTab.clientWidth;
                let /** @type {?} */ triggerOffset = 30;
                let /** @type {?} */ position = this.uxService.position(lastVisibleOnScreenTab);
                if (right + triggerOffset > this.uxService.windowWidth) {
                    this.tabs[this.tabs.length - 1].isVisibleOnScreen = false;
                }
                else {
                    this.tabs[this.tabs.length - 1].isVisibleOnScreen = true;
                }
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.activeTabIndex && this.tabs) {
            this._selectTab(this._getTab(this.activeTabIndex - 1), this.activeTabIndex);
        }
    }
    /**
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    onSelectTab(tab, index) {
        if (!tab.isDisabled) {
            this._selectTab(tab, index);
        }
    }
    /**
     * @param {?} event
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    onCloseTab(event, tab, index) {
        event.stopPropagation();
        tab.isVisible = false;
        if (index > 0) {
            this._selectTab(this.tabs[index - 1], index - 1);
        }
        this.tabClosed.emit(tab);
    }
    /**
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    _selectTab(tab, index) {
        if (tab) {
            this.tabs.forEach(currentStep => currentStep.isActive = false);
            tab.isActive = true;
            tab.index = index;
            this.activeTabIndex = index;
            this.activeTabIndexChange.emit(index);
            this.tabSelected.emit(tab);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    _getTab(index) {
        if (index >= 0 && index <= this.tabs.length) {
            return this.tabs[index];
        }
        return null;
    }
}
UxTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tabs',
                template: `
    <div class="ux-tabs {{styleClass}}" [class.ux-tabs--main-navigation]="isMainNavigation">
        <div class="ux-tabs__items">
            <ng-template *ngFor="let tab of tabs; let i = index" [ngIf]="tab.isVisible">
                <div class="ux-tab-item {{tab.styleClass}}" id="{{tab.id}}" (click)="onSelectTab(tab, i+1)"
                        [class.ux-tab-item--active]="tab.isActive"
                        [class.ux-tab-item--disabled]="tab.isDisabled"
                        [class.ux-tab-item--sub-tabs]="isSubTabs"
                        [class.ux-tab-item--invalid]="tab.hasValidationErrors"
                        [class.ux-tab-item--hidden]="!tab.isVisible">
                    <ux-a-icon styleClass="ux-tab-item__icon"
                            iconClass="{{tab.iconClass}}" typeClass="{{tab.iconTypeClass}}"
                            [isRounded]="false">
                    </ux-a-icon>
                    <ux-a-label styleClass="ux-tab-item__label" labelStyleClass="{{tab.labelStyleClass}}"
                                [isDisabled]="tab.isDisabled"
                                label="{{tab.label}}"
                                subLabel="{{tab.subLabel}}"
                                [isBoldLabel]="true">
                    </ux-a-label>
                    <ux-a-tag *ngIf="tab.tag" styleClass="ux-tab-item__tag"
                            label="{{tab.tag}}"
                            [isSmall]="true"
                            typeClass="{{tab.tagTypeClass}}">
                    </ux-a-tag>
                    <ux-a-marker *ngIf="tab.hasMarker"
                                styleClass="ux-tab-item__marker"
                                typeClass="{{tab.markerTypeClass}}">
                    </ux-a-marker>
                    <span
                        *ngIf="tab.isClosable"
                        class="ux-tab-item__close-toggle ux-icon ux-icon-times"
                        (click)="onCloseTab($event,tab,i)"></span>
                </div>
            </ng-template>
        </div>
        <div class="ux-tabs__right-content">
            <ng-content select="uxTabsRightContent"></ng-content>
        </div>
    </div>
    <div class="ux-tab-content">
        <ng-content></ng-content>
    </div>
  `
            },] },
];
/** @nocollapse */
UxTabsComponent.ctorParameters = () => [
    { type: UxService, },
    { type: ElementRef, },
];
UxTabsComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "tabs": [{ type: Input },],
    "isMainNavigation": [{ type: Input },],
    "isSubTabs": [{ type: Input },],
    "activeTabIndex": [{ type: Input },],
    "tabSelected": [{ type: Output },],
    "tabClosed": [{ type: Output },],
    "activeTabIndexChange": [{ type: Output },],
    "childrenTabs": [{ type: ContentChildren, args: [UxTabComponent,] },],
};
class UxTabsRightContentTagDirective {
}
UxTabsRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTabsRightContent' },] },
];
class UxTabsComponentModule {
}
UxTabsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxLabelComponentModule, UxIconComponentModule, UxMarkerComponentModule, UxTagComponentModule],
                exports: [UxTabsComponent, UxTabsRightContentTagDirective],
                declarations: [UxTabsComponent, UxTabsRightContentTagDirective],
                providers: [
                    UxTabService
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTab {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        this.isClosable = false;
        this.isDisabled = false;
        this.isActive = false;
        this.isVisible = true;
        this.isVisibleOnScreen = true;
        this.hasValidationErrors = false;
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTabsBarComponent {
    constructor() {
        this.tabs = [];
        this.isMainNavigation = false;
        this.isSubTabs = false;
        this.tabSelected = new EventEmitter();
        this.tabClosed = new EventEmitter();
        this.calculatedWidth = 'auto';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            if (item.getType() === 'tabContent') {
                this.tabContent = item.template;
            }
            if (item.getType() === 'rightTabContent') {
                this.rightTabContent = item.template;
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["tabs"] || changes["isMainNavigation"]) {
            if (this.isMainNavigation) {
                this.calculatedWidth = (100 / (this.tabs ? this.tabs.length : 1)) + '%';
            }
            else {
                this.calculatedWidth = 'auto';
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngOnDestroy() { }
    /**
     * @param {?} tab
     * @return {?}
     */
    onSelectTab(tab) {
        if (!tab.isDisabled) {
            this.tabSelected.emit(tab);
        }
    }
    /**
     * @param {?} event
     * @param {?} tab
     * @return {?}
     */
    onCloseTab(event, tab) {
        event.stopPropagation();
        this.tabClosed.emit(tab);
    }
}
UxTabsBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tabs-bar',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div *ngIf="tabs">
        <div class="ux-tabs {{styleClass}}" [class.ux-tabs--main-navigation]="isMainNavigation">
            <div class="ux-tabs__items">
                <div *ngFor="let tab of tabs" class="ux-tab-item {{tab.styleClass}}" (click)="onSelectTab(tab)"
                        [class.ux-tab-item--active]="tab.isActive"
                        [class.ux-tab-item--disabled]="tab.isDisabled"
                        [class.ux-tab-item--sub-tabs]="isSubTabs"
                        [style.width]="calculatedWidth">
                    <ng-template
                        [ngIf]="tabContent"
                        [ngTemplateOutlet]="tabContent"
                        [ngTemplateOutletContext]="{ $implicit: tab }">
                    </ng-template>
                    <ng-template [ngIf]="!tabContent">
                        <ux-a-icon styleClass="ux-tab-item__icon"
                                iconClass="{{tab.iconClass}}" typeClass="{{tab.iconTypeClass}}"
                                [isRounded]="false">
                        </ux-a-icon>
                        <ux-a-label styleClass="ux-tab-item__label {{tab.labelStyleClass}}"
                                    [isDisabled]="tab.isDisabled"
                                    label="{{tab.label}}"
                                    subLabel="{{tab.subLabel}}"
                                    [isBoldLabel]="true">
                        </ux-a-label>
                        <ux-a-tag *ngIf="tab.tag" styleClass="ux-tab-item__tag"
                                label="{{tab.tag}}"
                                [isSmall]="true"
                                typeClass="{{tab.tagTypeClass}}">
                        </ux-a-tag>
                        <ux-a-marker *ngIf="tab.hasMarker"
                                    styleClass="ux-tab-item__marker"
                                    typeClass="{{tab.markerTypeClass}}">
                        </ux-a-marker>
                        <ng-template
                            [ngIf]="rightTabContent"
                            [ngTemplateOutlet]="rightTabContent"
                            [ngTemplateOutletContext]="{ $implicit: tab }">
                        </ng-template>
                    </ng-template>

                    <span *ngIf="tab.isClosable"
                        class="ux-tab-item__close-toggle ux-icon ux-icon-times"
                        (click)="onCloseTab($event, tab)"></span>
                </div>
            </div>
            <div class="ux-tabs__right-content">
                <ng-content select="uxTabsBarRightContent"></ng-content>
            </div>
        </div>
        <div class="ux-tab-content">
            <ng-content></ng-content>
        </div>
    </div>
  `
            },] },
];
/** @nocollapse */
UxTabsBarComponent.ctorParameters = () => [];
UxTabsBarComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "tabs": [{ type: Input },],
    "isMainNavigation": [{ type: Input },],
    "isSubTabs": [{ type: Input },],
    "templates": [{ type: ContentChildren, args: [UxTemplateDirective,] },],
    "tabSelected": [{ type: Output },],
    "tabClosed": [{ type: Output },],
};
class UxTabsBarRightContentTagDirective {
}
UxTabsBarRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTabsBarRightContent' },] },
];
class UxTabsBarComponentModule {
}
UxTabsBarComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxLabelComponentModule, UxIconComponentModule, UxMarkerComponentModule, UxTagComponentModule],
                exports: [UxTabsBarComponent, UxTabsBarRightContentTagDirective],
                declarations: [UxTabsBarComponent, UxTabsBarRightContentTagDirective],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxStaticTabsComponent {
    constructor() {
        this.isMainNavigation = false;
        this.isSubTabs = false;
        // @Input() activeTabIndex: number; // tom: i'm not sure if this makes sense. If you want to
        // activate a tab you should use the [isActive] attribute on the <ux-tab> element
        this.tabSelected = new EventEmitter();
        this.tabClosed = new EventEmitter();
        this.tabs = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.tabs = this._filterChildren();
        // this._autoSelect();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if (changes.activeTabIndex) {
        //     this._autoSelect();
        // }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    onSelectTab(tab) {
        if (!tab.isDisabled) {
            this._selectTab(tab);
        }
    }
    /**
     * @param {?} closedTab
     * @return {?}
     */
    onCloseTab(closedTab) {
        let /** @type {?} */ nextTab;
        if (closedTab.isActive) {
            const /** @type {?} */ closedTabIndex = this.tabs.indexOf(closedTab);
            const /** @type {?} */ isSelectableTab = (tab) => !tab.isDisabled;
            nextTab = this.tabs
                .slice(closedTabIndex + 1)
                .find(isSelectableTab)
                || this.tabs
                    .slice(0, closedTabIndex)
                    .reverse()
                    .find(isSelectableTab);
            closedTab.isActive = false;
        }
        closedTab.isVisible = false;
        this.tabs = this._filterChildren(); // removes closedTab from tabs
        this.tabClosed.emit(closedTab);
        // select alternative tab
        if (nextTab) {
            this._selectTab(nextTab);
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    _selectTab(tab) {
        if (tab) {
            this.tabs = this.tabs
                .filter(_tab => _tab.isVisible)
                .map(_tab => {
                _tab.isActive = (_tab === tab);
                return _tab;
            });
            this.tabSelected.emit(tab);
        }
    }
    /**
     * @return {?}
     */
    _filterChildren() {
        const /** @type {?} */ _tabs = this.childrenTabs
            .filter(childTab => childTab.isVisible);
        // tom: if you want to change the order of the tabs based on the index attribute of the child-elements you
        // could sort them here.
        // you could perform a check/set isActive before returning the new array
        return _tabs;
    }
}
UxStaticTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-static-tabs',
                template: `
        <ux-tabs-bar [tabs]="tabs"
                         [styleClass]="styleClass"
                         [isMainNavigation]="isMainNavigation"
                         [isSubTabs]="isSubTabs"
                         (tabSelected)="onSelectTab($event)"
                         (tabClosed)="onCloseTab($event)">
            <ng-content></ng-content>
        </ux-tabs-bar>
  `
            },] },
];
// private _autoSelect(): void {
//     const hasTabs = this.tabs.length > 0;
//     const hasActiveTab = this.tabs.some((tab) => tab.isActive);
//
//     if (hasTabs && !hasActiveTab) {
//         this._selectTab(this._getTab(!!this.activeTabIndex ? this.activeTabIndex : 0));
//     }
// }
/** @nocollapse */
UxStaticTabsComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "isMainNavigation": [{ type: Input },],
    "isSubTabs": [{ type: Input },],
    "tabSelected": [{ type: Output },],
    "tabClosed": [{ type: Output },],
    "childrenTabs": [{ type: ContentChildren, args: [UxTabComponent,] },],
};
class UxStaticTabsComponentModule {
}
UxStaticTabsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxTabsBarComponentModule],
                exports: [UxStaticTabsComponent],
                declarations: [UxStaticTabsComponent],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimelineItemsComponent {
    constructor() {
        this.isLeftAligned = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() { }
}
UxTimelineItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-timeline-items',
                template: `
     <ul class="timeline" [class.left-aligned]="isLeftAligned">
        <ng-content></ng-content>
     </ul>
  `
            },] },
];
/** @nocollapse */
UxTimelineItemsComponent.propDecorators = {
    "isLeftAligned": [{ type: Input },],
};
class UxTimelineItemsComponentModule {
}
UxTimelineItemsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTimelineItemsComponent],
                declarations: [UxTimelineItemsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimelineItemComponent {
    /**
     * @param {?} uxTimelineItemsComponent
     */
    constructor(uxTimelineItemsComponent) {
        this.isGroup = false;
        this.isLeftAligned = false;
        this.uxTimelineItemsComponent = uxTimelineItemsComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.isLeftAligned = this.uxTimelineItemsComponent.isLeftAligned;
    }
}
UxTimelineItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-timeline-item',
                template: `
        <li [ngClass]="styleClass" [class.ux-timeline-item--more]="isGroup">
                <div *ngIf="!isLeftAligned" class="date">{{date}}</div>
                <span *ngIf="!isGroup" class="icon ux-icon ux-icon-circle-o"></span>
                <div class="content">
                    <div #customContent><ng-content></ng-content></div>
                    <ng-container *ngIf="customContent.childNodes.length === 0">
                        <div class="title">{{label}}</div>
                        <div class="sub">{{subLabel}}</div>
                        <div *ngIf="isLeftAligned && date" class="date">{{date}}</div>
                    </ng-container>
                </div>
        </li>
  `
            },] },
];
/** @nocollapse */
UxTimelineItemComponent.ctorParameters = () => [
    { type: UxTimelineItemsComponent, decorators: [{ type: Host }, { type: Inject, args: [forwardRef(() => UxTimelineItemsComponent),] },] },
];
UxTimelineItemComponent.propDecorators = {
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "date": [{ type: Input },],
    "isGroup": [{ type: Input },],
};
class UxTimelineItemComponentModule {
}
UxTimelineItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxTimelineItemComponent],
                declarations: [UxTimelineItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxWizardStepComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isCompleted = false;
        this.isActive = false;
        this.isShowStepTitle = false;
        this.isInvalid = false;
        this.isDisabled = false;
    }
}
UxWizardStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-wizard-step',
                template: `
    <div [hidden]="!isActive">
        <ng-template [ngIf]="!customContent">
            <ux-panel label="{{label}}">
                <ng-content></ng-content>
            </ux-panel>
        </ng-template>
        <ng-template [ngIf]="customContent">
            <h5 *ngIf="isShowStepTitle" class="section-title first">
               {{label}}
            </h5>
            <div class="content">
                <ng-content select="uxWizardStepContent"></ng-content>
            </div>
        </ng-template>
    </div>
  `
            },] },
];
/** @nocollapse */
UxWizardStepComponent.ctorParameters = () => [
    { type: ElementRef, },
];
UxWizardStepComponent.propDecorators = {
    "id": [{ type: Input },],
    "indexLabel": [{ type: Input },],
    "label": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "isCompleted": [{ type: Input },],
    "isActive": [{ type: Input },],
    "isShowStepTitle": [{ type: Input },],
    "isInvalid": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "index": [{ type: Input },],
    "url": [{ type: Input },],
    "customContent": [{ type: ContentChild, args: [forwardRef(() => UxWizardStepContentTagDirective),] },],
};
class UxWizardStepContentTagDirective {
}
UxWizardStepContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxWizardStepContent' },] },
];
class UxWizardStepComponentModule {
}
UxWizardStepComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxPanelComponentModule],
                exports: [UxWizardStepComponent, UxWizardStepContentTagDirective],
                declarations: [UxWizardStepComponent, UxWizardStepContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxWizardStepService {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.activeStepIndex = 1;
        this.steps = [];
        console.log('UxWizardService initiated');
    }
    /**
     * @param {?} steps
     * @param {?} route
     * @return {?}
     */
    init(steps, route) {
        this.steps = steps;
        this.route = route;
        const /** @type {?} */ currentRoute = this.uxService.appRouter.url;
        const /** @type {?} */ currentStepUrl = currentRoute.substr(currentRoute.lastIndexOf('/') + 1);
        for (let /** @type {?} */ i = 0; i < this.steps.length; i++) {
            if (this.steps[i].url === currentStepUrl) {
                this.activeStepIndex = i + 1;
            }
        }
    }
    /**
     * @param {?} increment
     * @return {?}
     */
    navigationIncrement(increment) {
        const /** @type {?} */ newIndex = this.activeStepIndex + increment;
        if (newIndex >= 1 && newIndex <= this.steps.length) {
            this.activeStepIndex = newIndex;
        }
    }
    /**
     * @param {?} step
     * @return {?}
     */
    selectStep(step) {
        this.activeStepIndex = step.index;
        if (step.url) {
            this._navigateToStep(step.url);
        }
    }
    /**
     * @param {?} url
     * @return {?}
     */
    _navigateToStep(url) {
        this.uxService.appRouter.navigate([url], { relativeTo: this.route });
    }
}
UxWizardStepService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxWizardStepService.ctorParameters = () => [
    { type: UxService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxWizardStepsComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.isCustomContent = false;
        this.isShowStepTitle = false;
        this.isNavigationAllowed = true;
        this.steps = [];
        this.tabindex = 0;
        this.selectStep = new EventEmitter();
        this.stepContentId = this.uxService.uniqueId();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        const /** @type {?} */ stepIdsBuffer = [];
        this.childrenSteps.forEach((step) => {
            this.steps.push(step);
            if (!step.id) {
                step.id = this.uxService.uniqueId();
            }
            stepIdsBuffer.push(step.id);
        });
        this.stepIds = stepIdsBuffer.join(' ');
        const /** @type {?} */ activeSteps = this.steps.filter((step) => step.isActive);
        if (activeSteps.length === 0 && !this.activeStepIndex) {
            this._selectStep(this.steps[0], 1);
        }
        else {
            if (this.activeStepIndex) {
                this._selectStep(this._getStep(this.activeStepIndex - 1), this.activeStepIndex);
            }
        }
        this.steps.forEach(step => {
            step.isShowStepTitle = this.isShowStepTitle;
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.activeStepIndex && this.steps) {
            this._selectStep(this._getStep(this.activeStepIndex - 1), this.activeStepIndex);
            const /** @type {?} */ stepIdsBuffer = [];
            this.steps.forEach((step) => {
                if (!step.id) {
                    step.id = this.uxService.uniqueId();
                }
                stepIdsBuffer.push(step.id);
            });
            this.stepIds = stepIdsBuffer.join(' ');
        }
    }
    /**
     * @param {?} step
     * @param {?} index
     * @return {?}
     */
    onSelectStep(step, index) {
        if (!step.isDisabled && this.isNavigationAllowed) {
            this._selectStep(step, index);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (this.isNavigationAllowed) {
            switch (event.keyCode) {
                case 37:
                    // ARROW LEFT
                    this.uxService.consumeEvent(event);
                    this.selectPreviousStep();
                    break;
                case 39:
                    // ARROW RIGHT
                    this.uxService.consumeEvent(event);
                    this.selectNextStep();
                    break;
            }
        }
    }
    /**
     * @return {?}
     */
    selectPreviousStep() {
        if (this.isNavigationAllowed && this.steps) {
            let /** @type {?} */ i = 0;
            for (; i < this.steps.length; i++) {
                const /** @type {?} */ step = this.steps[i];
                if (step.isActive) {
                    break;
                }
            }
            let /** @type {?} */ previousIndex = i;
            do {
                previousIndex--;
                if (previousIndex < 0) {
                    previousIndex = this.steps.length - 1;
                }
            } while (this.steps[previousIndex].isDisabled);
            this._selectStep(this.steps[previousIndex], previousIndex + 1);
            this.focusables.toArray()[previousIndex].nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    selectNextStep() {
        if (this.isNavigationAllowed && this.steps) {
            let /** @type {?} */ i = 0;
            for (; i < this.steps.length; i++) {
                const /** @type {?} */ step = this.steps[i];
                if (step.isActive) {
                    break;
                }
            }
            let /** @type {?} */ nextIndex = i;
            do {
                nextIndex++;
                if (nextIndex >= this.steps.length) {
                    nextIndex = 0;
                }
            } while (this.steps[nextIndex].isDisabled);
            this._selectStep(this.steps[nextIndex], nextIndex + 1);
            this.focusables.toArray()[nextIndex].nativeElement.focus();
        }
    }
    /**
     * @param {?} step
     * @param {?} index
     * @return {?}
     */
    _selectStep(step, index) {
        if (step) {
            this.steps.forEach(currentStep => currentStep.isActive = false);
            step.isActive = true;
            step.index = index;
            this.selectStep.emit(step);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    _getStep(index) {
        if (index >= 0 && index <= this.steps.length) {
            return this.steps[index];
        }
        return null;
    }
}
UxWizardStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-wizard-steps',
                template: `
    <div class="ux-wizard-steps" role="tablist" aria-orientation="horizontal" aria-label="">
        <div #focusable *ngFor="let step of steps; let idx = index" class="ux-wizard-step" role="tab"
            [id]="step.id"
            attr.aria-label="{{step.label}} {{step.subLabel}}"
            [attr.aria-disabled]="step.isDisabled"
            [attr.aria-controls]="stepContentId"
            [tabindex]="(step.isActive ? tabindex : -1)"
            [class.ux-wizard-step--completed]="step.isCompleted"
            [class.ux-wizard-step--active]="step.isActive"
            [class.ux-wizard-step--disabled]="step.isDisabled"
            [class.ux-wizard-step--error]="step.isInvalid"
            (click)="onSelectStep(step, idx+1)"
            (keydown)="onKeyDown($event)">
            <div *ngIf="step.isActive" class="ux-wizard-step__current-marker" role="presentation">
                <span class="ux-wizard-step__current-marker-icon ux-icon ux-icon-map-marker"></span>
            </div>
            <div class="ux-wizard-step__indicator-wrapper" role="presentation"></div>
            <div class="ux-wizard-step__bullet-item">
                <span class="ux-wizard-step__bullet-item-icon ux-icon" role="presentation"
                    [class.ux-icon-check]="step.isCompleted"
                    [class.ux-icon-exclamation]="step.isInvalid && !step.isActive"
                    [class.ux-icon-pencil]="step.isActive">
                    <span *ngIf="!step.isActive && !step.isCompleted && !step.isInvalid" role="presentation">
                        {{step.indexLabel !== undefined ? step.indexLabel : idx + 1}}
                    </span>
                </span>
            </div>
            <div class="ux-wizard-step__label-wrapper" role="presentation">
                <div class="ux-wizard-step__label-wrapper-label" role="presentation">
                    {{step.label}}
                </div>
                <div class="ux-wizard-step__label-wrapper-sub-label" role="presentation">
                    {{step.subLabel}}
                </div>
            </div>
        </div>
    </div>
    <div [id]="stepContentId" class="step-content" role="tabpanel" [attr.aria-labelledby]="stepIds">
        <ng-content></ng-content>
    </div>
    `
            },] },
];
/** @nocollapse */
UxWizardStepsComponent.ctorParameters = () => [
    { type: UxService, },
];
UxWizardStepsComponent.propDecorators = {
    "isCustomContent": [{ type: Input },],
    "isShowStepTitle": [{ type: Input },],
    "isNavigationAllowed": [{ type: Input },],
    "activeStepIndex": [{ type: Input },],
    "steps": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "selectStep": [{ type: Output },],
    "childrenSteps": [{ type: ContentChildren, args: [UxWizardStepComponent,] },],
    "focusables": [{ type: ViewChildren, args: ['focusable',] },],
};
class UxWizardStepsComponentModule {
}
UxWizardStepsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxWizardStepsComponent],
                declarations: [UxWizardStepsComponent],
                providers: [
                    UxWizardStepService
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxWizardStep {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        this.isCompleted = false;
        this.isActive = false;
        this.isShowStepTitle = false;
        this.isInvalid = false;
        this.isDisabled = false;
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTreeListItemComponent {
    /**
     * @param {?} treeListComponent
     * @param {?} uxService
     * @param {?} elementRef
     */
    constructor(treeListComponent, uxService, elementRef) {
        this.uxService = uxService;
        this.elementRef = elementRef;
        this.active = false;
        this.expanded = false;
        this.alwaysExpanded = false;
        this.isDisplaySubLinksOnHover = false;
        this.subLinks = [];
        this.hasMarker = false;
        this.isNavigateOnlyOnLabelClick = false;
        this.isIconRounded = false;
        this.toggled = new EventEmitter();
        this.isVisible = true;
        this.isHovered = false;
        // tree states
        this.hasSub = false;
        // custom content
        this.hasCustomContent = false;
        this.treeListComponent = treeListComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // make sure that the tree item can be aria-owned by a parent tree for WAI-ARIA attributes:
        if (!this.id) {
            this.id = this.uxService.uniqueId();
        }
        // setting tree states
        if (this.subTreeList.length !== 0) {
            this.hasSub = true;
        }
        // checking if customContent set
        if (this.customContent.length !== 0) {
            this.hasCustomContent = true;
        }
        if (this.markerTypeClass && !this.hasMarker) {
            this.hasMarker = true;
        }
        // make sure that any child tree-list is non-focusable and that it has the role of a WAI-ARIA group:
        if (this.subTreeList) {
            this.subTreeList.forEach((subtree) => {
                subtree.disableFocus();
                subtree.ariaRole = 'group';
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        this.expanded = !this.expanded;
        this.toggled.next(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateToLink(event) {
        if (this.linkUrl && !this.isNavigateOnlyOnLabelClick) {
            this.uxService.appRouter.navigate([this.linkUrl]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLabelClicked(event) {
        if (this.linkUrl && this.isNavigateOnlyOnLabelClick) {
            this.uxService.appRouter.navigate([this.linkUrl]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        switch (event.keyCode) {
            case 13: // ENTER
            case 32:
                // SPACE
                this.expanded = !this.expanded;
                this.uxService.consumeEvent(event);
                break;
            case 37:
                // ARROW LEFT
                this.expanded = false;
                this.uxService.consumeEvent(event);
                break;
            case 38:
                // ARROW UP
                if (this.treeListComponent) {
                    if (this.treeListComponent.focusOnPreviousTreeItem(this)) {
                        this.disableFocus();
                    }
                }
                this.uxService.consumeEvent(event);
                break;
            case 39:
                // ARROW RIGHT
                this.expanded = true;
                this.uxService.consumeEvent(event);
                break;
            case 40:
                // ARROW DOWN
                if (this.focusOnNextTreeItem()) {
                    this.disableFocus();
                }
                this.uxService.consumeEvent(event);
                break;
        }
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setVisibleState(state) {
        this.isVisible = state;
        if (this.subTreeList && this.subTreeList.length !== 0) {
            this.subTreeList.toArray().forEach((item) => {
                item.setVisibleState(state);
            });
        }
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setExpandedState(state) {
        this.expanded = state;
        if (this.subTreeList.length !== 0) {
            this.subTreeList.toArray().forEach((item) => {
                item.setExpandedState(state);
            });
        }
    }
    /**
     * @return {?}
     */
    focus() {
        if (this.focusable) {
            this.enableFocus();
            this.focusable.nativeElement.focus();
        }
        if (this.treeListComponent) {
            this.treeListComponent.disableFocus();
        }
    }
    /**
     * @return {?}
     */
    focusOnLastExpandedTreeItem() {
        const /** @type {?} */ lastExpanded = this.elementRef.nativeElement.querySelectorAll('.ux-tree-list-item-header__content');
        if (lastExpanded && lastExpanded.length > 0) {
            const /** @type {?} */ element = lastExpanded[lastExpanded.length - 1];
            element.setAttribute('tabindex', '0');
            element.focus();
        }
        else {
            this.focus();
        }
    }
    /**
     * @return {?}
     */
    get hasCustomDetailContent() {
        return this.customDetailContent;
    }
    /**
     * @return {?}
     */
    get hasCustomSubContainerContent() {
        return this.customSubContainerContent;
    }
    /**
     * @return {?}
     */
    focusOnNextTreeItem() {
        if (this.expanded && this.subTreeList && this.subTreeList.length > 0) {
            this.subTreeList.first.focus();
            return true;
        }
        else if (this.treeListComponent) {
            return this.treeListComponent.focusOnNextTreeItem(this);
        }
        return false;
    }
    /**
     * @return {?}
     */
    disableFocus() {
        if (this.focusable) {
            this.focusable.nativeElement.setAttribute('tabindex', '-1');
        }
    }
    /**
     * @return {?}
     */
    enableFocus() {
        if (this.focusable) {
            this.focusable.nativeElement.setAttribute('tabindex', '0');
        }
    }
}
UxTreeListItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tree-list-item',
                template: "<div class=\"ux-tree-list-item {{styleClass}}\" [class.ux-tree-list-item--active]=\"active\" [hidden]=\"!isVisible\"> <div class=\"ux-tree-list-item-header ux-tree-list-item-header--{{typeClass}} {{headerStyleClass}}\" (click)=\"navigateToLink($event)\"> <div #focusable class=\"ux-tree-list-item-header__content\" role=\"treeitem\" [id]=\"id\" (keydown)=\"onKeyDown($event)\" attr.aria-label=\"{{label}} {{subLabel}}\" [attr.aria-expanded]=\"expanded\"> <ng-template [ngIf]=\"hasCustomContent\"> <ng-content select=\"uxTreeListItemCustomContent\"></ng-content> <div class=\"ux-tree-list-item-header__content-right-content\"> <div class=\"ux-tree-list-item-header__content-right-content-sub\"> <ng-container *ngTemplateOutlet=\"rightContent\"></ng-container> </div> <span class=\"ux-tree-list-item-header__content-expand-toggle-wrapper\"> <span *ngIf=\"hasSub && !alwaysExpanded\" class=\"ux-tree-list-item-header__content-expand-toggle\" (click)=\"toggle($event)\"> <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !expanded, 'ux-icon-angle-down': expanded}\"></span> </span> </span> </div> </ng-template> <ng-template [ngIf]=\"!hasCustomContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isClickable]=\"linkUrl && isNavigateOnlyOnLabelClick\" (click)=\"navigateToLink($event)\" (labelClicked)=\"onLabelClicked($event)\" [isBoldLabel]=\"true\" tabindex=\"-1\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxTreeListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-tree-list-item-header__content-right-content\"> <div class=\"ux-tree-list-item-header__content-right-content-sub\"> <ng-container *ngTemplateOutlet=\"rightContent\"></ng-container> </div> <span class=\"ux-tree-list-item-header__content-expand-toggle-wrapper\"> <span *ngIf=\"hasSub && !alwaysExpanded\" class=\"ux-tree-list-item-header__content-expand-toggle\" (click)=\"toggle($event)\"> <span class=\"ux-icon\" [ngClass]=\"{'ux-icon-angle-right': !expanded, 'ux-icon-angle-down': expanded}\"></span> </span> </span> </div> </ng-template> </div> <ng-template [ngIf]=\"hasCustomDetailContent\"> <div class=\"ux-tree-list-item-header__details-content\"> <ng-content select=\"uxTreeListItemDetailsContent\"></ng-content> </div> </ng-template> <ng-template [ngIf]=\"hasCustomSubContainerContent\"> <ng-content select=\"uxTreeListItemSubContainerContent\"></ng-content> </ng-template> </div> <ng-template [ngIf]=\"expanded || alwaysExpanded\"> <ng-content></ng-content> </ng-template> </div> <ng-template #rightContent><ng-content select=\"uxTreeListItemRightContent\"></ng-content></ng-template> ",
            },] },
];
/** @nocollapse */
UxTreeListItemComponent.ctorParameters = () => [
    { type: UxTreeListComponent, decorators: [{ type: Host }, { type: Inject, args: [forwardRef(() => UxTreeListComponent),] },] },
    { type: UxService, },
    { type: ElementRef, },
];
UxTreeListItemComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "headerStyleClass": [{ type: Input },],
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "linkUrl": [{ type: Input },],
    "subLabel": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "active": [{ type: Input },],
    "expanded": [{ type: Input },],
    "alwaysExpanded": [{ type: Input },],
    "url": [{ type: Input },],
    "isDisplaySubLinksOnHover": [{ type: Input },],
    "subLinks": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "hasMarker": [{ type: Input },],
    "markerTypeClass": [{ type: Input },],
    "isNavigateOnlyOnLabelClick": [{ type: Input },],
    "isIconRounded": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "toggled": [{ type: Output },],
    "focusable": [{ type: ViewChild, args: ['focusable',] },],
    "subTreeList": [{ type: ContentChildren, args: [forwardRef(() => UxTreeListComponent), { descendants: true },] },],
    "customSubLabel": [{ type: ContentChild, args: [forwardRef(() => UxTreeListItemSubLabelTagDirective),] },],
    "customContent": [{ type: ContentChildren, args: [forwardRef(() => UxTreeListItemCustomContentTagDirective), { descendants: false },] },],
    "customDetailContent": [{ type: ContentChild, args: [forwardRef(() => UxTreeListItemDetailsContentTagDirective),] },],
    "customSubContainerContent": [{ type: ContentChild, args: [forwardRef(() => UxTreeListItemSubContainerContentTagDirective),] },],
};
class UxTreeListItemCustomContentTagDirective {
}
UxTreeListItemCustomContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListItemCustomContent' },] },
];
class UxTreeListItemRightContentTagDirective {
}
UxTreeListItemRightContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListItemRightContent' },] },
];
class UxTreeListItemSubLabelTagDirective {
}
UxTreeListItemSubLabelTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListItemSubLabel' },] },
];
class UxTreeListItemDetailsContentTagDirective {
}
UxTreeListItemDetailsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListItemDetailsContent' },] },
];
class UxTreeListItemSubContainerContentTagDirective {
}
UxTreeListItemSubContainerContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListItemSubContainerContent' },] },
];
class UxTreeListItemComponentModule {
}
UxTreeListItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, RouterModule, UxLabelComponentModule],
                exports: [UxTreeListItemComponent, UxTreeListItemSubLabelTagDirective, UxTreeListItemCustomContentTagDirective,
                    UxTreeListItemRightContentTagDirective, UxTreeListItemDetailsContentTagDirective, UxTreeListItemSubContainerContentTagDirective],
                declarations: [UxTreeListItemComponent, UxTreeListItemSubLabelTagDirective, UxTreeListItemCustomContentTagDirective,
                    UxTreeListItemRightContentTagDirective, UxTreeListItemDetailsContentTagDirective, UxTreeListItemSubContainerContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTreeListComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isShowToolbar = false;
        this.isShowToolbarToggle = true;
        this.isExpanded = false;
        this.hasItemsUrl = false;
        this.hasItemsBullet = true;
        this.hasLeftIndent = true;
        this.tabindex = '0';
        this.ariaRole = 'tree';
        this.ariaLabel = '';
        this.itemSelected = new EventEmitter();
        this.ariaOwns = '';
        this.originalTabindex = '0';
        this.classes = '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.classes = '';
        if (!this.hasItemsBullet) {
            this.classes += ' ux-tree-list--no-bullets';
        }
        if (this.hasLeftIndent) {
            this.classes += ' ux-tree-list--with-left-indent';
        }
        if (this.hasItemsUrl) {
            this.classes += ' ux-tree-list--with-items-url';
        }
        if (this.isExpanded) {
            this.setExpandedState(true);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const /** @type {?} */ treeItemIds = [];
        if (this.items) {
            this.items.forEach((treeItem) => {
                treeItemIds.push(treeItem.id);
            });
        }
        setTimeout(() => {
            this.ariaOwns = treeItemIds.join(' ');
            this.originalTabindex = this.tabindex;
        }, 0);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes && changes['tabindex']) {
            this.originalTabindex = this.tabindex;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExpandAll(event) {
        this.setExpandedState(true);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCollapseAll(event) {
        this.setExpandedState(false);
    }
    /**
     * @param {?} filterValue
     * @return {?}
     */
    onFilter(filterValue) {
        // TODO find a recursive way of doing the filtering throughout the tree structure
        if (filterValue !== '' && filterValue !== undefined) {
            this.setVisibleState(false);
            this.items.toArray().forEach((item1) => {
                item1.isVisible = this.filterMatched(item1.label, filterValue);
                if (item1.subTreeList.length !== 0) {
                    item1.subTreeList.toArray().forEach((item1SubTreeList) => {
                        item1SubTreeList.items.toArray().forEach((item2) => {
                            if (this.filterMatched(item2.label, filterValue)) {
                                item2.isVisible = true;
                                item1.isVisible = true;
                                item1.expanded = true;
                                if (item2.subTreeList.length !== 0) {
                                    item2.subTreeList.toArray().forEach((item2SubTreeList) => {
                                        item2SubTreeList.items.toArray().forEach((item3) => {
                                            item3.isVisible = true;
                                        });
                                    });
                                }
                            }
                            if (item2.subTreeList.length !== 0) {
                                item2.subTreeList.toArray().forEach((item2SubTreeList) => {
                                    item2SubTreeList.items.toArray().forEach((item4) => {
                                        if (this.filterMatched(item4.label, filterValue)) {
                                            item4.isVisible = true;
                                            item2.isVisible = true;
                                            item2.expanded = true;
                                            item1.isVisible = true;
                                            item1.expanded = true;
                                        }
                                    });
                                });
                            }
                        });
                    });
                }
            });
        }
        else {
            this.setVisibleState(true);
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.focus();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setVisibleState(state) {
        this.items.toArray().forEach(function (item) {
            item.setVisibleState(state);
        });
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setExpandedState(state) {
        this.items.toArray().forEach(function (item) {
            item.setExpandedState(state);
        });
    }
    /**
     * @return {?}
     */
    focus() {
        // Focus on the first child tree item:
        if (this.items && this.items.length > 0) {
            this.items.first.focus();
        }
    }
    /**
     * @return {?}
     */
    disableFocus() {
        this.tabindex = '-1';
    }
    /**
     * @param {?} currentTreeListItem
     * @return {?}
     */
    focusOnPreviousTreeItem(currentTreeListItem) {
        if (this.items && this.items.length > 0) {
            let /** @type {?} */ previousTreeListItem = null;
            for (let /** @type {?} */ treeListItem of this.items.toArray()) {
                if (treeListItem !== currentTreeListItem) {
                    previousTreeListItem = treeListItem;
                }
                else if (previousTreeListItem) {
                    previousTreeListItem.focusOnLastExpandedTreeItem();
                    return true;
                }
            }
            // Focus on the last item of the previous parent:
            // First find the parent list item:
            if (this.elementRef) {
                let /** @type {?} */ parent = this.elementRef.nativeElement.parentElement;
                while (parent && !parent.classList.contains('ux-tree-list-item')) {
                    parent = parent.parentElement;
                }
                if (parent) {
                    // parent tree-item is found
                    const /** @type {?} */ content = parent.querySelector('.ux-tree-list-item-header__content');
                    if (content) {
                        content.setAttribute('tabindex', '0');
                        content.focus();
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * @param {?} currentTreeListItem
     * @return {?}
     */
    focusOnNextTreeItem(currentTreeListItem) {
        if (this.items && this.items.length > 0) {
            if (currentTreeListItem !== this.items.last) {
                let /** @type {?} */ previousTreeListItem = null;
                for (let /** @type {?} */ treeListItem of this.items.toArray()) {
                    if (previousTreeListItem !== currentTreeListItem) {
                        previousTreeListItem = treeListItem;
                    }
                    else {
                        treeListItem.focus();
                        return true;
                    }
                }
            }
            else {
                // The current focused tree item is the last one; find the first next tree item:
                if (this.elementRef) {
                    // First find the parent tree list item:
                    let /** @type {?} */ parent = this.elementRef.nativeElement.parentElement;
                    // Find the parent that is not a last child itself:
                    while (parent && (parent.tagName.toLowerCase() !== 'ux-tree-list-item' || parent.nextElementSibling === null)) {
                        parent = parent.parentElement;
                    }
                    if (parent) {
                        // parent tree list item is found; focus on the first child of the next list item
                        const /** @type {?} */ nextTreeListItem = parent.nextElementSibling;
                        if (nextTreeListItem) {
                            const /** @type {?} */ next = nextTreeListItem.querySelector('.ux-tree-list-item-header__content');
                            next.setAttribute('tabindex', '0');
                            next.focus();
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * @param {?} label
     * @param {?} filterValue
     * @return {?}
     */
    filterMatched(label, filterValue) {
        if (!label) {
            return false;
        }
        if (label.toUpperCase().indexOf(filterValue.toUpperCase()) !== -1) {
            return true;
        }
        return false;
    }
}
UxTreeListComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tree-list',
                template: `
        <ux-a-toolbar-filter [isVisible]="isShowToolbar" [isToggleVisible]="isShowToolbarToggle"
                             (filter)="onFilter($event)" (expandAll)="onExpandAll($event)"
                             (collapseAll)="onCollapseAll($event)"
                             filterLabel="{{filterLabel}}" expandAllLabel="{{expandAllLabel}}"
                             collapseAllLabel="{{collapseAllLabel}}">
            <ng-content select="uxTreeListToolbarContent"></ng-content>
        </ux-a-toolbar-filter>

        <div class="ux-tree-list {{styleClass}} {{classes}}"
             [attr.role]="ariaRole"
             [tabindex]="tabindex" [attr.data-tabindex]="originalTabindex" [attr.aria-label]="ariaLabel" [attr.aria-owns]="ariaOwns"
             (focus)="onFocus()">
            <ng-content></ng-content>
        </div>
    `
            },] },
];
/** @nocollapse */
UxTreeListComponent.ctorParameters = () => [
    { type: ElementRef, },
];
UxTreeListComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "isShowToolbar": [{ type: Input },],
    "isShowToolbarToggle": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "filterLabel": [{ type: Input },],
    "expandAllLabel": [{ type: Input },],
    "collapseAllLabel": [{ type: Input },],
    "hasItemsUrl": [{ type: Input },],
    "hasItemsBullet": [{ type: Input },],
    "hasLeftIndent": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "ariaRole": [{ type: Input },],
    "ariaLabel": [{ type: Input },],
    "itemSelected": [{ type: Output },],
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxTreeListItemComponent),] },],
};
class UxTreeListToolbarContentTagDirective {
}
UxTreeListToolbarContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxTreeListToolbarContent' },] },
];
class UxTreeListComponentModule {
}
UxTreeListComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, UxToolbarFilterComponentModule],
                exports: [UxTreeListComponent, UxTreeListToolbarContentTagDirective],
                declarations: [UxTreeListComponent, UxTreeListToolbarContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCarouselItemComponent {
    constructor() {
        this.isActive = false;
    }
}
UxCarouselItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-carousel-item',
                template: "<div [hidden]=\"!isActive\" class=\"{{styleClass}}\"> <ng-content></ng-content> </div> ",
            },] },
];
/** @nocollapse */
UxCarouselItemComponent.ctorParameters = () => [];
UxCarouselItemComponent.propDecorators = {
    "isActive": [{ type: Input },],
    "styleClass": [{ type: Input },],
};
class UxCarouselItemComponentModule {
}
UxCarouselItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxCarouselItemComponent],
                declarations: [UxCarouselItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCarouselItemsComponent {
    constructor() {
        this.isShowSummaryIndicators = true;
        this.itemsArray = [];
        this.itemsLength = 0;
        this.currentItem = 0;
        this.animStyleClass = 'fx fadeIn';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.items.length > 0) {
            const /** @type {?} */ activeItems = this.items.filter((item) => item.isActive);
            if (activeItems.length === 0) {
                this.selectItem(this.items.first);
            }
            this.itemsArray = this.items.toArray();
            this.itemsLength = this.itemsArray.length;
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.itemsArray.forEach((currentItem) => currentItem.isActive = false);
        // Changing child already initialized normally produces ExpressionChangedAfterItHasBeenCheckedError
        // thus child change is made in microtask
        Promise.resolve().then(() => item.isActive = true);
    }
    /**
     * @param {?} itemIndex
     * @return {?}
     */
    gotoItem(itemIndex) {
        if (this.currentItem <= itemIndex) {
            this.animStyleClass = 'fx slideInRight';
        }
        else {
            this.animStyleClass = 'fx slideInLeft';
        }
        this.currentItem = itemIndex;
        this.selectItem(this.itemsArray[itemIndex]);
    }
    /**
     * @return {?}
     */
    get isFirstItemActive() {
        return this.currentItem === 0;
    }
    /**
     * @return {?}
     */
    get isLastItemActive() {
        return this.currentItem === this.itemsArray.length - 1;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    goPrevious(event) {
        this.animStyleClass = 'fx slideInLeft';
        if (!this.isFirstItemActive) {
            this.currentItem--;
            this.selectItem(this.itemsArray[this.currentItem]);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    goNext(event) {
        this.animStyleClass = 'fx slideInRight';
        if (!this.isLastItemActive) {
            this.currentItem++;
            this.selectItem(this.itemsArray[this.currentItem]);
        }
    }
}
UxCarouselItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-carousel-items',
                template: "<div class=\"ux-carousel-items\"> <div class=\"row flex-container\"> <div class=\"col-1 text-center\"> <span class=\"ux-icon ux-icon-caret-left ux-icon-3x ux-carousel-items__arrow\" [class.ux-carousel-items__arrow--inactive]=\"isFirstItemActive\" (click)=\"goPrevious($event)\"></span> </div> <div class=\"col-10 text-center\" [ngClass]=\"animStyleClass\"> <ng-content></ng-content> </div> <div class=\"col-1 text-center\"> <span class=\"ux-icon ux-icon-caret-right ux-icon-3x ux-carousel-items__arrow\" [class.ux-carousel-items__arrow--inactive]=\"isLastItemActive\" (click)=\"goNext($event)\"></span> </div> </div> <div *ngIf=\"isShowSummaryIndicators\" class=\"row flex-container ux-carousel-items__summary-indicators\"> <div class=\"col-12 text-center\"> <span *ngFor=\"let item of itemsArray; let i = index\" class=\"ux-icon ux-carousel-items__summary-indicators-item\" (click)=\"gotoItem(i)\" [ngClass]=\"i === currentItem ? 'ux-icon-circle ux-u-color-primary' : 'ux-icon-circle-o ux-u-color-grey-light'\"></span> </div> </div> </div> ",
            },] },
];
/** @nocollapse */
UxCarouselItemsComponent.propDecorators = {
    "isShowSummaryIndicators": [{ type: Input },],
    "items": [{ type: ContentChildren, args: [UxCarouselItemComponent,] },],
};
class UxCarouselItemsComponentModule {
}
UxCarouselItemsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxCarouselItemComponentModule],
                exports: [UxCarouselItemsComponent],
                declarations: [UxCarouselItemsComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTreeNodeComponent {
    /**
     * @param {?} router
     * @param {?} uxService
     */
    constructor(router, uxService) {
        this.router = router;
        this.uxService = uxService;
        this.isFirst = false;
        this.isLast = false;
        this.isRootNode = false;
        this.isClickTogglingNode = false;
        this.isMultiselect = false;
        this.isRecursiveSelection = false;
        this.isShowActiveNode = false;
        this.nodeClick = new EventEmitter();
        this.nodeToggle = new EventEmitter();
        this.selectionChange = new EventEmitter();
        this.nodeId = `ux-tree-node-${uxService.uniqueId()}`;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    hasNodeChildren(node) {
        return node && node.children && node.children.length > 0;
    }
    /**
     * @param {?} event
     * @param {?} uxLink
     * @return {?}
     */
    onNodeKeydown(event, uxLink) {
        if (event.keyCode === 13) {
            this.onNodeClick(event, uxLink);
        }
    }
    /**
     * @param {?} event
     * @param {?} uxLink
     * @return {?}
     */
    onNodeToggle(event, uxLink) {
        this.node.expanded = !this.node.expanded;
        this.nodeToggle.emit(uxLink);
    }
    /**
     * @param {?} event
     * @param {?} uxLink
     * @return {?}
     */
    onNodeClick(event, uxLink) {
        if (!this.node.metadata) {
            if (!this.node.children || this.node.children.length === 0) {
                this.node.expanded = !this.node.expanded;
                if (this.node.url) {
                    this.router.navigate([this.node.url]);
                }
                if (this.node.urlExternal) {
                    window.open(this.node.urlExternal, '_blank');
                }
            }
            else {
                const /** @type {?} */ clickedEl = event.target['nodeName'];
                if (this.isClickTogglingNode) {
                    this.onNodeToggle(event, uxLink);
                }
                if (clickedEl === 'SPAN' && (this.node.url || this.node.urlExternal)) {
                    if (this.node.url) {
                        this.router.navigate([this.node.url]);
                    }
                    if (this.node.urlExternal) {
                        window.open(this.node.urlExternal, '_blank');
                    }
                }
            }
        }
        else {
            if (this.node.url) {
                this.router.navigate([this.node.url]);
            }
            if (this.node.urlExternal) {
                window.open(this.node.urlExternal, '_blank');
            }
        }
        if (uxLink.command) {
            uxLink.command();
        }
        this.nodeClick.emit(uxLink);
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} uxLink
     * @param {?} evt
     * @return {?}
     */
    onCheckboxChange(uxLink, evt) {
        if (this.isRecursiveSelection) {
            this.changeSelectionRecursively(uxLink, evt.target.checked);
        }
        this.selectionChange.next(uxLink);
    }
    /**
     * @param {?} event
     * @param {?} uxLink
     * @return {?}
     */
    onMetadataNodeToggle(event, uxLink) {
        this.node.expanded = !this.node.expanded;
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onSubNodeClick(uxLink) {
        this.nodeClick.emit(uxLink);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onSubNodeToggle(uxLink) {
        this.nodeToggle.emit(uxLink);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onSelectionChange(uxLink) {
        this.selectionChange.next(uxLink);
    }
    /**
     * @param {?} uxLink
     * @param {?} value
     * @return {?}
     */
    changeSelectionRecursively(uxLink, value) {
        if (uxLink.hasChildren) {
            uxLink.children.forEach((link) => {
                link.selected = value;
                this.changeSelectionRecursively(link, value);
            });
        }
    }
}
UxTreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tree-node',
                template: "<li *ngIf=\"node.visible\" class=\"ux-tree__node\" tabindex=\"1\" title=\"{{node.label}}\" [class.first-child]=\"isFirst\" [class.last-child]=\"isLast\"> <div class=\"ux-tree__node-wrapper px-1\" [class.ux-tree__node--selected]=\"node.selected\"> <ux-button (click)=\"onNodeToggle($event, node)\" (keydown)=\"onNodeKeydown($event, node)\" styleClass=\"ux-tree__node-toggle-icon\" *ngIf=\"hasNodeChildren(node)\" [isSmall]=\"true\" [isFlat]=\"true\" [iconClass]=\"node.expanded ? expandedIconClass : collapsedIconClass\"></ux-button> <span *ngIf=\"isMultiselect\" class=\"ml-2\"> <input type=\"checkbox\" [id]=\"nodeId\" [value]=\"node.label\" [(ngModel)]=\"node.selected\" (change)=\"onCheckboxChange(node, $event)\"> <label class=\"ux-tree__node-checkbox-label\" [for]=\"nodeId\"> </label> </span> <div *ngIf=\"nodeContentTemplate\" class=\"ml-2\"> <ng-template [ngTemplateOutlet]=\"nodeContentTemplate\" [ngTemplateOutletContext]=\"{ $implicit: node }\"> </ng-template> </div> <ng-container *ngIf=\"!nodeContentTemplate\"> <ng-container *ngIf=\"node.typeLabel || node.iconClass\"> <span *ngIf=\"node.typeLabel\" class=\"ux-tree__node-type ux-tree__node-type--{{node.typeClass}}\" (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\"> {{node.typeLabel}} </span> <span *ngIf=\"node.iconClass\" class=\"ux-tree__node-icon ux-tree__node-type--{{node.iconTypeClass}}\"> <span class=\"{{node.iconClass}}\"></span> </span> <div class=\"ux-tree__node-label-wrapped\"> <span (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\">{{node.label}}</span> </div> </ng-container> <ng-container *ngIf=\"!(node.typeLabel || node.iconClass)\"> <span class=\"ux-tree__node-label\" (click)=\"onNodeClick($event, node)\" (keydown)=\"onNodeKeydown($event, node)\"> {{node.label}} </span> </ng-container> <div *ngIf=\"node.badges\" class=\"ml-auto\"> <span *ngFor=\"let badge of node.badges\" class=\"badge badge--small ux-c-badge--outline badge-pill ux-c-badge badge-{{badge.typeClass}} ux-c-badge--{{badge.typeClass}} ux-tree__node-badge\"> {{badge.label}} </span> </div> <span *ngIf=\"node.metadata && node.metadata.title && node.metadata.title.length > 0\" class=\"ux-tree__node-metacontent-toggle ux-tree__node-clickable\" (click)=\"onMetadataNodeToggle($event, node)\"> <span class=\"ux-icon\" [ngClass]=\"node.expanded ? 'ux-icon ux-icon-angle-down' : 'ux-icon ux-icon-angle-right'\"> </span> </span> </ng-container> </div> <ng-container *ngIf=\"node.expanded\"> <ul *ngIf=\"hasNodeChildren(node)\" class=\"ux-tree__nodes\"> <ux-tree-node *ngFor=\"let subNode of node.children; let isFirst = first; let isLast = last\" [node]=\"subNode\" [isMultiselect]=\"isMultiselect\" [isRecursiveSelection]=\"isRecursiveSelection\" (nodeClick)=\"onSubNodeClick($event)\" (nodeToggle)=\"onSubNodeToggle($event)\" (selectionChange)=\"onSelectionChange($event)\" [isFirst]=\"isFirst\" [isLast]=\"isLast\" [isClickTogglingNode]=\"isClickTogglingNode\" expandedIconClass=\"{{expandedIconClass}}\" collapsedIconClass=\"{{collapsedIconClass}}\" [templateVariable]=\"templateVariable\" [nodeContentTemplate]=\"nodeContentTemplate\" [isShowActiveNode]=\"isShowActiveNode\"> </ux-tree-node> </ul> <div *ngIf=\"node.metadata && node.metadata.title && node.metadata.title.length > 0\" class=\"ux-tree__node-metacontent\"> <ng-template [ngTemplateOutlet]=\"templateVariable\" [ngTemplateOutletContext]=\"{metadata: node.metadata}\"></ng-template> </div> </ng-container> </li> ",
            },] },
];
/** @nocollapse */
UxTreeNodeComponent.ctorParameters = () => [
    { type: Router, },
    { type: UxService, },
];
UxTreeNodeComponent.propDecorators = {
    "node": [{ type: Input },],
    "isFirst": [{ type: Input },],
    "isLast": [{ type: Input },],
    "isRootNode": [{ type: Input },],
    "isClickTogglingNode": [{ type: Input },],
    "isMultiselect": [{ type: Input },],
    "isRecursiveSelection": [{ type: Input },],
    "expandedIconClass": [{ type: Input },],
    "collapsedIconClass": [{ type: Input },],
    "templateVariable": [{ type: Input },],
    "isShowActiveNode": [{ type: Input },],
    "nodeContentTemplate": [{ type: Input },],
    "nodeClick": [{ type: Output },],
    "nodeToggle": [{ type: Output },],
    "selectionChange": [{ type: Output },],
};
class UxTreeComponent {
    constructor() {
        this.isShowToolbar = false;
        this.isExpanded = false;
        this.isMultiselect = false;
        this.isRecursiveSelection = false;
        this.isClickTogglingNode = false;
        this.collapsedIconClass = 'ux-icon ux-icon-ios-plus';
        this.expandedIconClass = 'ux-icon ux-icon-ios-minus';
        this.isShowActiveNode = false;
        this.nodeClick = new EventEmitter();
        this.nodeToggle = new EventEmitter();
        this.selectionChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.isExpanded) {
            this.setNodesExpandedState(this.nodes, true);
        }
        this.templates.forEach((item) => {
            if (item.getType() === 'nodeContent') {
                this.nodeContentTemplate = item.template;
            }
        });
    }
    /**
     * @return {?}
     */
    getSelectedNodes() {
        return this.getSelectedNodesRecursive(this.nodes);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onNodeToggle(uxLink) {
        this.nodeToggle.emit(uxLink);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onNodeClick(uxLink) {
        this.nodeClick.emit(uxLink);
        if (this.isClickTogglingNode && uxLink.hasChildren) {
            this.onNodeToggle(uxLink);
        }
        if (!this.isMultiselect && this.isShowActiveNode) {
            this.setNodesSelectedState(this.nodes, false);
            uxLink.selected = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onExpandAll(event) {
        this.setNodesExpandedState(this.nodes, true);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCollapseAll(event) {
        this.setNodesExpandedState(this.nodes, false);
    }
    /**
     * @param {?} uxLink
     * @return {?}
     */
    onSelectionChange(uxLink) {
        this.selectionChange.next(uxLink);
    }
    /**
     * @param {?} filterValue
     * @return {?}
     */
    onFilter(filterValue) {
        if (filterValue !== '') {
            this.setNodesVisibleState(this.nodes, false);
            this.nodes.forEach((node) => {
                this.isFilterMatched(node, filterValue);
            });
            this.setNodesExpandedState(this.nodes, true);
        }
        else {
            this.setNodesVisibleState(this.nodes, true);
        }
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    getSelectedNodesRecursive(nodes) {
        return (nodes || []).reduce((acc, node) => {
            if (node.hasChildren) {
                return node.selected ?
                    [...acc, node, ...this.getSelectedNodesRecursive(node.children)] :
                    [...acc, ...this.getSelectedNodesRecursive(node.children)];
            }
            else {
                return node.selected ? [...acc, node] : [...acc];
            }
        }, []);
    }
    /**
     * @param {?} node
     * @param {?} filterValue
     * @return {?}
     */
    isFilterMatched(node, filterValue) {
        node.label.toUpperCase().indexOf(filterValue.toUpperCase()) !== -1 ? node.visible = true : node.visible = false;
        if (node.children) {
            node.children.forEach((childrenNode) => {
                this.isFilterMatched(childrenNode, filterValue);
                if (childrenNode.visible) {
                    node.visible = true;
                }
            });
        }
    }
    /**
     * @param {?} nodes
     * @param {?} expanded
     * @return {?}
     */
    setNodesExpandedState(nodes, expanded) {
        nodes.forEach((node) => {
            node.expanded = expanded;
            if (node.children) {
                this.setNodesExpandedState(node.children, expanded);
            }
        });
    }
    /**
     * @param {?} nodes
     * @param {?} visible
     * @return {?}
     */
    setNodesVisibleState(nodes, visible) {
        nodes.forEach((node) => {
            node.visible = visible;
            if (node.children) {
                this.setNodesVisibleState(node.children, visible);
            }
        });
    }
    /**
     * @param {?} nodes
     * @param {?} selected
     * @return {?}
     */
    setNodesSelectedState(nodes, selected) {
        nodes.forEach((node) => {
            node.selected = selected;
            if (node.children) {
                this.setNodesSelectedState(node.children, selected);
            }
        });
    }
}
UxTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-tree',
                template: `
    <ux-a-toolbar-filter [isVisible]="isShowToolbar"
                         (filter)="onFilter($event)"
                         (expandAll)="onExpandAll($event)"
                         (collapseAll)="onCollapseAll($event)"
                         filterLabel="{{filterLabel}}"
                         expandAllLabel="{{expandAllLabel}}"
                         collapseAllLabel="{{collapseAllLabel}}"
                         [isToggleExpanded]="isExpanded">
    </ux-a-toolbar-filter>

    <ul class="ux-tree" [class.ux-tree--multiselect]="isMultiselect">
        <ux-tree-node *ngFor="let node of nodes"
                        [node]="node"
                        (nodeClick)="onNodeClick($event)"
                        (nodeToggle)="onNodeToggle($event)"
                        (selectionChange)="onSelectionChange($event)"
                        [isRootNode]="true"
                        [isMultiselect]="isMultiselect"
                        [isRecursiveSelection]="isRecursiveSelection"
                        [isClickTogglingNode]="isClickTogglingNode"
                        expandedIconClass="{{expandedIconClass}}"
                        collapsedIconClass="{{collapsedIconClass}}"
                        [templateVariable]="templateVariable"
                        [nodeContentTemplate]="nodeContentTemplate"
                        [isShowActiveNode]="isShowActiveNode">
        </ux-tree-node>
    </ul>
  `
            },] },
];
/** @nocollapse */
UxTreeComponent.propDecorators = {
    "nodes": [{ type: Input },],
    "isShowToolbar": [{ type: Input },],
    "collapseAllLabel": [{ type: Input },],
    "expandAllLabel": [{ type: Input },],
    "filterLabel": [{ type: Input },],
    "isExpanded": [{ type: Input },],
    "isMultiselect": [{ type: Input },],
    "isRecursiveSelection": [{ type: Input },],
    "isClickTogglingNode": [{ type: Input },],
    "collapsedIconClass": [{ type: Input },],
    "expandedIconClass": [{ type: Input },],
    "isShowActiveNode": [{ type: Input },],
    "nodeClick": [{ type: Output },],
    "nodeToggle": [{ type: Output },],
    "selectionChange": [{ type: Output },],
    "templateVariable": [{ type: ContentChild, args: [TemplateRef,] },],
    "templates": [{ type: ContentChildren, args: [UxTemplateDirective,] },],
};
class UxTreeComponentModule {
}
UxTreeComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, FormsModule, UxToolbarFilterComponentModule,
                    UxButtonComponentModule,
                    UxBadgeComponentModule
                ],
                exports: [UxTreeComponent, UxTreeNodeComponent],
                declarations: [UxTreeComponent, UxTreeNodeComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimebarItemUI {
}
class UxTimebarComponent {
    /**
     * @param {?} uxService
     * @param {?} asService
     * @param {?} renderer2
     */
    constructor(uxService, asService, renderer2) {
        this.uxService = uxService;
        this.asService = asService;
        this.renderer2 = renderer2;
        this.dateFormat = 'YYYY-MM-DD';
        this.isShowLegend = false;
        this.isShowLegendAsIndex = true;
        this.isShowCurrentDateMarker = false;
        this.isCurrentDateMarkerAlwaysInRange = false;
        this.isGroupOverlappingLabels = false;
        this.itemsUI = [];
        this.currentDate = new Date();
        this.timebarColumnClass = 'col-12';
        this.isMobile = false;
        this.isSomeStepsAreGrouped = false;
        this.extraTimelineLabelSpace = 21;
        this.maxStepWidth = 112;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscription = this.asService.breakpoints$.subscribe((bkps) => {
            this.onBreakpointChange(bkps);
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.removeNullItems();
        this.sortItems();
        const /** @type {?} */ startDate = this.items[0].date;
        const /** @type {?} */ endDate = this.items[this.items.length - 1].date;
        this.items.forEach((item) => {
            let /** @type {?} */ stepTypeClass = '';
            let /** @type {?} */ tooltipColor = 'none';
            if (item.stepType) {
                stepTypeClass = 'ux-timebar__step--' + item.stepType;
                tooltipColor = item.stepType;
            }
            let /** @type {?} */ isNumber = /^\d+\.\d+$/.test(item.label) || /^\d+$/.test(item.label);
            if (isNumber) {
                item.label = this.uxService.formatNumber(item.label, 2);
            }
            this.itemsUI.push({
                perc: this.calculatePercentage(item.date, startDate, endDate),
                item: item,
                stepTypeClass: stepTypeClass,
                tooltipColor: tooltipColor,
            });
        });
        this.currentPerc = this.calculatePercentage(this.currentDate, startDate, endDate, true);
        this.markedPerc = this.calculatePercentage(this.markedDate, startDate, endDate, true);
        if (this.startLabel && this.endLabel) {
            this.timebarColumnClass = 'col-8';
        }
        else {
            if (this.startLabel || this.endLabel) {
                this.timebarColumnClass = 'col-10';
            }
        }
        // initialize attributes
        this.isShowLegendGenerated = this.isShowLegend;
        this.isShowLegendAsIndexGenerated = this.isShowLegendAsIndex;
        this.isGroupOverlappingLabelsGenerated = this.isGroupOverlappingLabels;
        this.isMobile = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.groupOverlappingLabels();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes) {
            const /** @type {?} */ change = changes['markedDate'];
            if (change) {
                const /** @type {?} */ startDate = this.items[0].date;
                const /** @type {?} */ endDate = this.items[this.items.length - 1].date;
                this.markedPerc = this.calculatePercentage(/** @type {?} */ (change.currentValue), startDate, endDate);
            }
        }
    }
    /**
     * @param {?} bkps
     * @return {?}
     */
    onBreakpointChange(bkps) {
        if (bkps.isMobile) {
            this.isShowLegendGenerated = true;
            this.isShowLegendAsIndexGenerated = true;
            this.isMobile = true;
        }
        else {
            this.isShowLegendGenerated = this.isShowLegend;
            this.isShowLegendAsIndexGenerated = this.isShowLegendAsIndex;
            this.isMobile = false;
        }
        this.groupOverlappingLabels();
    }
    /**
     * @return {?}
     */
    removeNullItems() {
        if (this.items) {
            for (let /** @type {?} */ i = 0; i < this.items.length; i++) {
                if (!this.items[i]) {
                    this.items.splice(i, 1);
                    i--;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    sortItems() {
        if (this.items) {
            // Sort by ascending date:
            this.items = this.items.sort((a, b) => {
                if (a && b) {
                    return /** @type {?} */ (a.date) - /** @type {?} */ (b.date);
                }
                else {
                    return 0;
                }
            });
        }
    }
    /**
     * @return {?}
     */
    groupOverlappingLabels() {
        if (this.isGroupOverlappingLabelsGenerated) {
            this.clearGrouping();
            if (this.container && this.itemsUI && this.isShowLegendAsIndexGenerated) {
                const /** @type {?} */ containerElement = this.container.nativeElement;
                setTimeout(() => {
                    const /** @type {?} */ containerWidth = containerElement.clientWidth;
                    // const groupingThreshold = this.maxStepWidth / 2;
                    const /** @type {?} */ groupingThreshold = (this.maxStepWidth * 100) / containerWidth;
                    let /** @type {?} */ groupingCounter = 0;
                    let /** @type {?} */ mobileIndexDisplacement = 0;
                    let /** @type {?} */ previousUiItem = null;
                    for (let /** @type {?} */ i = 0; i < this.itemsUI.length; i++) {
                        const /** @type {?} */ uiItem = this.itemsUI[i];
                        if (previousUiItem) {
                            const /** @type {?} */ distance = Math.abs(uiItem.perc - previousUiItem.perc);
                            if (distance <= groupingThreshold) {
                                // Group the 2 items:
                                groupingCounter++;
                                if (this.isShowLegendGenerated && mobileIndexDisplacement <= 0) {
                                    mobileIndexDisplacement = i - 1;
                                }
                                if (!previousUiItem.groupLabel) {
                                    previousUiItem.groupIndex = groupingCounter;
                                    if (!this.isShowLegendGenerated) {
                                        previousUiItem.groupLabel = '' + groupingCounter;
                                    }
                                    else {
                                        previousUiItem.groupLabel = '' + (mobileIndexDisplacement + groupingCounter);
                                    }
                                    previousUiItem.groupLabelMobile = '' + (mobileIndexDisplacement + groupingCounter);
                                    groupingCounter++;
                                }
                                if (!this.isShowLegendGenerated) {
                                    previousUiItem.groupLabel += ', ' + groupingCounter;
                                }
                                else {
                                    previousUiItem.groupLabel += ', ' + (mobileIndexDisplacement + groupingCounter);
                                }
                                previousUiItem.groupLabelMobile += ', ' + (mobileIndexDisplacement + groupingCounter);
                                previousUiItem.groupEndDate = uiItem.item.date;
                                previousUiItem.stepTypeClass = uiItem.item.stepType;
                                uiItem.isGrouped = true;
                                uiItem.groupIndex = groupingCounter;
                                this.isSomeStepsAreGrouped = true;
                            }
                            else {
                                previousUiItem = uiItem;
                            }
                        }
                        else {
                            previousUiItem = uiItem;
                        }
                    }
                    // TODO: for what this code is really needed ?
                    // https://webgate.ec.europa.eu/CITnet/jira/browse/OPSYS-3958
                    // this.calculateExtraTimelineLabelSpace();
                }, 0);
            }
        }
    }
    /**
     * @return {?}
     */
    clearGrouping() {
        this.isSomeStepsAreGrouped = false;
        if (this.itemsUI) {
            for (const /** @type {?} */ item of this.itemsUI) {
                delete item.isGrouped;
                delete item.groupIndex;
                delete item.groupLabel;
                delete item.groupLabelMobile;
                delete item.groupEndDate;
            }
        }
        this.extraTimelineLabelSpace = 21;
    }
    /**
     * @return {?}
     */
    calculateExtraTimelineLabelSpace() {
        if (this.itemsUI) {
            let /** @type {?} */ maxLabelLength = 0;
            for (const /** @type {?} */ item of this.itemsUI) {
                if (item.item && item.item.label) {
                    maxLabelLength = Math.max(maxLabelLength, item.item.label.length);
                }
            }
            if (maxLabelLength > 56) {
                // 56px = 4rem margin of the timeline itself.
                this.extraTimelineLabelSpace = maxLabelLength + 28; // 28px = 2rem = 1 line of text in height + margins
            }
        }
    }
    /**
     * @param {?} date
     * @param {?} startDate
     * @param {?} endDate
     * @param {?=} compensateForRange
     * @return {?}
     */
    calculatePercentage(date, startDate, endDate, compensateForRange = false) {
        if (date && startDate && endDate) {
            let /** @type {?} */ percentage = ((date.getTime() - startDate.getTime()) / (endDate.getTime() - startDate.getTime())) * 100;
            if (compensateForRange) {
                // if the date is over the end date, or below the start date
                // simulate its positioning to not mess up the timebar global width
                if (percentage > 100) {
                    if (this.isCurrentDateMarkerAlwaysInRange) {
                        percentage = 100;
                    }
                    else {
                        percentage = 103;
                    }
                }
                else if (percentage <= 0) {
                    if (this.isCurrentDateMarkerAlwaysInRange) {
                        percentage = 0;
                    }
                    else {
                        percentage = -3;
                    }
                }
            }
            return percentage;
        }
        else {
            return 0;
        }
    }
}
UxTimebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-timebar',
                template: "<div class=\"row flex-container\" #container> <div *ngIf=\"startLabel\" class=\"col-2 ux-timebar__start-label\"> {{startLabel}} </div> <div class=\"{{timebarColumnClass}}\"> <div class=\"ux-timebar\" [style.marginBottom.px]=\"extraTimelineLabelSpace\"> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-progress\" [style.width.%]=\"currentPerc >= 100 ? 100 : currentPerc\"></div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-progress\" [style.width.%]=\"markedPerc >= 100 ? 100 : markedPerc\"></div> <ng-template [ngIf]=\"!isMobile\"> <ng-container *ngFor=\"let item of itemsUI; let i = index;\"> <ng-container *ngIf=\"! item.isGrouped\"> <div class=\"ux-timebar__step\" [ngClass]=\"item.stepTypeClass\" [style.left.%]=\"item.perc\" [class.ux-timebar__step--with-current-date-marker]=\"isShowCurrentDateMarker || markedDate\"> <div class=\"ux-timebar__step-date-item\" [class.ux-timebar__step-date-item--with-end-date]=\"item.groupEndDate\"> <span class=\"{{ item.tooltipColor ? 'ux-timebar__step--' + item.tooltipColor : '' }}\" [class.timebar__grouped__step]=\"item.groupEndDate\"> {{ item.item.date | amLocal | amDateFormat: dateFormat }} </span> <span *ngIf=\"item.groupEndDate\" class=\"timebar__grouped__step {{ item.stepTypeClass ? 'ux-timebar__step--' + item.stepTypeClass : '' }}\"> {{ item.groupEndDate | amLocal | amDateFormat: dateFormat }} </span> </div> <div *ngIf=\"!isShowLegendGenerated\" [style.left.%]=\"item.perc\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabel\"> <span title=\"{{item.item.label}}\">{{item.item.label}}</span> </ng-container> <ng-container *ngIf=\"item.groupLabel\"> <span title=\"{{item.groupLabel}}\">{{item.groupLabel}}</span> </ng-container> </div> <div *ngIf=\"isShowLegendGenerated && isShowLegendAsIndexGenerated\" [style.left.%]=\"item.perc\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> {{i+1}} </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> </div> </ng-container> </ng-container> </ng-template> <ng-template [ngIf]=\"isMobile\"> <ng-container *ngFor=\"let item of itemsUI; let i = index;\"> <ng-container *ngIf=\"! item.isGrouped\"> <div class=\"ux-timebar__step\" [ngClass]=\"item.stepTypeClass\" [style.left.%]=\"item.perc\" [class.ux-timebar__step--with-current-date-marker]=\"isShowCurrentDateMarker || markedDate\"> <div *ngIf=\"!isShowLegendGenerated\" class=\"ux-timebar__step-label\" title=\"{{item.item.label}}\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> <span title=\"{{item.item.label}}\">{{item.item.label}}</span> </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> <div *ngIf=\"isShowLegendGenerated && isShowLegendAsIndexGenerated\" class=\"ux-timebar__step-label\"> <ng-container *ngIf=\"! item.groupLabelMobile\"> {{i+1}} </ng-container> <ng-container *ngIf=\"item.groupLabelMobile\"> {{item.groupLabelMobile}} </ng-container> </div> </div> </ng-container> </ng-container> </ng-template> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-date-marker\" [style.left.%]=\"currentPerc\" uxTooltip=\"{{currentDate | amLocal | amDateFormat: dateFormat }}\"> <span class=\"ux-icon ux-icon-map-marker\"></span> </div> <div *ngIf=\"isShowCurrentDateMarker\" class=\"ux-timebar__current-date-marker-step\" [style.left.%]=\"currentPerc\"> <span class=\"ux-icon ux-icon-circle\"></span> </div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-date-marker\" [style.left.%]=\"markedPerc\" uxTooltip=\"{{markedDate | amLocal | amDateFormat: dateFormat }}\"> <span class=\"ux-icon ux-icon-map-marker\"></span> </div> <div *ngIf=\"markedDate\" class=\"ux-timebar__current-date-marker-step\" [style.left.%]=\"markedPerc\"> <span class=\"ux-icon ux-icon-circle\"></span> </div> </div> </div> <div *ngIf=\"endLabel\" class=\"col-2 ux-timebar__end-label\"> {{endLabel}} </div> </div> <div class=\"row flex-container\"> <div *ngIf=\"startLabel\" class=\"col-2\"></div> <div class=\"{{timebarColumnClass}}\"> <div *ngIf=\"isShowLegendGenerated || isSomeStepsAreGrouped\" class=\"ux-timebar__legend\"> <ng-container *ngIf=\"isShowLegendGenerated\"> <div class=\"ux-timebar__legend-item\" *ngFor=\"let item of itemsUI; let i = index\"> <div *ngIf=\"!isShowLegendAsIndexGenerated\" class=\"ux-timebar__legend-item-icon\"> <span class=\"ux-icon ux-icon-fw ux-icon-circle ux-timebar__legend-item-icon--{{item.item.stepType}}\"></span> </div> <div *ngIf=\"isShowLegendAsIndexGenerated\" class=\"ux-timebar__legend-item-index-wrapper\"> {{i+1}} </div> <div class=\"ux-timebar__legend-item-label\"> <ng-template [ngIf]=\"isMobile\"> <strong>{{item.item.date | amLocal | amDateFormat: dateFormat }}</strong> - {{item.item.label}} </ng-template> <ng-template [ngIf]=\"!isMobile\"> {{item.item.label}} </ng-template> </div> </div> </ng-container> <ng-container *ngIf=\"! isShowLegendGenerated\"> <ng-container *ngFor=\"let item of itemsUI\"> <div *ngIf=\"item.groupLabel || item.isGrouped\" class=\"ux-timebar__legend-item\"> <div class=\"ux-timebar__legend-item-index-wrapper\"> {{item.groupIndex}} </div> <div class=\"ux-timebar__legend-item-label\"> <strong>{{item.item.date | amLocal | amDateFormat: dateFormat }}</strong> - {{item.item.label}} </div> </div> </ng-container> </ng-container> </div> </div> <div *ngIf=\"endLabel\" class=\"col-2\"></div> </div> ",
            },] },
];
/** @nocollapse */
UxTimebarComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxAppShellService, },
    { type: Renderer2, },
];
UxTimebarComponent.propDecorators = {
    "items": [{ type: Input },],
    "startLabel": [{ type: Input },],
    "endLabel": [{ type: Input },],
    "dateFormat": [{ type: Input },],
    "isShowLegend": [{ type: Input },],
    "isShowLegendAsIndex": [{ type: Input },],
    "isShowCurrentDateMarker": [{ type: Input },],
    "isCurrentDateMarkerAlwaysInRange": [{ type: Input },],
    "isGroupOverlappingLabels": [{ type: Input },],
    "markedDate": [{ type: Input },],
    "container": [{ type: ViewChild, args: ['container',] },],
};
class UxTimebarComponentModule {
}
UxTimebarComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxTooltipModule, MomentModule],
                exports: [UxTimebarComponent],
                declarations: [UxTimebarComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxTimebarItem {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAutocompleteTagItem {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        this.isDeletable = true;
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Point {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    static create(x, y) {
        return new Point(x, y);
    }
    /**
     * @return {?}
     */
    clone() {
        return Point.create(this.x, this.y);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * @param {?} offsetX
     * @param {?} offsetY
     * @return {?}
     */
    translate(offsetX, offsetY) {
        this.x += offsetX;
        this.y += offsetY;
        return this;
    }
    /**
     * @param {?} offsetX
     * @return {?}
     */
    translateX(offsetX) {
        return this.translate(offsetX, 0);
    }
    /**
     * @param {?} offsetY
     * @return {?}
     */
    translateY(offsetY) {
        return this.translate(0, offsetY);
    }
    /**
     * @param {?} factor
     * @return {?}
     */
    scale(factor) {
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    map(fn) {
        this.x = fn.call(this, this.x);
        this.y = fn.call(this, this.y);
        return this;
    }
    /**
     * @return {?}
     */
    isZero() {
        return this.equals(Point.create(0, 0));
    }
    /**
     * @param {?} other
     * @return {?}
     */
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * @return {?}
     */
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Overflow {
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} right
     * @param {?} bottom
     */
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} right
     * @param {?} bottom
     * @return {?}
     */
    static create(left, top, right, bottom) {
        return new Overflow(left, top, right, bottom);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    equals(other) {
        return this.left === other.left &&
            this.top === other.top &&
            this.bottom === other.bottom &&
            this.right === other.right;
    }
    /**
     * @return {?}
     */
    toString() {
        return `(${this.left}, ${this.top}, ${this.right}, ${this.bottom})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Rectangle {
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} right
     * @param {?} bottom
     */
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    static create(x, y, width, height) {
        return new Rectangle(x, y, x + width, y + height);
    }
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} right
     * @param {?} bottom
     * @return {?}
     */
    static fromBounds(left, top, right, bottom) {
        return Rectangle.create(left, top, right - left, bottom - top);
    }
    /**
     * @param {?} rect
     * @return {?}
     */
    static fromRect(rect) {
        return Rectangle.create(rect.x, rect.y, rect.width, rect.height);
    }
    /**
     * @return {?}
     */
    static empty() {
        return Rectangle.create(0, 0, 0, 0);
    }
    /**
     * @return {?}
     */
    get x() {
        return this.left;
    }
    /**
     * @param {?} newX
     * @return {?}
     */
    set x(newX) {
        const /** @type {?} */ offsetX = newX - this.x;
        this.left = newX;
        this.right += offsetX;
    }
    /**
     * @return {?}
     */
    get y() {
        return this.top;
    }
    /**
     * @param {?} newY
     * @return {?}
     */
    set y(newY) {
        const /** @type {?} */ offsetY = newY - this.y;
        this.top = newY;
        this.bottom += offsetY;
    }
    /**
     * @return {?}
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * @param {?} newWidth
     * @return {?}
     */
    set width(newWidth) {
        this.right = this.left + newWidth;
    }
    /**
     * @return {?}
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * @param {?} newWidth
     * @return {?}
     */
    set height(newWidth) {
        this.bottom = this.top + newWidth;
    }
    /**
     * @return {?}
     */
    clone() {
        return Rectangle.create(this.x, this.y, this.width, this.height);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    setRectangle(x, y, width, height) {
        this.left = x;
        this.top = y;
        this.right = x + width;
        this.bottom = y + height;
        return this;
    }
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} right
     * @param {?} bottom
     * @return {?}
     */
    setBounds(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        return this;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    copyFrom(other) {
        this.left = other.left;
        this.top = other.top;
        this.right = other.right;
        this.bottom = other.bottom;
        return this;
    }
    /**
     * @param {?} p
     * @param {?=} anchor
     * @return {?}
     */
    moveTo(p, anchor = this.leftTop()) {
        this.x = p.x + (this.x - anchor.x);
        this.y = p.y + (this.y - anchor.y);
        return this;
    }
    /**
     * @param {?} x
     * @param {?=} anchor
     * @return {?}
     */
    moveXTo(x, anchor = this.leftTop()) {
        this.x = x + (this.x - anchor.x);
        return this;
    }
    /**
     * @param {?} y
     * @param {?=} anchor
     * @return {?}
     */
    moveYTo(y, anchor = this.leftTop()) {
        this.y = y + (this.y - anchor.y);
        return this;
    }
    /**
     * @param {?} offsetX
     * @param {?} offsetY
     * @return {?}
     */
    translate(offsetX, offsetY) {
        this.left += offsetX;
        this.top += offsetY;
        this.right += offsetX;
        this.bottom += offsetY;
        return this;
    }
    /**
     * @param {?} offsetX
     * @return {?}
     */
    translateX(offsetX) {
        return this.translate(offsetX, 0);
    }
    /**
     * @param {?} offsetY
     * @return {?}
     */
    translateY(offsetY) {
        return this.translate(0, offsetY);
    }
    /**
     * @param {?} factor
     * @return {?}
     */
    scale(factor) {
        this.left *= factor;
        this.top *= factor;
        this.right *= factor;
        this.bottom *= factor;
        return this;
    }
    /**
     * @param {?} yAxis
     * @return {?}
     */
    flipX(yAxis) {
        const /** @type {?} */ offsetY = 2 * (this.top - yAxis) + this.height;
        return this.translate(0, -offsetY);
    }
    /**
     * @param {?} xAxis
     * @return {?}
     */
    flipY(xAxis) {
        const /** @type {?} */ offsetX = 2 * (this.left - xAxis) + this.width;
        return this.translate(-offsetX, 0);
    }
    /**
     * @param {?} point
     * @return {?}
     */
    flip(point) {
        return this
            .flipX(point.y)
            .flipY(point.x);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    map(fn) {
        this.left = fn.call(this, this.left);
        this.top = fn.call(this, this.top);
        this.right = fn.call(this, this.right);
        this.bottom = fn.call(this, this.bottom);
        return this;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    isBelow(p) {
        return this.top >= p.y;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    isAbove(p) {
        return this.bottom <= p.y;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    isOnTheLeft(p) {
        return this.right <= p.x;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    isOnTheRight(p) {
        return this.left >= p.x;
    }
    /**
     * @return {?}
     */
    position() {
        return this.leftTop();
    }
    /**
     * @return {?}
     */
    leftTop() {
        return Point.create(this.left, this.top);
    }
    /**
     * @return {?}
     */
    centerTop() {
        return Point.create(this.left + (this.width / 2), this.top);
    }
    /**
     * @return {?}
     */
    rightTop() {
        return Point.create(this.right, this.top);
    }
    /**
     * @return {?}
     */
    leftCenter() {
        const /** @type {?} */ x = this.x;
        const /** @type {?} */ y = this.y + (this.height / 2);
        return Point.create(x, y);
    }
    /**
     * @return {?}
     */
    center() {
        const /** @type {?} */ x = this.x + (this.width / 2);
        const /** @type {?} */ y = this.y + (this.height / 2);
        return Point.create(x, y);
    }
    /**
     * @return {?}
     */
    rightCenter() {
        const /** @type {?} */ x = this.x + this.width;
        const /** @type {?} */ y = this.y + (this.height / 2);
        return Point.create(x, y);
    }
    /**
     * @return {?}
     */
    leftBottom() {
        return Point.create(this.left, this.bottom);
    }
    /**
     * @return {?}
     */
    centerBottom() {
        return Point.create(this.left + (this.width / 2), this.bottom);
    }
    /**
     * @return {?}
     */
    rightBottom() {
        return Point.create(this.right, this.bottom);
    }
    /**
     * @return {?}
     */
    isEmpty() {
        return this.width <= 0 || this.height <= 0;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    containsRect(other) {
        if (other.isEmpty()) {
            return true;
        }
        if (this.isEmpty()) {
            return false;
        }
        return other.left >= this.left &&
            other.top >= this.top &&
            other.right <= this.right &&
            other.bottom <= this.bottom;
    }
    /**
     * @param {?} point
     * @return {?}
     */
    containsPoint(point) {
        if (this.isEmpty()) {
            return false;
        }
        return point.x >= this.left &&
            point.x <= this.right &&
            point.y >= this.top &&
            point.y <= this.bottom;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflows(other) {
        return this.overflowsLeft(other) ||
            this.overflowsTop(other) ||
            this.overflowsRight(other) ||
            this.overflowsBottom(other);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflowsLeft(other) {
        return this.overflow(other).left > 0;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflowsTop(other) {
        return this.overflow(other).top > 0;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflowsRight(other) {
        return this.overflow(other).right > 0;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflowsBottom(other) {
        return this.overflow(other).bottom > 0;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    overflow(other) {
        return Overflow.create(Math.max(0, other.left - this.left), Math.max(0, other.top - this.top), Math.max(0, this.right - other.right), Math.max(0, this.bottom - other.bottom));
    }
    /**
     * @param {?} other
     * @return {?}
     */
    intersects(other) {
        if (this.isEmpty() || other.isEmpty()) {
            return false;
        }
        return this.left < other.right &&
            this.right > other.left &&
            this.top < other.bottom &&
            this.bottom > other.top;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    intersect(other) {
        return this
            .clone()
            .restrictTo(other);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    union(other) {
        return this
            .clone()
            .expandToContain(other);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    restrictTo(other) {
        if (this.isEmpty() || other.isEmpty()) {
            return this.setRectangle(0, 0, 0, 0);
        }
        const /** @type {?} */ left = Math.max(this.left, other.left);
        const /** @type {?} */ top = Math.max(this.top, other.top);
        const /** @type {?} */ right = Math.min(this.right, other.right);
        const /** @type {?} */ bottom = Math.min(this.bottom, other.bottom);
        return this.setRectangle(left, top, Math.max(0, right - left), Math.max(0, bottom - top));
    }
    /**
     * @param {?} other
     * @return {?}
     */
    expandToContain(other) {
        if (this.isEmpty()) {
            return this.copyFrom(other);
        }
        if (other.isEmpty()) {
            return this;
        }
        const /** @type {?} */ left = Math.min(this.left, other.left);
        const /** @type {?} */ top = Math.min(this.top, other.top);
        const /** @type {?} */ right = Math.max(this.right, other.right);
        const /** @type {?} */ bottom = Math.max(this.bottom, other.bottom);
        return this.setRectangle(left, top, right - left, bottom - top);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    translateInside(other) {
        return this
            .translateXInside(other)
            .translateYInside(other);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    translateXInside(other) {
        let /** @type {?} */ offsetX = 0;
        if (this.left <= other.left) {
            offsetX = other.left - this.left;
        }
        if (this.right >= other.right) {
            offsetX = other.right - this.right;
        }
        return this.translate(offsetX, 0);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    translateYInside(other) {
        let /** @type {?} */ offsetY = 0;
        if (this.top <= other.top) {
            offsetY = other.top - this.top;
        }
        if (this.bottom >= other.bottom) {
            offsetY = other.bottom - this.bottom;
        }
        return this.translate(0, offsetY);
    }
    /**
     * @param {?} rect
     * @param {?} scalar
     * @return {?}
     */
    blend(rect, scalar) {
        return Rectangle.fromBounds(this.left + (rect.left - this.left) * scalar, this.top + (rect.top - this.top) * scalar, this.right + (rect.right - this.right) * scalar, this.bottom + (rect.bottom - this.bottom) * scalar);
    }
    /**
     * @param {?} xScale
     * @param {?=} yScale
     * @return {?}
     */
    inflate(xScale, yScale = xScale) {
        const /** @type {?} */ xAdjust = (this.width * xScale - this.width) / 2;
        const /** @type {?} */ yAdjust = (this.height * yScale - this.height) / 2;
        this.left -= xAdjust;
        this.right += xAdjust;
        this.top -= yAdjust;
        this.bottom += yAdjust;
        return this;
    }
    /**
     * @return {?}
     */
    expandToIntegers() {
        this.left = Math.floor(this.left);
        this.top = Math.floor(this.top);
        this.right = Math.ceil(this.right);
        this.bottom = Math.ceil(this.bottom);
        return this;
    }
    /**
     * @param {?} parent
     * @return {?}
     */
    relativeTo(parent) {
        return Rectangle.create(this.left - parent.left, this.top - parent.top, this.width, this.height);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    equals(other) {
        return (this.isEmpty() && other.isEmpty() ||
            this.top === other.top &&
                this.left === other.left &&
                this.bottom === other.bottom &&
                this.right === other.right);
    }
    /**
     * @return {?}
     */
    toString() {
        return `(${this.x}, ${this.y}, ${this.width}, ${this.height})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RectangleFactory {
    /**
     * @param {?} el
     * @return {?}
     */
    static fromHtmlElement(el) {
        const /** @type {?} */ w = this.getWindow();
        return Rectangle.create(el.getBoundingClientRect().left + w.pageXOffset, el.getBoundingClientRect().top + w.pageYOffset, el.offsetWidth, el.offsetHeight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static fromSvgElement(el) {
        const /** @type {?} */ w = this.getWindow();
        return Rectangle.create(el.getBoundingClientRect().left + w.pageXOffset, el.getBoundingClientRect().top + w.pageYOffset, el.clientWidth, el.clientHeight);
    }
    /**
     * @return {?}
     */
    static fromWindow() {
        const /** @type {?} */ w = this.getWindow();
        return Rectangle.create(w.pageXOffset, w.pageYOffset, w.document.documentElement.clientWidth, w.document.documentElement.clientHeight);
    }
    /**
     * @return {?}
     */
    static getWindow() {
        return window;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PlacementService {
    /**
     * @param {?=} placementStrategies
     */
    constructor(placementStrategies = []) {
        this.placementStrategies = placementStrategies;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    static getEffectiveOptions(options) {
        return Object.assign({ anchor: Rectangle.empty(), element: Rectangle.empty(), placementId: 'bottom', parent: RectangleFactory.fromWindow(), offsetAlong: 0, offsetAcross: 0, constrainToParent: true, flip: true }, options);
    }
    /**
     * @param {?} placementStrategies
     * @param {?} placementId
     * @return {?}
     */
    static pickPlacementStrategy(placementStrategies, placementId) {
        /**
         * @param {?} strategy
         * @return {?}
         */
        function matchStrategy(strategy) {
            return strategy.getId() === placementId;
        }
        return (placementStrategies || []).find(matchStrategy);
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    place(options) {
        const /** @type {?} */ effectiveOptions = PlacementService.getEffectiveOptions(options);
        const /** @type {?} */ placementStrategy = PlacementService.pickPlacementStrategy(this.placementStrategies, effectiveOptions.placementId);
        if (!placementStrategy) {
            throw new Error('Placement not supported: ' + effectiveOptions.placementId);
        }
        return placementStrategy.calculate(effectiveOptions);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ noop$1 = () => { };
const /** @type {?} */ UX_AUTOCOMPLETETAG_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UxAutocompleteTagComponent),
    multi: true,
};
class UxAutocompleteTagComponent {
    /**
     * @param {?} uxService
     * @param {?} renderer
     * @param {?} placementService
     */
    constructor(uxService, renderer, placementService) {
        this.uxService = uxService;
        this.renderer = renderer;
        this.placementService = placementService;
        this.isReadOnly = false;
        this.items = [];
        this.selectedItems = [];
        this.isFreeTagsAllowed = false;
        this.isBadgeSmall = false;
        this.isDisplayTagsListBelow = false;
        this.selectionChanged = new EventEmitter();
        this.isSelectionValid = new EventEmitter();
        this.itemAdded = new EventEmitter();
        this.itemRemoved = new EventEmitter();
        this.onChange = noop$1;
        this.onTouched = noop$1;
        this.query = '';
        this.filteredList = [];
        this.selectedIdx = -1;
        this.isValid = true;
        this.badgeSizeClass = '';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.renderer.appendChild(document.body, this.dropdownEl.nativeElement);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusOut(event) {
        this.reset();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.items.length === 0) {
            this.isFreeTagsAllowed = true;
        }
        if (this.isBadgeSmall) {
            this.badgeSizeClass = 'badge--small';
        }
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputKeyup(event) {
        if (event.code === 'ArrowDown' && this.filteredList.length === 0) {
            this.updateFilteredList();
        }
        else if (event.code === 'ArrowDown' && this.selectedIdx < this.filteredList.length - 1) {
            this.selectedIdx++;
            this.query = this.filteredList[this.selectedIdx].label;
        }
        else if (event.code === 'ArrowUp' && this.selectedIdx > 0) {
            this.selectedIdx--;
            this.query = this.filteredList[this.selectedIdx].label;
        }
        else if (event.keyCode === 13 && this.query !== '') {
            const /** @type {?} */ itemInFilteredList = this.filteredList.find((item) => item.label === this.query);
            const /** @type {?} */ itemInSelectedItems = this.selectedItems.find((item) => item.label === this.query);
            if (!itemInFilteredList) {
                if (!itemInSelectedItems && this.isFreeTagsAllowed) {
                    const /** @type {?} */ newItem = new UxAutocompleteTagItem({ label: this.query });
                    this.selectedItems.push(newItem);
                    this.query = '';
                    this.itemAdded.emit(newItem);
                    this.selectionChanged.emit(this.selectedItems);
                    this.onChange(this.selectedItems);
                }
            }
            else {
                if (this.selectedIdx < 0) {
                    this.selectItem(itemInFilteredList);
                }
                else {
                    this.selectItem(this.filteredList[this.selectedIdx]);
                }
            }
        }
        else {
            if (this.query === '' && event.keyCode !== 9 && event.keyCode !== 16) {
                this.filteredList = [];
            }
            else {
                if (event.code !== 'ArrowUp' && event.code !== 'ArrowDown') {
                    this.updateFilteredList();
                }
            }
        }
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByFn(index, item) {
        return item.id;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputClick(event) {
        this.updateFilteredList();
        this.uxService.consumeEvent(event);
        // Hide temporarily, to avoid flash of unwanted content
        // show again after reposition
        this.dropdownEl.nativeElement.style.visibility = 'hidden';
        setTimeout(() => {
            this.repositionDropdown();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggle(event) {
        this.updateFilteredList();
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSuggestionsMouseDown(event) {
        // Prevent the scrolling on suggestions from losing focus on the input field; and therefore from closing the suggestions.
        // This happens for example when an auto-complete is put inside a modal dialog.
        // non-IE11 fix:
        this.uxService.consumeEvent(event);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.selectedItems.push(item);
        this.reset();
        this.itemAdded.emit(item);
        this.updateSelection();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
        this.itemRemoved.emit(item);
        this.updateSelection();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.selectedItems = value || [];
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.isReadOnly = isDisabled;
    }
    /**
     * @return {?}
     */
    repositionDropdown() {
        const /** @type {?} */ inputRect = RectangleFactory.fromHtmlElement(this.inputEl.nativeElement);
        this.dropdownEl.nativeElement.style.width = inputRect.width + 'px';
        const /** @type {?} */ dropdownRect = RectangleFactory.fromHtmlElement(this.dropdownEl.nativeElement);
        const /** @type {?} */ positionedRect = this.placementService.place({
            anchor: inputRect,
            element: dropdownRect,
            placementId: 'bottom left',
            flip: true,
            constrainToParent: true
        });
        this.dropdownEl.nativeElement.style.top = positionedRect.top + 'px';
        this.dropdownEl.nativeElement.style.left = positionedRect.left + 'px';
        this.dropdownEl.nativeElement.style.visibility = 'visible';
    }
    /**
     * @return {?}
     */
    updateSelection() {
        this.checkValidity();
        this.selectionChanged.emit(this.selectedItems);
        this.onChange(this.selectedItems);
    }
    /**
     * @return {?}
     */
    reset() {
        this.query = '';
        this.filteredList = [];
        this.selectedIdx = -1;
    }
    /**
     * @return {?}
     */
    updateFilteredList() {
        this.filteredList = this.items.filter((item) => {
            const /** @type {?} */ foundItem = this.selectedItems.find((selectedItem) => selectedItem.label === item.label);
            if (foundItem) {
                return false;
            }
            return item.label.toLowerCase().indexOf(this.query.toLowerCase()) > -1;
        });
        this.onTouched(this.selectedItems);
    }
    /**
     * @return {?}
     */
    checkValidity() {
        let /** @type {?} */ validationMessages = [];
        if (this.minRequiredItemsCount) {
            if (this.minRequiredItemsCount > this.selectedItems.length) {
                const /** @type {?} */ remainingItems = this.minRequiredItemsCount - this.selectedItems.length;
                validationMessages.push(this.uxService.translate('autocompleteTagRequiredItemsValidation')
                    .replace('%PARAM%', remainingItems.toString()));
            }
        }
        if (this.maxRequiredItemsCount) {
            if (this.selectedItems.length > this.maxRequiredItemsCount) {
                validationMessages.push(this.uxService.translate('autocompleteTagMaxRequiredItemsValidation')
                    .replace('%PARAM_1%', this.maxRequiredItemsCount.toString())
                    .replace('%PARAM_2%', this.selectedItems.length.toString()));
            }
        }
        this.isValid = validationMessages.length === 0;
        this.requiredItemsCountValidationMessage = validationMessages.join('\n');
        this.isSelectionValid.emit(this.isValid);
    }
}
UxAutocompleteTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-autocomplete-tag',
                template: "<div class=\"ux-autocomplete-tag\"> <div class=\"form-group\"> <div class=\"ux-autocomplete-tag__tags ux-autocomplete-tag__tags-top\" *ngIf=\"!isDisplayTagsListBelow && selectedItems?.length !== 0\"> <div *ngFor=\"let item of selectedItems\" class=\"ux-autocomplete-tag__tags-item\"> <div class=\"badge {{badgeSizeClass}} badge-primary badge-{{item.typeClass}}\"> <i *ngIf=\"item.iconClass\" class=\"mr-1 {{item.iconClass}}\"></i> <span>{{item.label}}</span> <span *ngIf=\"!isReadOnly && (item && item.isDeletable)\" class=\"ux-autocomplete-tag__tags-item-close ux-icon ux-icon-times\" (click)=\"removeItem(item)\"></span> </div> </div> </div> <div *ngIf=\"!isReadOnly\"> <div class=\"ux-autocomplete-tag__input\"> <input #input class=\"form-control custom-select\" type=\"text\" [(ngModel)]=\"query\" placeholder=\"{{placeholder}}\" (keyup)=\"onInputKeyup($event)\" (click)=\"onInputClick($event)\" /> <!--<span class=\"ux-icon ux-icon-sort ux-autocomplete-tag__input-icon\" (click)=\"onToggle($event)\"></span>--> </div> <ux-control-feedback *ngIf=\"!isValid\" typeClass=\"danger\"> {{requiredItemsCountValidationMessage}} </ux-control-feedback> </div> <div #dropdown class=\"ux-autocomplete-tag__dropdown-list dropdown-menu\" [style.display]=\"filteredList.length > 0 ? 'block' : 'none'\" (mousedown)=\"onSuggestionsMouseDown($event)\"> <ux-list-item *ngFor=\"let item of filteredList; let idx = index; trackBy: trackByFn\" [isActive]=\"idx == selectedIdx\" typeClass=\"{{item.typeClass}}\" (click)=\"selectItem(item)\" label=\"{{item.label}}\" iconClass=\"{{item.iconClass}}\"> </ux-list-item> </div> <div class=\"ux-autocomplete-tag__tags ux-autocomplete-tag__tags-bottom mt-1\" *ngIf=\"isDisplayTagsListBelow && selectedItems.length !== 0\"> <div *ngFor=\"let item of selectedItems\" class=\"ux-autocomplete-tag__tags-item\"> <div class=\"mt-1 badge {{badgeSizeClass}} badge-primary badge-{{item.typeClass}}\"> <i *ngIf=\"item.iconClass\" class=\"mr-1 {{item.iconClass}}\"></i> <span>{{item.label}}</span> <span *ngIf=\"!isReadOnly && (item && item.isDeletable)\" class=\"ux-autocomplete-tag__tags-item-close ux-icon ux-icon-times\" (click)=\"removeItem(item)\"></span> </div> </div> </div> </div> </div> ",
                providers: [UX_AUTOCOMPLETETAG_VALUE_ACCESSOR]
            },] },
];
/** @nocollapse */
UxAutocompleteTagComponent.ctorParameters = () => [
    { type: UxService, },
    { type: Renderer2, },
    { type: PlacementService, },
];
UxAutocompleteTagComponent.propDecorators = {
    "isReadOnly": [{ type: Input },],
    "items": [{ type: Input },],
    "selectedItems": [{ type: Input },],
    "placeholder": [{ type: Input },],
    "isFreeTagsAllowed": [{ type: Input },],
    "maxRequiredItemsCount": [{ type: Input },],
    "minRequiredItemsCount": [{ type: Input },],
    "isBadgeSmall": [{ type: Input },],
    "formControlName": [{ type: Input },],
    "isDisplayTagsListBelow": [{ type: Input },],
    "selectionChanged": [{ type: Output },],
    "isSelectionValid": [{ type: Output },],
    "itemAdded": [{ type: Output },],
    "itemRemoved": [{ type: Output },],
    "inputEl": [{ type: ViewChild, args: ['input',] },],
    "dropdownEl": [{ type: ViewChild, args: ['dropdown',] },],
    "focusOut": [{ type: HostListener, args: ['focusout', ['$event'],] },],
};
class UxAutocompleteTagComponentModule {
}
UxAutocompleteTagComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, UxControlFeedbackComponentModule, UxListItemComponentModule],
                exports: [UxAutocompleteTagComponent],
                declarations: [UxAutocompleteTagComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxButtonGroupItemComponent {
    constructor() {
        this.isActive = false;
    }
}
UxButtonGroupItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-button-group-item',
                template: "<div></div> ",
            },] },
];
/** @nocollapse */
UxButtonGroupItemComponent.propDecorators = {
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "isActive": [{ type: Input },],
    "typeClass": [{ type: Input },],
};
class UxButtonGroupItemComponentModule {
}
UxButtonGroupItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxButtonGroupItemComponent],
                declarations: [UxButtonGroupItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxButtonGroupComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.typeClass = 'primary';
        this.isOutline = false;
        this.links = [];
        this.isCheckboxButtons = false;
        this.isRadioButtons = false;
        this.hasPairedIcon = false;
        this.isSmall = false;
        this.isLarge = false;
        this.clicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.items && this.links.length === 0) {
            this.links = [];
            this.items.forEach((item) => {
                this.links.push(new UxLink({
                    id: item.id,
                    label: item.label,
                    iconClass: item.iconClass,
                    active: item.isActive,
                    typeClass: item.typeClass
                }));
            });
        }
        this.btnSizeClass = '';
        if (this.isSmall) {
            this.btnSizeClass = 'btn-sm';
        }
        if (this.isLarge) {
            this.btnSizeClass = 'btn-lg';
        }
    }
    /**
     * @param {?} link
     * @param {?} event
     * @return {?}
     */
    onClick(link, event) {
        if (this.isCheckboxButtons) {
            this.links.forEach((currentLink) => {
                if (JSON.stringify(currentLink) === JSON.stringify(link)) {
                    currentLink.active = !currentLink.active;
                }
            });
        }
        else if (this.isRadioButtons) {
            this.links.forEach((currentLink) => {
                currentLink.active = false;
                if (JSON.stringify(currentLink) === JSON.stringify(link)) {
                    currentLink.active = !currentLink.active;
                }
            });
        }
        this.uxService.consumeEvent(event);
        this.clicked.emit(link);
    }
}
UxButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-button-group',
                template: "<div class=\"ux-button-group btn-group {{styleClass}} {{btnSizeClass}}\" data-toggle=\"buttons\"> <ng-template [ngIf]=\"isCheckboxButtons\"> <label *ngFor=\"let link of links\" (click)=\"onClick(link, $event)\" class=\"btn btn-{{isOutline ? 'outline-' : ''}}{{link.typeClass || typeClass}} {{btnSizeClass}}\" [class.active]=\"link.active\"> <input type=\"checkbox\" autocomplete=\"off\" [attr.checked]=\"link.active\"> {{link.label}} <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </label> </ng-template> <ng-template [ngIf]=\"isRadioButtons\"> <label *ngFor=\"let link of links\" (click)=\"onClick(link, $event)\" class=\"btn btn-{{isOutline ? 'outline-' : ''}}{{link.typeClass || typeClass}} {{btnSizeClass}}\" [class.active]=\"link.active\"> <input type=\"radio\" name=\"options\" id=\"option1\" autocomplete=\"off\" [attr.checked]=\"link.active\"> {{link.label}} <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </label> </ng-template> <ng-template [ngIf]=\"!isCheckboxButtons && !isRadioButtons\"> <ng-template [ngIf]=\"hasPairedIcon\"> <button type=\"button\" (click)=\"onClick(links[0], $event)\" class=\"btn ux-button btn-{{typeClass}} {{btnSizeClass}}\"> <span class=\"ux-button__content\">{{links[0].label}}</span> </button> <button type=\"button\" (click)=\"onClick(links[1], $event)\" class=\"btn ux-button btn-{{typeClass}}-dark {{btnSizeClass}}\"> <span class=\"{{links[1].iconClass}}\"></span> </button> </ng-template> <ng-template [ngIf]=\"!hasPairedIcon\"> <button type=\"button\" *ngFor=\"let link of links; let i = index\" (click)=\"onClick(link, $event)\" class=\"btn ux-button btn-{{typeClass}} {{btnSizeClass}} mr-2\"> <span class=\"ux-button__content\">{{link.label}}</span> <span *ngIf=\"link.iconClass\" class=\"{{link.iconClass}}\"></span> </button> </ng-template> </ng-template> </div> ",
            },] },
];
/** @nocollapse */
UxButtonGroupComponent.ctorParameters = () => [
    { type: UxService, },
];
UxButtonGroupComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "isOutline": [{ type: Input },],
    "links": [{ type: Input },],
    "isCheckboxButtons": [{ type: Input },],
    "isRadioButtons": [{ type: Input },],
    "hasPairedIcon": [{ type: Input },],
    "isSmall": [{ type: Input },],
    "isLarge": [{ type: Input },],
    "clicked": [{ type: Output },],
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxButtonGroupItemComponent),] },],
};
class UxButtonGroupComponentModule {
}
UxButtonGroupComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxButtonGroupComponent],
                declarations: [UxButtonGroupComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxSplitButtonComponent {
    constructor() {
        this.typeClass = 'secondary';
        this.isOutline = false;
        this.links = [];
        this.isDropDownRightAligned = false;
        this.linkSelected = new EventEmitter();
        this.buttonClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.btnTypeClass = 'btn-' + this.typeClass;
        if (this.isOutline) {
            this.btnTypeClass = 'btn-outline-' + this.typeClass;
        }
    }
    /**
     * @param {?} link
     * @return {?}
     */
    onLinkSelected(link) {
        this.linkSelected.emit(link);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onButtonClicked(event) {
        this.buttonClicked.emit(event);
    }
}
UxSplitButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-split-button',
                template: `
        <div class="btn-group">
            <button type="button" class="btn {{btnTypeClass}}" (click)="onButtonClicked($event)">{{label}}</button>
            <ux-dropdown-button [links]="links"
                                typeClass="{{typeClass}}" [isSplitButtonToggle]="true"
                                [isOutline]="isOutline"
                                (linkSelected)="onLinkSelected($event)"
                                [isDropDownRightAligned]="isDropDownRightAligned"
                                [hasItems]="items.length !== 0">
                <ng-content></ng-content>
            </ux-dropdown-button>
        </div>
    `
            },] },
];
/** @nocollapse */
UxSplitButtonComponent.ctorParameters = () => [];
UxSplitButtonComponent.propDecorators = {
    "typeClass": [{ type: Input },],
    "isOutline": [{ type: Input },],
    "label": [{ type: Input },],
    "links": [{ type: Input },],
    "isDropDownRightAligned": [{ type: Input },],
    "linkSelected": [{ type: Output },],
    "buttonClicked": [{ type: Output },],
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxDropdownButtonItemComponent),] },],
};
class UxSplitButtonComponentModule {
}
UxSplitButtonComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxDropdownButtonComponentModule, UxDropdownButtonItemComponentModule],
                exports: [UxSplitButtonComponent],
                declarations: [UxSplitButtonComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMessageBoxComponent {
    /**
     * @param {?} uxService
     */
    constructor(uxService) {
        this.uxService = uxService;
        this.id = 'messagebox_modal';
        this.typeClass = 'warning';
        this.messageBoxType = 'confirmation';
        this.isFooterCustomAlignment = false;
        this.clicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.acceptLabel) {
            this.acceptLabel = this.uxService.translate('YES');
        }
        if (!this.dismissLabel) {
            this.dismissLabel = this.uxService.translate('NO');
        }
        this.stateClasses = '';
        if (this.typeClass) {
            this.stateClasses += 'ux-message-box--' + this.typeClass + ' ';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onClick(value) {
        this.uxService.closeModal(this.id);
        this.clicked.emit(value);
    }
}
UxMessageBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-message-box',
                template: `
        <ux-modal id="{{id}}" titleLabel="{{titleLabel}}"
                  styleClass="ux-message-box {{stateClasses}} {{styleClass}}"
                  [isSizeSmall]="true" [isFooterCustomAlignment]="isFooterCustomAlignment"
                  [isCloseModalOnEscape]="false"
                  [isShowCloseButton]="false"
                  [isMessageBox]="true">
            <uxModalBody>
                <div class="ux-message-box__body">
                    <div class="ux-message-box__body-icon"></div>
                    <div class="ux-message-box__body-content">
                        <ng-content></ng-content>
                    </div>
                </div>
            </uxModalBody>
            <uxModalFooter>
                <ng-template [ngIf]="customFooterContent">
                    <ng-content select="uxMessageBoxFooter"></ng-content>
                </ng-template>
                <ng-template [ngIf]="!customFooterContent">
                    <ng-template [ngIf]="messageBoxType === 'confirmation'">
                        <button type="button" class="btn btn-secondary" (click)="onClick(false)">{{dismissLabel}}</button>
                        <button type="button" class="btn btn-primary" (click)="onClick(true)">{{acceptLabel}}</button>
                    </ng-template>
                    <ng-template [ngIf]="messageBoxType === 'ok'">
                        <button type="button" class="btn btn-secondary" (click)="onClick(true)">OK</button>
                    </ng-template>
                </ng-template>
            </uxModalFooter>
        </ux-modal>
  `
            },] },
];
/** @nocollapse */
UxMessageBoxComponent.ctorParameters = () => [
    { type: UxService, },
];
UxMessageBoxComponent.propDecorators = {
    "id": [{ type: Input },],
    "titleLabel": [{ type: Input },],
    "message": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "messageBoxType": [{ type: Input },],
    "acceptLabel": [{ type: Input },],
    "dismissLabel": [{ type: Input },],
    "isFooterCustomAlignment": [{ type: Input },],
    "clicked": [{ type: Output },],
    "customFooterContent": [{ type: ContentChild, args: [forwardRef(() => UxMessageBoxFooterTagDirective),] },],
};
class UxMessageBoxFooterTagDirective {
}
UxMessageBoxFooterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxMessageBoxFooter' },] },
];
class UxMessageBoxComponentModule {
}
UxMessageBoxComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxModalComponentModule],
                exports: [UxMessageBoxComponent, UxMessageBoxFooterTagDirective],
                declarations: [UxMessageBoxComponent, UxMessageBoxFooterTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxStickyComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.zIndex = 10;
        this.width = 'auto';
        this.offsetTop = 0;
        this.offsetBottom = 0;
        this.start = 0;
        this.stickClass = 'ux-sticky';
        this.endStickClass = 'ux-sticky-end';
        this.mediaQuery = '';
        this.parentMode = true;
        this.activated = new EventEmitter();
        this.deactivated = new EventEmitter();
        this.onScrollBind = this.onScroll.bind(this);
        this.onResizeBind = this.onResize.bind(this);
        this.isStuck = false;
        this.elem = element.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        window.addEventListener('scroll', this.onScrollBind);
        window.addEventListener('resize', this.onResizeBind);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // define scroll container as parent element
        this.container = this.elem.parentNode;
        this.originalCss = {
            zIndex: this.getCssValue(this.elem, 'zIndex'),
            position: this.getCssValue(this.elem, 'position'),
            top: this.getCssValue(this.elem, 'top'),
            right: this.getCssValue(this.elem, 'right'),
            left: this.getCssValue(this.elem, 'left'),
            bottom: this.getCssValue(this.elem, 'bottom'),
            width: this.getCssValue(this.elem, 'width'),
        };
        if (this.width === 'auto') {
            this.width = this.originalCss.width;
        }
        this.defineDimensions();
        this.sticker();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        window.removeEventListener('scroll', this.onScrollBind);
        window.removeEventListener('resize', this.onResizeBind);
    }
    /**
     * @return {?}
     */
    onScroll() {
        this.defineDimensions();
        this.sticker();
    }
    /**
     * @return {?}
     */
    onResize() {
        this.defineDimensions();
        this.sticker();
        if (this.isStuck) {
            this.unstuckElement();
            this.stuckElement();
        }
    }
    /**
     * @return {?}
     */
    defineDimensions() {
        let /** @type {?} */ containerTop = this.getBoundingClientRectValue(this.container, 'top');
        this.windowHeight = window.innerHeight;
        this.elemHeight = this.getCssNumber(this.elem, 'height');
        this.containerHeight = this.getCssNumber(this.container, 'height');
        this.containerStart = containerTop + this.scrollbarYPos() - this.offsetTop + this.start;
        if (this.parentMode) {
            this.scrollFinish = this.containerStart - this.start - this.offsetBottom + (this.containerHeight - this.elemHeight);
        }
        else {
            this.scrollFinish = document.body.offsetHeight;
        }
    }
    /**
     * @return {?}
     */
    resetElement() {
        this.elem.classList.remove(this.stickClass);
        Object.assign(this.elem.style, this.originalCss);
    }
    /**
     * @return {?}
     */
    stuckElement() {
        this.isStuck = true;
        this.elem.classList.remove(this.endStickClass);
        this.elem.classList.add(this.stickClass);
        let /** @type {?} */ elementLeft = this.getBoundingClientRectValue(this.elem, 'left');
        this.elem.style.zIndex = this.zIndex;
        this.elem.style.position = 'fixed';
        this.elem.style.top = this.offsetTop + 'px';
        this.elem.style.right = 'auto';
        this.elem.style.left = elementLeft + 'px';
        this.elem.style.bottom = 'auto';
        this.elem.style.width = this.width;
        this.activated.next(this.elem);
    }
    /**
     * @return {?}
     */
    unstuckElement() {
        this.isStuck = false;
        this.elem.classList.add(this.endStickClass);
        this.container.style.position = 'relative';
        this.elem.style.position = 'absolute';
        this.elem.style.top = 'auto';
        this.elem.style.right = 0;
        this.elem.style.left = 'auto';
        this.elem.style.bottom = this.offsetBottom + 'px';
        this.elem.style.width = this.width;
        this.deactivated.next(this.elem);
    }
    /**
     * @return {?}
     */
    matchMediaQuery() {
        if (!this.mediaQuery) {
            return true;
        }
        return (window.matchMedia('(' + this.mediaQuery + ')').matches ||
            window.matchMedia(this.mediaQuery).matches);
    }
    /**
     * @return {?}
     */
    sticker() {
        // check media query
        if (this.isStuck && !this.matchMediaQuery()) {
            this.resetElement();
            return;
        }
        // detecting when a container's height changes
        let /** @type {?} */ currentContainerHeight = this.getCssNumber(this.container, 'height');
        if (currentContainerHeight !== this.containerHeight) {
            this.defineDimensions();
        }
        let /** @type {?} */ position = this.scrollbarYPos();
        // unstick
        if (this.isStuck && (position < this.containerStart || position > this.scrollFinish) || position > this.scrollFinish) {
            this.resetElement();
            if (position > this.scrollFinish) {
                this.unstuckElement();
            }
            this.isStuck = false;
            // stick
        }
        else if (this.isStuck === false && position > this.containerStart && position < this.scrollFinish) {
            this.stuckElement();
        }
    }
    /**
     * @return {?}
     */
    scrollbarYPos() {
        return window.pageYOffset || document.documentElement.scrollTop;
    }
    /**
     * @param {?} element
     * @param {?} property
     * @return {?}
     */
    getBoundingClientRectValue(element, property) {
        let /** @type {?} */ result = 0;
        if (element.getBoundingClientRect) {
            let /** @type {?} */ rect = element.getBoundingClientRect();
            result = (typeof rect[property] !== 'undefined') ? rect[property] : 0;
        }
        return result;
    }
    /**
     * @param {?} element
     * @param {?} property
     * @return {?}
     */
    getCssValue(element, property) {
        let /** @type {?} */ result = '';
        if (typeof window.getComputedStyle !== 'undefined') {
            result = window.getComputedStyle(element, null).getPropertyValue(property);
        }
        else if (typeof element.currentStyle !== 'undefined') {
            result = element.currentStyle[property];
        }
        return result;
    }
    /**
     * @param {?} element
     * @param {?} property
     * @return {?}
     */
    getCssNumber(element, property) {
        return parseInt(this.getCssValue(element, property), 10) || 0;
    }
}
UxStickyComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-sticky',
                template: '<ng-content></ng-content>'
            },] },
];
/** @nocollapse */
UxStickyComponent.ctorParameters = () => [
    { type: ElementRef, },
];
UxStickyComponent.propDecorators = {
    "zIndex": [{ type: Input },],
    "width": [{ type: Input },],
    "offsetTop": [{ type: Input },],
    "offsetBottom": [{ type: Input },],
    "start": [{ type: Input },],
    "stickClass": [{ type: Input },],
    "endStickClass": [{ type: Input },],
    "mediaQuery": [{ type: Input },],
    "parentMode": [{ type: Input },],
    "activated": [{ type: Output },],
    "deactivated": [{ type: Output },],
};
class UxStickyComponentModule {
}
UxStickyComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxStickyComponent],
                declarations: [UxStickyComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPieChartLegendItemComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
UxPieChartLegendItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-pie-chart-legend-item',
                template: "<li class=\"chart-legend-item {{styleClass}}\"> <span class=\"chart-legend-item-marker ux-icon ux-icon-fw ux-icon-circle\" [style.color]=\"markerColor\"></span> <span class=\"chart-legend-item-label\">{{ label }}</span> <span class=\"chart-legend-item-counter pr-2\"> <span>{{ value }}</span> </span> <span class=\"chart-legend-item-label\"> <ng-content></ng-content> </span> </li> ",
            },] },
];
/** @nocollapse */
UxPieChartLegendItemComponent.ctorParameters = () => [];
UxPieChartLegendItemComponent.propDecorators = {
    "styleClass": [{ type: Input },],
    "markerColor": [{ type: Input },],
    "label": [{ type: Input },],
    "value": [{ type: Input },],
};
class UxPieChartLegendItemComponentModule {
}
UxPieChartLegendItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxButtonComponentModule],
                exports: [UxPieChartLegendItemComponent],
                declarations: [UxPieChartLegendItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DEFAULT_OPTIONS = {
    animation: {
        animateRotate: false,
    },
    legend: {
        display: false,
    },
    tooltips: { enabled: false },
};
const /** @type {?} */ innerDougnutData = (data, labels) => {
    if (data.length === 0) {
        return;
    }
    const /** @type {?} */ totalAmount = data[0].amount;
    if (totalAmount === 0) {
        return;
    }
    const /** @type {?} */ innerData = data.reduce((acc, item, index) => {
        if (index > 0) {
            acc.data.push(Math.max(0, Math.round(item.amount / totalAmount * 100)));
            acc.backgroundColor.push(item.color);
        }
        return acc;
    }, { data: [], backgroundColor: [] });
    // Add white "space" left
    const /** @type {?} */ pctLeft = 100 - innerData.data.reduce((acc, pct) => acc + pct, 0);
    innerData.data.push(pctLeft);
    innerData.backgroundColor.push('white');
    const /** @type {?} */ innerLabels = data.reduce((acc, item, index) => {
        if (index > 0) {
            acc.labels.push(item.label);
        }
        return acc;
    }, { labels: [] });
    return { datasets: [innerData], labels: innerLabels.labels };
};
const /** @type {?} */ pieData = (data, labels) => {
    if (data.length === 0) {
        return;
    }
    const /** @type {?} */ pieDataset = data.reduce((acc, item, index) => {
        acc.data.push(item.amount);
        acc.backgroundColor.push(item.color);
        return acc;
    }, { data: [], backgroundColor: [] });
    if (!labels) {
        labels = [];
    }
    return { datasets: [pieDataset], labels: labels };
};
class UxPieChartComponent {
    constructor() {
        this.data = [];
        this.chartType = 'doughnut';
        this.isShowLabel = true;
        this.isDoughnutRenderZeroAmount = true;
        this.isDoughnutRenderAmountAsCurrency = true;
        this.emptyLabel = 'N/A';
        this.isDoughnutRendered = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initChart();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ngOnChanges(value) {
        this.initChart();
    }
    /**
     * @return {?}
     */
    initChart() {
        this.pieOptions = this.options ? Object.assign({}, DEFAULT_OPTIONS, this.options) : Object.assign({}, DEFAULT_OPTIONS);
        this.innerData = innerDougnutData(this.data.values, this.data.labels);
        this.pieData = pieData(this.data.values, this.data.labels);
        if (this.chartType === 'doughnut') {
            if (!this.isDoughnutRenderZeroAmount) {
                if (this.data.values[0].amount === 0) {
                    this.isDoughnutRendered = false;
                }
                else {
                    this.isDoughnutRendered = true;
                }
            }
            this.pieOptions.cutoutPercentage = 75;
        }
    }
}
UxPieChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-pie-chart',
                template: "<div class=\"chart-title\" *ngIf=\"chartTitle\"> {{chartTitle}} </div> <div class=\"chart-container\"> <ng-container *ngIf=\"chartType === 'doughnut'\"> <!--Outer doughnut--> <div *ngIf=\"isDoughnutRendered\"> <p-chart type=\"doughnut\" [data]=\"{ labels: [data.values[0].label], datasets: [{data: [100], backgroundColor: [data.values[0].color || 'blue']}]}\" [options]=\"pieOptions\"></p-chart> </div> <div *ngIf=\"!isDoughnutRendered\"> <p-chart type=\"doughnut\" [data]=\"{ labels: [data.values[0].label], datasets: [{data: [0], backgroundColor: [data.values[0].color || 'transparent']}]}\" [options]=\"pieOptions\"></p-chart> </div> <!--Inner doughnut--> <div class=\"inner-chart\" *ngIf=\"innerData\"> <p-chart type=\"doughnut\" [data]=\"innerData\" [options]=\"pieOptions\"></p-chart> </div> </ng-container> <ng-container *ngIf=\"chartType === 'pie'\"> <div> <p-chart type=\"pie\" [data]=\"pieData\" [options]=\"pieOptions\"></p-chart> </div> </ng-container> <!--Label center--> <div class=\"chart-inner-labels small\" *ngIf=\"isShowLabel\"> <span *ngIf=\"isDoughnutRendered\" class=\"amount\"> <span *ngIf=\"isDoughnutRenderAmountAsCurrency\">{{ data.values[0].amount | uxCurrency: 0 }}</span> <span *ngIf=\"!isDoughnutRenderAmountAsCurrency\">{{ data.values[0].amount }}</span> </span> <span *ngIf=\"!isDoughnutRendered\" class=\"amount\">{{emptyLabel}}</span> </div> </div> <ul class=\"chart-legend chart-legend-custom\" *ngIf=\"customFooterContent\"> <ng-content select=\"uxPieChartCustomLegend\"></ng-content> </ul> <!--Legend--> <ul class=\"chart-legend\" *ngIf=\"!customFooterContent\"> <li class=\"chart-legend-item\" *ngFor=\"let item of data.values\"> <span class=\"chart-legend-item-marker ux-icon ux-icon-fw ux-icon-circle\" [style.color]=\"item.color\"></span> <span class=\"chart-legend-item-label\">{{item.label}}</span> <span class=\"chart-legend-item-counter\" *ngIf=\"chartType === 'doughnut'\"> <span *ngIf=\"isDoughnutRenderAmountAsCurrency\">{{ item.amount | uxCurrency: 0 }}</span> <span *ngIf=\"!isDoughnutRenderAmountAsCurrency\">{{ item.amount }}</span> </span> <span class=\"chart-legend-item-counter\" *ngIf=\"chartType === 'pie'\">{{item.amount}}</span> </li> </ul> ",
            },] },
];
/** @nocollapse */
UxPieChartComponent.ctorParameters = () => [];
UxPieChartComponent.propDecorators = {
    "data": [{ type: Input },],
    "options": [{ type: Input },],
    "chartTitle": [{ type: Input },],
    "chartType": [{ type: Input },],
    "isShowLabel": [{ type: Input },],
    "isDoughnutRenderZeroAmount": [{ type: Input },],
    "isDoughnutRenderAmountAsCurrency": [{ type: Input },],
    "emptyLabel": [{ type: Input },],
    "customFooterContent": [{ type: ContentChild, args: [forwardRef(() => UxPieChartCustomLegendTagDirective),] },],
};
class UxPieChartCustomLegendTagDirective {
}
UxPieChartCustomLegendTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxPieChartCustomLegend' },] },
];
class UxPieChartComponentModule {
}
UxPieChartComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ChartModule, UxCurrencyPipeModule, UxPieChartLegendItemComponentModule],
                exports: [UxPieChartComponent, UxPieChartCustomLegendTagDirective],
                declarations: [UxPieChartComponent, UxPieChartCustomLegendTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPieChartGroupComponent {
    /**
     * @param {?} asService
     */
    constructor(asService) {
        this.asService = asService;
        this.itemsArray = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.itemsArray = this.items.toArray();
    }
}
UxPieChartGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-pie-chart-group',
                template: `
        <ng-template [ngIf]="!(asService.breakpoints$ | async).isMobile">
            <div class="row">
                <div *ngFor="let item of itemsArray" class="col-{{12 / itemsArray.length}}">
                   <ux-pie-chart chartTitle="{{item.chartTitle}}"
                                 [data]="item.data"
                                 [isShowLabel]="item.isShowLabel"
                                 chartType="{{item.chartType}}">
                   </ux-pie-chart>
                </div>
            </div>
        </ng-template>

        <ng-container *ngIf="(asService.breakpoints$ | async).isMobile">
            <ux-carousel-items>
                <ux-carousel-item *ngFor="let item of itemsArray">
                    <ux-pie-chart chartTitle="{{item.chartTitle}}"
                                    [data]="item.data"
                                    [isShowLabel]="item.isShowLabel"
                                    chartType="{{item.chartType}}">
                    </ux-pie-chart>
                </ux-carousel-item>
            </ux-carousel-items>
        </ng-container>
    `
            },] },
];
/** @nocollapse */
UxPieChartGroupComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxPieChartGroupComponent.propDecorators = {
    "items": [{ type: ContentChildren, args: [forwardRef(() => UxPieChartComponent),] },],
};
class UxPieChartGroupComponentModule {
}
UxPieChartGroupComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxPieChartComponentModule,
                    UxCarouselItemComponentModule, UxCarouselItemsComponentModule
                ],
                exports: [UxPieChartGroupComponent],
                declarations: [UxPieChartGroupComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicModalConfig {
    /**
     * @param {?} values
     */
    constructor(values) {
        this.id = 'single_modal';
        this.dismissLabel = 'Cancel';
        this.dismissDisabled = false;
        this.acceptLabel = 'OK';
        this.acceptActionDisabled = false;
        this.dismissActionDisabled = false;
        this.isFooterVisible = true;
        this.isKeepBodyScroll = false;
        this.isSizeSmall = false;
        this.isSizeLarge = false;
        this.isSizeFullScreen = false;
        this.isSizeFullHeight = false;
        this.isSizeMediumHeight = false;
        this.isShowActionIcons = false;
        this.messageBoxType = '';
        this.acceptIconClass = 'ux-icon ux-icon-check';
        this.dismissIconClass = 'ux-icon ux-icon-close';
        this.hasNoBodyPadding = false;
        this.isFooterCustomAlignment = false;
        this.isCloseModalOnEscape = true;
        this.isShowCloseButton = true;
        this.isMessageBox = false;
        this.isHandleCloseOnDismiss = true;
        this.isHandleCloseOnAccept = true;
        this.isHandleCloseOnClose = true;
        this.isOverflowVisible = false;
        this.content = '';
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicModalComponent {
    /**
     * @param {?} uxService
     * @param {?} uxDynamicComponentConfig
     * @param {?} uxDynamicComponentService
     */
    constructor(uxService, uxDynamicComponentConfig, uxDynamicComponentService) {
        this.uxService = uxService;
        this.uxDynamicComponentService = uxDynamicComponentService;
        this.stateClasses = '';
        this.config = uxDynamicComponentConfig;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.config.isSizeSmall) {
            this.stateClasses = 'ux-modal--small';
        }
        if (this.config.isSizeLarge) {
            this.stateClasses = 'ux-modal--large';
        }
        if (this.config.isSizeFullScreen) {
            this.stateClasses = 'ux-modal--full-screen';
        }
        if (this.config.bodyInjectedComponent && this.config.bodyInjectedComponent.component) {
            setTimeout(() => {
                const /** @type {?} */ injectedComponentConfig = Object.assign(this.config.bodyInjectedComponent.config, { parent: {
                        portalHostRef: this.config['portalHostRef'],
                        portalRef: this.config['portalRef'],
                        portalComponentInstanceRef: this.config['portalComponentInstanceRef'],
                    } });
                const /** @type {?} */ injectedComponent = this.uxDynamicComponentService.add(this.config.bodyInjectedComponent.component, this.uxModalBody, this.config.bodyInjectedComponent.config);
                if (injectedComponent) {
                    Object.assign(this.config, { child: {
                            portalHostRef: injectedComponent['portalHost'],
                            portalRef: injectedComponent['portal'],
                            portalComponentInstanceRef: injectedComponent['portalComponentInstance'],
                        } });
                }
            }, 0);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.vcCloseButton) {
            this.vcCloseButton.nativeElement.focus();
        }
    }
    /**
     * Close modal function
     * @param {?} event
     * @return {?}
     */
    close(event) {
        if (this.config.isHandleCloseOnClose) {
            // This function is defined as closeDynamicModal in ux-dynamic-modal.service if the component user didn't define it
            this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
        }
    }
    /**
     * Close modal on escape(key 27) press
     * @param {?} event
     * @return {?}
     */
    closeModalOnEscape(event) {
        if (this.config.isCloseModalOnEscape) {
            if (event.keyCode === 27) {
                this.close(event);
            }
        }
    }
    /**
     * Trigger by the message-box when user click on OK button
     * @param {?} event
     * @return {?}
     */
    onAcceptActionClick(event) {
        if (this.config.isHandleCloseOnAccept) {
            this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
        }
        if (this.config.onAccept) {
            this.config.onAccept(this.config['portalHostRef'], this.config['portalRef']);
        }
        if (this.config.onClick) {
            this.config.onClick(true);
        }
    }
    /**
     * Trigger by the message-box when user click on NO button
     * @param {?} event
     * @return {?}
     */
    onDismissActionClick(event) {
        if (this.config.isHandleCloseOnDismiss) {
            this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
        }
        if (this.config.onDismiss) {
            this.config.onDismiss(this.config['portalHostRef'], this.config['portalRef']);
        }
        if (this.config.onClick) {
            this.config.onClick(false);
        }
    }
    /**
     * Trigger by the message-box when user click on a custom buttons defined in the config
     * @param {?} button
     * @return {?}
     */
    customFooterButtonClick(button) {
        button.onClick(this.config['portalHostRef'], this.config['portalRef'], this.config['portalComponentInstanceRef']);
    }
    /**
     * Trigger by the message-box when user click on NO or OK buttons
     * @param {?} value
     * @return {?}
     */
    onClick(value) {
        if (this.config.onClick) {
            this.config.onClick(value);
        }
        if (this.config.onClose) {
            this.config.onClose(this.config['portalHostRef'], this.config['portalRef']);
        }
    }
}
UxDynamicModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dynamic-modal',
                template: "<div id=\"{{config.id}}\" cdkTrapFocus #modal class=\"modal fx ux-modal {{config.styleClass}} {{stateClasses}}\" tabindex=\"-1\" role=\"dialog\" [class.slideInDown]=\"!config.isMessageBox\" [class.flipInY]=\"config.isMessageBox\" [class.ux-modal--full-height]=\"config.isSizeFullHeight\" [class.ux-modal--medium-height]=\"config.isSizeMediumHeight\" (keydown)=\"closeModalOnEscape($event)\" tabIndex=\"-1\" [style.display]=\"'block'\"> <div class=\"modal-dialog ux-modal__dialog\" role=\"document\" [style.max-width]=\"config.customWidth\"> <div class=\"modal-content ux-modal__content\" [class.ux-u-overflow-visible]=\"config.isOverflowVisible\"> <div class=\"modal-header ux-modal__header\"> <ng-template [ngIf]=\"customHeaderContent\"> <ng-content select=\"uxModalHeader\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customHeaderContent\"> <h5 class=\"modal-title ux-modal__header-title\">{{config.titleLabel}}</h5> </ng-template> <button #closeButton type=\"button\" class=\"ux-modal__header-close close\" data-dismiss=\"modal\" aria-label=\"Close\" (click)=\"close($event)\" *ngIf=\"config.isShowCloseButton\"> <span>&times;</span> </button> </div> <div #uxmodalbody class=\"modal-body ux-modal__body {{config.bodyStyleClass}}\" [class.p-0]=\"config.hasNoBodyPadding\" [class.ux-u-overflow-visible]=\"config.isOverflowVisible\"> <span [outerHTML]=\"config.content\" *ngIf=\"!config.isMessageBox\"></span> <div class=\"ux-message-box__body\" *ngIf=\"config.isMessageBox\"> <div class=\"ux-message-box__body-icon\"></div> <div class=\"ux-message-box__body-content\"> <span [outerHTML]=\"config.content\"></span> </div> </div> </div> <div *ngIf=\"config.isFooterVisible\" class=\"modal-footer ux-modal__footer {{config.footerStyleClass}}\" [class.ux-modal__footer--custom-alignment]=\"config.customFooterContent\"> <!-- MODAL CUSTOM FOOTER --> <uxDynamicModalFooter *ngIf=\"config.customFooterContent && !config.isMessageBox\"> <ux-layout-horizontal> <uxLayoutHorizontalLeft *ngIf=\"config.customFooterContent.left\"> <ux-button *ngFor=\"let button of config.customFooterContent.left.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalLeft> <uxLayoutHorizontalRight *ngIf=\"config.customFooterContent.right\"> <ux-button *ngFor=\"let button of config.customFooterContent.right.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalRight> </ux-layout-horizontal> </uxDynamicModalFooter> <!-- /MODAL CUSTOM FOOTER --> <!-- MESSAGE-BOX CUSTOM FOOTER --> <uxDynamicMessageBoxFooter *ngIf=\"config.customFooterContent && config.isMessageBox\"> <ux-layout-horizontal> <uxLayoutHorizontalLeft *ngIf=\"config.customFooterContent.left\"> <ux-button *ngFor=\"let button of config.customFooterContent.left.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalLeft> <uxLayoutHorizontalRight *ngIf=\"config.customFooterContent.right\"> <ux-button *ngFor=\"let button of config.customFooterContent.right.buttons\" type=\"{{ button.type }}\" styleClass=\"{{ button.styleClass }}\" typeClass=\"{{ button.typeClass }}\" iconClass=\"{{ button.iconClass }}\" [isOutline]=\"button.isOutline\" [isSecondary]=\"button.isSecondary\" [isSmall]=\"button.isSmall\" [isLarge]=\"button.isLarge\" [isBlock]=\"button.isBlock\" [isFlat]=\"button.isFlat\" [isDisabled]=\"button.isDisabled\" (click)=\"customFooterButtonClick(button)\">{{ button.label }}</ux-button> </uxLayoutHorizontalRight> </ux-layout-horizontal> </uxDynamicMessageBoxFooter> <!-- /MESSAGE-BOX CUSTOM FOOTER --> <ng-template [ngIf]=\"!config.customFooterContent\"> <ng-template [ngIf]=\"!config.isMessageBox\"> <button type=\"button\" class=\"btn btn-secondary\" [disabled]=\"config.dismissActionDisabled\" (click)=\"onDismissActionClick($event)\"> <i *ngIf=\"config.isShowActionIcons\" class=\"ux-modal__action-icon-element {{config.dismissIconClass}}\"></i> {{config.dismissLabel}} </button> <button type=\"button\" class=\"btn btn-primary\" [disabled]=\"config.acceptActionDisabled\" (click)=\"onAcceptActionClick($event)\"> <i *ngIf=\"config.isShowActionIcons\" class=\"ux-modal__action-icon-element {{config.acceptIconClass}}\"></i> {{config.acceptLabel}} </button> </ng-template> <ng-template [ngIf]=\"config.isMessageBox\"> <ng-template [ngIf]=\"config.messageBoxType && config.messageBoxType === 'confirmation'\"> <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(false)\">{{config.dismissLabel}}</button> <button type=\"button\" class=\"btn btn-primary\" (click)=\"onClick(true)\">{{config.acceptLabel}}</button> </ng-template> <ng-template [ngIf]=\"config.messageBoxType && config.messageBoxType === 'ok'\"> <button type=\"button\" class=\"btn btn-secondary\" (click)=\"onClick(true)\">OK</button> </ng-template> </ng-template> </ng-template> </div> </div> </div> </div> <div class=\"modal-backdrop fade in show\" [style.display]=\"'block'\" (focus)=\"close($event)\"></div> "
            },] },
];
/** @nocollapse */
UxDynamicModalComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxDynamicModalConfig, decorators: [{ type: Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
    { type: UxDynamicComponentService, },
];
UxDynamicModalComponent.propDecorators = {
    "customFooterContent": [{ type: ContentChild, args: [forwardRef(() => UxDynamicModalFooterTagDirective),] },],
    "customHeaderContent": [{ type: ContentChild, args: [forwardRef(() => UxDynamicModalHeaderTagDirective),] },],
    "customMessageBoxFooterContent": [{ type: ContentChild, args: [forwardRef(() => UxDynamicMessageBoxFooterTagDirective),] },],
    "uxModalBody": [{ type: ViewChild, args: ['uxmodalbody',] },],
    "vcCloseButton": [{ type: ViewChild, args: ['closeButton',] },],
};
class UxDynamicModalBodyTagDirective {
}
UxDynamicModalBodyTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxDynamicModalBody' },] },
];
class UxDynamicModalFooterTagDirective {
}
UxDynamicModalFooterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxDynamicModalFooter' },] },
];
class UxDynamicModalHeaderTagDirective {
}
UxDynamicModalHeaderTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxDynamicModalHeader' },] },
];
class UxDynamicMessageBoxFooterTagDirective {
}
UxDynamicMessageBoxFooterTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxDynamicMessageBoxFooter' },] },
];
class UxDynamicModalComponentModule {
}
UxDynamicModalComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxButtonComponentModule,
                    UxLayoutHorizontalModule,
                    A11yModule
                ],
                exports: [
                    UxDynamicModalComponent,
                    UxDynamicModalBodyTagDirective,
                    UxDynamicModalFooterTagDirective,
                    UxDynamicModalHeaderTagDirective,
                    UxDynamicMessageBoxFooterTagDirective,
                ],
                declarations: [
                    UxDynamicModalComponent,
                    UxDynamicModalBodyTagDirective,
                    UxDynamicModalFooterTagDirective,
                    UxDynamicModalHeaderTagDirective,
                    UxDynamicMessageBoxFooterTagDirective,
                ],
                entryComponents: [
                    UxDynamicModalComponent,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicMessageBoxConfig {
    /**
     * @param {?} values
     */
    constructor(values) {
        this.id = 'messagebox_modal';
        this.typeClass = 'warning';
        this.messageBoxType = 'confirmation';
        this.isFooterCustomAlignment = false;
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicMessageBoxComponent {
    /**
     * @param {?} uxService
     * @param {?} uxDynamicComponentConfig
     * @param {?} uxDynamicComponentService
     */
    constructor(uxService, uxDynamicComponentConfig, uxDynamicComponentService) {
        this.uxService = uxService;
        this.uxDynamicComponentService = uxDynamicComponentService;
        this.stateClasses = '';
        this.config = uxDynamicComponentConfig;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.config.acceptLabel) {
            this.config.acceptLabel = this.uxService.translate('YES');
        }
        if (!this.config.dismissLabel) {
            this.config.dismissLabel = this.uxService.translate('NO');
        }
        if (this.config.typeClass) {
            this.stateClasses += 'ux-message-box--' + this.config.typeClass + ' ';
        }
        setTimeout(() => {
            this.config = Object.assign({}, this.config, {
                isMessageBox: true,
                isShowCloseButton: false,
                isCloseModalOnEscape: false,
                isSizeSmall: true,
                styleClass: 'ux-message-box ' + this.stateClasses + ' ' + this.config.styleClass,
            });
            const /** @type {?} */ modalConfig = new UxDynamicModalConfig(this.config);
            this.uxDynamicComponentService.add(UxDynamicModalComponent, this.uxMessageBoxBody, modalConfig);
        }, 0);
    }
}
UxDynamicMessageBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dynamic-message-box',
                template: '<div #uxmessageboxbody id="{{config.id}}"></div>',
            },] },
];
/** @nocollapse */
UxDynamicMessageBoxComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxDynamicMessageBoxConfig, decorators: [{ type: Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
    { type: UxDynamicComponentService, },
];
UxDynamicMessageBoxComponent.propDecorators = {
    "uxMessageBoxBody": [{ type: ViewChild, args: ['uxmessageboxbody',] },],
};
class UxDynamicMessageBoxComponentModule {
}
UxDynamicMessageBoxComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                exports: [
                    UxDynamicMessageBoxComponent,
                ],
                declarations: [
                    UxDynamicMessageBoxComponent,
                ],
                entryComponents: [
                    UxDynamicMessageBoxComponent,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicModalService {
    /**
     * Constructor
     * @param {?} uxDynamicComponentService
     */
    constructor(uxDynamicComponentService) {
        this.uxDynamicComponentService = uxDynamicComponentService;
    }
    /**
     * Open a modal dynamically (Add it to the DOM)
     * @param {?} config
     * @return {?}
     */
    openModal(config) {
        let /** @type {?} */ component;
        document.body.classList.add('modal-open');
        if (config instanceof UxDynamicModalConfig) {
            if (!(/** @type {?} */ (config)).onClose) {
                (/** @type {?} */ (config)).onClose = this.closeModal.bind(this);
            }
            component = UxDynamicModalComponent;
        }
        else {
            component = UxDynamicMessageBoxComponent;
        }
        return this.uxDynamicComponentService.add(component, null, config);
    }
    /**
     * Close a modal created dynamically (Remove it from the DOM)
     * @param {?} portalHostRef
     * @param {?} portalRef
     * @return {?}
     */
    closeModal(portalHostRef, portalRef) {
        document.body.classList.remove('modal-open');
        this.uxDynamicComponentService.remove(portalHostRef, portalRef);
    }
}
UxDynamicModalService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicModalService.ctorParameters = () => [
    { type: UxDynamicComponentService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicMessageBoxService {
    /**
     * @param {?} uxDynamicModalService
     */
    constructor(uxDynamicModalService) {
        this.uxDynamicModalService = uxDynamicModalService;
    }
    /**
     * Open a message-box dynamically (Add it to the DOM)
     * @param {?} config
     * @return {?}
     */
    openMessageBox(config) {
        if (!(/** @type {?} */ (config)).onClose) {
            (/** @type {?} */ (config)).onClose = this.closeMessageBox.bind(this);
        }
        const { portalHost, portal } = this.uxDynamicModalService.openModal(config);
        this.portalHost = portalHost;
        this.portal = portal;
    }
    /**
     * Close a message-box created dynamically (Remove it from the DOM)
     * @return {?}
     */
    closeMessageBox() {
        this.uxDynamicModalService.closeModal(this.portalHost, this.portal);
    }
}
UxDynamicMessageBoxService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicMessageBoxService.ctorParameters = () => [
    { type: UxDynamicModalService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMenuItemConfig extends UxItemConfig {
    constructor() {
        super(...arguments);
        this.hasBorder = false;
    }
}
UxMenuItemConfig.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMenuItemComponent extends UxItemComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        super(config);
        this.customContent = false;
        this.customSubLabel = false;
    }
}
UxMenuItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-menu-item',
                template: "<div class=\"ux-list-item-wrapper\" [class.ux-list-item-wrapper--hovered]=\"isHovered && !isExpanded\" (click)=\"onClick()\" (mouseenter)=\"onMouseenter()\" (mouseleave)=\"onMouseleave()\"> <div *ngIf=\"isHovered && !isExpanded\" class=\"ux-list-item-hover-content\" [class.ux-list-item-hover-content--left-positioned]=\"isLeftPositioned\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\"></ux-a-label> </div> <div class=\"ux-list-item ux-list-item--{{typeClass}} {{styleClass}}\" [class.ux-list-item--small]=\"isSmall\" [class.ux-list-item--large]=\"isLarge\" [class.ux-list-item--hovered]=\"isHovered && !isExpanded\" [class.ux-list-item--not-hoverable]=\"!isHoverable\" [class.ux-list-item--bordered]=\"hasBorder\" [class.ux-list-item--collapsed]=\"!isExpanded\" [class.ux-list-item--active]=\"isActive\" [class.ux-list-item--seperator]=\"!label && !subLabel && !customContent\" [class.ux-list-item--disabled]=\"isDisabled\" tabindex=\"0\"> <ng-template [ngIf]=\"customContent\"> <ng-content select=\"uxListItemContent\"></ng-content> </ng-template> <ng-template [ngIf]=\"!customContent\"> <ux-a-label label=\"{{label}}\" subLabel=\"{{subLabel}}\" iconClass=\"{{iconClass}}\" [isIconRounded]=\"isIconRounded\" iconTypeClass=\"{{iconTypeClass}}\" [hasMarker]=\"hasMarker\" markerTypeClass=\"{{markerTypeClass}}\" [isDisabled]=\"isDisabled\"> <uxLabelSubLabel *ngIf=\"customSubLabel\"> <ng-content select=\"uxListItemSubLabel\"></ng-content> </uxLabelSubLabel> </ux-a-label> <div class=\"ux-list-item__right-content\"> <ux-a-tag label=\"{{tagLabel}}\" subLabel=\"{{tagCount}}\" typeClass=\"{{tagTypeClass}}\" [isRounded]=\"isTagRounded\"> </ux-a-tag> </div> </ng-template> </div> </div> "
            },] },
];
/** @nocollapse */
UxMenuItemComponent.ctorParameters = () => [
    { type: UxMenuItemConfig, },
];
class UxMenuItemComponentModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: UxItemComponentModule, providers: [UxMenuItemConfig] }; }
}
UxMenuItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxItemComponentModule],
                exports: [UxMenuItemComponent],
                declarations: [UxMenuItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxLoadingIndicatorComponent {
    constructor() {
        this.hidden = true;
    }
    /**
     * @return {?}
     */
    show() {
        this.hidden = false;
    }
    /**
     * @return {?}
     */
    hide() {
        this.hidden = true;
    }
    /**
     * @return {?}
     */
    isShown() {
        return !this.hidden;
    }
    /**
     * @return {?}
     */
    isHidden() {
        return this.hidden;
    }
}
UxLoadingIndicatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-loading-indicator',
                template: "<div class=\"ux-loading-indicator\" [hidden]=\"hidden\"><div></div><div></div><div></div></div>",
                styles: [".ux-loading-indicator{display:inline-block;vertical-align:middle}.ux-loading-indicator>div{animation:ux-loading-indicator-bouncedelay 1s infinite ease-in-out both;background-color:black;border-radius:100%;display:inline-block;height:.5rem;margin:.25rem;width:.5rem}.ux-loading-indicator>div:nth-child(1){animation-delay:-0.4s}.ux-loading-indicator>div:nth-child(2){animation-delay:-0.2s}@keyframes ux-loading-indicator-bouncedelay{0%,80%,100%{opacity:0;transform:scale(0) rotate(0.02deg)}40%{opacity:1;transform:scale(1) rotate(0.02deg)}} /*# sourceMappingURL=ux-loading-indicator.component.css.map */"],
            },] },
];
/** @nocollapse */
UxLoadingIndicatorComponent.propDecorators = {
    "hidden": [{ type: Input },],
};
class UxLoadingIndicatorComponentModule {
}
UxLoadingIndicatorComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxLoadingIndicatorComponent],
                declarations: [UxLoadingIndicatorComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LeftPlacementStrategy {
    /**
     * @return {?}
     */
    getId() {
        return 'left';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    calculate(options) {
        const /** @type {?} */ placedRect = options.element
            .clone()
            .moveTo(options.anchor.leftCenter(), options.element.rightCenter())
            .translateX(-options.offsetAlong)
            .translateY(options.offsetAcross);
        if (options.flip && placedRect.overflowsLeft(options.parent)) {
            placedRect.flipY(options.anchor.center().x);
        }
        if (options.constrainToParent) {
            placedRect.translateInside(options.parent);
        }
        return placedRect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TopPlacementStrategy {
    /**
     * @return {?}
     */
    getId() {
        return 'top';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    calculate(options) {
        const /** @type {?} */ placedRect = options.element
            .clone()
            .moveTo(options.anchor.centerTop(), options.element.centerBottom())
            .translateY(-options.offsetAlong)
            .translateX(options.offsetAcross);
        if (options.flip && placedRect.overflowsTop(options.parent)) {
            placedRect.flipX(options.anchor.center().y);
        }
        if (options.constrainToParent) {
            placedRect.translateInside(options.parent);
        }
        return placedRect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class BottomPlacementStrategy {
    /**
     * @return {?}
     */
    getId() {
        return 'bottom';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    calculate(options) {
        const /** @type {?} */ placedRect = options.element
            .clone()
            .moveTo(options.anchor.centerBottom(), options.element.centerTop())
            .translateY(options.offsetAlong)
            .translateX(options.offsetAcross);
        if (options.flip && placedRect.overflowsBottom(options.parent)) {
            placedRect.flipX(options.anchor.center().y);
        }
        if (options.constrainToParent) {
            placedRect.translateInside(options.parent);
        }
        return placedRect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RightPlacementStrategy {
    /**
     * @return {?}
     */
    getId() {
        return 'right';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    calculate(options) {
        const /** @type {?} */ placedRect = options.element
            .clone()
            .moveTo(options.anchor.rightCenter(), options.element.leftCenter())
            .translateX(options.offsetAlong)
            .translateY(options.offsetAcross);
        if (options.flip && placedRect.overflowsRight(options.parent)) {
            placedRect.flipY(options.anchor.center().x);
        }
        if (options.constrainToParent) {
            placedRect.translateInside(options.parent);
        }
        return placedRect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class BottomLeftPlacementStrategy {
    /**
     * @return {?}
     */
    getId() {
        return 'bottom left';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    calculate(options) {
        const /** @type {?} */ placedRect = options.element
            .clone()
            .moveTo(options.anchor.leftBottom(), options.element.leftTop())
            .translateY(options.offsetAlong)
            .translateX(options.offsetAcross);
        if (options.flip && placedRect.overflowsBottom(options.parent)) {
            placedRect.flipX(options.anchor.center().y);
        }
        if (options.constrainToParent) {
            placedRect.translateInside(options.parent);
        }
        return placedRect;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function placementServiceFactory() {
    return new PlacementService([
        new LeftPlacementStrategy(),
        new TopPlacementStrategy(),
        new BottomPlacementStrategy(),
        new RightPlacementStrategy(),
        new BottomLeftPlacementStrategy()
    ]);
}
class GeometryModule {
}
GeometryModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [],
                declarations: [],
                providers: [
                    { provide: PlacementService, useFactory: placementServiceFactory },
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ constants = {
    offset: 15,
    directionClass: {
        none: 'no-direction',
        left: 'left',
        top: 'top',
        right: 'right',
        bottom: 'bottom',
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Offset {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    static create(x, y) {
        return new Offset(x, y);
    }
    /**
     * @param {?} other
     * @return {?}
     */
    equals(other) {
        return this.x === other.x &&
            this.y === other.y;
    }
    /**
     * @return {?}
     */
    toString() {
        return `(${this.x}, ${this.y})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PopoverVM {
    /**
     * @param {?=} placementClassModifier
     * @param {?=} popoverPosition
     * @param {?=} arrowOffset
     */
    constructor(placementClassModifier = 'no-direction', popoverPosition = Point.create(0, 0), arrowOffset = Offset.create(0, 0)) {
        this.placementClassModifier = placementClassModifier;
        this.popoverPosition = popoverPosition;
        this.arrowOffset = arrowOffset;
    }
    /**
     * @param {?=} popoverDetails
     * @return {?}
     */
    static create(popoverDetails) {
        if (!popoverDetails) {
            return new PopoverVM();
        }
        return new PopoverVM(popoverDetails.placementClassModifier, popoverDetails.popoverPosition, popoverDetails.arrowOffset);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RightPlacementStrategy$1 {
    /**
     * @param {?} placementService
     */
    constructor(placementService) {
        this.placementService = placementService;
    }
    /**
     * @return {?}
     */
    getId() {
        return 'right';
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ positionedPopoverRect = this.placementService.place({
            anchor: placementOptions.anchorRect,
            element: placementOptions.popoverRect,
            placementId: this.getId(),
            offsetAlong: constants.offset
        });
        const /** @type {?} */ arrowOffset = getArrowOffset(placementOptions.anchorRect, positionedPopoverRect);
        const /** @type {?} */ placementClassModifier = getPlacementClassModifier(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
        const /** @type {?} */ popoverPosition = positionedPopoverRect.position();
        return PopoverVM.create({
            popoverPosition, arrowOffset, placementClassModifier
        });
    }
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function getArrowOffset(anchorRect, popoverRect) {
    const /** @type {?} */ offsetX = 0;
    const /** @type {?} */ offsetY = anchorRect.center().y - popoverRect.center().y;
    return Offset.create(offsetX, offsetY);
}
/**
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getMaxArrowOffset(popoverRect, arrowRect) {
    return (popoverRect.height - arrowRect.height) / 2;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function isArrowTooFar(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ arrowOffset = getArrowOffset(anchorRect, popoverRect);
    const /** @type {?} */ maxOffset = getMaxArrowOffset(popoverRect, arrowRect);
    const /** @type {?} */ isTooFar = Math.abs(arrowOffset.y) >= maxOffset;
    return isTooFar;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getPlacementClassModifier(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ isFlip = isFlipped(anchorRect, popoverRect);
    const /** @type {?} */ isTooFar = isArrowTooFar(anchorRect, popoverRect, arrowRect);
    if (isTooFar) {
        return constants.directionClass.none;
    }
    return isFlip ? constants.directionClass.left : constants.directionClass.right;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function isFlipped(anchorRect, popoverRect) {
    return popoverRect.isOnTheLeft(anchorRect.center());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LeftPlacementStrategy$1 extends RightPlacementStrategy$1 {
    /**
     * @return {?}
     */
    getId() {
        return 'left';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class BottomPlacementStrategy$1 {
    /**
     * @param {?} placementService
     */
    constructor(placementService) {
        this.placementService = placementService;
    }
    /**
     * @return {?}
     */
    getId() {
        return 'bottom';
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ positionedPopoverRect = this.placementService.place({
            anchor: placementOptions.anchorRect,
            element: placementOptions.popoverRect,
            placementId: this.getId(),
            offsetAlong: constants.offset
        });
        const /** @type {?} */ arrowOffset = getArrowOffset$1(placementOptions.anchorRect, positionedPopoverRect);
        const /** @type {?} */ placementClassModifier = getPlacementClassModifier$1(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
        const /** @type {?} */ popoverPosition = positionedPopoverRect.position();
        return PopoverVM.create({
            popoverPosition, arrowOffset, placementClassModifier
        });
    }
}
/**
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getMaxArrowOffset$1(popoverRect, arrowRect) {
    return (popoverRect.width - arrowRect.width) / 2;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function getArrowOffset$1(anchorRect, popoverRect) {
    const /** @type {?} */ offsetX = anchorRect.center().x - popoverRect.center().x;
    const /** @type {?} */ offsetY = 0;
    return Offset.create(offsetX, offsetY);
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function isArrowTooFar$1(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ arrowOffset = getArrowOffset$1(anchorRect, popoverRect);
    const /** @type {?} */ maxOffset = getMaxArrowOffset$1(popoverRect, arrowRect);
    const /** @type {?} */ isTooFar = Math.abs(arrowOffset.x) >= maxOffset;
    return isTooFar;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function isFlipped$1(anchorRect, popoverRect) {
    return popoverRect.isAbove(anchorRect.center());
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getPlacementClassModifier$1(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ isFlip = isFlipped$1(anchorRect, popoverRect);
    const /** @type {?} */ isTooFar = isArrowTooFar$1(anchorRect, popoverRect, arrowRect);
    if (isTooFar) {
        return constants.directionClass.none;
    }
    return isFlip ? constants.directionClass.top : constants.directionClass.bottom;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TopPlacementStrategy$1 extends BottomPlacementStrategy$1 {
    /**
     * @return {?}
     */
    getId() {
        return 'top';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PopoverService {
    constructor() {
        this.placementStrategies = [];
    }
    /**
     * @param {?} placementStrategies
     * @param {?} placementId
     * @return {?}
     */
    static pickPlacementStrategy(placementStrategies, placementId) {
        /**
         * @param {?} strategy
         * @return {?}
         */
        function matchStrategy(strategy) {
            return strategy.getId() === placementId;
        }
        return (placementStrategies || []).find(matchStrategy);
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ placementStrategy = PopoverService.pickPlacementStrategy(this.placementStrategies, placementOptions.placement);
        if (!placementStrategy) {
            throw new Error('Placement not supported: ' + placementOptions.placement);
        }
        return placementStrategy.calculate(placementOptions);
    }
}
PopoverService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PopoverService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxPopoverComponent {
    /**
     * @param {?} popoverService
     * @param {?} renderer
     * @param {?} cd
     * @param {?} uxService
     */
    constructor(popoverService, renderer, cd, uxService) {
        this.popoverService = popoverService;
        this.renderer = renderer;
        this.cd = cd;
        this.uxService = uxService;
        this.title = '';
        this.showCloseIcon = true;
        this.type = 'default';
        this.placement = 'bottom';
        this.size = 'default';
        this.hasNoContentPadding = false;
        this.isDismissable = true;
        this.isVisible = false;
        this.vm = PopoverVM.create();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.handleWindowResize();
        this.handleDocumentEvents();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.renderer.appendChild(document.body, this.popoverEl.nativeElement);
    }
    /**
     * @return {?}
     */
    handleWindowResize() {
        this.windowResizedSubscription = this.uxService.activeBreakpoint
            .debounceTime(300)
            .subscribe(bkp => {
            if (this.lastTriggerElement) {
                this.reposition(this.lastTriggerElement);
            }
        });
    }
    /**
     * @return {?}
     */
    handleDocumentEvents() {
        if (this.isDismissable) {
            this.documentClickListener = this.renderer.listen('document', 'click', (evt) => {
                if (!this.popoverEl.nativeElement.contains(evt.target)) {
                    this.hide(evt);
                }
                this.cd.markForCheck();
            });
        }
        this.documentKeyupListener = this.renderer.listen('document', 'keyup', (evt) => {
            if (evt.keyCode === 27) {
                // 27 = escape
                this.hide(evt);
            }
        });
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onCloseClick(evt) {
        this.hide(evt);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        const /** @type {?} */ triggerElement = event.target;
        if (this.lastTriggerElement === triggerElement) {
            this.isVisible ? this.hide(event) : this.show(event);
        }
        else {
            this.show(event);
        }
        this.lastTriggerElement = triggerElement;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    reposition(element) {
        const /** @type {?} */ anchorRect = RectangleFactory.fromHtmlElement(element);
        const /** @type {?} */ popoverRect = RectangleFactory.fromHtmlElement(this.popoverEl.nativeElement);
        const /** @type {?} */ arrowRect = RectangleFactory.fromHtmlElement(this.arrowEl.nativeElement);
        const /** @type {?} */ placement = this.placement;
        this.vm = this.popoverService.calculate({
            placement,
            anchorRect,
            popoverRect,
            arrowRect
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    show(event) {
        // makes sure that this is called after document click event
        setTimeout(() => {
            this.reposition(event.target);
            this.isVisible = true;
            this.cd.markForCheck();
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    hide(event) {
        this.isVisible = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
        if (this.documentKeyupListener) {
            this.documentKeyupListener();
        }
        if (this.windowResizedSubscription) {
            this.windowResizedSubscription.unsubscribe();
        }
        if (this.popoverEl) {
            this.renderer.removeChild(document.body, this.popoverEl.nativeElement);
        }
    }
}
UxPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-popover',
                template: "<div #popoverContainer class=\"ux-popover ux-popover--{{ vm.placementClassModifier }} ux-popover--{{ type }} ux-popover--size-{{ size }}\" [class.ux-popover--visible]=\"isVisible\" [style.left]=\"vm.popoverPosition.x + 'px'\" [style.top]=\"vm.popoverPosition.y + 'px'\"> <div #popoverArrow class=\"ux-popover__arrow\" [style.marginLeft]=\"vm.arrowOffset.x + 'px'\" [style.marginTop]=\"vm.arrowOffset.y + 'px'\" > <div class=\"ux-popover__arrow-inner\"></div> </div> <div *ngIf=\"title\" class=\"ux-popover__header  {{ headerStyleClass }}\"> <div class=\"ux-popover__title\">{{ title }}</div> <div *ngIf=\"showCloseIcon\" (click)=\"onCloseClick($event)\" class=\"ux-popover__close\"> <i class=\"ux-icon ux-icon-close\"></i> </div> </div> <div class=\"ux-popover__content\" [class.p-0]=\"hasNoContentPadding\"> <ng-content></ng-content> </div> </div> ",
            },] },
];
/** @nocollapse */
UxPopoverComponent.ctorParameters = () => [
    { type: PopoverService, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
    { type: UxService, },
];
UxPopoverComponent.propDecorators = {
    "popoverEl": [{ type: ViewChild, args: ['popoverContainer',] },],
    "arrowEl": [{ type: ViewChild, args: ['popoverArrow',] },],
    "title": [{ type: Input },],
    "showCloseIcon": [{ type: Input },],
    "type": [{ type: Input },],
    "placement": [{ type: Input },],
    "size": [{ type: Input },],
    "hasNoContentPadding": [{ type: Input },],
    "isDismissable": [{ type: Input },],
    "headerStyleClass": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} placementService
 * @return {?}
 */
function placementServiceFactory$1(placementService) {
    const /** @type {?} */ popoverService = new PopoverService();
    popoverService.placementStrategies = [
        new LeftPlacementStrategy$1(placementService),
        new TopPlacementStrategy$1(placementService),
        new RightPlacementStrategy$1(placementService),
        new BottomPlacementStrategy$1(placementService),
    ];
    return popoverService;
}
class UxPopoverComponentModule {
}
UxPopoverComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, GeometryModule],
                exports: [UxPopoverComponent],
                declarations: [UxPopoverComponent],
                providers: [
                    {
                        provide: PopoverService,
                        useFactory: placementServiceFactory$1,
                        deps: [PlacementService]
                    },
                    UxAssetsService,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDiscussionThreadItemComponent {
    constructor() {
        this.isOdd = false;
    }
    /**
     * @return {?}
     */
    get iconClass() {
        let /** @type {?} */ iconClass = 'ion ion-quote';
        switch (this.typeClass) {
            case 'success':
                iconClass = 'ux-icon ux-icon-check';
                break;
            case 'danger':
                iconClass = 'ux-icon ux-icon-times';
                break;
        }
        return iconClass;
    }
}
UxDiscussionThreadItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-discussion-thread-item',
                template: "<li class=\"ux-discussion-thread__item\" [class.ux-discussion-thread-inverted]=\"isOdd\"> <div class=\"ux-discussion-thread-badge {{typeClass}}\"> <span class=\"{{iconClass}}\"></span> </div> <div class=\"ux-discussion-thread-panel\"> <div class=\"ux-discussion-thread-header\"> <div class=\"ux-discussion-thread-heading\"> <div class=\"ux-discussion-thread-title\"> {{ date | amLocal | amDateFormat: 'DD/MM/YYYY' }} </div> <div class=\"ux-discussion-thread-time\"> <span class=\"ion ion-android-time\"></span> {{ date | amLocal | amDateFormat: 'HH:mm' }} </div> </div> <div class=\"ux-discussion-thread-subheading\"> {{ author }} </div> </div> <div class=\"ux-discussion-thread-body\"> <p>{{ body }}</p> </div> </div> </li> "
            },] },
];
/** @nocollapse */
UxDiscussionThreadItemComponent.propDecorators = {
    "isOdd": [{ type: Input },],
    "id": [{ type: Input },],
    "typeClass": [{ type: Input },],
    "date": [{ type: Input },],
    "author": [{ type: Input },],
    "body": [{ type: Input },],
};
class UxDiscussionThreadItemComponentModule {
}
UxDiscussionThreadItemComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MomentModule,
                    UxIconComponentModule,
                    UxDropdownButtonComponentModule
                ],
                exports: [UxDiscussionThreadItemComponent],
                declarations: [UxDiscussionThreadItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDiscussionThreadComponent {
    constructor() { }
}
UxDiscussionThreadComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-discussion-thread',
                template: "<div class=\"ux-discussion-thread-wrapper\"> <div class=\"section-title page-sub-title ux-u-font-size-h4 mt-0 mb-2 pb-2\">{{titleLabel}}</div> <div class=\"section-sub-title ux-u-font-size-h5 ux-u-font-light mb-2\">{{subTitleLabel}}</div> <ul class=\"ux-discussion-thread\"> <ng-template [ngIf]=\"items\"> <ux-discussion-thread-item *ngFor=\"let item of items; let o = odd; let e = even;\" [isOdd]=\"o\" id=\"{{item.id}}\" typeClass=\"{{item.typeClass}}\" date=\"{{item.date}}\" author=\"{{item.author}}\" body=\"{{item.body}}\"> </ux-discussion-thread-item> </ng-template> <ng-template [ngIf]=\"!items\"> <ng-content></ng-content> </ng-template> </ul> </div> "
            },] },
];
/** @nocollapse */
UxDiscussionThreadComponent.ctorParameters = () => [];
UxDiscussionThreadComponent.propDecorators = {
    "items": [{ type: Input },],
    "titleLabel": [{ type: Input },],
    "subTitleLabel": [{ type: Input },],
};
class UxDiscussionThreadComponentModule {
}
UxDiscussionThreadComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxDiscussionThreadItemComponentModule,
                ],
                exports: [UxDiscussionThreadComponent],
                declarations: [UxDiscussionThreadComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDiscussionThreadItem {
    /**
     * @param {?=} values
     */
    constructor(values = {}) {
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFormGroupComponent {
    /**
     * @param {?} uxFieldsetComponent
     */
    constructor(uxFieldsetComponent) {
        this.isVertical = false;
        this.isReadOnly = false;
        this.isValid = true;
        this.isLoadingIndicatorActive = false;
        this.isCompact = false;
        this.isRenderHTML = false;
        this.iconClass = 'ux-icon ux-icon-info-circle';
        this.iconTypeClass = 'grey-darkest';
        this.isInline = false;
        this.uxFieldsetComponent = uxFieldsetComponent;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.uxFieldsetComponent) {
            this.isCompact = this.uxFieldsetComponent.isCompactFields;
        }
        if (this.uxFieldsetComponent) {
            this.isVertical = this.uxFieldsetComponent.isVerticalFields;
        }
        if (!this.label && !this.labelWidthClass && !this.isInline) {
            this.labelWidthClass = 'col-md-4';
        }
        if (this.isVertical || (!this.label && !this.labelWidthClass)) {
            this.labelWidthClass = '';
            this.inputWidthClass = '';
        }
        else {
            if (this.uxFieldsetComponent) {
                if (this.uxFieldsetComponent.labelWidthClass && !this.labelWidthClass) {
                    this.labelWidthClass = this.uxFieldsetComponent.labelWidthClass;
                }
                if (this.uxFieldsetComponent.inputWidthClass && !this.inputWidthClass) {
                    this.inputWidthClass = this.uxFieldsetComponent.inputWidthClass;
                }
            }
            if (!this.labelWidthClass && !this.isInline) {
                this.labelWidthClass = 'col-md-4';
            }
            if (!this.inputWidthClass && !this.isInline) {
                this.inputWidthClass = 'col-md-8';
            }
        }
        this.stateClass = '';
        if (!this.isVertical) {
            if (!this.isInline) {
                this.stateClass += 'row ';
            }
            else {
                this.stateClass += 'ux-form-group--inline ';
            }
        }
        else {
            this.stateClass += 'ux-form-group--vertical ';
        }
        if (!this.label) {
            this.stateClass += 'ux-form-group--no-label ';
        }
        if (this.isCompact) {
            this.stateClass += 'ux-form-group--compact';
        }
    }
    /**
     * @return {?}
     */
    get dynamicStateClass() {
        let /** @type {?} */ dynamicStateClass = '';
        if (this.feedbackTypeClass) {
            dynamicStateClass += 'has-' + this.feedbackTypeClass + ' ';
        }
        else {
            if (!this.isValid && !this.validationErrorFeedbackClass) {
                dynamicStateClass += 'has-danger ';
            }
            else if (!this.isValid && this.validationErrorFeedbackClass) {
                dynamicStateClass += 'has-' + this.validationErrorFeedbackClass + ' ';
            }
        }
        return dynamicStateClass;
    }
}
UxFormGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-form-group',
                template: "<div class=\"ux-form-group form-group {{stateClass}} {{dynamicStateClass}} {{styleClass}}\" [class.has-danger]=\"!isValid && !validationErrorFeedbackClass\"> <label for=\"{{id}}\" class=\"ux-form-group__label-wrapper {{labelWidthClass}}\" *ngIf=\"label\" [class.col-form-label]=\"!isVertical\" [class.form-control-label]=\"isVertical\"> <span *ngIf=\"isRenderHTML\" class=\"ux-form-group__label\" [innerHTML]=\"label\"></span> <span *ngIf=\"!isRenderHTML\" class=\"ux-form-group__label\"> <ng-container *ngIf=\"label\">{{label}}</ng-container> <ng-container *ngIf=\"!label\">&nbsp;</ng-container> </span> <span *ngIf=\"isRequired\" class=\"ux-form-group__required-indicator ux-u-color-{{isRequiredTooltipTypeClass?isRequiredTooltipTypeClass:'danger'}}\">*</span> <span *ngIf=\"infoLabel\" class=\"ux-form-group__info-label {{ iconClass }} ux-u-color-{{iconTypeClass}}\" [class.ux-u-cursor-help]=\"infoLabel !== ''\" title=\"{{infoLabel}}\"> </span> </label> <label for=\"{{id}}\" class=\"ux-form-group__label-wrapper {{labelWidthClass}}\" *ngIf=\"!label\" [class.col-form-label]=\"!isVertical\" [class.form-control-label]=\"isVertical\"> </label> <div class=\"{{inputWidthClass}}\"> <div class=\"ux-form-group__input-content\"> <div [class.ux-form-group__read-only]=\"isReadOnly\"> <ng-content></ng-content> </div> <span *ngIf=\"isLoadingIndicatorActive\" class=\"ux-form-group__loading-indicator ux-icon ux-icon-refresh ux-icon-spin ux-u-color-primary\"> </span> </div> </div> <span *ngIf=\"isRequired && !label\" class=\"ux-form-group__required-indicator ux-u-color-{{isRequiredTooltipTypeClass?isRequiredTooltipTypeClass:'danger'}}\">*</span> </div> <div class=\"ux-form-group__messages-wrapper {{stateClass}}\"> <div class=\"{{labelWidthClass}}\"></div> <div class=\"{{inputWidthClass}}\"> <ng-container *ngIf=\"!isValid\"> <ux-control-feedback *ngIf=\"validationErrorMessage\" typeClass=\"{{validationErrorFeedbackClass?validationErrorFeedbackClass:'danger'}}\"> {{validationErrorMessage}} </ux-control-feedback> </ng-container> </div> </div> <ng-template [ngIf]=\"customSubContent\"> <div class=\"ux-form-group__messages-wrapper {{stateClass}}\"> <div class=\"{{labelWidthClass}}\"></div> <div class=\"{{inputWidthClass}}\"> <ng-content select=\"uxFormGroupSubContent\"></ng-content> </div> </div> </ng-template> "
            },] },
];
/** @nocollapse */
UxFormGroupComponent.ctorParameters = () => [
    { type: UxFieldsetComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [forwardRef(() => UxFieldsetComponent),] },] },
];
UxFormGroupComponent.propDecorators = {
    "id": [{ type: Input },],
    "label": [{ type: Input },],
    "isVertical": [{ type: Input },],
    "isRequired": [{ type: Input },],
    "isRequiredTooltipTypeClass": [{ type: Input },],
    "feedbackTypeClass": [{ type: Input },],
    "labelWidthClass": [{ type: Input },],
    "inputWidthClass": [{ type: Input },],
    "isReadOnly": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "validationErrorMessage": [{ type: Input },],
    "validationErrorFeedbackClass": [{ type: Input },],
    "infoLabel": [{ type: Input },],
    "isValid": [{ type: Input },],
    "isLoadingIndicatorActive": [{ type: Input },],
    "isCompact": [{ type: Input },],
    "isRenderHTML": [{ type: Input },],
    "iconClass": [{ type: Input },],
    "iconTypeClass": [{ type: Input },],
    "isInline": [{ type: Input },],
    "customSubContent": [{ type: ContentChild, args: [forwardRef(() => UxFormGroupSubContentTagDirective),] },],
};
class UxFormGroupSubContentTagDirective {
}
UxFormGroupSubContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFormGroupSubContent' },] },
];
class UxFormGroupComponentModule {
}
UxFormGroupComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxControlFeedbackComponentModule,
                ],
                exports: [UxFormGroupComponent, UxFormGroupSubContentTagDirective],
                declarations: [UxFormGroupComponent, UxFormGroupSubContentTagDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ calendarLocales = {
    'fr': {
        firstDayOfWeek: 0,
        dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
        dayNamesShort: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'],
        dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
        monthNames: [
            'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
            'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
        ],
        monthNamesShort: [
            'Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Jun',
            'Jul', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'
        ],
        today: 'Aujourd\'hui',
        clear: 'Effacer'
    },
    'en': {
        firstDayOfWeek: 0,
        dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        dayNamesMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
        monthNames: [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ],
        monthNamesShort: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
        ],
        today: 'Today',
        clear: 'Clear'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFormControlComponent {
    /**
     * @param {?} uxFormGroupComponent
     * @param {?} uxService
     * @param {?} translateService
     * @param {?} cd
     * @param {?} elementRef
     */
    constructor(uxFormGroupComponent, uxService, translateService, cd, elementRef) {
        this.uxService = uxService;
        this.translateService = translateService;
        this.cd = cd;
        this.elementRef = elementRef;
        this.isReadOnly = false;
        this.isRequired = false;
        this.isInputText = false;
        this.isTextarea = false;
        this.rows = 2;
        this.isTextareaAutoresize = false;
        this.isDatepicker = false;
        this.isDatetimepicker = false;
        this.datepickerDateformat = 'dd/mm/yy';
        this.datepickerYearRange = '1900:2050';
        this.isSelect = false;
        this.selectKeyName = 'id';
        this.selectValueName = 'value';
        this.isCheckbox = false;
        this.isRadio = false;
        this.isNumber = false;
        this.decimalSeparator = null;
        this.isNumberFormatPlaceholder = true;
        this.isDisabled = false;
        this.tabindex = '0';
        this.groupId = '';
        this.modelChange = new EventEmitter();
        this.touched = new EventEmitter();
        this.isMaxLengthValid = true;
        this.isSelectHasOptions = false;
        this.ariaInvalid = false;
        this.hasFormGroupParent = false;
        // Stores the isValid value for the parent form in case the user edits the field for the first time,
        // i.e.: not "touched" yet, but still invalid.
        // In such cases, the parent formGroup should become invalid when the user blurs the field.
        this.intendedFormGroupIsValid = true;
        this.propagateChange = (_) => {
        };
        this.propagateTouched = () => {
        };
        this.uxFormGroupComponent = uxFormGroupComponent;
        if (this.uxFormGroupComponent) {
            this.hasFormGroupParent = true;
        }
        else {
            this.hasFormGroupParent = false;
        }
        this.languageChangeSubscription = translateService.onLangChange.subscribe((evt) => {
            if (this.calendarControl && !this.datepickerLocale) {
                const /** @type {?} */ locale = calendarLocales[evt.lang] || calendarLocales['en'];
                this.calendarControl.locale = locale;
            }
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.calendarControl && this.datepickerLocale) {
            this.calendarControl.locale = this.datepickerLocale;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.id) {
            this.generatedId = 'ux-form-control-' + (Math.floor(Math.random() * 1000000) + 1).toString();
        }
        else {
            this.generatedId = this.id;
        }
        if (this.uxFormGroupComponent && !this.uxFormGroupComponent.id) {
            this.uxFormGroupComponent.id = this.generatedId;
            if (!this.uxFormGroupComponent.isRequired) {
                this.uxFormGroupComponent.isRequired = this.isRequired;
            }
            else if (!this.isRequired) {
                this.isRequired = true;
            }
        }
        if (!this.isInputText && !this.isTextarea &&
            !this.isDatepicker && !this.isDatetimepicker && !this.isSelect && !this.isCheckbox && !this.isRadio &&
            !this.isNumber) {
            this.isInputText = true;
        }
        if (this.isDatepicker && this.datepickerDateformat === 'dd/mm/yy') {
            this.placeholderLabel = 'dd/mm/yyyy';
        }
        if (this.isDatetimepicker && this.datepickerDateformat === 'dd/mm/yy') {
            this.placeholderLabel = 'dd/mm/yyyy hh:mm';
        }
        if (this.isNumber && this.maxlength) {
            this.thousandSeparator = '';
        }
        if (this.isNumber && this.isNumberFormatPlaceholder && !this.maxlength) {
            if (this.decimalSeparator) {
                if (this.decimalSeparator === ',') {
                    this.thousandSeparator = ' ';
                }
                else {
                    this.thousandSeparator = this.thousandSeparator === this.decimalSeparator ? ',' : this.thousandSeparator;
                }
            }
            else {
                this.decimalSeparator = ',';
            }
            if (this.thousandSeparator) {
                if (this.thousandSeparator === ',') {
                    this.decimalSeparator = '.';
                }
                else {
                    this.decimalSeparator = !this.decimalSeparator || (this.decimalSeparator !== '.' && this.decimalSeparator !== ',') ?
                        ',' :
                        this.decimalSeparator;
                }
            }
            else {
                this.thousandSeparator = '';
            }
            // console.log('thousandsSeparator in comp: ' + this.thousandSeparator);
            // console.log('decimalSeparator in comp: ' + this.decimalSeparator);
            this.placeholderLabel = '###' + this.thousandSeparator + '###' + this.decimalSeparator + '##';
        }
        if (this._formControl) {
            this._formControl.statusChanges.subscribe(v => {
                if (this.uxFormGroupComponent) {
                    this.intendedFormGroupIsValid = true;
                    this.uxFormGroupComponent.isValid = (v !== 'INVALID');
                    if (!this._formControl.touched) {
                        this.intendedFormGroupIsValid = this.uxFormGroupComponent.isValid;
                        this.uxFormGroupComponent.isValid = true;
                    }
                    if (!this.uxFormGroupComponent.validationErrorMessage && this.validationErrorMessage) {
                        this.uxFormGroupComponent.validationErrorMessage = this.validationErrorMessage;
                    }
                    else if (this._formControl.errors && this._formControl.errors["uxValidationError"]) {
                        this.setUxValidationErrorsToParentFormGroup();
                    }
                }
                else if (this._formControl.errors && this._formControl.errors["uxValidationError"]) {
                    this.setUxValidationErrorsToFormControl();
                }
            });
        }
        if (this.isSelect && this.selectOptions) {
            this.selectOptions.forEach((item) => {
                if (item.options) {
                    this.isSelectHasOptions = true;
                    return;
                }
            });
        }
        this.lastAutoCorrectedValue = this.inputValue;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // Bug fix for when a user types an invalid value, and then switching off read-only mode.
        // In such cases, the last characters would remain in the (read-only) value.
        // To prevent this, we will force the value to the last known correct value.
        if (changes && changes['isReadOnly'] && (this.isNumber || this.maxlength)) {
            if (this.isReadOnly) {
                this.inputValue = this.lastAutoCorrectedValue;
            }
        }
        this.updateAriaInvalid();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.languageChangeSubscription) {
            this.languageChangeSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    setUxValidationErrorsToFormControl() {
        if (this._formControl.errors["uxValidationError"].message) {
            this.validationErrorMessage = this._formControl.errors["uxValidationError"].message;
        }
        if (this._formControl.errors["uxValidationError"].type) {
            this.validationErrorType = this._formControl.errors["uxValidationError"].type;
        }
    }
    /**
     * @return {?}
     */
    setUxValidationErrorsToParentFormGroup() {
        if (this._formControl.errors["uxValidationError"].message) {
            this.uxFormGroupComponent.validationErrorMessage = this._formControl.errors["uxValidationError"].message;
        }
        if (this._formControl.errors["uxValidationError"].type) {
            this.uxFormGroupComponent.validationErrorFeedbackClass = this._formControl.errors["uxValidationError"].type;
        }
    }
    /**
     * @return {?}
     */
    get isFieldValid() {
        if (this._formControl) {
            if (this._formControl.touched && this._formControl.invalid) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    OnMaxLengthValidityChange(state) {
        this.isMaxLengthValid = state;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.isNumber) {
            this.inputValue = this.uxService.formatNumber(value, 2, this.decimalSeparator, this.thousandSeparator);
        }
        else {
            if (this.isRadio) {
                if (this.isReadOnly) {
                    this.inputValue = value;
                }
                else {
                    this.checked = (value === this.formControlValue);
                    if (this.radioElement) {
                        this.radioElement.nativeElement.checked = this.checked;
                    }
                }
            }
            else {
                this.inputValue = value;
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        if (this._formControl &&
            !this._formControl.touched &&
            this.uxFormGroupComponent &&
            (typeof this.intendedFormGroupIsValid !== 'undefined')) {
            this.uxFormGroupComponent.isValid = this.intendedFormGroupIsValid;
        }
        this.propagateTouched = fn;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        this._formControl = c;
        setTimeout(() => {
            this.updateAriaInvalid();
        }, 0);
        return (c.invalid) ? {
            fieldError: {
                errorMessage: this.validationErrorMessage || 'error'
            }
        } : null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        if (event.target) {
            // Ignore, if TAB, Shift + Tab key combinations are used
            if (event.keyCode === 9 || event.keyCode === 16) {
                return;
            }
            let /** @type {?} */ newValue = event.target.value;
            if (this.isCheckbox) {
                newValue = event.target.checked;
            }
            if (this.isDatepicker) {
                let /** @type {?} */ momentDate = moment$1(event.target.value, 'DD/MM/YYYY');
                if (momentDate.isValid()) {
                    newValue = momentDate;
                }
            }
            if (this.isDatetimepicker) {
                let /** @type {?} */ momentDate = moment$1(event.target.value, 'DD/MM/YYYY HH:mm');
                if (momentDate.isValid()) {
                    newValue = momentDate;
                }
            }
            if (this.isNumber) {
                if (event.target.value.length > 0) {
                    if (this.decimalSeparator === ',') {
                        newValue = Number(event.target.value.split(this.thousandSeparator).join('').replace(new RegExp(',', 'g'), '.'));
                    }
                    else {
                        newValue = Number(event.target.value.split(this.thousandSeparator).join(''));
                    }
                }
                else {
                    newValue = null;
                }
            }
            if (this.isSelect) {
                if (event.target.value === 'null' || event.target.value === '') {
                    newValue = null;
                }
                else {
                    const /** @type {?} */ value = event.target.value;
                    if (isNaN(Number(value))) {
                        newValue = value;
                    }
                    else {
                        newValue = Number(value);
                    }
                }
            }
            if (this.isNumber || this.maxlength) {
                this.lastAutoCorrectedValue = newValue;
            }
            this.data = newValue;
            this.propagateChange(this.data);
            this.modelChange.emit(this.data);
        }
        else {
            this.propagateChange(event);
            this.modelChange.emit(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouched(event) {
        this.touched.emit(event);
        this.propagateTouched();
        this.updateFormGroupValidationStatus();
    }
    /**
     * @return {?}
     */
    get selectValue() {
        let /** @type {?} */ valueItem = null;
        if (this.selectOptions) {
            valueItem = this.selectOptions.find(item => item[this.selectKeyName] === this.inputValue);
        }
        if (valueItem) {
            return valueItem[this.selectValueName];
        }
        else {
            return null;
        }
    }
    /**
     * @return {?}
     */
    updateAriaInvalid() {
        this.ariaInvalid = (!this.isMaxLengthValid || (this._formControl && this._formControl.touched && this._formControl.invalid));
    }
    /**
     * @return {?}
     */
    updateFormGroupValidationStatus() {
        if (this._formControl &&
            this.uxFormGroupComponent &&
            this._formControl.dirty) {
            this.uxFormGroupComponent.isValid = !this._formControl.invalid;
        }
    }
}
UxFormControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-form-control',
                template: "<ng-container *ngIf=\"isInputText && !isReadOnly\"> <span> <input id=\"{{generatedId}}\" type=\"text\" [(ngModel)]=\"inputValue\" class=\"form-control {{inputStyleClass}}\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [uxMaxlength]=\"maxlength\" (validityChange)=\"OnMaxLengthValidityChange($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> </span> </ng-container> <ng-container *ngIf=\"isTextarea && !isReadOnly\"> <span> <textarea id=\"{{generatedId}}\" class=\"form-control {{inputStyleClass}}\" [(ngModel)]=\"inputValue\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [uxMaxlength]=\"maxlength\" (validityChange)=\"OnMaxLengthValidityChange($event)\" rows=\"{{rows}}\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"> </textarea> </span> </ng-container> <ng-container *ngIf=\"isDatepicker && !isReadOnly && !isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" yearRange=\"{{datepickerYearRange}}\" placeholder=\"{{placeholderLabel}}\" [showIcon]=\"true\" [monthNavigator]=\"true\" [yearNavigator]=\"true\" [disabled]=\"false\" inputStyleClass=\"{{inputStyleClass}}\" (onSelect)=\"onChange($event)\" (onInput)=\"onChange($event)\" (onBlur)=\"onTouched($event)\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatepicker && isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [disabled]=\"true\" inputStyleClass=\"ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatepicker && isReadOnly\"> <span attr.aria-labelledby=\"{{generatedId}}\" class=\"ux-form-group__read-only\" [tabindex]=\"tabindex\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [disabled]=\"true\" inputStyleClass=\"ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </span> </ng-container> <ng-container *ngIf=\"isDatetimepicker && !isReadOnly && !isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" yearRange=\"{{datepickerYearRange}}\" placeholder=\"{{placeholderLabel}}\" [showIcon]=\"true\" [showTime]=\"true\" [monthNavigator]=\"true\" [yearNavigator]=\"true\" [disabled]=\"false\" inputStyleClass=\"datetime {{inputStyleClass}}\" (onSelect)=\"onChange($event)\" (onInput)=\"onChange($event)\" (onBlur)=\"onTouched($event)\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatetimepicker && isDisabled\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [showTime]=\"true\" [disabled]=\"true\" inputStyleClass=\"datetime ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </ng-container> <ng-container *ngIf=\"isDatetimepicker && isReadOnly\"> <span attr.aria-labelledby=\"{{generatedId}}\" class=\"ux-form-group__read-only\" [tabindex]=\"tabindex\"> <p-calendar #calendar [inputId]=\"generatedId\" dateFormat=\"{{datepickerDateformat}}\" [(ngModel)]=\"inputValue\" [showTime]=\"true\" [disabled]=\"true\" inputStyleClass=\"datetime ux-form-group__read-only ux-u-font-bold ux-u-no-border ux-u-bg-color-transparent {{inputStyleClass}}\" appendTo=\"body\"> </p-calendar> </span> </ng-container> <ng-container *ngIf=\"isSelect && !isReadOnly\"> <select id=\"{{generatedId}}\" class=\"form-control custom-select {{inputStyleClass}}\" [(ngModel)]=\"inputValue\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"> <ng-container *ngIf=\"selectOptions\"> <option [value]=\"'' || null\" class=\"ux-u-color-grey\">{{placeholderLabel}}</option> <ng-template [ngIf]=\"isSelectHasOptions\"> <ng-template ngFor let-item [ngForOf]=\"selectOptions\"> <optgroup *ngIf=\"item.options\" label=\"{{item.value}}\" class=\"ux-u-font-regular\"> <option *ngFor=\"let opt of item.options\" [value]=\"opt[selectKeyName]\" [selected]=\"inputValue == opt[selectKeyName]\"> {{opt[selectValueName]}} </option> </optgroup> <option *ngIf=\"!item.options\" [value]=\"item[selectKeyName]\" [selected]=\"inputValue == item[selectKeyName]\"> {{item[selectValueName]}} </option> </ng-template> </ng-template> <ng-template [ngIf]=\"!isSelectHasOptions\"> <option *ngFor=\"let opt of selectOptions\" [value]=\"opt[selectKeyName]\" [selected]=\"inputValue == opt[selectKeyName]\"> {{opt[selectValueName]}} </option> </ng-template> </ng-container> <ng-content *ngIf=\"! selectOptions\"></ng-content> </select> </ng-container> <ng-container *ngIf=\"isReadOnly && isSelect\"> <input type=\"text\" role=\"combobox\" [attr.aria-readonly]=\"true\" readonly=\"readonly\" id=\"{{generatedId}}\" class=\"ux-form-control__read-only {{inputStyleClass}}\" [value]=\"selectValue\" [tabindex]=\"tabindex\" /> </ng-container> <ng-container *ngIf=\"isCheckbox && !isReadOnly\"> <input id=\"{{generatedId}}\" type=\"checkbox\" [(ngModel)]=\"inputValue\" (click)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> <label for=\"{{generatedId}}\" class=\"checkbox-label\">{{checkboxLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isCheckbox && isReadOnly\"> <input id=\"{{generatedId}}\" type=\"checkbox\" [checked]=\"inputValue\" onclick=\"return false;\" [tabindex]=\"tabindex\" readonly=\"readonly\" aria-readonly=\"true\" /> <label for=\"{{generatedId}}\">{{checkboxLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isRadio && !isReadOnly\"> <input #radioElement id=\"{{generatedId}}\" class=\"radio\" type=\"radio\" [checked]=\"checked\" [name]=\"formControlName + groupId\" [value]=\"formControlValue\" (click)=\"onChange($event)\" (blur)=\"onTouched($event)\" [disabled]=\"isDisabled\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\" /> <label for=\"{{generatedId}}\" class=\"radio-label\">{{radioLabel || '&nbsp;'}}</label> </ng-container> <ng-container *ngIf=\"isNumber && !isReadOnly\"> <span> <input id=\"{{generatedId}}\" uxCleave=\"numeral\" [decimalSeparator]=\"decimalSeparator\" [thousandSeparator]=\"thousandSeparator\" type=\"text\" [(ngModel)]=\"inputValue\" class=\"form-control {{inputStyleClass}}\" (change)=\"onChange($event)\" (keyup)=\"onChange($event)\" (blur)=\"onTouched($event)\" placeholder=\"{{placeholderLabel}}\" [disabled]=\"isDisabled\" [uxMaxlength]=\"maxlength\" [tabindex]=\"tabindex\" [attr.aria-invalid]=\"ariaInvalid\" [attr.aria-required]=\"isRequired\"/> </span> </ng-container> <ng-container *ngIf=\"isNumber && isReadOnly\"> <div id=\"{{generatedId}}\" class=\"ux-form-group__read-only {{inputStyleClass}}\" [tabindex]=\"tabindex\"> {{inputValue | uxNumberFormat: decimalSeparator}} </div> </ng-container> <ng-container *ngIf=\"isReadOnly && !isDatepicker && !isDatetimepicker && !isCheckbox && !isNumber && !isSelect\"> <div id=\"{{generatedId}}\" class=\"ux-form-group__read-only {{inputStyleClass}}\" [tabindex]=\"tabindex\"> {{inputValue}} </div> </ng-container> <ng-container *ngIf=\"!isFieldValid && !hasFormGroupParent\"> <ux-control-feedback *ngIf=\"validationErrorMessage\" typeClass=\"{{validationErrorType ? validationErrorType : 'danger' }}\"> {{validationErrorMessage}} </ux-control-feedback> </ng-container> <ng-container *ngIf=\"!isMaxLengthValid\"> <ux-control-feedback *ngIf=\"maxLengthValidationErrorMessage\" typeClass=\"danger\"> {{maxLengthValidationErrorMessage}} </ux-control-feedback> </ng-container> ",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => UxFormControlComponent),
                        multi: true,
                    }, {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => UxFormControlComponent),
                        multi: true,
                    }],
                styles: [`
                 :host {
                     width: 100%;
                 }
             `]
            },] },
];
/** @nocollapse */
UxFormControlComponent.ctorParameters = () => [
    { type: UxFormGroupComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [forwardRef(() => UxFormGroupComponent),] },] },
    { type: UxService, },
    { type: TranslateService, },
    { type: ChangeDetectorRef, },
    { type: ElementRef, },
];
UxFormControlComponent.propDecorators = {
    "id": [{ type: Input },],
    "feedbackTypeClass": [{ type: Input },],
    "isReadOnly": [{ type: Input },],
    "isRequired": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "validationErrorMessage": [{ type: Input },],
    "infoLabel": [{ type: Input },],
    "placeholderLabel": [{ type: Input },],
    "formControlName": [{ type: Input },],
    "isInputText": [{ type: Input },],
    "isTextarea": [{ type: Input },],
    "rows": [{ type: Input },],
    "minRows": [{ type: Input },],
    "isTextareaAutoresize": [{ type: Input },],
    "isDatepicker": [{ type: Input },],
    "isDatetimepicker": [{ type: Input },],
    "datepickerDateformat": [{ type: Input },],
    "datepickerYearRange": [{ type: Input },],
    "datepickerLocale": [{ type: Input },],
    "isSelect": [{ type: Input },],
    "selectOptions": [{ type: Input },],
    "selectKeyName": [{ type: Input },],
    "selectValueName": [{ type: Input },],
    "isCheckbox": [{ type: Input },],
    "checkboxLabel": [{ type: Input },],
    "isRadio": [{ type: Input },],
    "radioLabel": [{ type: Input },],
    "formControlValue": [{ type: Input },],
    "isNumber": [{ type: Input },],
    "decimalSeparator": [{ type: Input },],
    "thousandSeparator": [{ type: Input },],
    "isNumberFormatPlaceholder": [{ type: Input },],
    "maxlength": [{ type: Input },],
    "maxLengthValidationErrorMessage": [{ type: Input },],
    "isDisabled": [{ type: Input },],
    "inputStyleClass": [{ type: Input },],
    "tabindex": [{ type: Input },],
    "groupId": [{ type: Input },],
    "modelChange": [{ type: Output },],
    "touched": [{ type: Output },],
    "calendarControl": [{ type: ViewChild, args: ['calendar',] },],
    "radioElement": [{ type: ViewChild, args: ['radioElement',] },],
};
class UxFormControlComponentModule {
}
UxFormControlComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxControlFeedbackComponentModule,
                    CalendarModule,
                    FormsModule,
                    UxCleaveModule,
                    UxNumberFormatPipeModule,
                    UxMaxlengthModule
                ],
                exports: [UxFormControlComponent],
                declarations: [UxFormControlComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PopoverService$1 {
    constructor() {
        this.placementStrategies = [];
    }
    /**
     * @param {?} placementStrategies
     * @param {?} placementId
     * @return {?}
     */
    static pickPlacementStrategy(placementStrategies, placementId) {
        /**
         * @param {?} strategy
         * @return {?}
         */
        function matchStrategy(strategy) {
            return strategy.getId() === placementId;
        }
        return (placementStrategies || []).find(matchStrategy);
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ placementStrategy = PopoverService$1.pickPlacementStrategy(this.placementStrategies, placementOptions.placement);
        if (!placementStrategy) {
            throw new Error('Placement not supported: ' + placementOptions.placement);
        }
        return placementStrategy.calculate(placementOptions);
    }
}
PopoverService$1.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PopoverService$1.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicOpenedPopoverService {
    /**
     * Constructor
     */
    constructor() {
        this.openedPopover = {};
    }
    /**
     * @param {?} id
     * @param {?} domPortalHost
     * @param {?} portal
     * @return {?}
     */
    add(id, domPortalHost, portal) {
        if (id) {
            this.openedPopover[String(id)] = { domPortalHost, portal };
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    remove(id) {
        if (id) {
            delete this.openedPopover[String(id)];
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    isOpenedPopover(id) {
        return !!id ? this.openedPopover[String(id)] : void 0;
    }
}
UxDynamicOpenedPopoverService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicOpenedPopoverService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicPopoverConfig {
    /**
     * @param {?} values
     */
    constructor(values) {
        this.title = '';
        this.showCloseIcon = true;
        this.type = 'default';
        this.placement = 'bottom';
        this.size = 'default';
        this.hasNoContentPadding = false;
        this.isDismissable = true;
        this.headerStyleClass = '';
        Object.assign(this, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PopoverVM$1 {
    /**
     * @param {?=} placementClassModifier
     * @param {?=} popoverPosition
     * @param {?=} arrowOffset
     */
    constructor(placementClassModifier = 'no-direction', popoverPosition = Point.create(0, 0), arrowOffset = Offset.create(0, 0)) {
        this.placementClassModifier = placementClassModifier;
        this.popoverPosition = popoverPosition;
        this.arrowOffset = arrowOffset;
    }
    /**
     * @param {?=} popoverDetails
     * @return {?}
     */
    static create(popoverDetails) {
        if (!popoverDetails) {
            return new PopoverVM$1();
        }
        return new PopoverVM$1(popoverDetails.placementClassModifier, popoverDetails.popoverPosition, popoverDetails.arrowOffset);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicPopoverComponent {
    /**
     * @param {?} popoverService
     * @param {?} uxService
     * @param {?} router
     * @param {?} uxDynamicComponentService
     * @param {?} uxDynamicOpenedPopoverService
     * @param {?} config
     */
    constructor(popoverService, uxService, router, uxDynamicComponentService, uxDynamicOpenedPopoverService, config) {
        this.popoverService = popoverService;
        this.uxService = uxService;
        this.router = router;
        this.uxDynamicComponentService = uxDynamicComponentService;
        this.uxDynamicOpenedPopoverService = uxDynamicOpenedPopoverService;
        this.config = config;
        this.isVisible = false;
        this.explicitRepositionSubject = new Subject();
        this.destroySubject = new ReplaySubject();
        this.vm = PopoverVM$1.create();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ repositionTrigger$ = this.explicitRepositionSubject.asObservable();
        const /** @type {?} */ destroyed$ = this.destroySubject.asObservable();
        const /** @type {?} */ breakpointTrigger$ = this.uxService.activeBreakpoint
            .switchMap(() => timer(300)
            .pipe(takeUntil(repositionTrigger$)));
        const /** @type {?} */ repositionNeeded$ = Observable.merge(repositionTrigger$, breakpointTrigger$).pipe(takeUntil(destroyed$));
        repositionNeeded$.subscribe(() => {
            if (this.config.anchor) {
                this.reposition(this.config.anchor);
            }
            else {
                this.hide();
            }
        });
        // close on router event
        this.router.events.take(1)
            .subscribe(() => {
            this.hide();
        });
        fromEvent(document, 'keyup').pipe(filter((evt) => evt.keyCode === 27), takeUntil(destroyed$)).subscribe(() => this.hide());
        // dismiss on click
        fromEvent(document, 'click')
            .pipe(withLatestFrom(repositionTrigger$, (event /*, trigger*/) => event.target), takeUntil(destroyed$))
            .subscribe((eventTarget) => {
            if (this.config.isDismissable
                && !this.popoverEl.nativeElement.contains(eventTarget)
                && eventTarget !== this.config.anchor) {
                this.hide();
            }
        });
        if (this.config.width) {
            this.config.size = 'auto';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.config.anchor) {
            this.config.anchor.classList.add('popover-open');
            setTimeout(() => {
                if (this.config.bodyInjectedComponent && this.config.bodyInjectedComponent.component) {
                    this.uxDynamicComponentService.add(this.config.bodyInjectedComponent.component, this.uxPopoverContent, this.config.bodyInjectedComponent.config);
                    setTimeout(() => {
                        this.show();
                    }, 0);
                }
                else {
                    this.show();
                }
            }, 0);
        }
        else {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroySubject.next(void 0);
        if (this.config.anchor) {
            this.config.anchor.classList.remove('popover-open');
        }
    }
    /**
     * @return {?}
     */
    show() {
        this.explicitRepositionSubject.next(void 0);
    }
    /**
     * @return {?}
     */
    hide() {
        this.uxDynamicComponentService.remove(this.config['portalHostRef'], this.config['portalRef']);
        this.uxDynamicOpenedPopoverService.remove(this.config.id);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    reposition(element) {
        const /** @type {?} */ anchorRect = RectangleFactory.fromHtmlElement(element);
        const /** @type {?} */ popoverRect = RectangleFactory.fromHtmlElement(this.popoverEl.nativeElement);
        const /** @type {?} */ arrowRect = RectangleFactory.fromHtmlElement(this.arrowEl.nativeElement);
        const /** @type {?} */ placement = this.config.placement;
        this.vm = this.popoverService.calculate({ placement, anchorRect, popoverRect, arrowRect });
        this.isVisible = true;
    }
}
UxDynamicPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-dynamic-popover',
                template: "<div #popoverContainer class=\"ux-popover ux-popover--{{ vm.placementClassModifier }} ux-popover--{{ config.type }} ux-popover--size-{{ config.size }} ux-popover--visible\" [class.ux-popover--visible]=\"isVisible\" [style.left]=\"vm.popoverPosition.x + 'px'\" [style.top]=\"vm.popoverPosition.y + 'px'\" [style.width]=\"config.width + 'px'\"> <div #popoverArrow class=\"ux-popover__arrow\" [style.marginLeft]=\"vm.arrowOffset.x + 'px'\" [style.marginTop]=\"vm.arrowOffset.y + 'px'\"> <div class=\"ux-popover__arrow-inner\"></div> </div> <div *ngIf=\"config.title\" class=\"ux-popover__header {{ config.headerStyleClass }}\"> <div class=\"ux-popover__title\">{{ config.title }}</div> <div *ngIf=\"config.showCloseIcon\" (click)=\"hide()\" class=\"ux-popover__close\"> <i class=\"ux-icon ux-icon-close\"></i> </div> </div> <div #uxpopovercontent class=\"ux-popover__content\" [class.p-0]=\"config.hasNoContentPadding\"> <span *ngIf=\"config.content\" [outerHTML]=\"config.content\"></span> </div> </div> ",
            },] },
];
/** @nocollapse */
UxDynamicPopoverComponent.ctorParameters = () => [
    { type: PopoverService$1, },
    { type: UxService, },
    { type: Router, },
    { type: UxDynamicComponentService, },
    { type: UxDynamicOpenedPopoverService, },
    { type: UxDynamicPopoverConfig, decorators: [{ type: Inject, args: [DYNAMIC_COMPONENT_CONFIG,] },] },
];
UxDynamicPopoverComponent.propDecorators = {
    "popoverEl": [{ type: ViewChild, args: ['popoverContainer',] },],
    "arrowEl": [{ type: ViewChild, args: ['popoverArrow',] },],
    "uxPopoverContent": [{ type: ViewChild, args: ['uxpopovercontent',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxDynamicPopoverService {
    /**
     * Constructor
     * @param {?} uxDynamicComponentService
     * @param {?} uxDynamicOpenedPopoverService
     */
    constructor(uxDynamicComponentService, uxDynamicOpenedPopoverService) {
        this.uxDynamicComponentService = uxDynamicComponentService;
        this.uxDynamicOpenedPopoverService = uxDynamicOpenedPopoverService;
    }
    /**
     * Toggle the popover
     * @param {?} config
     * @return {?}
     */
    toggle(config) {
        config = this.processConfig(config);
        if (this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id)) {
            this.hide(config);
        }
        else {
            this.show(config);
        }
    }
    /**
     * Show a popover
     * @param {?} config
     * @return {?}
     */
    show(config) {
        config = this.processConfig(config);
        const /** @type {?} */ popover = this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id);
        if (!popover) {
            const { portalHost, portal } = this.uxDynamicComponentService.add(UxDynamicPopoverComponent, null, config);
            this.uxDynamicOpenedPopoverService.add(config.id, portalHost, portal);
        }
    }
    /**
     * Hide a popover
     * @param {?} config
     * @return {?}
     */
    hide(config) {
        config = this.processConfig(config);
        const /** @type {?} */ popover = this.uxDynamicOpenedPopoverService.isOpenedPopover(config.id);
        if (popover) {
            this.uxDynamicComponentService.remove(popover.domPortalHost, popover.portal);
            this.uxDynamicOpenedPopoverService.remove(config.id);
        }
    }
    /**
     * @param {?} config
     * @return {?}
     */
    processConfig(config) {
        if (!config || !!config.anchor) {
            return config;
        }
        return Object.assign({}, config, {
            // BLACK MAGIC as it was present in the original version of the UxDynamicPopoverComponent
            // If the anchor element is not specified in the config object, the global 'event' var is used to identify the anchor element.
            anchor: event && /** @type {?} */ (event.target)
        });
    }
}
UxDynamicPopoverService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UxDynamicPopoverService.ctorParameters = () => [
    { type: UxDynamicComponentService, },
    { type: UxDynamicOpenedPopoverService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxFilterResultsComponent {
    /**
     * @param {?} uxService
     * @param {?} asService
     */
    constructor(uxService, asService) {
        this.uxService = uxService;
        this.asService = asService;
        this.isAdvancedFilterVisible = false;
        this.isScrollableNavigation = true;
        this.navigationLabel = 'Navigation';
        this.isLoadingResults = false;
        this.resultsHasNoContentPadding = false;
        this.isFilterCollapsed = false;
        this.mainStateClass = '';
        this.breakpointsSub = asService.breakpoints$.subscribe((bkps) => {
            this.isFilterCollapsed = bkps.isLtDesktop;
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.filtersLabel) {
            this.translatedFiltersLabel = this.uxService.translate('filters');
        }
        else {
            this.translatedFiltersLabel = this.filtersLabel;
        }
        if (!this.resultsLabel) {
            this.translatedResultsLabel = this.uxService.translate('results');
        }
        else {
            this.translatedResultsLabel = this.resultsLabel;
        }
        if (!this.advancedFilterLabel) {
            this.translatedAdvancedFilterLabel = this.uxService.translate('advancedFilter');
        }
        else {
            this.translatedAdvancedFilterLabel = this.advancedFilterLabel;
        }
        if (!this.quickFilterLabel) {
            this.translatedQuickFilterLabel = this.uxService.translate('quickFilter');
        }
        else {
            this.translatedQuickFilterLabel = this.quickFilterLabel;
        }
        this.advancedFilterShowhide();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.breakpointsSub) {
            this.breakpointsSub.unsubscribe();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFilterClick(event) {
        this.isAdvancedFilterVisible = !this.isAdvancedFilterVisible;
        this.advancedFilterShowhide();
    }
    /**
     * @param {?} collapsed
     * @return {?}
     */
    onCollapse(collapsed) {
        this.isFilterCollapsed = collapsed;
    }
    /**
     * @return {?}
     */
    advancedFilterShowhide() {
        if (this.isScrollableNavigation) {
            if (this.isAdvancedFilterVisible) {
                this.mainStateClass = 'ux-filter-results__filter-main--limited-height';
            }
            else {
                this.mainStateClass = '';
            }
        }
    }
}
UxFilterResultsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-filter-results',
                template: "<div class=\"ux-filter-results\" [class.ux-filter-results--filter-collapsed]=\"isFilterCollapsed\"> <div class=\"ux-filter-results__filter\"> <ux-panel label=\"{{translatedFiltersLabel}}\" isFlat=true isCollapsible=true [isCollapsed]=\"isFilterCollapsed\" (panelCollapsed)=\"onCollapse($event)\"> <uxPanelHeaderRightContent *ngIf=\"customNavigationContent.length !== 0\"> <span class=\"ux-u-font-size-h7 ux-u-font-light\">{{translatedAdvancedFilterLabel}}:&nbsp;</span> <ux-switch [isChecked]=\"isAdvancedFilterVisible\" (click)=\"onFilterClick($event)\"></ux-switch> </uxPanelHeaderRightContent> <ng-template [ngIf]=\"customQuickFilterContent.length !== 0\"> <h6 class=\"ux-u-font-bold\">{{translatedQuickFilterLabel}}</h6> <div class=\"ux-filter-results__filter-quick\"> <ng-content select=\"uxFilterResultsQuickFilterContent\"></ng-content> </div> <hr> </ng-template> <ng-template [ngIf]=\"customNavigationContent.length !== 0\"> <h6 class=\"ux-u-font-bold\">{{navigationLabel}}</h6> <div class=\"ux-filter-results__filter-main {{mainStateClass}}\"> <ng-content select=\"uxFilterResultsNavigationContent\"></ng-content> </div> </ng-template> <div *ngIf=\"isAdvancedFilterVisible || customNavigationContent.length === 0\"> <ng-template [ngIf]=\"customNavigationContent.length !== 0\"> <hr> <h6 class=\"ux-u-font-bold\">{{translatedAdvancedFilterLabel}}</h6> </ng-template> <ng-content select=\"uxFilterResultsFilterContent\"></ng-content> </div> </ux-panel> </div> <div class=\"ux-filter-results__results\"> <ux-block-content [isBlocked]=\"isLoadingResults\"> <ng-container *ngIf=\"customResultsFullContent.length !== 0\"> <ng-content select=\"uxFilterResultsFullContent\"></ng-content> </ng-container> <ng-container *ngIf=\"customResultsFullContent.length === 0\"> <ng-template [ngIf]=\"customResultsHeaderContent.length === 0\"> <ux-panel label=\"{{translatedResultsLabel}}\" isFlat=true [hasNoContentPadding]=\"resultsHasNoContentPadding\" badgeLabel=\"{{resultsHeaderBadgeLabel}}\" labelInfos=\"{{resultsHeaderInfosLabel}}\"> <ng-container *ngTemplateOutlet=\"resultsContent\"></ng-container> </ux-panel> </ng-template> <ng-template [ngIf]=\"customResultsHeaderContent.length !== 0\"> <ux-panel isFlat=true [hasNoContentPadding]=\"resultsHasNoContentPadding\"> <uxPanelHeader> <ng-content select=\"uxFilterResultsHeaderContent\"></ng-content> </uxPanelHeader> <ng-container *ngTemplateOutlet=\"resultsContent\"></ng-container> </ux-panel> </ng-template> </ng-container> </ux-block-content> </div> </div> <ng-template #resultsContent> <ng-content select=\"uxFilterResultsContent\"></ng-content> <ng-template> ",
            },] },
];
/** @nocollapse */
UxFilterResultsComponent.ctorParameters = () => [
    { type: UxService, },
    { type: UxAppShellService, },
];
UxFilterResultsComponent.propDecorators = {
    "filtersLabel": [{ type: Input },],
    "resultsLabel": [{ type: Input },],
    "quickFilterLabel": [{ type: Input },],
    "advancedFilterLabel": [{ type: Input },],
    "isAdvancedFilterVisible": [{ type: Input },],
    "isScrollableNavigation": [{ type: Input },],
    "navigationLabel": [{ type: Input },],
    "isLoadingResults": [{ type: Input },],
    "resultsHeaderBadgeLabel": [{ type: Input },],
    "resultsHeaderInfosLabel": [{ type: Input },],
    "resultsHasNoContentPadding": [{ type: Input },],
    "customNavigationContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsNavigationContentTagDirective),] },],
    "customFilterContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsFilterContentTagDirective),] },],
    "customQuickFilterContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsQuickFilterContentTagDirective),] },],
    "customResultsContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsFilterContentTagDirective),] },],
    "customResultsFullContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsFullContentTagDirective),] },],
    "customResultsHeaderContent": [{ type: ContentChildren, args: [forwardRef(() => UxFilterResultsHeaderContentTagDirective),] },],
};
class UxFilterResultsNavigationContentTagDirective {
}
UxFilterResultsNavigationContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsNavigationContent' },] },
];
class UxFilterResultsFilterContentTagDirective {
}
UxFilterResultsFilterContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsFilterContent' },] },
];
class UxFilterResultsQuickFilterContentTagDirective {
}
UxFilterResultsQuickFilterContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsQuickFilterContent' },] },
];
class UxFilterResultsHeaderContentTagDirective {
}
UxFilterResultsHeaderContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsHeaderContent' },] },
];
class UxFilterResultsContentTagDirective {
}
UxFilterResultsContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsContent' },] },
];
class UxFilterResultsFullContentTagDirective {
}
UxFilterResultsFullContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxFilterResultsFullContent' },] },
];
class UxFilterResultsComponentModule {
}
UxFilterResultsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    UxPanelComponentModule,
                    UxButtonComponentModule,
                    UxSwitchComponentModule,
                    UxBlockContentComponentModule,
                ],
                exports: [
                    UxFilterResultsComponent,
                    UxFilterResultsNavigationContentTagDirective,
                    UxFilterResultsFilterContentTagDirective,
                    UxFilterResultsContentTagDirective,
                    UxFilterResultsQuickFilterContentTagDirective,
                    UxFilterResultsHeaderContentTagDirective,
                    UxFilterResultsFullContentTagDirective,
                ],
                declarations: [
                    UxFilterResultsComponent,
                    UxFilterResultsNavigationContentTagDirective,
                    UxFilterResultsFilterContentTagDirective,
                    UxFilterResultsContentTagDirective,
                    UxFilterResultsQuickFilterContentTagDirective,
                    UxFilterResultsHeaderContentTagDirective,
                    UxFilterResultsFullContentTagDirective,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ EDITOR_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => UxEditorComponent),
    multi: true
};
class UxEditorComponent {
    /**
     * @param {?} el
     * @param {?} sanitizer
     */
    constructor(el, sanitizer) {
        this.el = el;
        this.sanitizer = sanitizer;
        this.isEnabledOnFocus = false;
        this.isReadOnly = false;
        this.theme = 'snow';
        this.onInit = new EventEmitter();
        this.onTextChange = new EventEmitter();
        this.onSelectionChange = new EventEmitter();
        this.isEnabled = true;
        this.crlf = String.fromCharCode(10, 13);
        this.blank = ' ';
        this.onModelChange = () => { };
        this.onModelTouched = () => { };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isEnabledOnFocus || this.isReadOnly) {
            this.isEnabled = false;
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // console.log('ngOnChanges() - changes:', changes);
        if (changes) {
            if (changes["isReadOnly"] && changes["isReadOnly"].currentValue === true) {
                this.isEnabled = false;
            }
            else {
                this.isEnabled = true;
            }
            // Set Quill instance
            setTimeout(() => {
                this.initQuill();
            });
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if ((value === 'undefined') || (value === 'null')) {
            this.value += this.blank;
        }
        else {
            this.value = value;
        }
        // console.log('writeValue() - this.value:', this.value );
        if (this.quill) {
            this.quill.clipboard.dangerouslyPasteHTML(this.value);
            this.secureHtmlValue = this.getSecureHTMLValue(this.value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    editorOnFocus(event) {
        if (this.isEnabledOnFocus && !this.isReadOnly) {
            this.isEnabled = true;
            setTimeout(() => {
                this.initQuill();
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    editorOnBlur(event) {
        if (event) {
            // Do not blur when using toolbar
            if ((event.srcElement.localName === 'span') ||
                // Style classes & Font face popups
                (event.srcElement.localName === 'line' || event.srcElement.localName === 'polyline') ||
                // Font color popup
                (event.srcElement.localName === 'svg')) ;
            else {
                this.isEnabled = false;
            }
        }
    }
    /**
     * @return {?}
     */
    editorUndo() {
        this.quill.history.undo();
    }
    /**
     * @return {?}
     */
    editorRedo() {
        this.quill.history.redo();
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    findSingle(element, selector) {
        return element.querySelector(selector);
    }
    /**
     * @return {?}
     */
    initQuill() {
        let /** @type {?} */ editorElement = this.findSingle(this.el.nativeElement, 'div.ux-editor__content');
        let /** @type {?} */ toolbarElement = this.findSingle(this.el.nativeElement, 'div.ux-editor__toolbar');
        this.quill = new Quill(editorElement, {
            modules: {
                toolbar: toolbarElement,
                clipboard: true,
                history: {
                    delay: 1000,
                    maxStack: 100,
                    userOnly: true
                }
            },
            placeholder: this.placeholder,
            readOnly: this.isReadOnly,
            theme: this.theme,
            formats: this.formats
        });
        // Populate with initial value
        this.writeValue(this.value);
        this.quill.on('text-change', (delta, oldContents, source) => {
            // console.log('text-change - source:', source);
            if (source === 'user') {
                let /** @type {?} */ html = editorElement.children[0].innerHTML;
                let /** @type {?} */ text = this.quill.getText().trim();
                if (text.length === 0) {
                    html = null;
                }
                // Update with changed value
                this.value = html;
                this.onTextChange.emit({
                    htmlValue: html,
                    textValue: text,
                    delta: delta,
                    source: source
                });
                this.onModelChange(html);
                this.onModelTouched();
            }
        });
        this.quill.on('selection-change', (range, oldRange, source) => {
            // console.log('selection-change - source:', source);
            // Track in/out blur (for future release!)
            // if (range === null && oldRange !== null) {
            //     this.editorOnBlur(event);
            // }
            this.onSelectionChange.emit({
                range: range,
                oldRange: oldRange,
                source: source
            });
        });
        this.onInit.emit({
            editor: this.quill
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getSecureHTMLValue(data) {
        return this.sanitizer.bypassSecurityTrustHtml(data);
    }
}
UxEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-editor',
                template: " <!-- <ng-template [ngIf]=\"isEnabledOnFocus && isEnabled || !isEnabledOnFocus\"> --> <ng-template [ngIf]=\"isEnabled\"> <div class=\"ux-editor {{styleClass}}\"> <div class=\"ux-editor__toolbar\"> <span class=\"ql-formats\"> <button class=\"ql-script\" aria-label=\"Undo\" title=\"Undo{{crlf}}Cancels the previous action\" (click)=\"editorUndo()\"><span class=\"fa fa-undo\"></span></button> <button class=\"ql-script\" aria-label=\"Redo\" title=\"Redo{{crlf}}Do the next history action again\" (click)=\"editorRedo()\"><span class=\"fa fa-repeat\"></span></button> </span> <span class=\"ql-formats\"> <select class=\"ql-header\" title=\"Style{{crlf}}Apply an HTML tag or CSS class to the selected text\"> <option value=\"1\">Heading</option> <option value=\"2\">Subheading</option> <option selected>Normal</option> </select> <select class=\"ql-font\" title=\"Font{{crlf}}Change the font face\"> <option selected>Sans Serif</option> <option value=\"serif\">Serif</option> <option value=\"monospace\">Monospace</option> </select> </span> <span class=\"ql-formats\"> <button class=\"ql-bold\" aria-label=\"Bold (Ctrl + B)\" title=\"Bold (Ctrl + B){{crlf}}Make the selected text bold\"></button> <button class=\"ql-italic\" aria-label=\"Italic (Ctrl + I)\" title=\"Italic (Ctrl + I){{crlf}}Italicize the selected text\"></button> <button class=\"ql-underline\" aria-label=\"Underline (Ctrl + U)\" title=\"Underline (Ctrl + U){{crlf}}Underline the selected text\"></button> <button class=\"ql-strike\" aria-label=\"Strikethrough\" title=\"Strikethrough{{crlf}}Draw a line to the middle of the selected text\"></button> </span> <span class=\"ql-formats\"> <select class=\"ql-color\" aria-label=\"Font Color\" title=\"Font Color{{crlf}}Change the text color\"></select> <select class=\"ql-background\" aria-label=\"Text Highlight Color\" title=\"Text Highlight Color{{crlf}}Change the background color of the text\"></select> </span> <span class=\"ql-formats\"> <button class=\"ql-script\" value=\"sub\" aria-label=\"Subscript\" title=\"Subscript{{crlf}}Create ssmall letters below the text baseline\"></button> <button class=\"ql-script\" value=\"super\" aria-label=\"Superscript\" title=\"Superscript{{crlf}}Create small letters above the line of the text\"></button> </span> <span class=\"ql-formats\"> <select class=\"ql-align\" aria-label=\"Text Align\" title=\"Text Align{{crlf}}Align the text to the selected position: left (default), center, right or justify\"> <option selected></option> <option value=\"center\"></option> <option value=\"right\"></option> <option value=\"justify\"></option> </select> </span> <span class=\"ql-formats\"> <button class=\"ql-list\" value=\"ordered\" aria-label=\"Ordered List\" title=\"Numbering{{crlf}}Start an ordered list\"></button> <button class=\"ql-list\" value=\"bullet\" aria-label=\"Unordered List\" title=\"Bullets{{crlf}}Start a bulleted list\"></button> <button class=\"ql-indent\" value=\"-1\" type=\"button\" aria-label=\"Decrease Indent\" title=\"Decrease Indent{{crlf}}Decrease the indent level of the paragraph\"></button> <button class=\"ql-indent\" value=\"+1\" type=\"button\" aria-label=\"Increase Indent\" title=\"Increase Indent{{crlf}}Increase the indent level of the paragraph\"></button> </span> <span class=\"ql-formats\"> <button class=\"ql-blockquote\" aria-label=\"Blockquote\" title=\"Blockquote{{crlf}}Create a quoted block of the selected text\"></button> <button class=\"ql-code-block\" aria-label=\"Insert Code Block\" title=\"Insert Code Block{{crlf}}Insert a code block at the cursor row position\"></button> <button class=\"ql-link\" aria-label=\"Insert Link\" title=\"Insert Hyperlink (Ctrl + K){{crlf}}Create a link to a Web page, a picture, an e-mail address or a program\"></button> <button class=\"ql-image\" aria-label=\"Insert Image\" title=\"Insert Picture{{crlf}}Insert a picture from a file\"></button> </span> <!-- <span class=\"ql-formats\" *ngIf=\"hasTable\"> <button id=\"insert-table\" aria-label=\"Insert Table\" title=\"Insert Table{{crlf}}Insert a table at the cursor's position\" (click)=\"onTableInsert()\"><span class=\"ux-icon-table ux-icon-table__add\"></span></button> <button id=\"delete-table\" aria-label=\"Delete Table\" title=\"Delete Table{{crlf}}Delete the table at the cursor's position\" (click)=\"onTableDelete()\"><span class=\"ux-icon-table ux-icon-table__delete\"></span></button> <button id=\"insert-row-above\" aria-label=\"Insert row before\" title=\"Insert row before{{crlf}}Add a table row above the cursor's position\" (click)=\"onRowInsertBefore()\"><span class=\"ux-icon-table ux-icon-table__row-insert--before\"></span></button> <button id=\"insert-row-below\" aria-label=\"Insert row after\" title=\"Insert row after{{crlf}}Add a table row below the cursor's position\" (click)=\"onRowInsertAfter()\"><span class=\"ux-icon-table ux-icon-table__row-insert--after\"></span></button> <button id=\"delete-row\" aria-label=\"Delete row\" title=\"Delete row{{crlf}}Delete the table row at the cursor position\" (click)=\"onRowDelete()\"><span class=\"ux-icon-table ux-icon-table__row-delete\"></span></button> <button id=\"insert-column-left\" aria-label=\"Insert column before\" title=\"Insert column before{{crlf}}Inserts a column at the left of the cursor's position\" (click)=\"onColumnInsertBefore()\"><span class=\"ux-icon-table ux-icon-table__col-insert--before\"></span></button> <button id=\"insert-column-right\" aria-label=\"Insert column after\" title=\"Insert column after{{crlf}}Inserts a column at the right of the cursor's position\" (click)=\"onColumnInsertAfter()\"><span class=\"ux-icon-table ux-icon-table__col-insert--after\"></span></button> <button id=\"delete-column\" aria-label=\"Delete column\" title=\"Delete column{{crlf}}Delete the column at the cursor's position\" (click)=\"onColumnDelete()\"><span class=\"ux-icon-table ux-icon-table__col-delete\"></span></button> </span> --> <span class=\"ql-formats\"> <button class=\"ql-clean\" aria-label=\"Remove Styles\" title=\"Remove Styles{{crlf}}Remove the styles of the selected text\"></button> </span> </div> <div class=\"ux-editor__content\" style=\"overflow: auto; text-overflow: ellipsis; resize: vertical;\" [ngStyle]=\"style\"></div> </div> </ng-template> <!-- <ng-template [ngIf]=\"isEnabledOnFocus && !isEnabled\"> --> <ng-template [ngIf]=\"!isEnabled\"> <div class=\"ux-editor__toolbar\" style=\"visibility:hidden;\"></div> <div class=\"ux-editor__content p-2 ux-u-bg-grey-lightester ux-u-color-black ux-u-cursor-text\" [ngClass]=\"isReadOnly ? 'ux-u-cursor-not-allowed' : 'ux-u-cursor-text'\" (click)=\"editorOnFocus($event)\" style=\"border: 1px solid #ccc; overflow: auto; text-overflow: ellipsis; resize: vertical;\"> <p [innerHTML]=\"secureHtmlValue\"></p> </div> </ng-template> ",
                providers: [EDITOR_VALUE_ACCESSOR],
            },] },
];
/** @nocollapse */
UxEditorComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: DomSanitizer, },
];
UxEditorComponent.propDecorators = {
    "style": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "placeholder": [{ type: Input },],
    "formats": [{ type: Input },],
    "isEnabledOnFocus": [{ type: Input },],
    "isReadOnly": [{ type: Input },],
    "theme": [{ type: Input },],
    "onInit": [{ type: Output },],
    "onTextChange": [{ type: Output },],
    "onSelectionChange": [{ type: Output },],
};
class UxEditorComponentModule {
}
UxEditorComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [UxEditorComponent],
                declarations: [UxEditorComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxErrorOutputComponent {
    /**
     * @param {?} uxErrorFeedbackService
     */
    constructor(uxErrorFeedbackService) {
        this.uxErrorFeedbackService = uxErrorFeedbackService;
        this.errorFeedBacks = [];
        this.errors = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initShape();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.initShape();
    }
    /**
     * @return {?}
     */
    initShape() {
        if (this.uxErrorOutput) {
            this.errorFeedBacks = this.uxErrorOutput.getFeedBacks();
        }
        else if (this.errorManager) {
            this.runErrorSubscription();
        }
        else {
            this.errorManager = this.uxErrorFeedbackService.createGlobalErrorManager();
            this.runErrorSubscription();
        }
    }
    /**
     * @return {?}
     */
    runErrorSubscription() {
        this.errorManager.errors().subscribe((evt) => {
            if (evt instanceof UxPublishErrorFeedbackEvent && evt.err) {
                if (this.itemKey) {
                    this.errorFeedBacks = this.errorFeedBacks.concat(evt.err.getFeedBacks(this.itemKey));
                }
                else {
                    this.errorFeedBacks = this.errorFeedBacks.concat(evt.err.getFeedBacks());
                }
            }
            else {
                this.errorFeedBacks = [];
            }
            this.errors.emit(this.errorFeedBacks);
        });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    removeAt(index) {
        this.errorFeedBacks.splice(index, 1);
    }
}
UxErrorOutputComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-error-output',
                template: "<div *ngIf=\"errorFeedBacks.length>0 && isAlert\"> <div *ngFor=\"let feedBack of errorFeedBacks;let i = index;\"> <ux-alert [isCloseable]=\"true\" [isMuted]=\"true\" styleClass=\"ux-reduced-margin\" typeClass=\"{{feedBack.severity ? feedBack.severity : 'danger' }}\" (close)=\"removeAt(i)\"> {{feedBack.msgId}} </ux-alert> </div> </div> <div *ngIf=\"errorFeedBacks.length>0 && !isAlert\"> <div *ngFor=\"let feedBack of errorFeedBacks;\"> <ux-control-feedback typeClass=\"{{feedBack.severity ? feedBack.severity : 'danger' }}\"> {{feedBack.msgId}} </ux-control-feedback> </div> </div> ",
            },] },
];
/** @nocollapse */
UxErrorOutputComponent.ctorParameters = () => [
    { type: UxErrorFeedbackService, },
];
UxErrorOutputComponent.propDecorators = {
    "errorManager": [{ type: Input },],
    "itemKey": [{ type: Input },],
    "isCustom": [{ type: Input },],
    "uxErrorOutput": [{ type: Input },],
    "isAlert": [{ type: Input },],
    "errors": [{ type: Output },],
};
class UxErrorOutputComponentModule {
}
UxErrorOutputComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, UxControlFeedbackComponentModule, UxAlertComponentModule],
                exports: [UxErrorOutputComponent],
                declarations: [UxErrorOutputComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxMessage {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxButtonConfig {
    /**
     * @param {?} values
     */
    constructor(values) {
        this.type = 'button';
        this.isOutline = false;
        this.isSecondary = false;
        this.isSmall = false;
        this.isLarge = false;
        this.isBlock = false;
        this.isFlat = false;
        this.isDisabled = false;
        Object.assign(this, values);
    }
    /**
     * @param {?} portalHostRef
     * @param {?} portalRef
     * @param {?} componentInstance
     * @return {?}
     */
    onClick(portalHostRef, portalRef, componentInstance) { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxModule {
}
UxModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, RouterModule, ReactiveFormsModule, FormsModule,
                    UxLayoutAppShellComponentModule,
                    UxLayoutHeaderProfileComponentModule,
                    UxLayoutSidebarItemComponentModule,
                    UxLayoutSidebarItemsComponentModule,
                    UxLayoutNavBarActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemComponentModule,
                    UxLayoutNavBarActionItemNotificationsComponentModule,
                    UxLayoutOverlayPanelComponentModule,
                    UxLayoutBreadcrumbsComponentModule,
                    UxLayoutTopMessageComponentModule,
                    UxLayoutBannerComponentModule,
                    UxLayoutPageHeaderComponentModule,
                    UxGrowlComponentModule,
                    UxBlockDocumentComponentModule,
                    UxPanelComponentModule,
                    UxPanelsComponentModule,
                    UxLanguageSelectorComponentModule,
                    UxSearchInputComponentModule
                ],
                declarations: [],
                exports: [
                    CommonModule, RouterModule, ReactiveFormsModule, FormsModule,
                    UxLayoutAppShellComponentModule,
                    UxLayoutHeaderProfileComponentModule,
                    UxLayoutSidebarItemComponentModule,
                    UxLayoutSidebarItemsComponentModule,
                    UxLayoutNavBarActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemComponentModule,
                    UxLayoutNavBarActionItemNotificationsComponentModule,
                    UxLayoutOverlayPanelComponentModule,
                    UxLayoutBreadcrumbsComponentModule,
                    UxLayoutTopMessageComponentModule,
                    UxLayoutBannerComponentModule,
                    UxLayoutPageHeaderComponentModule,
                    UxGrowlComponentModule,
                    UxBlockDocumentComponentModule,
                    UxPanelComponentModule,
                    UxPanelsComponentModule,
                    UxLanguageSelectorComponentModule,
                    UxSearchInputComponentModule
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ constants$1 = {
    offset: 15,
    directionClass: {
        none: 'no-direction',
        left: 'left',
        top: 'top',
        right: 'right',
        bottom: 'bottom',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class BottomPlacementStrategy$2 {
    /**
     * @param {?} placementService
     */
    constructor(placementService) {
        this.placementService = placementService;
    }
    /**
     * @return {?}
     */
    getId() {
        return 'bottom';
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ positionedPopoverRect = this.placementService.place({
            anchor: placementOptions.anchorRect,
            element: placementOptions.popoverRect,
            placementId: this.getId(),
            offsetAlong: constants$1.offset
        });
        const /** @type {?} */ arrowOffset = getArrowOffset$2(placementOptions.anchorRect, positionedPopoverRect);
        const /** @type {?} */ placementClassModifier = getPlacementClassModifier$2(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
        const /** @type {?} */ popoverPosition = positionedPopoverRect.position();
        return PopoverVM$1.create({
            popoverPosition, arrowOffset, placementClassModifier
        });
    }
}
/**
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getMaxArrowOffset$2(popoverRect, arrowRect) {
    return (popoverRect.width - arrowRect.width) / 2;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function getArrowOffset$2(anchorRect, popoverRect) {
    const /** @type {?} */ offsetX = anchorRect.center().x - popoverRect.center().x;
    const /** @type {?} */ offsetY = 0;
    return Offset.create(offsetX, offsetY);
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function isArrowTooFar$2(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ arrowOffset = getArrowOffset$2(anchorRect, popoverRect);
    const /** @type {?} */ maxOffset = getMaxArrowOffset$2(popoverRect, arrowRect);
    const /** @type {?} */ isTooFar = Math.abs(arrowOffset.x) >= maxOffset;
    return isTooFar;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function isFlipped$2(anchorRect, popoverRect) {
    return popoverRect.isAbove(anchorRect.center());
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getPlacementClassModifier$2(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ isFlip = isFlipped$2(anchorRect, popoverRect);
    const /** @type {?} */ isTooFar = isArrowTooFar$2(anchorRect, popoverRect, arrowRect);
    if (isTooFar) {
        return constants$1.directionClass.none;
    }
    return isFlip ? constants$1.directionClass.top : constants$1.directionClass.bottom;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class RightPlacementStrategy$2 {
    /**
     * @param {?} placementService
     */
    constructor(placementService) {
        this.placementService = placementService;
    }
    /**
     * @return {?}
     */
    getId() {
        return 'right';
    }
    /**
     * @param {?} placementOptions
     * @return {?}
     */
    calculate(placementOptions) {
        const /** @type {?} */ positionedPopoverRect = this.placementService.place({
            anchor: placementOptions.anchorRect,
            element: placementOptions.popoverRect,
            placementId: this.getId(),
            offsetAlong: constants$1.offset
        });
        const /** @type {?} */ arrowOffset = getArrowOffset$3(placementOptions.anchorRect, positionedPopoverRect);
        const /** @type {?} */ placementClassModifier = getPlacementClassModifier$3(placementOptions.anchorRect, positionedPopoverRect, placementOptions.arrowRect);
        const /** @type {?} */ popoverPosition = positionedPopoverRect.position();
        return PopoverVM$1.create({
            popoverPosition, arrowOffset, placementClassModifier
        });
    }
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function getArrowOffset$3(anchorRect, popoverRect) {
    const /** @type {?} */ offsetX = 0;
    const /** @type {?} */ offsetY = anchorRect.center().y - popoverRect.center().y;
    return Offset.create(offsetX, offsetY);
}
/**
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getMaxArrowOffset$3(popoverRect, arrowRect) {
    return (popoverRect.height - arrowRect.height) / 2;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function isArrowTooFar$3(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ arrowOffset = getArrowOffset$3(anchorRect, popoverRect);
    const /** @type {?} */ maxOffset = getMaxArrowOffset$3(popoverRect, arrowRect);
    const /** @type {?} */ isTooFar = Math.abs(arrowOffset.y) >= maxOffset;
    return isTooFar;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @param {?} arrowRect
 * @return {?}
 */
function getPlacementClassModifier$3(anchorRect, popoverRect, arrowRect) {
    const /** @type {?} */ isFlip = isFlipped$3(anchorRect, popoverRect);
    const /** @type {?} */ isTooFar = isArrowTooFar$3(anchorRect, popoverRect, arrowRect);
    if (isTooFar) {
        return constants$1.directionClass.none;
    }
    return isFlip ? constants$1.directionClass.left : constants$1.directionClass.right;
}
/**
 * @param {?} anchorRect
 * @param {?} popoverRect
 * @return {?}
 */
function isFlipped$3(anchorRect, popoverRect) {
    return popoverRect.isOnTheLeft(anchorRect.center());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LeftPlacementStrategy$2 extends RightPlacementStrategy$2 {
    /**
     * @return {?}
     */
    getId() {
        return 'left';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TopPlacementStrategy$2 extends BottomPlacementStrategy$2 {
    /**
     * @return {?}
     */
    getId() {
        return 'top';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} placementService
 * @return {?}
 */
function placementServiceFactory$2(placementService) {
    const /** @type {?} */ popoverService = new PopoverService$1();
    popoverService.placementStrategies = [
        new LeftPlacementStrategy$2(placementService),
        new TopPlacementStrategy$2(placementService),
        new RightPlacementStrategy$2(placementService),
        new BottomPlacementStrategy$2(placementService),
    ];
    return popoverService;
}
class UxDynamicPopoverComponentModule {
}
UxDynamicPopoverComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, GeometryModule],
                exports: [UxDynamicPopoverComponent],
                declarations: [UxDynamicPopoverComponent],
                providers: [
                    {
                        provide: PopoverService$1,
                        useFactory: placementServiceFactory$2,
                        deps: [PlacementService]
                    },
                    UxAssetsService,
                    UxDynamicOpenedPopoverService,
                ],
                entryComponents: [
                    UxDynamicPopoverComponent,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCardItemComponent {
    /**
     * @param {?} uxAppShellService
     */
    constructor(uxAppShellService) {
        this.uxAppShellService = uxAppShellService;
        this.hasNumberRows = false;
        this.hasHeader = false;
        this.hasHeaderSort = false;
        this.isCompact = false;
        this.index = 0;
        this.hasCardItemCustomContent = false;
        this.sortClicked = new EventEmitter();
        this.orderBy = {};
        this.sortedColumn = {};
        this.breakpointsValue = {
            isMobile: false,
            isTablet: false,
            isLtDesktop: false,
            isDesktop: false,
            isXL: false,
            isXXL: false,
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe((bkps) => {
            this.breakpointsValue = bkps;
        });
        // Map Data to columns (default)
        if (this.rowItem) {
            this.columns = Object.keys(this.rowItem);
            Object.keys(this.rowItem).map((col) => {
                Object.assign(this.orderBy, { [col]: '' });
            });
        }
        // Custom
        if (!this.rowItem && this.columnLabels) {
            this.columns = Object.keys(this.columnLabels);
            Object.keys(this.columnLabels).map((col) => {
                Object.assign(this.orderBy, { [col]: '' });
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.breakpointsSubscription.unsubscribe();
    }
    /**
     * Sort columns data based on strings & numbers. 2DO: sort by dates!
     * @param {?} column
     * @param {?=} order
     * @return {?}
     */
    sortColumn(column, order) {
        // First Reset all columns
        for (const /** @type {?} */ col in this.orderBy) {
            if (this.orderBy[col]) {
                Object.assign(this.orderBy, { [col]: '' });
            }
        }
        // Then assign the new orderBy column value
        this.orderBy[column] = order; // or use:   Object.assign(this.orderBy, { [column]: order });
        this.sortedColumn = { column: column, order: this.orderBy[column] };
        console.log('sortColumn() - 2DO:', this.sortedColumn);
        // 2DO !
        // this.sortClicked.emit( this.sortedColumn );
    }
}
UxCardItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-card-item',
                template: "<div *ngIf=\"hasHeader && index === 0\" class=\"ux-card-item__header\"> <div class=\"ux-card-item__header-row\"> <div *ngIf=\"hasNumberRows && !((uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile)\" class=\"ux-card-item__header-row--hasNumberRows\">&nbsp;</div> <ng-template [ngIf]=\"hasHeaderSort\"> <div *ngFor=\"let col of columns;\" class=\"ux-card-item__header-cell ux-card-item__header-cell--sortable\" (click)=\"sortColumn( col, orderBy[col] === '' || orderBy[col] === 'desc' ? 'asc' : 'desc' )\"> {{ columnLabels[col] ? columnLabels[col] : col }} <span class=\"ml-1 fa\" [ngClass]=\"orderBy[col] === '' ? 'fa-sort ux-u-color-grey-light' : orderBy[col] === 'desc' ? 'fa-sort-desc' : 'fa-sort-asc'\"></span> </div> </ng-template> <ng-template [ngIf]=\"!hasHeaderSort && !((uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile)\"> <div class=\"ux-card-item__header-cell\" *ngFor=\"let col of columns;\"> {{ columnLabels[col] ? columnLabels[col] : col }} </div> </ng-template> </div> </div> <div class=\"ux-card-item__row\" [class.ux-card-item__row--odd]=\"isOdd\"> <!-- DESKTOP --> <ng-template [ngIf]=\"!( (uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile )\"> <div class=\"ux-card-item__row-content\" [class.ux-card-item__row-content--compact]=\"isCompact\"> <div *ngIf=\"hasNumberRows\" class=\"ux-card-item__row-content--hasNumberRows\"> <span class=\"badge badge-secondary badge-small\">{{index + 1}}</span> </div> <ng-container *ngIf=\"rowItem\"> <ux-card-item-cell *ngFor=\"let cellItem of columns\"> {{ rowItem[cellItem] }} </ux-card-item-cell> </ng-container> <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> <!-- <ng-content></ng-content> --> </div> </ng-template> <!-- TABLET / MOBILE --> <ng-template [ngIf]=\"(uxAppShellService.breakpoints$ | async).isTablet || (uxAppShellService.breakpoints$ | async).isMobile\"> <div class=\"ux-card-item__row-content\" [class.ux-card-item__row-content--compact]=\"isCompact\"> <div *ngIf=\"hasNumberRows\" class=\"ux-card-item__row-content--hasNumberRows\"> <span class=\"badge badge-secondary badge-small\">{{index + 1}}</span> </div> <div *ngFor=\"let col of columns; let j = index\" class=\"Zd-flex p-2\"> <!-- <div class=\"ux-card-item__row-cell\"> --> <strong class=\"ux-u-color-grey-darker\">{{ columnLabels[col] ? columnLabels[col] : col }}</strong> <!-- </div> --> <ng-container *ngIf=\"rowItem\"> <ux-card-item-cell>{{ rowItem[col] }}</ux-card-item-cell> </ng-container> <!-- <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> --> </div> <ng-template [ngIf]=\"hasCardItemCustomContent\"> <ng-content select=\"uxCardItemCustomContent\"></ng-content> </ng-template> <!-- <ng-content></ng-content> --> </div> </ng-template> </div> ",
                styles: ["ux-card-item{flex:1 1 0}uxCardItemCustomContent{display:flex;flex:1 1 0;width:100% !important}.ux-card-item{align-items:center;border:0;border-bottom:1px solid #d2d2d2;display:flex;width:100%}.ux-card-item__header{background:#f5f5f5;display:flex;overflow:hidden;text-overflow:ellipsis;vertical-align:top;width:100%}.ux-card-item__header-row{border-bottom:1px solid #bdbdbd !important;display:flex;vertical-align:bottom;width:100%;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-card-item__header-row--hasNumberRows{min-width:3rem !important}.ux-card-item__header-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-item__header-cell--sortable:hover:not(.ui-state-active){background-color:#4d7cb4;color:white !important;cursor:pointer}.ux-card-item__row{align-items:center;border:0;border-bottom:1px solid #d2d2d2;display:flex;width:100%}.ux-card-item__row-content{align-items:center;display:flex;flex-wrap:wrap;margin-bottom:.89rem !important;margin-top:.89rem !important;width:100% !important}.ux-card-item__row-content--hasNumberRows{padding-left:.89rem;min-width:3rem !important}.ux-card-item__row-content--compact{margin-bottom:.66rem !important;margin-top:.66rem !important}.ux-card-item__row-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-item__row--odd{background-color:#fafafa}.ux-card-item__row:focus,.ux-card-item__row:hover{background-color:#f5f5f5} /*# sourceMappingURL=ux-card-item.component.css.map */"],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
UxCardItemComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxCardItemComponent.propDecorators = {
    "rowItem": [{ type: Input },],
    "columnLabels": [{ type: Input },],
    "hasNumberRows": [{ type: Input },],
    "hasHeader": [{ type: Input },],
    "hasHeaderSort": [{ type: Input },],
    "isCompact": [{ type: Input },],
    "isOdd": [{ type: Input },],
    "index": [{ type: Input },],
    "hasCardItemCustomContent": [{ type: Input },],
    "sortClicked": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCardItemCellComponent {
    constructor() { }
}
UxCardItemCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-card-item-cell',
                template: "<div *ngIf=\"cellItem\" class=\"ux-card-item__cell {{styleClass}}\"> {{ cellItem }} </div> <div *ngIf=\"!cellItem\" class=\"ux-card-item__cell {{styleClass}}\"> <ng-content></ng-content> </div> ",
                styles: ["ux-card-item-cell{flex:1 1 0}.ux-card-item__cell{display:flex;width:100%} /*# sourceMappingURL=ux-card-item-cell.component.css.map */"],
                encapsulation: ViewEncapsulation.None,
            },] },
];
// ngOnInit() {
//     this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe((bkps) => {
//         this.breakpointsValue = bkps;
//     });
// }
// ngOnDestroy() {
//     this.breakpointsSubscription.unsubscribe();
// }
/** @nocollapse */
UxCardItemCellComponent.ctorParameters = () => [];
UxCardItemCellComponent.propDecorators = {
    "cellItem": [{ type: Input },],
    "column": [{ type: Input },],
    "styleClass": [{ type: Input },],
};
/* tslint:disable */
// @Directive({ selector: 'uxCardCellContent' })
// export class UxCardCellContentTagDirective { }
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxCardItemsComponent {
    /**
     * @param {?} uxAppShellService
     */
    constructor(uxAppShellService) {
        this.uxAppShellService = uxAppShellService;
        this.columnLabels = {};
        this.hasNumberRows = false;
        this.hasBorders = false;
        this.hasHeader = false;
        this.hasHeaderSort = false;
        this.isCompact = false;
        this.pageSize = 10;
        this.orderBy = {};
        this.breakpointsValue = {
            isMobile: false,
            isTablet: false,
            isLtDesktop: false,
            isDesktop: false,
            isXL: false,
            isXXL: false,
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Subscribing to breakpoint changes to adapt the display dynamically
        this.breakpointsSubscription = this.uxAppShellService.breakpoints$.subscribe((bkps) => {
            this.breakpointsValue = bkps;
        });
        // Using default config
        if (this.payload) {
            this.payload = this.payload.filter((data, index) => {
                return index < this.pageSize;
            });
            this.columns = Object.keys(this.payload);
            Object.keys(this.payload).map((col) => {
                Object.assign(this.orderBy, { [col]: '' });
            });
        }
        // Using custom config
        // ...
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.breakpointsSubscription.unsubscribe();
    }
    /**
     * Sort cards data based on strings & numbers. 2DO: sort by dates!
     * @param {?} event
     * @return {?}
     */
    sortCards(event) {
        console.log('sortCards() event:', event);
        // let response: any;
        // let data: any = this.payload;
        if (this.payload && event) {
            this.payload.sort(function (a, b) {
                // console.log ( 'A:', typeof(a[event.column]), a[event.column], 'B:', typeof(b[event.column]), b[event.column] );
                // Set to empty if null values
                if (a[event.column] === null) {
                    a[event.column] = '';
                }
                if (b[event.column] === null) {
                    b[event.column] = '';
                }
                if (typeof (a[event.column]) === 'string' && typeof (b[event.column]) === 'string') {
                    if (a[event.column].toLowerCase() < b[event.column].toLowerCase()) {
                        return -1;
                    }
                    if (a[event.column].toLowerCase() > b[event.column].toLowerCase()) {
                        return 1;
                    }
                    return 0;
                }
                else {
                    if (a[event.column] < b[event.column]) {
                        return -1;
                    }
                    if (a[event.column] > b[event.column]) {
                        return 1;
                    }
                    return 0;
                }
            });
            if (event.order === 'desc') {
                this.payload.reverse();
            }
        }
        // this.payload = response;
        // return response;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    _setPageSize(size) {
        if (size) {
            this.payload = this.payload.filter((data, index) => {
                return index < size;
            });
        }
    }
}
UxCardItemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'ux-card-items',
                template: "<div class=\"ux-card-items {{styleClass}}\"> <div class=\"ux-card-items__wrapper\" [ngClass]=\"hasBorders ? 'ux-card-items__wrapper--borders' : 'ux-card-items__wrapper--no-borders'\"> <!-- DEFAULT TEMPLATE --> <ng-template [ngIf]=\"payload\"> <ux-card-item *ngFor=\"let rowItem of payload; let i = index; let odd = odd;\" [rowItem]=\"rowItem\" [columnLabels]=\"columnLabels\" [hasNumberRows]=\"hasNumberRows\" [hasHeader]=\"hasHeader\" [hasHeaderSort]=\"hasHeaderSort\" [isCompact]=\"isCompact\" [isOdd]=\"odd\" [index]=\"i\" (sortClicked)=\"sortCards($event)\"> </ux-card-item> </ng-template> <!-- CUSTOM TEMPLATE --> <ng-template [ngIf]=\"!payload\"> <ng-content></ng-content> </ng-template> </div> </div> ",
                styles: ["ux-card-items{flex:1 1 0}.ux-card-items{display:flex;margin-bottom:1.25rem}.ux-card-items__wrapper{background:white;border:0;outline:0;width:100%}.ux-card-items__wrapper--no-borders{border:0 solid transparent !important}.ux-card-items__wrapper--borders{border:1px solid #d2d2d2 !important}.ux-card-items__header{background:#f5f5f5;display:flex;overflow:hidden;text-overflow:ellipsis;vertical-align:top;width:100%}.ux-card-items__header-row{border-bottom:1px solid #bdbdbd !important;display:flex;vertical-align:bottom;width:100%;font-family:\"eui-bold\",\"Helvetica Neue\",Helvetica,sans-serif;font-weight:normal}.ux-card-items__header-row--hasNumberRows{padding-left:.89rem;min-width:3rem !important}.ux-card-items__header-cell{flex-basis:0;flex-grow:1;max-width:100%;padding:1.25rem .66rem !important}.ux-card-items__header-cell--sortable:hover:not(.ui-state-active){background-color:#4d7cb4;color:white !important;cursor:pointer} /*# sourceMappingURL=ux-card-items.component.css.map */"],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
UxCardItemsComponent.ctorParameters = () => [
    { type: UxAppShellService, },
];
UxCardItemsComponent.propDecorators = {
    "payload": [{ type: Input },],
    "columnLabels": [{ type: Input },],
    "hasNumberRows": [{ type: Input },],
    "hasBorders": [{ type: Input },],
    "hasHeader": [{ type: Input },],
    "hasHeaderSort": [{ type: Input },],
    "isCompact": [{ type: Input },],
    "pageSize": [{ type: Input },],
    "styleClass": [{ type: Input },],
};
class UxCardItemCustomContentTagDirective {
}
UxCardItemCustomContentTagDirective.decorators = [
    { type: Directive, args: [{ selector: 'uxCardItemCustomContent' },] },
];
class UxCardItemsComponentModule {
}
UxCardItemsComponentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                exports: [
                    UxCardItemsComponent,
                    UxCardItemComponent,
                    UxCardItemCellComponent,
                    UxCardItemCustomContentTagDirective,
                ],
                declarations: [
                    UxCardItemsComponent,
                    UxCardItemComponent,
                    UxCardItemCellComponent,
                    UxCardItemCustomContentTagDirective,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UxAllModule {
}
UxAllModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule, RouterModule, ReactiveFormsModule, FormsModule,
                    UxLayoutAppShellComponentModule,
                    UxLayoutHeaderProfileComponentModule,
                    UxLayoutSidebarItemComponentModule,
                    UxLayoutSidebarItemsComponentModule,
                    UxLayoutNavBarActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemComponentModule,
                    UxLayoutNavBarActionItemNotificationsComponentModule,
                    UxLayoutOverlayPanelComponentModule,
                    UxLayoutBreadcrumbsComponentModule,
                    UxLayoutTopMessageComponentModule,
                    UxLayoutBannerComponentModule,
                    UxLayoutHorizontalModule,
                    UxLayoutPageHeaderComponentModule,
                    UxLayoutPageHeaderActionIconItemComponentModule,
                    UxLayoutFooterActionBarComponentModule,
                    UxLayoutFlexContentModule,
                    UxOrderByPipeModule,
                    UxFilterPipeModule,
                    UxTruncatePipeModule,
                    UxCurrencyPipeModule,
                    UxNumberFormatPipeModule,
                    UxMomentTzPipeModule,
                    UxIsoToCountryPipeModule,
                    UxScrollHandlerDirectiveModule,
                    UxMaxlengthModule,
                    UxTooltipModule,
                    UxAutoResizeModule,
                    UxCollapsibleDirectiveModule,
                    UxHasPermissionDirectiveModule,
                    UxTemplateDirectiveModule,
                    UxSmoothScrollDirectiveModule,
                    UxCleaveModule,
                    NguiAutoCompleteDropdownButtonModule,
                    UxAlertComponentModule,
                    UxDashboardCardComponentModule,
                    UxDashboardButtonsComponentModule,
                    UxDashboardButtonComponentModule,
                    UxActionBoxComponentModule,
                    UxPanelComponentModule,
                    UxPanelsComponentModule,
                    UxTabComponentModule,
                    UxTabsComponentModule,
                    UxTabsBarComponentModule,
                    UxStaticTabsComponentModule,
                    UxTimelineItemsComponentModule,
                    UxTimelineItemComponentModule,
                    UxWizardStepComponentModule,
                    UxWizardStepsComponentModule,
                    UxTreeListComponentModule,
                    UxTreeListItemComponentModule,
                    UxSwitchComponentModule,
                    UxButtonComponentModule,
                    UxControlFeedbackComponentModule,
                    UxDropdownButtonComponentModule,
                    UxDropdownButtonItemComponentModule,
                    UxFieldsetComponentModule,
                    UxModalComponentModule,
                    UxDynamicModalComponentModule,
                    UxDynamicMessageBoxComponentModule,
                    UxDynamicPopoverComponentModule,
                    UxLanguageSelectorComponentModule,
                    UxSearchInputComponentModule,
                    UxBlockContentComponentModule,
                    UxTagComponentModule,
                    UxIconComponentModule,
                    UxIconToggleComponentModule,
                    UxIconBoxComponentModule,
                    UxMarkerComponentModule,
                    UxLabelComponentModule,
                    UxDateTagComponentModule,
                    UxProgressCircleComponentModule,
                    UxCarouselItemsComponentModule,
                    UxCarouselItemComponentModule,
                    UxGrowlComponentModule,
                    UxBlockDocumentComponentModule,
                    UxTreeComponentModule,
                    UxTimebarComponentModule,
                    UxBadgeComponentModule,
                    UxAutocompleteTagComponentModule,
                    UxToolbarFilterComponentModule,
                    UxButtonGroupComponentModule,
                    UxButtonGroupItemComponentModule,
                    UxSplitButtonComponentModule,
                    UxMessageBoxComponentModule,
                    UxBadgeGroupComponentModule,
                    UxNotificationsPanelComponentModule,
                    UxNotificationItemComponentModule,
                    UxStickyComponentModule,
                    UxPieChartComponentModule,
                    UxPieChartLegendItemComponentModule,
                    UxPieChartGroupComponentModule,
                    UxOverlayComponentModule,
                    UxListItemComponentModule.forRoot(),
                    UxListItemsComponentModule,
                    UxMenuItemComponentModule.forRoot(),
                    UxDropdownComponentModule,
                    UxFieldSearchComponentModule,
                    UxLoadingIndicatorComponentModule,
                    UxPopoverComponentModule,
                    UxDiscussionThreadComponentModule,
                    UxDiscussionThreadItemComponentModule,
                    UxFormControlComponentModule,
                    UxFormGroupComponentModule,
                    UxDisableContentComponentModule,
                    UxFilterResultsComponentModule,
                    UxEditorComponentModule,
                    UxCardItemsComponentModule,
                    UxErrorOutputComponentModule
                ],
                declarations: [],
                exports: [
                    CommonModule, RouterModule, ReactiveFormsModule, FormsModule,
                    UxLayoutAppShellComponentModule,
                    UxLayoutHeaderProfileComponentModule,
                    UxLayoutSidebarItemComponentModule,
                    UxLayoutSidebarItemsComponentModule,
                    UxLayoutNavBarActionItemComponentModule,
                    UxLayoutNavBarLeftActionItemComponentModule,
                    UxLayoutNavBarActionItemNotificationsComponentModule,
                    UxLayoutOverlayPanelComponentModule,
                    UxLayoutBreadcrumbsComponentModule,
                    UxLayoutTopMessageComponentModule,
                    UxLayoutBannerComponentModule,
                    UxLayoutHorizontalModule,
                    UxLayoutPageHeaderComponentModule,
                    UxLayoutPageHeaderActionIconItemComponentModule,
                    UxLayoutFooterActionBarComponentModule,
                    UxLayoutFlexContentModule,
                    UxOrderByPipeModule,
                    UxFilterPipeModule,
                    UxTruncatePipeModule,
                    UxCurrencyPipeModule,
                    UxNumberFormatPipeModule,
                    UxMomentTzPipeModule,
                    UxIsoToCountryPipeModule,
                    UxScrollHandlerDirectiveModule,
                    UxMaxlengthModule,
                    UxTooltipModule,
                    UxAutoResizeModule,
                    UxCollapsibleDirectiveModule,
                    UxHasPermissionDirectiveModule,
                    UxSmoothScrollDirectiveModule,
                    UxTemplateDirectiveModule,
                    UxCleaveModule,
                    NguiAutoCompleteDropdownButtonModule,
                    UxAlertComponentModule,
                    UxDashboardCardComponentModule,
                    UxDashboardButtonsComponentModule,
                    UxDashboardButtonComponentModule,
                    UxActionBoxComponentModule,
                    UxPanelComponentModule,
                    UxPanelsComponentModule,
                    UxTabComponentModule,
                    UxTabsComponentModule,
                    UxTabsBarComponentModule,
                    UxStaticTabsComponentModule,
                    UxTimelineItemsComponentModule,
                    UxTimelineItemComponentModule,
                    UxWizardStepComponentModule,
                    UxWizardStepsComponentModule,
                    UxTreeListComponentModule,
                    UxTreeListItemComponentModule,
                    UxSwitchComponentModule,
                    UxButtonComponentModule,
                    UxControlFeedbackComponentModule,
                    UxDropdownButtonComponentModule,
                    UxDropdownButtonItemComponentModule,
                    UxFieldsetComponentModule,
                    UxModalComponentModule,
                    UxDynamicModalComponentModule,
                    UxDynamicMessageBoxComponentModule,
                    UxDynamicPopoverComponentModule,
                    UxLanguageSelectorComponentModule,
                    UxSearchInputComponentModule,
                    UxBlockContentComponentModule,
                    UxTagComponentModule,
                    UxIconComponentModule,
                    UxIconToggleComponentModule,
                    UxIconBoxComponentModule,
                    UxMarkerComponentModule,
                    UxLabelComponentModule,
                    UxDateTagComponentModule,
                    UxProgressCircleComponentModule,
                    UxCarouselItemsComponentModule,
                    UxCarouselItemComponentModule,
                    UxGrowlComponentModule,
                    UxBlockDocumentComponentModule,
                    UxTreeComponentModule,
                    UxTimebarComponentModule,
                    UxBadgeComponentModule,
                    UxAutocompleteTagComponentModule,
                    UxToolbarFilterComponentModule,
                    UxButtonGroupComponentModule,
                    UxButtonGroupItemComponentModule,
                    UxSplitButtonComponentModule,
                    UxMessageBoxComponentModule,
                    UxBadgeGroupComponentModule,
                    UxNotificationsPanelComponentModule,
                    UxNotificationItemComponentModule,
                    UxStickyComponentModule,
                    UxPieChartComponentModule,
                    UxPieChartLegendItemComponentModule,
                    UxPieChartGroupComponentModule,
                    UxOverlayComponentModule,
                    UxListItemComponentModule,
                    UxListItemsComponentModule,
                    UxMenuItemComponentModule,
                    UxDropdownComponentModule,
                    UxFieldSearchComponentModule,
                    UxLoadingIndicatorComponentModule,
                    UxPopoverComponentModule,
                    UxDiscussionThreadComponentModule,
                    UxDiscussionThreadItemComponentModule,
                    UxFormControlComponentModule,
                    UxFormGroupComponentModule,
                    UxDisableContentComponentModule,
                    UxFilterResultsComponentModule,
                    UxEditorComponentModule,
                    UxCardItemsComponentModule,
                    UxErrorOutputComponentModule
                ],
                providers: [
                    UxDynamicModalService,
                    UxDynamicMessageBoxService,
                    UxDynamicPopoverService,
                    UxDynamicComponentService,
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* tslint:enable */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { CoreModule, getConfig, CONFIG_TOKEN, LocalizationService, translateStaticLoader, translateConfig, StorageService, LocalstorageService, UserService, UxAuthService, UxAuthGuardService, UxPermissionService, UxDynamicMenuService, RouteService, GlobalErrorHandler, QueueApiService, UxService, UxDomService, UxAppShellService, DYNAMIC_COMPONENT_CONFIG, UxDynamicComponentService, UxAssetsService, UxTimezoneService, UxErrorFeedbackService, UxErrorManager, OpenidConnectService, StoreService, reducers, localStorageSync, getAppState, getUserState, getUserIdState, getUserPrefsState, getAppConnection, getAppStatus, getApiQueue, getApiQueueById, reducer as appReducer, reducer$2 as userReducer, getUserId, getUserPreferences, reducer$1 as notificationReducer, RouteUpdateAction, ChangeModuleAction, ApiQueueAdd, ApiQueueRemove, UpdateListAction, UpdateUserDetailAction, UpdateUserPreferencesAction, CoreModuleEffects, LOG_LEVEL, TraceService, HttpService, RequestErrorInterceptor, ResponseErrorHandlerTypes, CachePreventionInterceptor, CorsSecurityInterceptor, CsrfPreventionInterceptor, EuLoginSessionTimeoutHandlingInterceptor, OpenidConnectInterceptor, UxBadge, UxLink, UxErrorOutput, UxMessageSeverity, UxValidationErrorClass, transformToUxHttpResponse, UxPublishErrorFeedbackEvent, UxClearErrorFeedbackEvent, withUxErrorManager, UX_COLORS, UX_I18N, UX_COUNTRIES, UX_TIMEZONES, UxOrderByPipe, UxOrderByPipeModule, UxFilterPipe, UxFilterPipeModule, UxTruncatePipe, UxTruncatePipeModule, UxCurrencyPipe, UxCurrencyPipeModule, UxNumberFormatPipe, UxNumberFormatPipeModule, UxMomentTzPipe, UxMomentTzPipeModule, UxIsoToCountryPipe, UxIsoToCountryPipeModule, UxScrollHandlerDirective, UxScrollHandlerElementDirective, UxScrollHandlerDirectiveModule, UxMaxlengthDirective, UxMaxlengthModule, UxTooltip, UxTooltipModule, UxAutoResizeDirective, UxAutoResizeModule, UxCollapsibleDirective, UxCollapsibleDirectiveModule, UxHasPermissionDirective, UxHasPermissionDirectiveModule, UxSmoothScrollToDirective, UxSmoothScrollDirective, UxSmoothScrollDirectiveModule, UxCleaveDirective, UxCleaveModule, UxTemplateDirective, UxTemplateDirectiveModule, NguiAutoCompleteDropdownButtonDirective, NguiAutoCompleteDropdownButtonModule, UxLayoutAppShellComponent, UxAppShellSidebarContentTagDirective, UxAppShellSidebarHeaderContentTagDirective, UxAppShellHeaderRightContentTagDirective, UxAppShellHeaderTitleContentTagDirective, UxAppShellMainContentTagDirective, UxAppShellNavBarItemsContentTagDirective, UxAppShellNavBarLeftItemsContentTagDirective, UxAppShellFooterContentTagDirective, UxAppShellOverlayPanelHeaderTagDirective, UxAppShellTopMessageContentTagDirective, UxAppShellErrorStateContentTagDirective, UxLayoutAppShellComponentModule, UxLayoutHeaderProfileComponent, UxLayoutHeaderProfileMenuContentTagDirective, UxLayoutHeaderProfileNotLoggedInContentTagDirective, UxLayoutHeaderProfileSubContentTagDirective, UxLayoutHeaderProfileComponentModule, UxLayoutSidebarItemsComponent, UxLayoutSidebarItemsComponentModule, UxLayoutSidebarItemComponent, UxLayoutSidebarItemComponentModule, UxLayoutNavBarActionItemComponent, UxLayoutNavBarOverlayPanelContentTagDirective, UxLayoutNavBarOverlayHeaderPanelContentTagDirective, UxLayoutNavBarItemContentTagDirective, UxLayoutNavBarActionItemComponentModule, UxLayoutNavBarLeftActionItemComponent, UxLayoutNavBarLeftActionItemComponentModule, UxLayoutNavBarActionItemNotificationsComponent, UxLayoutNavBarActionItemNotificationsComponentModule, UxAppComponent, UxAppModule, UxLayoutBreadcrumbsComponent, UxLayoutBreadcrumbsComponentModule, UxBreadcrumbsService, UxLayoutOverlayPanelComponent, UxLayoutOverlayPanelComponentModule, UxLayoutTopMessageComponent, UxLayoutTopMessageComponentModule, UxLayoutBannerComponent, UxLayoutBannerComponentModule, UxLayoutHorizontalComponent, UxLayoutHorizontalLeftTagDirective, UxLayoutHorizontalRightTagDirective, UxLayoutHorizontalCenterTagDirective, UxLayoutHorizontalModule, UxLayoutPageHeaderComponent, UxLayoutPageHeaderActionsContentTagDirective, UxLayoutPageHeaderActionIconsContentTagDirective, UxLayoutPageHeaderComponentModule, UxLayoutPageHeaderActionIconItemComponent, UxLayoutPageHeaderActionIconItemComponentModule, UxLayoutFooterActionBarComponent, UxLayoutFooterActionBarContentTagDirective, UxLayoutFooterActionBarComponentModule, UxLayoutFlexContentComponent, UxLayoutFlexContentModule, UxLanguageSelectorComponent, UxLanguageSelectorComponentModule, UxLanguage, UxEuLanguages, UxSearchInputComponent, UxSearchInputComponentModule, UxTagComponent, UxTagComponentModule, UxIconComponent, UxIconComponentModule, UxIconToggleComponent, UxIconToggleComponentModule, UxIconBoxComponent, UxIconBoxComponentModule, UxMarkerComponent, UxMarkerComponentModule, UxLabelComponent, UxLabelContentTagDirective, UxLabelSubLabelTagDirective, UxLabelComponentModule, UxDateTagComponent, UxDateTagComponentModule, UxToolbarFilterComponent, UxToolbarFilterButtonsTagDirective, UxToolbarFilterComponentModule, UxBlockDocumentComponent, UxBlockDocumentComponentModule, UxBlockContentComponent, UxBlockContentComponentModule, UxDisableContentComponent, UxDisableContentComponentModule, UxProgressCircleComponent, UxProgressCircleComponentModule, UxPanelComponent, UxPanelHeaderTagDirective, UxPanelFooterTagDirective, UxPanelHeaderRightContentTagDirective, UxPanelHeaderWithDescendantsTagDirective, UxPanelFooterWithDescendantsTagDirective, UxPanelHeaderRightContentWithDescendantsTagDirective, UxPanelHeaderStatusIndicatorContentTagDirective, UxPanelSubHeaderContentTagDirective, UxPanelComponentModule, UxPanelsComponent, UxPanelsComponentModule, UxActionBoxComponent, UxActionBoxComponentModule, UxActionBoxItem, UxAlertComponent, UxAlertComponentModule, UxDashboardCardComponent, UxDashboardCardComponentModule, UxControlFeedbackComponent, UxControlFeedbackComponentModule, UxFieldSearchComponent, UxFieldSearchFilterContentTagDirective, UxFieldSearchComponentModule, UxFieldsetComponent, UxFieldsetLabelRightContentTagDirective, UxFieldsetComponentModule, UX_SWITCH_VALUE_ACCESSOR, UxSwitchComponent, UxSwitchComponentModule, UxBadgeComponent, UxBadgeComponentModule, UxBadgeGroupComponent, UxBadgeGroupComponentModule, UxButtonComponent, UxButtonComponentModule, UX_DROPDOWNBUTTON_VALUE_ACCESSOR, UxDropdownButtonComponent, UxDropdownButtonComponentModule, UxDropdownButtonItemComponent, UxDropdownButtonItemComponentModule, UxDropdownComponent, UxDropdownComponentModule, UxGrowlComponent, UxGrowlComponentModule, UxDashboardButtonsComponent, UxDashboardButtonsComponentModule, UxDashboardButtonComponent, UxDashboardButtonComponentModule, UxTabComponent, UxTabComponentModule, UxTabsComponent, UxTabsRightContentTagDirective, UxTabsComponentModule, UxTab, UxTabService, UxTabsBarComponent, UxTabsBarRightContentTagDirective, UxTabsBarComponentModule, UxStaticTabsComponent, UxStaticTabsComponentModule, UxTimelineItemsComponent, UxTimelineItemsComponentModule, UxTimelineItemComponent, UxTimelineItemComponentModule, UxWizardStepComponent, UxWizardStepContentTagDirective, UxWizardStepComponentModule, UxWizardStepsComponent, UxWizardStepsComponentModule, UxWizardStep, UxWizardStepService, UxTreeListComponent, UxTreeListToolbarContentTagDirective, UxTreeListComponentModule, UxTreeListItemComponent, UxTreeListItemCustomContentTagDirective, UxTreeListItemRightContentTagDirective, UxTreeListItemSubLabelTagDirective, UxTreeListItemDetailsContentTagDirective, UxTreeListItemSubContainerContentTagDirective, UxTreeListItemComponentModule, UxModalComponent, UxModalBodyTagDirective, UxModalFooterTagDirective, UxModalHeaderTagDirective, UxModalComponentModule, UxCarouselItemComponent, UxCarouselItemComponentModule, UxCarouselItemsComponent, UxCarouselItemsComponentModule, UxTreeNodeComponent, UxTreeComponent, UxTreeComponentModule, UxTimebarItemUI, UxTimebarComponent, UxTimebarComponentModule, UxTimebarItem, UxAutocompleteTagItem, UX_AUTOCOMPLETETAG_VALUE_ACCESSOR, UxAutocompleteTagComponent, UxAutocompleteTagComponentModule, UxButtonGroupComponent, UxButtonGroupComponentModule, UxButtonGroupItemComponent, UxButtonGroupItemComponentModule, UxSplitButtonComponent, UxSplitButtonComponentModule, UxMessageBoxComponent, UxMessageBoxFooterTagDirective, UxMessageBoxComponentModule, UxOverlayComponent, UxOverlayComponentModule, UxNotificationItemComponent, UxNotificationItemComponentModule, UxNotificationsPanelComponent, UxNotificationsPanelComponentModule, UxStickyComponent, UxStickyComponentModule, UxPieChartComponent, UxPieChartCustomLegendTagDirective, UxPieChartComponentModule, UxPieChartLegendItemComponent, UxPieChartLegendItemComponentModule, UxPieChartGroupComponent, UxPieChartGroupComponentModule, UxDynamicMessageBoxService, UxDynamicMessageBoxComponent, UxDynamicMessageBoxComponentModule, UxDynamicMessageBoxConfig, UxDynamicModalComponent, UxDynamicModalBodyTagDirective, UxDynamicModalFooterTagDirective, UxDynamicModalHeaderTagDirective, UxDynamicMessageBoxFooterTagDirective, UxDynamicModalComponentModule, UxDynamicModalService, UxItemComponent, UxItemComponentModule, UxListItemComponent, UxListItemSubLabelTagDirective, UxListtemContentTagDirective, UxListItemComponentModule, UxListItemsComponent, UxListItemsComponentModule, UxMenuItemComponent, UxMenuItemComponentModule, UxLoadingIndicatorComponent, UxLoadingIndicatorComponentModule, placementServiceFactory$1 as placementServiceFactory, UxPopoverComponentModule, UxPopoverComponent, UxDiscussionThreadComponent, UxDiscussionThreadComponentModule, UxDiscussionThreadItemComponent, UxDiscussionThreadItemComponentModule, UxDiscussionThreadItem, UxFormControlComponent, UxFormControlComponentModule, UxFormGroupComponent, UxFormGroupSubContentTagDirective, UxFormGroupComponentModule, UxDynamicPopoverService, UxDynamicPopoverConfig, UxFilterResultsComponent, UxFilterResultsNavigationContentTagDirective, UxFilterResultsFilterContentTagDirective, UxFilterResultsQuickFilterContentTagDirective, UxFilterResultsHeaderContentTagDirective, UxFilterResultsContentTagDirective, UxFilterResultsFullContentTagDirective, UxFilterResultsComponentModule, EDITOR_VALUE_ACCESSOR, UxEditorComponent, UxEditorComponentModule, UxErrorOutputComponent, UxErrorOutputComponentModule, UxMessage, UxButtonConfig, UxDynamicModalConfig, UxModule, UxAllModule, RectangleFactory as ɵbv, GeometryModule as ɵby, placementServiceFactory as ɵbx, Rectangle as ɵbu, PlacementService as ɵbs, BottomLeftPlacementStrategy as ɵcd, BottomPlacementStrategy as ɵcb, LeftPlacementStrategy as ɵbz, RightPlacementStrategy as ɵcc, TopPlacementStrategy as ɵca, UxLayoutFooterAppInfosTagDirective as ɵz, UxLayoutFooterComponent as ɵy, UxLayoutFooterComponentModule as ɵbb, UxLayoutFooterLinksTagDirective as ɵba, UxLayoutHeaderComponent as ɵr, UxLayoutHeaderComponentModule as ɵv, UxLayoutHeaderRightContentTagDirective as ɵs, UxLayoutHeaderTitleContentTagDirective as ɵu, UxLayoutHeaderUserProfileLinksTagDirective as ɵt, UxLayoutNavBarActionsComponent as ɵbg, UxLayoutNavBarActionsComponentModule as ɵbh, UxLayoutNavBarLeftActionItemSidebarToggleComponent as ɵbi, UxLayoutNavBarLeftActionItemSidebarToggleComponentModule as ɵbj, UxLayoutNavBarLeftActionsComponent as ɵbk, UxLayoutNavBarLeftActionsComponentModule as ɵbl, UxLayoutNavBarTopMenuComponent as ɵbm, UxLayoutNavBarTopMenuComponentModule as ɵbn, UxLayoutNavBarComponent as ɵbc, UxLayoutNavBarComponentModule as ɵbf, UxLayoutNavBarElementsContentTagDirective as ɵbd, UxLayoutNavBarLeftActionsContentTagDirective as ɵbe, UxLayoutSidebarComponent as ɵbo, UxLayoutSidebarComponentModule as ɵbr, UxLayoutSidebarContentTagDirective as ɵbq, UxLayoutSidebarHeaderTagDirective as ɵbp, UxCardItemCellComponent as ɵco, UxCardItemComponent as ɵcn, UxCardItemCustomContentTagDirective as ɵcl, UxCardItemsComponent as ɵck, UxCardItemsComponentModule as ɵcm, PopoverService$1 as ɵcj, UxDynamicOpenedPopoverService as ɵcf, UxDynamicPopoverComponent as ɵci, UxDynamicPopoverComponentModule as ɵch, placementServiceFactory$2 as ɵcg, UxItemConfig as ɵw, UxListItemConfig as ɵx, UxMenuItemConfig as ɵbw, PopoverService as ɵce, AppService as ɵm, EnvConfigService as ɵn, APP_CONFIG_TOKEN as ɵj, ENVIRONMENT_TOKEN as ɵk, OptionalDeps as ɵa, errorFeedbackServiceFactory as ɵi, localizationServiceFactory as ɵh, providersModule as ɵb, storeServiceFactory as ɵc, uxAuthGuardServiceFactory as ɵe, uxAuthServiceFactory as ɵd, uxDynamicMenuServiceFactory as ɵg, uxPermissionsServiceFactory as ɵf, UxRequestErrorModelInterceptor as ɵo, initApp as ɵp, AppEffects as ɵl, RoutesEffects as ɵq };
