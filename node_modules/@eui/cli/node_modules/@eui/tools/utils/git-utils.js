const execa = require('execa');
const path = require('path');

const utils = require('./utils');

var execaOptions;

const extractCommits = (opts) => {

  const SEPARATOR = '===END===';
  const COMMIT_PATTERN = /^(\w*)(?:\((.*)\))?\: (.*)$/;
  const ISSUE_PATTERN = /((?!([A-Z0-9a-z]{1,10})-?$)[A-Z]{1}[A-Z0-9]+-\d+)/g;
  const FORMAT = '%H%n%s%n%ad%n%an%n%b%n%f%n' + SEPARATOR;

  const DEFAULT_OPTS = {
    fromTag: null,
    allRevisions: false,
    toTag: 'HEAD',
    logAll: true,
    cwd: path.resolve(process.cwd()),
  };

  opts = Object.assign(DEFAULT_OPTS, opts);

  execaOptions = { cwd: opts.cwd };

  return Promise.resolve()
    .then(() => {
      var tag;

      if (opts.fromTag) {
        tag = opts.fromTag;
      } else {
        if (opts.allRevisions) {
          tag = null;
        } else {
          tag = getLastTag();
        }
      }
      return tag;
    })
    .then((tag) => {
      var revisions;

      if (tag) {
        tag = tag.toString().trim();
        revisions = tag ? tag + '..' + opts.toTag : '';

        if (opts.logAll) utils.logInfo('git log command : ' + 'git log -E --date=short --format=' + FORMAT + ' ' + revisions);
        return execa.sync('git', ['log', '-E', '--date=short', '--format=' + FORMAT, revisions], execaOptions).stdout;
      } else {
        if (opts.logAll) utils.logInfo('git log command : ' + 'git log -E --date=short --format=' + FORMAT);
        return execa.sync('git', ['log', '-E', '--date=short', '--format=' + FORMAT], execaOptions).stdout;
      }
    })
    .then((commits) => {
      return commits.split('\n' + SEPARATOR + '\n');
    })
    .then((raws) => {
      return raws.map((raw) => {
        if (!raw) {
          return null;
        }

        var lines = raw.split('\n');
        var commit = {};
        var parsedMessage;

        commit.hash = lines[0];
        commit.subject = lines[1];
        commit.date = lines[2];
        commit.user = lines[3];
        commit.body = lines[4];

        commit.breakingChange = false;

        if (commit.body) {
          var parsedIssueBody = commit.body.match(ISSUE_PATTERN);
          if (parsedIssueBody) {
            commit.issue = parsedIssueBody[0];
          }
          if (commit.body.indexOf('BREAKING CHANGE') !== -1) {
            commit.breakingChange = true;
          }
        }

        if (opts.logAll) utils.logInfo('parsing commit : ' + commit.date + ' ==> ' + commit.subject);

        commit.originalSubject = commit.subject;

        var parsed = commit.subject.match(COMMIT_PATTERN);
        var parsedIssue = commit.subject.match(ISSUE_PATTERN);

        if (!parsed || !parsed[1]) {
          if (commit.subject.indexOf('Merge pull request') === -1 &&
            commit.subject.indexOf('Merge branch') === -1 &&
            commit.subject.indexOf('Merge remote-tracking branch') === -1) {
            utils.logError('INVALID COMMIT MESSAGE FORMAT : ' + formatCommit(commit));
          }
          return null;
        }

        commit.type = parsed[1].toLowerCase();
        if (parsed[2] !== undefined) {
          commit.category = parsed[2].substr(0) || '';
        }
        commit.subject = parsed[3];

        if (parsedIssue) {
          commit.issue = parsedIssue[0];
        }

        if (!commit.issue) {
          commit.issue = '';
        }

        if (commit.type === 'chore' && commit.category === 'release') {
          return null;
        }

        utils.logSuccess('VALID COMMIT MESSAGE : ' + formatCommit(commit));

        return commit;
      })
    })
    .then((parsedCommits) => {
      return parsedCommits.filter((commit) => {
        if (!commit) {
          return false;
        }
        return commit;
      })
    })
    .then((finalCommits) => {
      return utils.removeArrayDuplicates(finalCommits, 'subject');
    })
    .catch((e) => {
      throw e;
    })
};

const getLastTag = () => {
  return Promise.resolve()
    .then(() => {
      var tag;
      try {
        tag = execa.sync('git', ['describe', '--tags', '--abbrev=0'], execaOptions).stdout
      } catch (e) {
        tag = null;
      }
      return tag;
    })
    .catch((e) => {
      throw e;
    });
}

const formatCommit = (commit) => {
  const issueString = commit.issue ? commit.issue : 'NOT PROVIDED';
  return `${commit.date} => issue: ${issueString} - ${commit.originalSubject} by ${commit.user}`;
}

const getRepoUrl = () => {
  return Promise.resolve()
    .then(() => {
      const repoUrl = execa.sync('git', ['config', '--get', 'remote.origin.url'], execaOptions).stdout;
      const atLocation = repoUrl.indexOf('@');
      if (atLocation > -1) {
        return repoUrl.substr(0, 8) + repoUrl.substr(atLocation + 1);
      } else {
        return repoUrl;
      }
    })
    .catch((e) => {
      console.log(e);
      process.exit(1);
    })
}

const getShortHash = () => {
  return Promise.resolve()
    .then(() => {
      return execa.sync('git', ['rev-parse', '--short', 'HEAD'], execaOptions).stdout;
    })
    .catch((e) => {
      console.log(e);
      process.exit(1);
    })
}

module.exports.extractCommits = extractCommits;
module.exports.getShortHash = getShortHash;
module.exports.getRepoUrl = getRepoUrl;
