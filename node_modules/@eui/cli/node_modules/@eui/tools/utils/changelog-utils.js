'use strict';

const path = require('path');
const fs = require('fs');

const gitUtils = require('./git-utils');

const utils = require('./utils');

var DEFAULT_TYPE = 'other';
var DEFAULT_CATEGORY = 'other';

var TYPES = {
  build: 'Build System / Dependencies',
  ci: 'Continuous Integration',
  chore: 'Chores',
  docs: 'Documentation Changes',
  feat: 'New Features',
  fix: 'Bug Fixes',
  other: 'Other Changes',
  perf: 'Performance Improvements',
  refactor: 'Refactors',
  revert: 'Reverts',
  style: 'Code Style Changes',
  test: 'Tests',
  breakingChange: 'BREAKING CHANGES',
  break: 'BREAKING CHANGES'
};

module.exports.generate = function (version, commits) {

  var content = [];
  var date = new Date().toJSON().slice(0, 10);
  var heading = '##';

  var repoUrl;

  heading += ' ' + version + ' (' + date + ')';

  content.push(heading);
  content.push('');

  return Promise.resolve()
    .then(() => {
      return gitUtils.getRepoUrl();
    })
    .then((repoUrlFound) => {
      repoUrl = repoUrlFound;
    })
    .then(() => {
      var types = {}

      commits.forEach((commit) => {
        var type = TYPES[commit.type] ? commit.type : DEFAULT_TYPE;

        if (commit.body && commit.body.indexOf('BREAKING CHANGE') !== -1) {
          type = 'breakingChange';
        }
        var category = commit.category ? commit.category : DEFAULT_CATEGORY;

        types[type] = types[type] || {};
        types[type][category] = types[type][category] || [];
        types[type][category].push(commit);
      })

      return types;
    })
    .then((rawTypes) => {
      var types = rawTypes;

      Object.keys(rawTypes).sort().forEach((type) => {

        content.push('##### ' + TYPES[type]);
        content.push('');

        Object.keys(rawTypes[type]).forEach(function (category) {
          var prefix = '*';
          var nested = types[type][category].length > 1;
          var categoryHeading = prefix + (category ? ' **' + category + ':**' : '');

          content.push(categoryHeading);
          prefix = '  *';

          types[type][category].forEach(function (commit) {

            var shorthash = commit.hash.substring(0, 8);
            if (repoUrl) {
              shorthash = '[' + shorthash + '](' + repoUrl + '/commits/' + commit.hash + ')';
            }

            var issueString = '';
            if (commit.issue) {
              issueString += '[' + commit.issue + '](https://webgate.ec.europa.eu/CITnet/jira/browse/' + commit.issue + ') ';
            }

            content.push(prefix + ' ' + commit.subject + ' ' + issueString + ' (' + shorthash + ')');
          });
        });

      });
    })
    .then(() => {
      content.push('');
      content.push('* * *');
      content.push('* * *');
      content.push('');
      return content.join('\n');
    })
    .catch((e) => {
      throw e;
    });
}

module.exports.writeChangelog = (changelogContent, outputPath) => {
  return Promise.resolve()
    .then(() => {
      utils.logInfo('writing changelog markdown...');
      utils.logInfo(changelogContent);

      var changelogFile;
      if (!outputPath) {
        changelogFile = path.join(process.cwd(), 'CHANGELOG.md');
      } else {
        changelogFile = path.join(outputPath, 'CHANGELOG.md');
      }

      if (fs.existsSync(changelogFile)) {
        const data = fs.readFileSync(changelogFile);
        const fd = fs.openSync(changelogFile, 'w+');
        const buffer = new Buffer(changelogContent);

        fs.writeSync(fd, buffer, 0, buffer.length, 0);
        fs.writeSync(fd, data, 0, data.length, buffer.length);
        fs.close(fd);
      } else {
        fs.writeFileSync(changelogFile, changelogContent);
      }
    })
}
