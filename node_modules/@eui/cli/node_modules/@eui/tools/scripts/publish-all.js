'use strict';

const path = require('path');
const chalk = require('chalk');
const arrify = require('arrify');

const { publishMultipleRegistries, aliases, defaultRegistry } = require('./publish.helpers');
const config = require('../config/project');
const paths = require('../config/paths')({ isRoot: true });
const { listPackages: pkgToArray } = require('./utils/packages');

const { registry, packages } = config;

/**
 * Filter out packages that should not be published
 */
const  listPackages = pkgToArray().filter(p => p.inPublishAll !== false);

/**
 * Publish packages to the registries
 */
const publishPackagesRegistries = (_registries, options = {}) => {
    return listPackages.reduce((promise, pkg) => {
        const folder = packages[pkg.name].folder || pkg.name;
        const pkgFolder = path.resolve(paths.packages, folder);

        let registries;
        if (options.forceRegistry !== true && typeof packages[pkg.name].registry !== 'undefined') {
            /**
             * If the package has a "registry" declared, use it... Unless "forceRegistry" has been set to true.
             */
            registries = arrify(packages[pkg.name].registry);
        } else {
            registries = _registries;
        }
        return promise.then(() => publishMultipleRegistries(registries, pkg.name, pkgFolder, { log: false }))
    }, Promise.resolve())
    .then(() => {
        console.log('----------------------------------------------');
        console.log('All packages published!');
        console.log('----------------------------------------------');
    })
    .catch(() => {
        process.exit(1);
    });
};

if (listPackages.length > 0) {
    console.log('----------------------------------------------');
    console.log(chalk.cyan(`Publishing ALL packages (total: ${listPackages.length})\n[${listPackages.map(p => p.name)}]`));
    console.log('----------------------------------------------');

    /**
     * Publish on registry provided through command argument
     * ex: npm run publish-all -- --registry=https://my-registry.com
     */
    if (typeof registry !== 'undefined') {
        return publishPackagesRegistries([registry], { forceRegistry: true });
    }

    /**
     * Publish on *SOME* registries
     * ex: npm run publish-all -- --diplazium --ecdevops
     */
    if (aliases) {
        const registries = Object.keys(aliases);
        const listRegistries = [];

        Object.keys(config).forEach((k) => {
            if (registries.indexOf(k) >= 0) {
                listRegistries.push(aliases[k].uri);
            }
        });

        if (listRegistries.length > 0) {
            return publishPackagesRegistries(listRegistries, { forceRegistry: true });
        }
    }

    /**
     * Publish to ALL registries or fallback to "default"
     * ex: npm run publish-all
     */
    let registries;
    if (aliases && Object.keys(aliases).filter(k => aliases[k].inPublishAll !== false).length > 0) {
        registries = aliases;
    } else {
        registries = defaultRegistry && { default: config.npm.registry.default };
    }

    if (!registries) {
        console.log(chalk.red(`Trying to publish package "${pkgInfo.pkg}" on *all* registries but registry setting not found.`));
        return;
    }

    const listRegistries = Object.keys(registries)
        .map(k => registries[k])
        .filter(r => r.inPublishAll !== false)
        .map(r => r.uri);

    return publishPackagesRegistries(listRegistries);;
}

console.log('No packages to publish.');
