'use strict';

var Bluebird = require('bluebird');

var DEFAULT_TYPE = 'other';
var TYPES = {
  build: 'Build System / Dependencies',
  ci: 'Continuous Integration',
  chore: 'Chores',
  docs: 'Documentation Changes',
  feat: 'New Features',
  fix: 'Bug Fixes',
  other: 'Other Changes',
  perf: 'Performance Improvements',
  refactor: 'Refactors',
  revert: 'Reverts',
  style: 'Code Style Changes',
  test: 'Tests',
  breakingChange: 'BREAKING CHANGES',
  break: 'BREAKING CHANGES'
};

/**
 * Generate the markdown for the changelog.
 * @param {String} version - the new version affiliated to this changelog
 * @param {Array<Object>} commits - array of parsed commit objects
 * @param {Object} options - generation options
 * @param {Boolean} options.patch - whether it should be a patch changelog
 * @param {Boolean} options.minor - whether it should be a minor changelog
 * @param {Boolean} options.major - whether it should be a major changelog
 * @param {String} options.repoUrl - repo URL that will be used when linking commits
 * @returns {Promise<String>} the \n separated changelog string
 */
exports.markdown = function (version, commits, options) {
  var content = [];
  var date = new Date().toJSON().slice(0,10);
  var heading = '##';

  heading += ' ' + version + ' (' + date + ')';

  content.push(heading);
  content.push('');

  return Bluebird.resolve(commits)
  .bind({ types: {} })
  .each(function (commit) {
    var type = TYPES[commit.type] ? commit.type : DEFAULT_TYPE;
    if (commit.footer && commit.footer.indexOf('BREAKING CHANGE') !== -1) {
        type = 'breakingChange';
    }
    var category = commit.category;

    this.types[type] = this.types[type] || {};
    this.types[type][category] = this.types[type][category] || [];

    this.types[type][category].push(commit);
  })
  .then(function () {
    return Object.keys(this.types).sort();
  })
  .each(function (type) {
    var types = this.types;

    content.push('##### ' + TYPES[type]);
    content.push('');

    Object.keys(this.types[type]).forEach(function (category) {
      var prefix = '*';
      var nested = types[type][category].length > 1;
      var categoryHeading = prefix + (category ? ' **' + category + ':**' : '');

      content.push(categoryHeading);
      prefix = '  *';

      types[type][category].forEach(function (commit) {
        var shorthash = commit.hash.substring(0, 8);

        if (options.repoUrl) {
          shorthash = '[' + shorthash + '](' + options.repoUrl + '/commits/' + commit.hash + ')';
        }

        var issuesString = '';
        if (commit.body.indexOf('UXATEC-') > -1 || commit.body.indexOf('EUI-') > -1) {
            var issues = commit.body.split(' ');
            issues.forEach(function(issue) {
                issuesString += '[' + issue + '](https://webgate.ec.europa.eu/CITnet/jira/browse/' + issue + ') ';
            });
        }

        if (commit.footer && commit.footer !== 'undefined' && type !== 'breakingChange') {
            content.push(prefix + ' ' + commit.subject + '\n' + commit.footer + ' ' + issuesString + ' (' + shorthash + ')');
        }
        if (!commit.footer || commit.footer === 'undefined') {
            content.push(prefix + ' ' + commit.subject + ' ' + issuesString + ' (' + shorthash + ')');
        }

        if (type === 'breakingChange') {
            content.push('    * ' + commit.footer.substr(17));
        }
      });
    });

  })
  .then(function () {
    content.push('');
    content.push('* * *');
    content.push('* * *');
    content.push('');
    return content.join('\n');
  });
};
