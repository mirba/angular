'use strict';

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const camelCase = require('camelcase');
const rollup = require('rollup');
const uglify = require('rollup-plugin-uglify');
const sourcemaps = require('rollup-plugin-sourcemaps');
const execa = require('execa');
const chalk = require('chalk');
const ngc = require('@angular/compiler-cli/src/main').main;
// const replace = require('replace-in-file');

const tools = require('./tools');
const inlineResources = require('./inline-resources');
const utilsPackages = require('./utils/packages');

const pkgInfo = utilsPackages.getPackage();
const paths = require('../config/paths')(pkgInfo);
const config = require('../config/project');
const GLOBALS = require('../config/rollup.globals');

const { pkg } = pkgInfo;
const { pkgDirectory } = paths;
const externalsProject = config.build && config.build.externals || {};
const globals = Object.assign({}, GLOBALS, externalsProject);

const libNameWithScope = require(path.join(pkgDirectory, 'package.json')).name;
const libName = libNameWithScope.slice(libNameWithScope.indexOf('/') + 1);
const srcFolder = paths.pkgLibFolder;
const distFolder = paths.pkgBuild;
const compilationFolder = path.join(pkgDirectory, 'out-tsc');
const tempLibFolder = path.join(compilationFolder, 'lib');
const es5OutputFolder = path.join(compilationFolder, 'lib-es5');
const es2015OutputFolder = path.join(compilationFolder, 'lib-es2015');

const angular = require('@angular/core/package.json');
const angularVersion = parseInt(angular.version.slice(0, 1), 10);

return Promise.resolve()
    // Copy library to temporary folder, compile sass files and inline html/css.
    .then(() => Promise.resolve()
        .then(() => console.log('---- Copying to temp folder...'))
        .then(() => tools.relativeCopy(`**/*`, srcFolder, tempLibFolder))
        .then(() => console.log(chalk.green('------> OK')))
    )
    // Copy library to temporary folder, compile sass files and inline html/css.
    .then(() => Promise.resolve()
        .then(() => console.log('---- Compiling SASS...'))
        .then(() => compileSassFiles(tempLibFolder))
        .then(() => inlineResources(tempLibFolder))
        .then(() => console.log(chalk.green('------> OK')))
    )
    // Compile to ES2015.
    .then(() => {
        console.log('---- Compiling to ES2015...');
        return Promise.resolve(ngcCompile(`${tempLibFolder}/tsconfig.lib.json`))
            .then(exitCode => exitCode === 0 ? Promise.resolve() : Promise.reject())
            .then(() => console.log(chalk.green('------> OK')));
    })
    // Compile to ES5.
    .then(() => {
        console.log('---- Compiling to ES5...');
        return Promise.resolve(ngcCompile(`${tempLibFolder}/tsconfig.es5.json`))
            .then(exitCode => exitCode === 0 ? Promise.resolve() : Promise.reject())
            .then(() => console.log(chalk.green('------> OK')));
    })
    // Copy typings and metadata to `dist/` folder.
    .then(() => {
        console.log('---- Copying typings and metadata...');
        return Promise.resolve()
            .then(() => tools.relativeCopy('**/*.d.ts', es2015OutputFolder, distFolder))
            .then(() => tools.relativeCopy('**/*.metadata.json', es2015OutputFolder, distFolder))
            .then(() => console.log(chalk.green('------> OK')))
    })
    // Bundle lib.
    .then(() => {
        // Base configuration.
        console.log(`Creating bundles... (libname: ${libName})`);
        const es5Entry = path.join(es5OutputFolder, `${libName}.js`);
        const es2015Entry = path.join(es2015OutputFolder, `${libName}.js`);
        const rollupBaseConfig = {
            output: {
                name: camelCase(libName),
                globals: GLOBALS,
                sourcemap: true,
            },
            external: Object.keys(GLOBALS),
            plugins: [
                {
                    name: 'replace moment imports',
                    transform: code =>
                    ({
                        code: code.replace(/import\s*\*\s*as\s*moment/g, 'import moment'),
                        map: { mappings: '' }
                    })
                },
                {
                    name: 'replace extend imports',
                    transform: code =>
                    ({
                        code: code.replace(/import\s*\*\s*as\s*extend/g, 'import extend'),
                        map: { mappings: '' }
                    })
                },
                sourcemaps(),
            ],
            onwarn: function (warning) {
                if (warning.code === 'THIS_IS_UNDEFINED') {
                    return;
                }
                console.error(warning.message);
            }
        };

        // UMD bundle.
        const umdConfig = Object.assign({}, rollupBaseConfig, {
            input: es5Entry,
            file: path.join(distFolder, `bundles`, `${libName}.umd.js`),
            output: Object.assign({}, rollupBaseConfig.output, { format: 'umd' }),
        });

        // Minified UMD bundle.
        const minifiedUmdConfig = Object.assign({}, rollupBaseConfig, {
            input: es5Entry,
            file: path.join(distFolder, `bundles`, `${libName}.umd.min.js`),
            output: Object.assign({}, rollupBaseConfig.output, { format: 'umd' }),
            plugins: rollupBaseConfig.plugins.concat([uglify.uglify({})])
        });

        // ESM+ES5 flat module bundle.
        const fesm5config = Object.assign({}, rollupBaseConfig, {
            input: es5Entry,
            file: path.join(distFolder, `${libName}.es5.js`),
            output: Object.assign({}, rollupBaseConfig.output, { format: 'es' }),
        });

        // ESM+ES2015 flat module bundle.
        const fesm2015config = Object.assign({}, rollupBaseConfig, {
            input: es2015Entry,
            file: path.join(distFolder, `${libName}.js`),
            output: Object.assign({}, rollupBaseConfig.output, { format: 'es' }),
        });

        const allBundles = [
            umdConfig,
            minifiedUmdConfig,
            fesm5config,
            fesm2015config
        ].map((cfg) => {
            return rollup.rollup(cfg)
                .then((bundle) => {
                    return bundle.write(cfg);
                });
        });

        return Promise.all(allBundles)
            .then(() => console.log(chalk.green('==> All bundles generated successfully.')));
    })
    // Copy package files
    .then(() => Promise.resolve()
        .then(() => tools.relativeCopy('LICENSE', pkgDirectory, distFolder))
        .then(() => tools.relativeCopy('README.md', pkgDirectory, distFolder))
        .then(() => tools.relativeCopy('./assets/**/*.*', pkgDirectory, distFolder))
        .then(() => console.log('Package files copy succeeded.'))
    )
    .catch(e => {
        console.error('\Build failed. See below for errors.\n');
        console.error(e);
        process.exit(1);
    });

// Compile Sass files
function compileSassFiles(tempLibFolder) {
    return execa('node-sass', [
        tempLibFolder,
        '-o', tempLibFolder,
        '--output-style',
        'compressed',
        '--source-map',
        true,
        '--source-map-contents'
    ]).catch((err) => {
        if (err.stderr !== 'No input file was found.\n') {
            console.log('[Node Sass Error]', err);
            throw err;
        }
    });
}

function ngcCompile(tsconfig) {
    if (angularVersion === 4) {
        return ngc({ project: tsconfig });
    }
    return ngc(['-p', `${tsconfig}`]);
}

// module.exports.run = run;

// function run(package, inputOpt) {

//     const DEFAULT_OPTS = {
//         externals: {},
//         rootPath: path.resolve(process.cwd()),
//         packageRootPath: 'src/packages/'
//     };

//     const opt = Object.assign(DEFAULT_OPTS, inputOpt);

//     const globals = Object.assign(GLOBALS, opt.externals);

//     if (!package) {
//         console.log('ERROR : no package specified!!!');
//         return;
//     }

//     const packagePath = path.join(opt.rootPath, opt.packageRootPath, package);

//     const libNameWithScope = require(path.join(packagePath, 'package.json')).name;
//     const libName = libNameWithScope.slice(libNameWithScope.indexOf('/') + 1);
//     // const libName = package;
//     const compilationFolder = path.join(packagePath, 'out-tsc');
//     const srcFolder = path.join(packagePath, 'src/lib');
//     const distFolder = path.join(packagePath, 'dist');
//     const tempLibFolder = path.join(compilationFolder, 'lib');
//     const es5OutputFolder = path.join(compilationFolder, 'lib-es5');
//     const es2015OutputFolder = path.join(compilationFolder, 'lib-es2015');

//     return Promise.resolve()
//         // Copy library to temporary folder, compile sass files and inline html/css.
//         .then(() => Promise.resolve()
//             .then(() => console.log('---- Copying to temp folder...'))
//             .then(() => tools.relativeCopy(`**/*`, srcFolder, tempLibFolder))
//             .then(() => console.log(chalk.green('------> OK')))
//         )
//         // Copy library to temporary folder, compile sass files and inline html/css.
//         .then(() => Promise.resolve()
//             .then(() => console.log('---- Compiling SASS...'))
//             .then(() => compileSassFiles(tempLibFolder))
//             .then(() => inlineResources(tempLibFolder))
//             .then(() => console.log(chalk.green('------> OK')))
//         )
//         // Compile to ES2015.
//         .then(() => {
//             console.log('---- Compiling to ES2015...');
//             tools.runScript(`ngc -p ${tempLibFolder}/tsconfig.json`)
//             console.log(chalk.green('------> OK'));
//         })
//         // Compile to ES5.
//         .then(() => {
//             console.log('---- Compiling to ES5...');
//             tools.runScript(`ngc -p ${tempLibFolder}/tsconfig.es5.json`)
//             console.log(chalk.green('------> OK'));
//         })
//         // Copy typings and metadata to `dist/` folder.
//         .then(() => Promise.resolve()
//             .then(() => console.log('---- Copying typings and metadata...'))
//             .then(() => tools.relativeCopy('**/*.d.ts', es2015OutputFolder, distFolder))
//             .then(() => tools.relativeCopy('**/*.metadata.json', es2015OutputFolder, distFolder))
//             .then(() => console.log(chalk.green('------> OK')))
//         )
//         // Bundle lib.
//         .then(() => {
//             // Base configuration.
//             const es5Entry = path.join(es5OutputFolder, `${libName}.js`);
//             const es2015Entry = path.join(es2015OutputFolder, `${libName}.js`);
//             const rollupBaseConfig = {
//                 moduleName: camelCase(libName),
//                 sourceMap: true,
//                 globals: GLOBALS,
//                 external: Object.keys(globals),
//                 plugins: [
//                     {
//                         name: 'replace moment imports',
//                         transform: code =>
//                         ({
//                             code: code.replace(/import\s*\*\s*as\s*moment/g, 'import moment'),
//                             map: { mappings: '' }
//                         })
//                     },
//                     {
//                         name: 'replace extend imports',
//                         transform: code =>
//                         ({
//                             code: code.replace(/import\s*\*\s*as\s*extend/g, 'import extend'),
//                             map: { mappings: '' }
//                         })
//                     },
//                     sourcemaps()
//                 ],
//                 onwarn: function (warning) {
//                     if (warning.code === 'THIS_IS_UNDEFINED') {
//                         return;
//                     }
//                     console.warn(warning.message);
//                 }
//             };

//             // UMD bundle.
//             const umdConfig = Object.assign({}, rollupBaseConfig, {
//                 entry: es5Entry,
//                 dest: path.join(distFolder, `bundles`, `${libName}.umd.js`),
//                 format: 'umd',
//             });

//             // Minified UMD bundle.
//             const minifiedUmdConfig = Object.assign({}, rollupBaseConfig, {
//                 entry: es5Entry,
//                 dest: path.join(distFolder, `bundles`, `${libName}.umd.min.js`),
//                 format: 'umd',
//                 plugins: rollupBaseConfig.plugins.concat([uglify({})])
//             });

//             // ESM+ES5 flat module bundle.
//             const fesm5config = Object.assign({}, rollupBaseConfig, {
//                 entry: es5Entry,
//                 dest: path.join(distFolder, `${libName}.es5.js`),
//                 format: 'es'
//             });

//             // ESM+ES2015 flat module bundle.
//             const fesm2015config = Object.assign({}, rollupBaseConfig, {
//                 entry: es2015Entry,
//                 dest: path.join(distFolder, `${libName}.js`),
//                 format: 'es'
//             });

//             const allBundles = [
//                 umdConfig,
//                 minifiedUmdConfig,
//                 fesm5config,
//                 fesm2015config
//             ].map(cfg => rollup.rollup(cfg).then(bundle => bundle.write(cfg)));

//             return Promise.all(allBundles)
//                 .then(() => console.log(chalk.green('==> All bundles generated successfully.')))
//         })
//         // Copy package files
//         .then(() => {
//             if (libName === 'ux-commons') {
//                 replace({
//                     files: path.join(distFolder, `bundles`, `${libName}.umd.js`),
//                     from: 'moment = moment && \'default\' in moment ? moment[\'default\'] : moment;',
//                     to: 'moment = moment && \'default\' in moment ? moment[\'default\'] : moment;\nCleave = Cleave && \'default\' in Cleave ? Cleave[\'default\'] : Cleave;',
//                 })
//                 .then(changes => {
//                   console.log('Modified files:', changes.join(', '));
//                 })
//             }
//         })
//         .then(() => {
//             if (libName === 'ux-commons') {
//                 replace({
//                     files: path.join(distFolder, `${libName}.es5.js`),
//                     from: 'import moment from \'moment\';',
//                     to: 'import moment from \'moment\';\nimport Cleave from \'cleave.js\';',
//                 })
//                 .then(changes => {
//                 console.log('Modified files:', changes.join(', '));
//                 })
//             }
//         })
//         .then(() => {
//             if (libName === 'ux-commons') {
//                 replace({
//                     files: path.join(distFolder, `${libName}.js`),
//                     from: 'import moment from \'moment\';',
//                     to: 'import moment from \'moment\';\nimport Cleave from \'cleave.js\';',
//                 })
//                 .then(changes => {
//                 console.log('Modified files:', changes.join(', '));
//                 })
//             }
//         })
//         .then(() => Promise.resolve()
//             .then(() => tools.relativeCopy('LICENSE', packagePath, distFolder))
//             // .then(() => tools.relativeCopy('package.json', packagePath, distFolder))
//             .then(() => tools.relativeCopy('README.md', packagePath, distFolder))
//             .then(() => tools.relativeCopy('./assets/**/*.*', packagePath, distFolder))
//             .then(() => console.log('Package files copy succeeded.'))
//         )
//         .catch(e => {
//             console.error('\Build failed. See below for errors.\n');
//             console.error(e);
//             throw e;
//         });
// }
